/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "Urn-tva-metadata-2005.h"
#include "Urn-mpeg-mpeg7-schema-2001.h"
#include "rtxsrc/rtxCommon.h"

/**************************************************************/
/*                                                            */
/*  TVAIDType                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TVAIDType (OSCTXT* pctxt,
   TVAIDType pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_utf8str (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_TVAIDType (OSCTXT* pctxt, TVAIDType value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt, value, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CSAliasType                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CSAliasType (OSCTXT* pctxt,
   CSAliasType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode fragmentVersion */

   if (pvalue->m.fragmentVersionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_uint64 (pctxt, &pvalue->fragmentVersion, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode fragmentId */

   if (pvalue->m.fragmentIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         asn1E_TVAIDType (pctxt, pvalue->fragmentId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode href */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->href, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode alias */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->alias, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CSAliasType (OSCTXT* pctxt, CSAliasType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" alias=\""), 8);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->alias, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->href, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.fragmentIdPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" fragmentId=\""), 13);

      stat = XmlEnc_TVAIDType (pctxt, pvalue->fragmentId, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');
   }

   if (pvalue->m.fragmentVersionPresent) {
      stat = rtXmlEncUInt64Attr
         (pctxt, pvalue->fragmentVersion, OSUTF8("fragmentVersion"), 15);
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ClassificationSchemeType                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Urn_tva_metadata_2005_ClassificationSchemeType (OSCTXT* pctxt,
   Urn_tva_metadata_2005_ClassificationSchemeType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode fragmentVersion */

   if (pvalue->m.fragmentVersionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|8,
         xe_uint64 (pctxt, &pvalue->fragmentVersion, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode fragmentId */

   if (pvalue->m.fragmentIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
         asn1E_TVAIDType (pctxt, pvalue->fragmentId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode uri */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
      xe_utf8str (pctxt, pvalue->uri, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode timeUnit */

   if (pvalue->m.timeUnitPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         asn1E_DurationType (pctxt, (DurationType)pvalue->timeUnit, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode timeBase */

   if (pvalue->m.timeBasePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         asn1E_XPathRefType (pctxt, (XPathRefType)pvalue->timeBase, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode mediaTimeUnit */

   if (pvalue->m.mediaTimeUnitPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         asn1E_MediaDurationType (pctxt, (MediaDurationType)pvalue->mediaTimeUnit, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode mediaTimeBase */

   if (pvalue->m.mediaTimeBasePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         asn1E_XPathRefType (pctxt, (XPathRefType)pvalue->mediaTimeBase, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode domain */

   if (pvalue->m.domainPresent) {
      pnode2 = pvalue->domain.tail;
      while (0 != pnode2) {
         ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll2 += ll;

         pnode2 = pnode2->prev;
      }
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      else { ll1 += ll; ll2 = 0; }
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Urn_tva_metadata_2005_ClassificationSchemeType (OSCTXT* pctxt, 
   Urn_tva_metadata_2005_ClassificationSchemeType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.domainPresent) {
   }

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.mediaTimeBasePresent) {
      if (!rtxMatchPattern (pctxt, pvalue->mediaTimeBase, OSUTF8("/?((((child::)?((\\i\\c*:)?(\\i\\c*)(\\[\\d+\\])?))|\\.|(\\.\\.))/)*((((child::)?((\\i\\c*:)?(\\i\\c*)(\\[\\d+\\])?))|\\.)|((attribute::|@)((\\i\\c*:)?(\\i\\c*|\\*))))"))) {
         return LOG_RTERRNEW2 (pctxt, RTERR_PATMATCH,
            rtxErrAddStrParm (pctxt, "ClassificationSchemeType.mediaTimeBase"),
            rtxErrAddStrParm (pctxt, (const char*)pvalue->mediaTimeBase));
      }

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" mediaTimeBase=\""), 16);

      stat = XmlEnc_XPathRefType (pctxt, pvalue->mediaTimeBase, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');
   }

   if (pvalue->m.mediaTimeUnitPresent) {
      if (!rtxMatchPattern (pctxt, pvalue->mediaTimeUnit, OSUTF8("\\-?P(\\d+D)?(T(\\d+H)?(\\d+M)?(\\d+S)?(\\d+N)?)?(\\d+F)?"))) {
         return LOG_RTERRNEW2 (pctxt, RTERR_PATMATCH,
            rtxErrAddStrParm (pctxt, "ClassificationSchemeType.mediaTimeUnit"),
            rtxErrAddStrParm (pctxt, (const char*)pvalue->mediaTimeUnit));
      }

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" mediaTimeUnit=\""), 16);

      stat = XmlEnc_MediaDurationType (pctxt, pvalue->mediaTimeUnit, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');
   }

   if (pvalue->m.timeBasePresent) {
      if (!rtxMatchPattern (pctxt, pvalue->timeBase, OSUTF8("/?((((child::)?((\\i\\c*:)?(\\i\\c*)(\\[\\d+\\])?))|\\.|(\\.\\.))/)*((((child::)?((\\i\\c*:)?(\\i\\c*)(\\[\\d+\\])?))|\\.)|((attribute::|@)((\\i\\c*:)?(\\i\\c*|\\*))))"))) {
         return LOG_RTERRNEW2 (pctxt, RTERR_PATMATCH,
            rtxErrAddStrParm (pctxt, "ClassificationSchemeType.timeBase"),
            rtxErrAddStrParm (pctxt, (const char*)pvalue->timeBase));
      }

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" timeBase=\""), 11);

      stat = XmlEnc_XPathRefType (pctxt, pvalue->timeBase, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');
   }

   if (pvalue->m.timeUnitPresent) {
      if (!rtxMatchPattern (pctxt, pvalue->timeUnit, OSUTF8("\\-?P(\\d+D)?(T(\\d+H)?(\\d+M)?(\\d+S)?(\\d+N)?)?(\\d+F)?((\\-|\\+)\\d{2}:\\d{2}Z)?"))) {
         return LOG_RTERRNEW2 (pctxt, RTERR_PATMATCH,
            rtxErrAddStrParm (pctxt, "ClassificationSchemeType.timeUnit"),
            rtxErrAddStrParm (pctxt, (const char*)pvalue->timeUnit));
      }

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" timeUnit=\""), 11);

      stat = XmlEnc_DurationType (pctxt, pvalue->timeUnit, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" uri=\""), 6);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->uri, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.fragmentIdPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" fragmentId=\""), 13);

      stat = XmlEnc_TVAIDType (pctxt, pvalue->fragmentId, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');
   }

   if (pvalue->m.fragmentVersionPresent) {
      stat = rtXmlEncUInt64Attr
         (pctxt, pvalue->fragmentVersion, OSUTF8("fragmentVersion"), 15);
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ServiceInformationNameLengthType                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ServiceInformationNameLengthType (OSCTXT* pctxt,
   ServiceInformationNameLengthType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ServiceInformationNameLengthType (OSCTXT* pctxt, 
   ServiceInformationNameLengthType value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      ServiceInformationNameLengthType_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SynopsisLengthType                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SynopsisLengthType (OSCTXT* pctxt,
   SynopsisLengthType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_SynopsisLengthType (OSCTXT* pctxt, SynopsisLengthType value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      SynopsisLengthType_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TVAIDRefType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TVAIDRefType (OSCTXT* pctxt,
   TVAIDRefType pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_utf8str (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_TVAIDRefType (OSCTXT* pctxt, TVAIDRefType value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt, value, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FrameRateType                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FrameRateType (OSCTXT* pctxt,
   FrameRateType pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_utf8str (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_FrameRateType (OSCTXT* pctxt, FrameRateType value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!rtxMatchPattern (pctxt, value, OSUTF8("([0-9]{1,3}(.[0-9]{1,3})?)|([0-9]{1,3}/1.001)"))) {
      return LOG_RTERRNEW2 (pctxt, RTERR_PATMATCH,
         rtxErrAddStrParm (pctxt, "FrameRateType"),
         rtxErrAddStrParm (pctxt, (const char*)value));
   }

   stat = rtXmlEncUTF8Str (pctxt, value, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GenreType_type                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_GenreType_type (OSCTXT* pctxt,
   GenreType_type *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_GenreType_type (OSCTXT* pctxt, GenreType_type value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      GenreType_type_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  KeywordType_type                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_KeywordType_type (OSCTXT* pctxt,
   KeywordType_type *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_KeywordType_type (OSCTXT* pctxt, KeywordType_type value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      KeywordType_type_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TermNameType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TermNameType (OSCTXT* pctxt,
   TermNameType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode preferred */

   if (pvalue->m.preferredPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_boolean (pctxt, &pvalue->preferred, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode phoneticTranscription */

   if (pvalue->m.phoneticTranscriptionPresent) {
      pnode2 = pvalue->phoneticTranscription.tail;
      while (0 != pnode2) {
         ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll2 += ll;

         pnode2 = pnode2->prev;
      }
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      else { ll1 += ll; ll2 = 0; }
   }
   /* encode phoneticAlphabet */

   if (pvalue->m.phoneticAlphabetPresent) {
      if(pvalue->phoneticAlphabet < 0 || pvalue->phoneticAlphabet > 3)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         asn1E_PhoneticAlphabetType (pctxt, (PhoneticAlphabetType*)&pvalue->phoneticAlphabet, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode lang */

   if (pvalue->m.langPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->lang, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TermNameType (OSCTXT* pctxt, TermNameType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.langPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" xml:lang=\""), 11);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->lang, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.phoneticAlphabetPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" phoneticAlphabet=\""), 19);

      if(pvalue->phoneticAlphabet < 0 || pvalue->phoneticAlphabet > 3)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_PhoneticAlphabetType (pctxt, pvalue->phoneticAlphabet
         , 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');
   }

   if (pvalue->m.phoneticTranscriptionPresent) {
   }

   if (pvalue->m.preferredPresent) {
      stat = rtXmlEncBoolAttr (pctxt, pvalue->preferred
         , OSUTF8("preferred"), 9);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:tva:metadata:2005"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ControlledTermType                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ControlledTermType (OSCTXT* pctxt,
   ControlledTermType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode definition */

   if (pvalue->m.definitionPresent) {
      if (pvalue->definition == NULL) {
         rtxErrAddStrParm (pctxt, "pvalue->definition");
         return LOG_RTERR (pctxt, RTERR_NULLPTR);
      }
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_TextualType (pctxt, (TextualType*)pvalue->definition, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_TermNameType (pctxt, &pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode href */

   if (pvalue->href == NULL) {
      rtxErrAddStrParm (pctxt, "pvalue->href");
      return LOG_RTERR (pctxt, RTERR_NULLPTR);
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_TermReferenceType (pctxt, (TermReferenceType*)pvalue->href, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ControlledTermType (OSCTXT* pctxt, ControlledTermType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

   stat = XmlEnc_TermReferenceType (pctxt, pvalue->href, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:tva:metadata:2005"));

   /* encode name */

   if (pvalue->m.namePresent) {
      stat = XmlEnc_TermNameType (pctxt, &pvalue->name
         , OSUTF8("Name"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode definition */

   if (pvalue->m.definitionPresent) {
      stat = XmlEnc_TextualType (pctxt, pvalue->definition
         , OSUTF8("Definition"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ClassificationSchemeTableType                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ClassificationSchemeTableType (OSCTXT* pctxt,
   ClassificationSchemeTableType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode classificationScheme_list */

   pnode2 = pvalue->classificationScheme_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ClassificationSchemeType (pctxt, (ClassificationSchemeType*)((ClassificationSchemeType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode cSAlias_list */

   pnode2 = pvalue->cSAlias_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CSAliasType (pctxt, ((CSAliasType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ClassificationSchemeTableType (OSCTXT* pctxt, 
   ClassificationSchemeTableType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:tva:metadata:2005"));

   /* encode cSAlias_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:tva:metadata:2005"));

   { OSRTDListNode* pnode = pvalue->cSAlias_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CSAliasType (pctxt, ((CSAliasType*)pnode->data)
         , OSUTF8("CSAlias"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode classificationScheme_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:tva:metadata:2005"));

   { OSRTDListNode* pnode = pvalue->classificationScheme_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ClassificationSchemeType (pctxt, 
         ((ClassificationSchemeType*)pnode->data)
         , OSUTF8("ClassificationScheme"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TVAAgentType_element_personNameIDRef                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TVAAgentType_element_personNameIDRef (OSCTXT* pctxt,
   TVAAgentType_element_personNameIDRef *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_TVAIDRefType (pctxt, pvalue->ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TVAAgentType_element_personNameIDRef (OSCTXT* pctxt, 
   TVAAgentType_element_personNameIDRef* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" ref=\""), 6);

   stat = XmlEnc_TVAIDRefType (pctxt, pvalue->ref, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TVAAgentType_element_organizationNameIDRef                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TVAAgentType_element_organizationNameIDRef (OSCTXT* pctxt,
   TVAAgentType_element_organizationNameIDRef *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_TVAIDRefType (pctxt, pvalue->ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TVAAgentType_element_organizationNameIDRef (OSCTXT* pctxt, 
   TVAAgentType_element_organizationNameIDRef* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" ref=\""), 6);

   stat = XmlEnc_TVAIDRefType (pctxt, pvalue->ref, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TVAAgentType_element                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TVAAgentType_element (OSCTXT* pctxt,
   TVAAgentType_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_PersonNameType (pctxt, (PersonNameType*)pvalue->u.personName, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_TVAAgentType_element_personNameIDRef (pctxt, pvalue->u.personNameIDRef, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_TextualType (pctxt, (TextualType*)pvalue->u.organizationName, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 4:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
            asn1E_TVAAgentType_element_organizationNameIDRef (pctxt, pvalue->u.organizationNameIDRef, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_TVAAgentType_element (OSCTXT* pctxt, TVAAgentType_element* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:tva:metadata:2005"));

   switch (pvalue->t)
   {
      case 1:
         /* encode personName */

         stat = XmlEnc_PersonNameType (pctxt, pvalue->u.personName
            , OSUTF8("PersonName"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode personNameIDRef */

         stat = XmlEnc_TVAAgentType_element_personNameIDRef (pctxt, pvalue->
            u.personNameIDRef, OSUTF8("PersonNameIDRef"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode organizationName */

         stat = XmlEnc_TextualType (pctxt, pvalue->u.organizationName
            , OSUTF8("OrganizationName"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 4:
         /* encode organizationNameIDRef */

         stat = XmlEnc_TVAAgentType_element_organizationNameIDRef (pctxt, 
            pvalue->u.organizationNameIDRef
            , OSUTF8("OrganizationNameIDRef"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TVAAgentType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TVAAgentType (OSCTXT* pctxt,
   TVAAgentType *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_TVAAgentType_element (pctxt, ((TVAAgentType_element*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TVAAgentType (OSCTXT* pctxt, TVAAgentType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:tva:metadata:2005"));

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_TVAAgentType_element (pctxt, 
         ((TVAAgentType_element*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CreditsItemType_element_personNameIDRef                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CreditsItemType_element_personNameIDRef (OSCTXT* pctxt,
   CreditsItemType_element_personNameIDRef *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_TVAIDRefType (pctxt, pvalue->ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CreditsItemType_element_personNameIDRef (OSCTXT* pctxt, 
   CreditsItemType_element_personNameIDRef* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" ref=\""), 6);

   stat = XmlEnc_TVAIDRefType (pctxt, pvalue->ref, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CreditsItemType_element_organizationNameIDRef             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CreditsItemType_element_organizationNameIDRef (OSCTXT* pctxt,
   CreditsItemType_element_organizationNameIDRef *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_TVAIDRefType (pctxt, pvalue->ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CreditsItemType_element_organizationNameIDRef (OSCTXT* pctxt, 
   CreditsItemType_element_organizationNameIDRef* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" ref=\""), 6);

   stat = XmlEnc_TVAIDRefType (pctxt, pvalue->ref, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CreditsItemType_element                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CreditsItemType_element (OSCTXT* pctxt,
   CreditsItemType_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_PersonNameType (pctxt, (PersonNameType*)pvalue->u.personName, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_CreditsItemType_element_personNameIDRef (pctxt, pvalue->u.personNameIDRef, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_TextualType (pctxt, (TextualType*)pvalue->u.organizationName, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 4:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
            asn1E_CreditsItemType_element_organizationNameIDRef (pctxt, pvalue->u.organizationNameIDRef, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_CreditsItemType_element (OSCTXT* pctxt, 
   CreditsItemType_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:tva:metadata:2005"));

   switch (pvalue->t)
   {
      case 1:
         /* encode personName */

         stat = XmlEnc_PersonNameType (pctxt, pvalue->u.personName
            , OSUTF8("PersonName"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode personNameIDRef */

         stat = XmlEnc_CreditsItemType_element_personNameIDRef (pctxt, pvalue->
            u.personNameIDRef, OSUTF8("PersonNameIDRef"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode organizationName */

         stat = XmlEnc_TextualType (pctxt, pvalue->u.organizationName
            , OSUTF8("OrganizationName"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 4:
         /* encode organizationNameIDRef */

         stat = XmlEnc_CreditsItemType_element_organizationNameIDRef (pctxt, 
            pvalue->u.organizationNameIDRef
            , OSUTF8("OrganizationNameIDRef"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CreditsItemType                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CreditsItemType (OSCTXT* pctxt,
   CreditsItemType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode character_list */

   pnode2 = pvalue->character_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PersonNameType (pctxt, (PersonNameType*)((PersonNameType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode choice_list */

   pnode2 = pvalue->choice_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CreditsItemType_element (pctxt, ((CreditsItemType_element*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode role */

   if (pvalue->role == NULL) {
      rtxErrAddStrParm (pctxt, "pvalue->role");
      return LOG_RTERR (pctxt, RTERR_NULLPTR);
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_TermReferenceType (pctxt, (TermReferenceType*)pvalue->role, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CreditsItemType (OSCTXT* pctxt, CreditsItemType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" role=\""), 7);

   stat = XmlEnc_TermReferenceType (pctxt, pvalue->role, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:tva:metadata:2005"));

   /* encode choice_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:tva:metadata:2005"));

   { OSRTDListNode* pnode = pvalue->choice_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CreditsItemType_element (pctxt, 
         ((CreditsItemType_element*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode character_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:tva:metadata:2005"));

   { OSRTDListNode* pnode = pvalue->character_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PersonNameType (pctxt, ((PersonNameType*)pnode->data)
         , OSUTF8("Character"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CreditsListType                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CreditsListType (OSCTXT* pctxt,
   CreditsListType *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_CreditsItemType (pctxt, ((CreditsItemType*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CreditsListType (OSCTXT* pctxt, CreditsListType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:tva:metadata:2005"));

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_CreditsItemType (pctxt, ((CreditsItemType*)pnode->data)
         , OSUTF8("CreditsItem"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FlagType                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FlagType (OSCTXT* pctxt,
   FlagType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode value */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_boolean (pctxt, &pvalue->value, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FlagType (OSCTXT* pctxt, FlagType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   stat = rtXmlEncBoolAttr (pctxt, pvalue->value, OSUTF8("value"), 5);

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ServiceInformationNameType                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ServiceInformationNameType (OSCTXT* pctxt,
   ServiceInformationNameType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode length */

   if (pvalue->m.lengthPresent) {
      if(pvalue->length < 0 || pvalue->length > 2)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         asn1E_ServiceInformationNameLengthType (pctxt, &pvalue->length, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode phoneticTranscription */

   if (pvalue->m.phoneticTranscriptionPresent) {
      pnode2 = pvalue->phoneticTranscription.tail;
      while (0 != pnode2) {
         ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll2 += ll;

         pnode2 = pnode2->prev;
      }
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      else { ll1 += ll; ll2 = 0; }
   }
   /* encode phoneticAlphabet */

   if (pvalue->m.phoneticAlphabetPresent) {
      if(pvalue->phoneticAlphabet < 0 || pvalue->phoneticAlphabet > 3)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         asn1E_PhoneticAlphabetType (pctxt, (PhoneticAlphabetType*)&pvalue->phoneticAlphabet, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode lang */

   if (pvalue->m.langPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->lang, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ServiceInformationNameType (OSCTXT* pctxt, 
   ServiceInformationNameType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.langPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" xml:lang=\""), 11);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->lang, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.phoneticAlphabetPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" phoneticAlphabet=\""), 19);

      if(pvalue->phoneticAlphabet < 0 || pvalue->phoneticAlphabet > 3)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_PhoneticAlphabetType (pctxt, pvalue->phoneticAlphabet
         , 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');
   }

   if (pvalue->m.phoneticTranscriptionPresent) {
   }

   if (pvalue->m.lengthPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" length=\""), 9);

      if(pvalue->length < 0 || pvalue->length > 2)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_ServiceInformationNameLengthType (pctxt, pvalue->length
         , 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:tva:metadata:2005"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SynopsisType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SynopsisType (OSCTXT* pctxt,
   SynopsisType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode phoneticTranscription */

   if (pvalue->m.phoneticTranscriptionPresent) {
      pnode2 = pvalue->phoneticTranscription.tail;
      while (0 != pnode2) {
         ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll2 += ll;

         pnode2 = pnode2->prev;
      }
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      else { ll1 += ll; ll2 = 0; }
   }
   /* encode phoneticAlphabet */

   if (pvalue->m.phoneticAlphabetPresent) {
      if(pvalue->phoneticAlphabet < 0 || pvalue->phoneticAlphabet > 3)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         asn1E_PhoneticAlphabetType (pctxt, (PhoneticAlphabetType*)&pvalue->phoneticAlphabet, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode lang */

   if (pvalue->m.langPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->lang, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SynopsisType (OSCTXT* pctxt, SynopsisType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.langPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" xml:lang=\""), 11);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->lang, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.phoneticAlphabetPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" phoneticAlphabet=\""), 19);

      if(pvalue->phoneticAlphabet < 0 || pvalue->phoneticAlphabet > 3)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_PhoneticAlphabetType (pctxt, pvalue->phoneticAlphabet
         , 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');
   }

   if (pvalue->m.phoneticTranscriptionPresent) {
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:tva:metadata:2005"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GenreType                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_GenreType (OSCTXT* pctxt,
   GenreType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode definition */

   if (pvalue->m.definitionPresent) {
      if (pvalue->definition == NULL) {
         rtxErrAddStrParm (pctxt, "pvalue->definition");
         return LOG_RTERR (pctxt, RTERR_NULLPTR);
      }
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_TextualType (pctxt, (TextualType*)pvalue->definition, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_TermNameType (pctxt, &pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode type */

   if (pvalue->m.typePresent) {
      if(pvalue->type < 0 || pvalue->type > 2)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         asn1E_GenreType_type (pctxt, &pvalue->type, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode href */

   if (pvalue->href == NULL) {
      rtxErrAddStrParm (pctxt, "pvalue->href");
      return LOG_RTERR (pctxt, RTERR_NULLPTR);
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_TermReferenceType (pctxt, (TermReferenceType*)pvalue->href, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_GenreType (OSCTXT* pctxt, GenreType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

   stat = XmlEnc_TermReferenceType (pctxt, pvalue->href, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   if (pvalue->m.typePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" type=\""), 7);

      if(pvalue->type < 0 || pvalue->type > 2)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_GenreType_type (pctxt, pvalue->type, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:tva:metadata:2005"));

   /* encode name */

   if (pvalue->m.namePresent) {
      stat = XmlEnc_TermNameType (pctxt, &pvalue->name
         , OSUTF8("Name"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode definition */

   if (pvalue->m.definitionPresent) {
      stat = XmlEnc_TextualType (pctxt, pvalue->definition
         , OSUTF8("Definition"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  KeywordType                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_KeywordType (OSCTXT* pctxt,
   KeywordType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode type */

   if (pvalue->m.typePresent) {
      if(pvalue->type < 0 || pvalue->type > 2)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         asn1E_KeywordType_type (pctxt, &pvalue->type, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode phoneticTranscription */

   if (pvalue->m.phoneticTranscriptionPresent) {
      pnode2 = pvalue->phoneticTranscription.tail;
      while (0 != pnode2) {
         ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll2 += ll;

         pnode2 = pnode2->prev;
      }
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      else { ll1 += ll; ll2 = 0; }
   }
   /* encode phoneticAlphabet */

   if (pvalue->m.phoneticAlphabetPresent) {
      if(pvalue->phoneticAlphabet < 0 || pvalue->phoneticAlphabet > 3)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         asn1E_PhoneticAlphabetType (pctxt, (PhoneticAlphabetType*)&pvalue->phoneticAlphabet, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode lang */

   if (pvalue->m.langPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->lang, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_KeywordType (OSCTXT* pctxt, KeywordType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.langPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" xml:lang=\""), 11);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->lang, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.phoneticAlphabetPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" phoneticAlphabet=\""), 19);

      if(pvalue->phoneticAlphabet < 0 || pvalue->phoneticAlphabet > 3)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_PhoneticAlphabetType (pctxt, pvalue->phoneticAlphabet
         , 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');
   }

   if (pvalue->m.phoneticTranscriptionPresent) {
   }

   if (pvalue->m.typePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" type=\""), 7);

      if(pvalue->type < 0 || pvalue->type > 2)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_KeywordType_type (pctxt, pvalue->type, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:tva:metadata:2005"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CaptionLanguageType                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CaptionLanguageType (OSCTXT* pctxt,
   CaptionLanguageType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode supplemental */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_boolean (pctxt, &pvalue->supplemental, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode closed */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_boolean (pctxt, &pvalue->closed, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CaptionLanguageType (OSCTXT* pctxt, CaptionLanguageType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   stat = rtXmlEncBoolAttr (pctxt, pvalue->closed, OSUTF8("closed"), 6);

   stat = rtXmlEncBoolAttr (pctxt, pvalue->supplemental
      , OSUTF8("supplemental"), 12);

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:tva:metadata:2005"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SignLanguageType                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SignLanguageType (OSCTXT* pctxt,
   SignLanguageType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode type */

   if (pvalue->m.typePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->type, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode translation */

   if (pvalue->m.translationPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_boolean (pctxt, &pvalue->translation, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode primary */

   if (pvalue->m.primaryPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_boolean (pctxt, &pvalue->primary, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SignLanguageType (OSCTXT* pctxt, SignLanguageType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.primaryPresent) {
      stat = rtXmlEncBoolAttr (pctxt, pvalue->primary, OSUTF8("primary"), 7);
   }

   if (pvalue->m.translationPresent) {
      stat = rtXmlEncBoolAttr (pctxt, pvalue->translation
         , OSUTF8("translation"), 11);
   }

   if (pvalue->m.typePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" type=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->type, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:tva:metadata:2005"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BitRateType                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BitRateType (OSCTXT* pctxt,
   BitRateType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
      xe_unsigned (pctxt, &pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode variable */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
      xe_boolean (pctxt, &pvalue->variable, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode minimum */

   if (pvalue->m.minimumPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_uint64 (pctxt, &pvalue->minimum, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode maximum */

   if (pvalue->m.maximumPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_uint64 (pctxt, &pvalue->maximum, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode average */

   if (pvalue->m.averagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_uint64 (pctxt, &pvalue->average, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BitRateType (OSCTXT* pctxt, BitRateType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.averagePresent) {
      stat = rtXmlEncUInt64Attr
         (pctxt, pvalue->average, OSUTF8("average"), 7);
   }

   if (pvalue->m.maximumPresent) {
      stat = rtXmlEncUInt64Attr
         (pctxt, pvalue->maximum, OSUTF8("maximum"), 7);
   }

   if (pvalue->m.minimumPresent) {
      stat = rtXmlEncUInt64Attr
         (pctxt, pvalue->minimum, OSUTF8("minimum"), 7);
   }

   stat = rtXmlEncBoolAttr (pctxt, pvalue->variable, OSUTF8("variable"), 8);

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:tva:metadata:2005"));

   /* encode base */

   stat = rtXmlEncUIntValue (pctxt, pvalue->base);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TVAAgentType_derivations                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TVAAgentType_derivations (OSCTXT* pctxt,
   TVAAgentType_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_TVAAgentType (pctxt, pvalue->u.tVAAgentType, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_CreditsItemType (pctxt, pvalue->u.creditsItemType, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_TVAAgentType_derivations (OSCTXT* pctxt, 
   TVAAgentType_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:tva:metadata:2005"));

   switch (pvalue->t)
   {
      case 1:
         /* encode tVAAgentType */

         stat = XmlEnc_TVAAgentType (pctxt, pvalue->u.tVAAgentType
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode creditsItemType */

         stat = XmlEnc_CreditsItemType (pctxt, pvalue->u.creditsItemType
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ControlledTermType_derivations                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ControlledTermType_derivations (OSCTXT* pctxt,
   ControlledTermType_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_ControlledTermType (pctxt, pvalue->u.controlledTermType, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_GenreType (pctxt, pvalue->u.genreType, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_ControlledTermType_derivations (OSCTXT* pctxt, 
   ControlledTermType_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:tva:metadata:2005"));

   switch (pvalue->t)
   {
      case 1:
         /* encode controlledTermType */

         stat = XmlEnc_ControlledTermType (pctxt, pvalue->u.controlledTermType
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode genreType */

         stat = XmlEnc_GenreType (pctxt, pvalue->u.genreType, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

int XmlEnc_SynopsisLengthType_PDU (OSCTXT* pctxt, SynopsisLengthType value)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   rtXmlNSSetNamespace (pctxt, OSUTF8("tva"), OSUTF8("urn:tva:metadata:2005"), 
      FALSE);

   rtXmlNSSetNamespace (pctxt, OSUTF8("mpeg7"), 
      OSUTF8("urn:mpeg:mpeg7:schema:2001"), FALSE);

   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:tva:metadata:2005"));

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("synopsisLengthType"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if(value < 0 || value > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_SynopsisLengthType (pctxt, value, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("synopsisLengthType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_FlagType_PDU (OSCTXT* pctxt, FlagType* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   rtXmlNSSetNamespace (pctxt, OSUTF8("tva"), OSUTF8("urn:tva:metadata:2005"), 
      FALSE);

   rtXmlNSSetNamespace (pctxt, OSUTF8("mpeg7"), 
      OSUTF8("urn:mpeg:mpeg7:schema:2001"), FALSE);

   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:tva:metadata:2005"));

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("flagType"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_FlagType (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("flagType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
