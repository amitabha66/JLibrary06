/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "Urn-GoogleSearch.h"
#include "rtxsrc/rtxCommon.h"

/**************************************************************/
/*                                                            */
/*  DirectoryCategory                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DirectoryCategory (OSCTXT* pctxt,
   DirectoryCategory *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   int xx2;
   int ll2 = 0;

   /* encode specialEncoding */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_utf8str (pctxt, pvalue->specialEncoding, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode fullViewableName */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->fullViewableName, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode _order */

   for (xx2 = (pvalue->_order.n - 1); xx2 >= 0; xx2--)
   {
      if (!((pvalue->_order.elem[xx2] <= OSUINTCONST(1)))) {
         rtxErrAddStrParm (pctxt, "DirectoryCategory._order.elem[xx2]");
         rtxErrAddIntParm (pctxt, (int)pvalue->_order.elem[xx2]);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      ll = xe_uint8 (pctxt, &pvalue->_order.elem[xx2], ASN1IMPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);

      ll = xe_tag_len (pctxt, TM_UNIV|TM_PRIM|10, ll);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DirectoryCategory (OSCTXT* pctxt, DirectoryCategory* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:GoogleSearch"));

   /* encode elements in given order */

   { OSUINT32 xx1;
   for (xx1 = 0; xx1 < pvalue->_order.n; xx1++) {
      switch (pvalue->_order.elem[xx1]) {
      case 0:
         /* encode fullViewableName */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->fullViewableName
            , OSUTF8("fullViewableName"), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 1:
         /* encode specialEncoding */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->specialEncoding
            , OSUTF8("specialEncoding"), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default:
         rtxErrAddStrParm (pctxt, "DirectoryCategory._order.elem[xx1]");
         rtxErrAddIntParm (pctxt, (int)pvalue->_order.elem[xx1]);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResultElement                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ResultElement (OSCTXT* pctxt,
   ResultElement *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   int xx2;
   int ll2 = 0;

   /* encode directoryTitle */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|9,
      xe_utf8str (pctxt, pvalue->directoryTitle, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode directoryCategory */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
      asn1E_DirectoryCategory (pctxt, &pvalue->directoryCategory, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode hostName */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
      xe_utf8str (pctxt, pvalue->hostName, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode relatedInformationPresent */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
      xe_boolean (pctxt, &pvalue->relatedInformationPresent, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode cachedSize */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
      xe_utf8str (pctxt, pvalue->cachedSize, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode title */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
      xe_utf8str (pctxt, pvalue->title, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode snippet */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
      xe_utf8str (pctxt, pvalue->snippet, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode uRL */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_utf8str (pctxt, pvalue->uRL, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode summary */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->summary, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode _order */

   for (xx2 = (pvalue->_order.n - 1); xx2 >= 0; xx2--)
   {
      if (!((pvalue->_order.elem[xx2] <= OSUINTCONST(8)))) {
         rtxErrAddStrParm (pctxt, "ResultElement._order.elem[xx2]");
         rtxErrAddIntParm (pctxt, (int)pvalue->_order.elem[xx2]);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      ll = xe_uint8 (pctxt, &pvalue->_order.elem[xx2], ASN1IMPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);

      ll = xe_tag_len (pctxt, TM_UNIV|TM_PRIM|10, ll);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ResultElement (OSCTXT* pctxt, ResultElement* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:GoogleSearch"));

   /* encode elements in given order */

   { OSUINT32 xx1;
   for (xx1 = 0; xx1 < pvalue->_order.n; xx1++) {
      switch (pvalue->_order.elem[xx1]) {
      case 0:
         /* encode summary */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->summary
            , OSUTF8("summary"), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 1:
         /* encode uRL */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->uRL, OSUTF8("URL"), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode snippet */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->snippet
            , OSUTF8("snippet"), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode title */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->title, OSUTF8("title"), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 4:
         /* encode cachedSize */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->cachedSize
            , OSUTF8("cachedSize"), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 5:
         /* encode relatedInformationPresent */

         stat = rtXmlEncBool (pctxt, pvalue->relatedInformationPresent
            , OSUTF8("relatedInformationPresent"), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 6:
         /* encode hostName */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->hostName
            , OSUTF8("hostName"), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 7:
         /* encode directoryCategory */

         stat = XmlEnc_DirectoryCategory (pctxt, &pvalue->directoryCategory
            , OSUTF8("directoryCategory"), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 8:
         /* encode directoryTitle */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->directoryTitle
            , OSUTF8("directoryTitle"), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default:
         rtxErrAddStrParm (pctxt, "ResultElement._order.elem[xx1]");
         rtxErrAddIntParm (pctxt, (int)pvalue->_order.elem[xx1]);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResultElementArray                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ResultElementArray (OSCTXT* pctxt,
   ResultElementArray *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ResultElementArray.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_ResultElement (pctxt, ((ResultElement*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ResultElementArray (OSCTXT* pctxt, ResultElementArray* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ResultElementArray.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:GoogleSearch"));

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_ResultElement (pctxt, ((ResultElement*)pnode->data)
         , OSUTF8("item"), 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DirectoryCategoryArray                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DirectoryCategoryArray (OSCTXT* pctxt,
   DirectoryCategoryArray *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DirectoryCategoryArray.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_DirectoryCategory (pctxt, ((DirectoryCategory*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DirectoryCategoryArray (OSCTXT* pctxt, 
   DirectoryCategoryArray* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DirectoryCategoryArray.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:GoogleSearch"));

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_DirectoryCategory (pctxt, ((DirectoryCategory*)pnode->data)
         , OSUTF8("item"), 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GoogleSearchResult                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_GoogleSearchResult (OSCTXT* pctxt,
   GoogleSearchResult *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   int xx2;
   int ll2 = 0;

   /* encode searchTime */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|11,
      xe_real (pctxt, &pvalue->searchTime, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode directoryCategories */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10,
      asn1E_DirectoryCategoryArray (pctxt, &pvalue->directoryCategories, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode searchTips */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|9,
      xe_utf8str (pctxt, pvalue->searchTips, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode endIndex */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|8,
      xe_integer (pctxt, &pvalue->endIndex, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode startIndex */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
      xe_integer (pctxt, &pvalue->startIndex, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode searchQuery */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
      xe_utf8str (pctxt, pvalue->searchQuery, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode resultElements */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_ResultElementArray (pctxt, &pvalue->resultElements, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode estimateIsExact */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
      xe_boolean (pctxt, &pvalue->estimateIsExact, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode estimatedTotalResultsCount */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
      xe_integer (pctxt, &pvalue->estimatedTotalResultsCount, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode searchComments */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_utf8str (pctxt, pvalue->searchComments, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode documentFiltering */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_boolean (pctxt, &pvalue->documentFiltering, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode _order */

   for (xx2 = (pvalue->_order.n - 1); xx2 >= 0; xx2--)
   {
      if (!((pvalue->_order.elem[xx2] <= OSUINTCONST(10)))) {
         rtxErrAddStrParm (pctxt, "GoogleSearchResult._order.elem[xx2]");
         rtxErrAddIntParm (pctxt, (int)pvalue->_order.elem[xx2]);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      ll = xe_uint8 (pctxt, &pvalue->_order.elem[xx2], ASN1IMPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);

      ll = xe_tag_len (pctxt, TM_UNIV|TM_PRIM|10, ll);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_GoogleSearchResult (OSCTXT* pctxt, GoogleSearchResult* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:GoogleSearch"));

   /* encode elements in given order */

   { OSUINT32 xx1;
   for (xx1 = 0; xx1 < pvalue->_order.n; xx1++) {
      switch (pvalue->_order.elem[xx1]) {
      case 0:
         /* encode documentFiltering */

         stat = rtXmlEncBool (pctxt, pvalue->documentFiltering
            , OSUTF8("documentFiltering"), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 1:
         /* encode searchComments */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->searchComments
            , OSUTF8("searchComments"), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode estimatedTotalResultsCount */

         stat = rtXmlEncInt (pctxt, pvalue->estimatedTotalResultsCount
            , OSUTF8("estimatedTotalResultsCount"), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode estimateIsExact */

         stat = rtXmlEncBool (pctxt, pvalue->estimateIsExact
            , OSUTF8("estimateIsExact"), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 4:
         /* encode resultElements */

         stat = XmlEnc_ResultElementArray (pctxt, &pvalue->resultElements
            , OSUTF8("resultElements"), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 5:
         /* encode searchQuery */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->searchQuery
            , OSUTF8("searchQuery"), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 6:
         /* encode startIndex */

         stat = rtXmlEncInt (pctxt, pvalue->startIndex, OSUTF8("startIndex"), 0
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 7:
         /* encode endIndex */

         stat = rtXmlEncInt (pctxt, pvalue->endIndex, OSUTF8("endIndex"), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 8:
         /* encode searchTips */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->searchTips
            , OSUTF8("searchTips"), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 9:
         /* encode directoryCategories */

         stat = XmlEnc_DirectoryCategoryArray (pctxt, &pvalue->
            directoryCategories, OSUTF8("directoryCategories"), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 10:
         /* encode searchTime */

         stat = rtXmlEncDouble (pctxt, pvalue->searchTime
            , OSUTF8("searchTime"), 0, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default:
         rtxErrAddStrParm (pctxt, "GoogleSearchResult._order.elem[xx1]");
         rtxErrAddIntParm (pctxt, (int)pvalue->_order.elem[xx1]);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DoGoogleSearchResponse                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DoGoogleSearchResponse (OSCTXT* pctxt,
   DoGoogleSearchResponse *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode return_ */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_GoogleSearchResult (pctxt, &pvalue->return_, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode encodingStyle */

   if (pvalue->m.encodingStylePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_EncodingStyle (pctxt, &pvalue->encodingStyle, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DoGoogleSearchResponse (OSCTXT* pctxt, 
   DoGoogleSearchResponse* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.encodingStylePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" soap-env:encodingStyle=\""), 25);

      stat = XmlEnc_EncodingStyle (pctxt, &pvalue->encodingStyle, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:GoogleSearch"));

   /* encode return_ */

   stat = XmlEnc_GoogleSearchResult (pctxt, &pvalue->return_
      , OSUTF8("return"), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlEnc_DoGoogleSearchResponse_PDU (OSCTXT* pctxt, DoGoogleSearchResponse* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   rtXmlNSSetNamespace (pctxt, OSUTF8("gs"), OSUTF8("urn:GoogleSearch"), 
      FALSE);

   rtXmlNSSetNamespace (pctxt, OSUTF8("soap-env"), 
      OSUTF8("http://schemas.xmlsoap.org/soap/envelope/"), FALSE);

   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:GoogleSearch"));

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("doGoogleSearchResponse"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_DoGoogleSearchResponse (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("doGoogleSearchResponse"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
