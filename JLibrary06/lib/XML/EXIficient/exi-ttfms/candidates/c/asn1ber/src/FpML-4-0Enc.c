/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "FpML-4-0.h"
#include "rtxsrc/rtxCommon.h"

/**************************************************************/
/*                                                            */
/*  ProductType                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ProductType (OSCTXT* pctxt,
   ProductType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode productTypeScheme */

   if (pvalue->m.productTypeSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->productTypeScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ProductType (OSCTXT* pctxt, ProductType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.productTypeSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" productTypeScheme=\""), 20);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->productTypeScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ProductId                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ProductId (OSCTXT* pctxt,
   ProductId *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ProductId (OSCTXT* pctxt, ProductId* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PartyReference                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PartyReference (OSCTXT* pctxt,
   PartyReference *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode href */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->href, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PartyReference (OSCTXT* pctxt, PartyReference* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->href, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BuyerSeller_model                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BuyerSeller_model (OSCTXT* pctxt,
   BuyerSeller_model *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode sellerPartyReference */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_PartyReference (pctxt, &pvalue->sellerPartyReference, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode buyerPartyReference */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_PartyReference (pctxt, &pvalue->buyerPartyReference, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BuyerSeller_model (OSCTXT* pctxt, BuyerSeller_model* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode buyerPartyReference */

   stat = XmlEnc_PartyReference (pctxt, &pvalue->buyerPartyReference
      , OSUTF8("buyerPartyReference"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode sellerPartyReference */

   stat = XmlEnc_PartyReference (pctxt, &pvalue->sellerPartyReference
      , OSUTF8("sellerPartyReference"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BusinessCenter                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BusinessCenter (OSCTXT* pctxt,
   BusinessCenter *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode businessCenterScheme */

   if (pvalue->m.businessCenterSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->businessCenterScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BusinessCenter (OSCTXT* pctxt, BusinessCenter* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.businessCenterSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" businessCenterScheme=\""), 23);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->businessCenterScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BusinessCenterTime                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BusinessCenterTime (OSCTXT* pctxt,
   BusinessCenterTime *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode businessCenter */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_BusinessCenter (pctxt, &pvalue->businessCenter, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode hourMinuteTime */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_charstr (pctxt, pvalue->hourMinuteTime, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BusinessCenterTime (OSCTXT* pctxt, BusinessCenterTime* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode hourMinuteTime */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->hourMinuteTime
      , OSUTF8("hourMinuteTime"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode businessCenter */

   stat = XmlEnc_BusinessCenter (pctxt, &pvalue->businessCenter
      , OSUTF8("businessCenter"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CutName                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CutName (OSCTXT* pctxt,
   CutName *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode cutNameScheme */

   if (pvalue->m.cutNameSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->cutNameScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CutName (OSCTXT* pctxt, CutName* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.cutNameSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" cutNameScheme=\""), 16);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->cutNameScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExpiryDateTime                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExpiryDateTime (OSCTXT* pctxt,
   ExpiryDateTime *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode cutName */

   if (pvalue->m.cutNamePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_CutName (pctxt, &pvalue->cutName, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode expiryTime */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_BusinessCenterTime (pctxt, &pvalue->expiryTime, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode expiryDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_charstr (pctxt, pvalue->expiryDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ExpiryDateTime (OSCTXT* pctxt, ExpiryDateTime* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode expiryDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->expiryDate
      , OSUTF8("expiryDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode expiryTime */

   stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->expiryTime
      , OSUTF8("expiryTime"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cutName */

   if (pvalue->m.cutNamePresent) {
      stat = XmlEnc_CutName (pctxt, &pvalue->cutName
         , OSUTF8("cutName"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExerciseStyleEnum                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExerciseStyleEnum (OSCTXT* pctxt,
   ExerciseStyleEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ExerciseStyleEnum (OSCTXT* pctxt, ExerciseStyleEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      ExerciseStyleEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PayerReceiver_model                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PayerReceiver_model (OSCTXT* pctxt,
   PayerReceiver_model *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode receiverPartyReference */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_PartyReference (pctxt, &pvalue->receiverPartyReference, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode payerPartyReference */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_PartyReference (pctxt, &pvalue->payerPartyReference, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PayerReceiver_model (OSCTXT* pctxt, PayerReceiver_model* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode payerPartyReference */

   stat = XmlEnc_PartyReference (pctxt, &pvalue->payerPartyReference
      , OSUTF8("payerPartyReference"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode receiverPartyReference */

   stat = XmlEnc_PartyReference (pctxt, &pvalue->receiverPartyReference
      , OSUTF8("receiverPartyReference"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Currency                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Currency (OSCTXT* pctxt,
   Currency *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode currencyScheme */

   if (pvalue->m.currencySchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->currencyScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Currency (OSCTXT* pctxt, Currency* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.currencySchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" currencyScheme=\""), 17);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->currencyScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Money                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Money (OSCTXT* pctxt,
   Money *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode amount */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_real (pctxt, &pvalue->amount, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode currency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Currency (pctxt, &pvalue->currency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Money (OSCTXT* pctxt, Money* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode currency */

   stat = XmlEnc_Currency (pctxt, &pvalue->currency
      , OSUTF8("currency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode amount */

   stat = rtXmlEncDouble (pctxt, pvalue->amount, OSUTF8("amount"), nsPrefix
      , 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PayoutEnum                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PayoutEnum (OSCTXT* pctxt,
   PayoutEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_PayoutEnum (OSCTXT* pctxt, PayoutEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      PayoutEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  StandardSettlementStyleEnum                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_StandardSettlementStyleEnum (OSCTXT* pctxt,
   StandardSettlementStyleEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_StandardSettlementStyleEnum (OSCTXT* pctxt, 
   StandardSettlementStyleEnum value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      StandardSettlementStyleEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SettlementMethod                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SettlementMethod (OSCTXT* pctxt,
   SettlementMethod *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode settlementMethodScheme */

   if (pvalue->m.settlementMethodSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->settlementMethodScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SettlementMethod (OSCTXT* pctxt, SettlementMethod* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.settlementMethodSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" settlementMethodScheme=\""), 25);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->settlementMethodScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RoutingId                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RoutingId (OSCTXT* pctxt,
   RoutingId *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode routingIdScheme */

   if (pvalue->m.routingIdSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->routingIdScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_RoutingId (OSCTXT* pctxt, RoutingId* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.routingIdSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" routingIdScheme=\""), 18);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->routingIdScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RoutingIds                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RoutingIds (OSCTXT* pctxt,
   RoutingIds *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "RoutingIds.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_RoutingId (pctxt, ((RoutingId*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_RoutingIds (OSCTXT* pctxt, RoutingIds* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "RoutingIds.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_RoutingId (pctxt, ((RoutingId*)pnode->data)
         , OSUTF8("routingId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  StreetAddress                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_StreetAddress (OSCTXT* pctxt,
   StreetAddress *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "StreetAddress.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_StreetAddress (OSCTXT* pctxt, StreetAddress* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "StreetAddress.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("streetLine"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Country                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Country (OSCTXT* pctxt,
   Country *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode countryScheme */

   if (pvalue->m.countrySchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->countryScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Country (OSCTXT* pctxt, Country* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.countrySchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" countryScheme=\""), 16);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->countryScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Address                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Address (OSCTXT* pctxt,
   Address *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode postalCode */

   if (pvalue->m.postalCodePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_utf8str (pctxt, pvalue->postalCode, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode country */

   if (pvalue->m.countryPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Country (pctxt, &pvalue->country, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode state */

   if (pvalue->m.statePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->state, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode city */

   if (pvalue->m.cityPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->city, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode streetAddress */

   if (pvalue->m.streetAddressPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_StreetAddress (pctxt, &pvalue->streetAddress, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Address (OSCTXT* pctxt, Address* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode streetAddress */

   if (pvalue->m.streetAddressPresent) {
      stat = XmlEnc_StreetAddress (pctxt, &pvalue->streetAddress
         , OSUTF8("streetAddress"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode city */

   if (pvalue->m.cityPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->city, OSUTF8("city"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode state */

   if (pvalue->m.statePresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->state
         , OSUTF8("state"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode country */

   if (pvalue->m.countryPresent) {
      stat = XmlEnc_Country (pctxt, &pvalue->country
         , OSUTF8("country"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode postalCode */

   if (pvalue->m.postalCodePresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->postalCode
         , OSUTF8("postalCode"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RoutingExplicitDetails                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RoutingExplicitDetails (OSCTXT* pctxt,
   RoutingExplicitDetails *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode routingReferenceText_list */

   pnode2 = pvalue->routingReferenceText_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode routingAccountNumber */

   if (pvalue->m.routingAccountNumberPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->routingAccountNumber, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode routingAddress */

   if (pvalue->m.routingAddressPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Address (pctxt, &pvalue->routingAddress, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode routingName */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->routingName, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_RoutingExplicitDetails (OSCTXT* pctxt, 
   RoutingExplicitDetails* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode routingName */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->routingName
      , OSUTF8("routingName"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode routingAddress */

   if (pvalue->m.routingAddressPresent) {
      stat = XmlEnc_Address (pctxt, &pvalue->routingAddress
         , OSUTF8("routingAddress"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode routingAccountNumber */

   if (pvalue->m.routingAccountNumberPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->routingAccountNumber
         , OSUTF8("routingAccountNumber"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode routingReferenceText_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->routingReferenceText_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("routingReferenceText"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RoutingIdsAndExplicitDetails                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RoutingIdsAndExplicitDetails (OSCTXT* pctxt,
   RoutingIdsAndExplicitDetails *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode routingReferenceText_list */

   pnode2 = pvalue->routingReferenceText_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode routingAccountNumber */

   if (pvalue->m.routingAccountNumberPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_utf8str (pctxt, pvalue->routingAccountNumber, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode routingAddress */

   if (pvalue->m.routingAddressPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Address (pctxt, &pvalue->routingAddress, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode routingName */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->routingName, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode routingIds_list */

   if (!(pvalue->routingIds_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "RoutingIdsAndExplicitDetails.routingIds_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->routingIds_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->routingIds_list.tail;
   while (0 != pnode2) {
      ll = asn1E_RoutingIds (pctxt, ((RoutingIds*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_RoutingIdsAndExplicitDetails (OSCTXT* pctxt, 
   RoutingIdsAndExplicitDetails* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode routingIds_list */

   if (!(pvalue->routingIds_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "RoutingIdsAndExplicitDetails.routingIds_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->routingIds_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->routingIds_list.head;
   while (0 != pnode) {
      stat = XmlEnc_RoutingIds (pctxt, ((RoutingIds*)pnode->data)
         , OSUTF8("routingIds"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode routingName */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->routingName
      , OSUTF8("routingName"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode routingAddress */

   if (pvalue->m.routingAddressPresent) {
      stat = XmlEnc_Address (pctxt, &pvalue->routingAddress
         , OSUTF8("routingAddress"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode routingAccountNumber */

   if (pvalue->m.routingAccountNumberPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->routingAccountNumber
         , OSUTF8("routingAccountNumber"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode routingReferenceText_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->routingReferenceText_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("routingReferenceText"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Routing                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Routing (OSCTXT* pctxt,
   Routing *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_RoutingIds (pctxt, pvalue->u.routingIds, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_RoutingExplicitDetails (pctxt, pvalue->u.routingExplicitDetails, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_RoutingIdsAndExplicitDetails (pctxt, pvalue->u.routingIdsAndExplicitDetails, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   if (tagging == ASN1EXPL) {
      ll1 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll1);
      if (ll1 < 0) return LOG_RTERR (pctxt, ll1);
   }

   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Routing (OSCTXT* pctxt, Routing* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode routingIds */

         stat = XmlEnc_RoutingIds (pctxt, pvalue->u.routingIds
            , OSUTF8("routingIds"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode routingExplicitDetails */

         stat = XmlEnc_RoutingExplicitDetails (pctxt, pvalue->
            u.routingExplicitDetails
            , OSUTF8("routingExplicitDetails"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode routingIdsAndExplicitDetails */

         stat = XmlEnc_RoutingIdsAndExplicitDetails (pctxt, pvalue->
            u.routingIdsAndExplicitDetails
            , OSUTF8("routingIdsAndExplicitDetails"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IntermediaryInformation_choice                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_IntermediaryInformation_choice (OSCTXT* pctxt,
   IntermediaryInformation_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_RoutingIds (pctxt, pvalue->u.routingIds, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_RoutingExplicitDetails (pctxt, pvalue->u.routingExplicitDetails, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_RoutingIdsAndExplicitDetails (pctxt, pvalue->u.routingIdsAndExplicitDetails, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_IntermediaryInformation_choice (OSCTXT* pctxt, 
   IntermediaryInformation_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode routingIds */

         stat = XmlEnc_RoutingIds (pctxt, pvalue->u.routingIds
            , OSUTF8("routingIds"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode routingExplicitDetails */

         stat = XmlEnc_RoutingExplicitDetails (pctxt, pvalue->
            u.routingExplicitDetails
            , OSUTF8("routingExplicitDetails"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode routingIdsAndExplicitDetails */

         stat = XmlEnc_RoutingIdsAndExplicitDetails (pctxt, pvalue->
            u.routingIdsAndExplicitDetails
            , OSUTF8("routingIdsAndExplicitDetails"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IntermediaryInformation                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_IntermediaryInformation (OSCTXT* pctxt,
   IntermediaryInformation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode intermediarySequenceNumber */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_integer (pctxt, &pvalue->intermediarySequenceNumber, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_IntermediaryInformation_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_IntermediaryInformation (OSCTXT* pctxt, 
   IntermediaryInformation* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode choice */

   stat = XmlEnc_IntermediaryInformation_choice (pctxt, &pvalue->choice
      , OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode intermediarySequenceNumber */

   stat = rtXmlEncInt (pctxt, pvalue->intermediarySequenceNumber
      , OSUTF8("intermediarySequenceNumber"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SplitSettlement                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SplitSettlement (OSCTXT* pctxt,
   SplitSettlement *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode beneficiary */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_Routing (pctxt, &pvalue->beneficiary, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode beneficiaryBank */

   if (pvalue->m.beneficiaryBankPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Routing (pctxt, &pvalue->beneficiaryBank, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode splitSettlementAmount */

   if (pvalue->splitSettlementAmount == NULL) {
      rtxErrAddStrParm (pctxt, "pvalue->splitSettlementAmount");
      return LOG_RTERR (pctxt, RTERR_NULLPTR);
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Money_derivations (pctxt, (Money_derivations*)pvalue->splitSettlementAmount, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SplitSettlement (OSCTXT* pctxt, SplitSettlement* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode splitSettlementAmount */

   stat = XmlEnc_Money_derivations (pctxt, pvalue->splitSettlementAmount
      , OSUTF8("splitSettlementAmount"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode beneficiaryBank */

   if (pvalue->m.beneficiaryBankPresent) {
      stat = XmlEnc_Routing (pctxt, &pvalue->beneficiaryBank
         , OSUTF8("beneficiaryBank"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode beneficiary */

   stat = XmlEnc_Routing (pctxt, &pvalue->beneficiary
      , OSUTF8("beneficiary"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SettlementInstruction                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SettlementInstruction (OSCTXT* pctxt,
   SettlementInstruction *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode splitSettlement_list */

   pnode2 = pvalue->splitSettlement_list.tail;
   while (0 != pnode2) {
      ll = asn1E_SplitSettlement (pctxt, ((SplitSettlement*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode beneficiary */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_Routing (pctxt, &pvalue->beneficiary, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode beneficiaryBank */

   if (pvalue->m.beneficiaryBankPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Routing (pctxt, &pvalue->beneficiaryBank, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode intermediaryInformation_list */

   pnode2 = pvalue->intermediaryInformation_list.tail;
   while (0 != pnode2) {
      ll = asn1E_IntermediaryInformation (pctxt, ((IntermediaryInformation*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode correspondentInformation */

   if (pvalue->m.correspondentInformationPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Routing (pctxt, &pvalue->correspondentInformation, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode settlementMethod */

   if (pvalue->m.settlementMethodPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_SettlementMethod (pctxt, &pvalue->settlementMethod, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SettlementInstruction (OSCTXT* pctxt, 
   SettlementInstruction* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode settlementMethod */

   if (pvalue->m.settlementMethodPresent) {
      stat = XmlEnc_SettlementMethod (pctxt, &pvalue->settlementMethod
         , OSUTF8("settlementMethod"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode correspondentInformation */

   if (pvalue->m.correspondentInformationPresent) {
      stat = XmlEnc_Routing (pctxt, &pvalue->correspondentInformation
         , OSUTF8("correspondentInformation"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode intermediaryInformation_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->intermediaryInformation_list.head;
   while (0 != pnode) {
      stat = XmlEnc_IntermediaryInformation (pctxt, 
         ((IntermediaryInformation*)pnode->data)
         , OSUTF8("intermediaryInformation"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode beneficiaryBank */

   if (pvalue->m.beneficiaryBankPresent) {
      stat = XmlEnc_Routing (pctxt, &pvalue->beneficiaryBank
         , OSUTF8("beneficiaryBank"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode beneficiary */

   stat = XmlEnc_Routing (pctxt, &pvalue->beneficiary
      , OSUTF8("beneficiary"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode splitSettlement_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->splitSettlement_list.head;
   while (0 != pnode) {
      stat = XmlEnc_SplitSettlement (pctxt, ((SplitSettlement*)pnode->data)
         , OSUTF8("splitSettlement"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SettlementInformation                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SettlementInformation (OSCTXT* pctxt,
   SettlementInformation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         if(pvalue->u.standardSettlementStyle < 0 || pvalue->u.standardSettlementStyle > 2)
            return LOG_RTERR (pctxt, RTERR_INVENUM);

         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            asn1E_StandardSettlementStyleEnum (pctxt, &pvalue->u.standardSettlementStyle, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_SettlementInstruction (pctxt, pvalue->u.settlementInstruction, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   if (tagging == ASN1EXPL) {
      ll1 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll1);
      if (ll1 < 0) return LOG_RTERR (pctxt, ll1);
   }

   ll0 += ll1;

   return (ll0);
}

int XmlEnc_SettlementInformation (OSCTXT* pctxt, 
   SettlementInformation* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode standardSettlementStyle */

         if(pvalue->u.standardSettlementStyle < 0 || pvalue->
            u.standardSettlementStyle > 2)
            return LOG_RTERR (pctxt, RTERR_INVENUM);

         stat = XmlEnc_StandardSettlementStyleEnum (pctxt, pvalue->
            u.standardSettlementStyle
            , OSUTF8("standardSettlementStyle"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode settlementInstruction */

         stat = XmlEnc_SettlementInstruction (pctxt, pvalue->
            u.settlementInstruction
            , OSUTF8("settlementInstruction"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FXOptionPayout                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FXOptionPayout (OSCTXT* pctxt,
   FXOptionPayout *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode settlementInformation */

   if (pvalue->m.settlementInformationPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_SettlementInformation (pctxt, &pvalue->settlementInformation, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode payoutStyle */

   if(pvalue->payoutStyle < 0 || pvalue->payoutStyle > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      asn1E_PayoutEnum (pctxt, &pvalue->payoutStyle, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode amount */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_real (pctxt, &pvalue->amount, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode currency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Currency (pctxt, &pvalue->currency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FXOptionPayout (OSCTXT* pctxt, FXOptionPayout* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode currency */

   stat = XmlEnc_Currency (pctxt, &pvalue->currency
      , OSUTF8("currency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode amount */

   stat = rtXmlEncDouble (pctxt, pvalue->amount, OSUTF8("amount"), nsPrefix
      , 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode payoutStyle */

   if(pvalue->payoutStyle < 0 || pvalue->payoutStyle > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_PayoutEnum (pctxt, pvalue->payoutStyle
      , OSUTF8("payoutStyle"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode settlementInformation */

   if (pvalue->m.settlementInformationPresent) {
      stat = XmlEnc_SettlementInformation (pctxt, &pvalue->
         settlementInformation, OSUTF8("settlementInformation"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Money_derivations                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Money_derivations (OSCTXT* pctxt,
   Money_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_Money (pctxt, pvalue->u.money, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_FXOptionPayout (pctxt, pvalue->u.fXOptionPayout, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Money_derivations (OSCTXT* pctxt, Money_derivations* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode money */

         stat = XmlEnc_Money (pctxt, pvalue->u.money, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode fXOptionPayout */

         stat = XmlEnc_FXOptionPayout (pctxt, pvalue->u.fXOptionPayout
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PremiumQuoteBasisEnum                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PremiumQuoteBasisEnum (OSCTXT* pctxt,
   PremiumQuoteBasisEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_PremiumQuoteBasisEnum (OSCTXT* pctxt, PremiumQuoteBasisEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      PremiumQuoteBasisEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PremiumQuote                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PremiumQuote (OSCTXT* pctxt,
   PremiumQuote *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode premiumQuoteBasis */

   if(pvalue->premiumQuoteBasis < 0 || pvalue->premiumQuoteBasis > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_PremiumQuoteBasisEnum (pctxt, &pvalue->premiumQuoteBasis, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode premiumValue */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_real (pctxt, &pvalue->premiumValue, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PremiumQuote (OSCTXT* pctxt, PremiumQuote* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode premiumValue */

   stat = rtXmlEncDouble (pctxt, pvalue->premiumValue
      , OSUTF8("premiumValue"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode premiumQuoteBasis */

   if(pvalue->premiumQuoteBasis < 0 || pvalue->premiumQuoteBasis > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_PremiumQuoteBasisEnum (pctxt, pvalue->premiumQuoteBasis
      , OSUTF8("premiumQuoteBasis"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FXOptionPremium                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FXOptionPremium (OSCTXT* pctxt,
   FXOptionPremium *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode premiumQuote */

   if (pvalue->m.premiumQuotePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_PremiumQuote (pctxt, &pvalue->premiumQuote, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode settlementInformation */

   if (pvalue->m.settlementInformationPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_SettlementInformation (pctxt, &pvalue->settlementInformation, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode premiumSettlementDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_charstr (pctxt, pvalue->premiumSettlementDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode premiumAmount */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Money_derivations (pctxt, &pvalue->premiumAmount, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode payerReceiver_model */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FXOptionPremium (OSCTXT* pctxt, FXOptionPremium* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode payerReceiver_model */

   stat = XmlEnc_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode premiumAmount */

   stat = XmlEnc_Money_derivations (pctxt, &pvalue->premiumAmount
      , OSUTF8("premiumAmount"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode premiumSettlementDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
      premiumSettlementDate, OSUTF8("premiumSettlementDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode settlementInformation */

   if (pvalue->m.settlementInformationPresent) {
      stat = XmlEnc_SettlementInformation (pctxt, &pvalue->
         settlementInformation, OSUTF8("settlementInformation"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode premiumQuote */

   if (pvalue->m.premiumQuotePresent) {
      stat = XmlEnc_PremiumQuote (pctxt, &pvalue->premiumQuote
         , OSUTF8("premiumQuote"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  StrikeQuoteBasisEnum                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_StrikeQuoteBasisEnum (OSCTXT* pctxt,
   StrikeQuoteBasisEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_StrikeQuoteBasisEnum (OSCTXT* pctxt, StrikeQuoteBasisEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      StrikeQuoteBasisEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FXStrikePrice                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FXStrikePrice (OSCTXT* pctxt,
   FXStrikePrice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode strikeQuoteBasis */

   if(pvalue->strikeQuoteBasis < 0 || pvalue->strikeQuoteBasis > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_StrikeQuoteBasisEnum (pctxt, &pvalue->strikeQuoteBasis, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode rate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_real (pctxt, &pvalue->rate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FXStrikePrice (OSCTXT* pctxt, FXStrikePrice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode rate */

   stat = rtXmlEncDouble (pctxt, pvalue->rate, OSUTF8("rate"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode strikeQuoteBasis */

   if(pvalue->strikeQuoteBasis < 0 || pvalue->strikeQuoteBasis > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_StrikeQuoteBasisEnum (pctxt, pvalue->strikeQuoteBasis
      , OSUTF8("strikeQuoteBasis"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationProvider                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_InformationProvider (OSCTXT* pctxt,
   InformationProvider *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode informationProviderScheme */

   if (pvalue->m.informationProviderSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->informationProviderScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_InformationProvider (OSCTXT* pctxt, InformationProvider* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.informationProviderSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" informationProviderScheme=\""), 28);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->informationProviderScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RateSourcePage                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RateSourcePage (OSCTXT* pctxt,
   RateSourcePage *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode rateSourcePageScheme */

   if (pvalue->m.rateSourcePageSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->rateSourcePageScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_RateSourcePage (OSCTXT* pctxt, RateSourcePage* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.rateSourcePageSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" rateSourcePageScheme=\""), 23);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->rateSourcePageScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationSource                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_InformationSource (OSCTXT* pctxt,
   InformationSource *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode rateSourcePageHeading */

   if (pvalue->m.rateSourcePageHeadingPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->rateSourcePageHeading, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode rateSourcePage */

   if (pvalue->m.rateSourcePagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_RateSourcePage (pctxt, &pvalue->rateSourcePage, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode rateSource */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_InformationProvider (pctxt, &pvalue->rateSource, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_InformationSource (OSCTXT* pctxt, InformationSource* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode rateSource */

   stat = XmlEnc_InformationProvider (pctxt, &pvalue->rateSource
      , OSUTF8("rateSource"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rateSourcePage */

   if (pvalue->m.rateSourcePagePresent) {
      stat = XmlEnc_RateSourcePage (pctxt, &pvalue->rateSourcePage
         , OSUTF8("rateSourcePage"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode rateSourcePageHeading */

   if (pvalue->m.rateSourcePageHeadingPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->rateSourcePageHeading
         , OSUTF8("rateSourcePageHeading"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PeriodEnum                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PeriodEnum (OSCTXT* pctxt,
   PeriodEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_PeriodEnum (OSCTXT* pctxt, PeriodEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      PeriodEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RollConventionEnum                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RollConventionEnum (OSCTXT* pctxt,
   RollConventionEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 43)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_RollConventionEnum (OSCTXT* pctxt, RollConventionEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      RollConventionEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CalculationPeriodFrequency                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CalculationPeriodFrequency (OSCTXT* pctxt,
   CalculationPeriodFrequency *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode rollConvention */

   if(pvalue->rollConvention < 0 || pvalue->rollConvention > 43)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
      asn1E_RollConventionEnum (pctxt, &pvalue->rollConvention, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode period */

   if(pvalue->period < 0 || pvalue->period > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      asn1E_PeriodEnum (pctxt, &pvalue->period, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode periodMultiplier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_integer (pctxt, &pvalue->periodMultiplier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CalculationPeriodFrequency (OSCTXT* pctxt, 
   CalculationPeriodFrequency* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode periodMultiplier */

   stat = rtXmlEncInt (pctxt, pvalue->periodMultiplier
      , OSUTF8("periodMultiplier"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode period */

   if(pvalue->period < 0 || pvalue->period > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_PeriodEnum (pctxt, pvalue->period
      , OSUTF8("period"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rollConvention */

   if(pvalue->rollConvention < 0 || pvalue->rollConvention > 43)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_RollConventionEnum (pctxt, pvalue->rollConvention
      , OSUTF8("rollConvention"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FXAverageRateObservationSchedule                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FXAverageRateObservationSchedule (OSCTXT* pctxt,
   FXAverageRateObservationSchedule *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode calculationPeriodFrequency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_CalculationPeriodFrequency (pctxt, &pvalue->calculationPeriodFrequency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode observationEndDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_charstr (pctxt, pvalue->observationEndDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode observationStartDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_charstr (pctxt, pvalue->observationStartDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FXAverageRateObservationSchedule (OSCTXT* pctxt, 
   FXAverageRateObservationSchedule* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode observationStartDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
      observationStartDate, OSUTF8("observationStartDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode observationEndDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->observationEndDate
      , OSUTF8("observationEndDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode calculationPeriodFrequency */

   stat = XmlEnc_CalculationPeriodFrequency (pctxt, &pvalue->
      calculationPeriodFrequency
      , OSUTF8("calculationPeriodFrequency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FXAverageRateObservationDate                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FXAverageRateObservationDate (OSCTXT* pctxt,
   FXAverageRateObservationDate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode averageRateWeightingFactor */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_real (pctxt, &pvalue->averageRateWeightingFactor, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode observationDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_charstr (pctxt, pvalue->observationDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FXAverageRateObservationDate (OSCTXT* pctxt, 
   FXAverageRateObservationDate* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode observationDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->observationDate
      , OSUTF8("observationDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode averageRateWeightingFactor */

   stat = rtXmlEncDouble (pctxt, pvalue->averageRateWeightingFactor
      , OSUTF8("averageRateWeightingFactor"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FXAverageRateOption_choice                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FXAverageRateOption_choice (OSCTXT* pctxt,
   FXAverageRateOption_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_FXAverageRateObservationSchedule (pctxt, pvalue->u.averageRateObservationSchedule, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         if (!(pvalue->u.averageRateObservationDate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "FXAverageRateOption_choice.u.averageRateObservationDate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.averageRateObservationDate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         pnode2 = pvalue->u.averageRateObservationDate_list->tail;
         while (0 != pnode2) {
            ll = asn1E_FXAverageRateObservationDate (pctxt, ((FXAverageRateObservationDate*)pnode2->data), ASN1EXPL);
            if (ll < 0) return LOG_RTERR (pctxt, ll);
            ll2 += ll;

            pnode2 = pnode2->prev;
         }
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else { ll1 += ll; ll2 = 0; }
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_FXAverageRateOption_choice (OSCTXT* pctxt, 
   FXAverageRateOption_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode averageRateObservationSchedule */

         stat = XmlEnc_FXAverageRateObservationSchedule (pctxt, pvalue->
            u.averageRateObservationSchedule
            , OSUTF8("averageRateObservationSchedule"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode averageRateObservationDate_list */

         if (!(pvalue->u.averageRateObservationDate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "FXAverageRateOption_choice.u.averageRateObservationDate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->
               u.averageRateObservationDate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         { const OSUTF8CHAR* savedPrefix = nsPrefix;
         nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
            "http://www.fpml.org/2003/FpML-4-0"));

         { OSRTDListNode* pnode = pvalue->u.averageRateObservationDate_list->
            head;
         while (0 != pnode) {
            stat = XmlEnc_FXAverageRateObservationDate (pctxt, 
               ((FXAverageRateObservationDate*)pnode->data)
               , OSUTF8("averageRateObservationDate"), nsPrefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            pnode = pnode->next;
         }}
         nsPrefix = savedPrefix;
         }

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ObservedRates                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ObservedRates (OSCTXT* pctxt,
   ObservedRates *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode observedRate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_real (pctxt, &pvalue->observedRate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode observationDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_charstr (pctxt, pvalue->observationDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ObservedRates (OSCTXT* pctxt, ObservedRates* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode observationDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->observationDate
      , OSUTF8("observationDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode observedRate */

   stat = rtXmlEncDouble (pctxt, pvalue->observedRate
      , OSUTF8("observedRate"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FXAverageRateOption                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FXAverageRateOption (OSCTXT* pctxt,
   FXAverageRateOption *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode observedRates_list */

   pnode2 = pvalue->observedRates_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ObservedRates (pctxt, ((ObservedRates*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|20, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|19,
      asn1E_FXAverageRateOption_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode fixingTime */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|18,
      asn1E_BusinessCenterTime (pctxt, &pvalue->fixingTime, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode secondaryRateSource */

   if (pvalue->m.secondaryRateSourcePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|17,
         asn1E_InformationSource (pctxt, &pvalue->secondaryRateSource, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode primaryRateSource */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|16,
      asn1E_InformationSource (pctxt, &pvalue->primaryRateSource, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode payoutFormula */

   if (pvalue->m.payoutFormulaPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|15,
         xe_utf8str (pctxt, pvalue->payoutFormula, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode precision */

   if (pvalue->m.precisionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|14,
         xe_unsigned (pctxt, &pvalue->precision, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode averageRateQuoteBasis */

   if(pvalue->averageRateQuoteBasis < 0 || pvalue->averageRateQuoteBasis > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|13,
      asn1E_StrikeQuoteBasisEnum (pctxt, &pvalue->averageRateQuoteBasis, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode payoutCurrency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|12,
      asn1E_Currency (pctxt, &pvalue->payoutCurrency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode spotRate */

   if (pvalue->m.spotRatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|11,
         xe_real (pctxt, &pvalue->spotRate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode fxStrikePrice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10,
      asn1E_FXStrikePrice (pctxt, &pvalue->fxStrikePrice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode callCurrencyAmount */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9,
      asn1E_Money_derivations (pctxt, &pvalue->callCurrencyAmount, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode putCurrencyAmount */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
      asn1E_Money_derivations (pctxt, &pvalue->putCurrencyAmount, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode valueDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
      xe_charstr (pctxt, pvalue->valueDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode fxOptionPremium_list */

   pnode2 = pvalue->fxOptionPremium_list.tail;
   while (0 != pnode2) {
      ll = asn1E_FXOptionPremium (pctxt, ((FXOptionPremium*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode exerciseStyle */

   if(pvalue->exerciseStyle < 0 || pvalue->exerciseStyle > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
      asn1E_ExerciseStyleEnum (pctxt, &pvalue->exerciseStyle, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode expiryDateTime */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_ExpiryDateTime (pctxt, &pvalue->expiryDateTime, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode buyerSeller_model */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_BuyerSeller_model (pctxt, &pvalue->buyerSeller_model, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode productId_list */

   pnode2 = pvalue->productId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ProductId (pctxt, ((ProductId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ProductType (pctxt, &pvalue->productType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FXAverageRateOption (OSCTXT* pctxt, FXAverageRateOption* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      stat = XmlEnc_ProductType (pctxt, &pvalue->productType
         , OSUTF8("productType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode productId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->productId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ProductId (pctxt, ((ProductId*)pnode->data)
         , OSUTF8("productId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode buyerSeller_model */

   stat = XmlEnc_BuyerSeller_model (pctxt, &pvalue->buyerSeller_model
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode expiryDateTime */

   stat = XmlEnc_ExpiryDateTime (pctxt, &pvalue->expiryDateTime
      , OSUTF8("expiryDateTime"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode exerciseStyle */

   if(pvalue->exerciseStyle < 0 || pvalue->exerciseStyle > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_ExerciseStyleEnum (pctxt, pvalue->exerciseStyle
      , OSUTF8("exerciseStyle"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode fxOptionPremium_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->fxOptionPremium_list.head;
   while (0 != pnode) {
      stat = XmlEnc_FXOptionPremium (pctxt, ((FXOptionPremium*)pnode->data)
         , OSUTF8("fxOptionPremium"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode valueDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->valueDate
      , OSUTF8("valueDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode putCurrencyAmount */

   stat = XmlEnc_Money_derivations (pctxt, &pvalue->putCurrencyAmount
      , OSUTF8("putCurrencyAmount"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode callCurrencyAmount */

   stat = XmlEnc_Money_derivations (pctxt, &pvalue->callCurrencyAmount
      , OSUTF8("callCurrencyAmount"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode fxStrikePrice */

   stat = XmlEnc_FXStrikePrice (pctxt, &pvalue->fxStrikePrice
      , OSUTF8("fxStrikePrice"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode spotRate */

   if (pvalue->m.spotRatePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->spotRate
         , OSUTF8("spotRate"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode payoutCurrency */

   stat = XmlEnc_Currency (pctxt, &pvalue->payoutCurrency
      , OSUTF8("payoutCurrency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode averageRateQuoteBasis */

   if(pvalue->averageRateQuoteBasis < 0 || pvalue->averageRateQuoteBasis > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_StrikeQuoteBasisEnum (pctxt, pvalue->averageRateQuoteBasis
      , OSUTF8("averageRateQuoteBasis"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode precision */

   if (pvalue->m.precisionPresent) {
      stat = rtXmlEncUInt (pctxt, pvalue->precision
         , OSUTF8("precision"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode payoutFormula */

   if (pvalue->m.payoutFormulaPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->payoutFormula
         , OSUTF8("payoutFormula"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode primaryRateSource */

   stat = XmlEnc_InformationSource (pctxt, &pvalue->primaryRateSource
      , OSUTF8("primaryRateSource"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode secondaryRateSource */

   if (pvalue->m.secondaryRateSourcePresent) {
      stat = XmlEnc_InformationSource (pctxt, &pvalue->secondaryRateSource
         , OSUTF8("secondaryRateSource"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fixingTime */

   stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->fixingTime
      , OSUTF8("fixingTime"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode choice */

   stat = XmlEnc_FXAverageRateOption_choice (pctxt, &pvalue->choice
      , OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode observedRates_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->observedRates_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ObservedRates (pctxt, ((ObservedRates*)pnode->data)
         , OSUTF8("observedRates"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FxAverageRateOption                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FxAverageRateOption (OSCTXT* pctxt,
   FxAverageRateOption *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_FXAverageRateOption (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_FxAverageRateOption (OSCTXT* pctxt, FxAverageRateOption* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_FXAverageRateOption (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FxBarrierTypeEnum                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FxBarrierTypeEnum (OSCTXT* pctxt,
   FxBarrierTypeEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 3)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_FxBarrierTypeEnum (OSCTXT* pctxt, FxBarrierTypeEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      FxBarrierTypeEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuoteBasisEnum                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuoteBasisEnum (OSCTXT* pctxt,
   QuoteBasisEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_QuoteBasisEnum (OSCTXT* pctxt, QuoteBasisEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      QuoteBasisEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuotedCurrencyPair                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuotedCurrencyPair (OSCTXT* pctxt,
   QuotedCurrencyPair *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quoteBasis */

   if(pvalue->quoteBasis < 0 || pvalue->quoteBasis > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      asn1E_QuoteBasisEnum (pctxt, &pvalue->quoteBasis, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode currency2 */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Currency (pctxt, &pvalue->currency2, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode currency1 */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Currency (pctxt, &pvalue->currency1, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuotedCurrencyPair (OSCTXT* pctxt, QuotedCurrencyPair* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode currency1 */

   stat = XmlEnc_Currency (pctxt, &pvalue->currency1
      , OSUTF8("currency1"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode currency2 */

   stat = XmlEnc_Currency (pctxt, &pvalue->currency2
      , OSUTF8("currency2"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode quoteBasis */

   if(pvalue->quoteBasis < 0 || pvalue->quoteBasis > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_QuoteBasisEnum (pctxt, pvalue->quoteBasis
      , OSUTF8("quoteBasis"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FXBarrier                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FXBarrier (OSCTXT* pctxt,
   FXBarrier *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode observationEndDate */

   if (pvalue->m.observationEndDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         xe_charstr (pctxt, pvalue->observationEndDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode observationStartDate */

   if (pvalue->m.observationStartDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_charstr (pctxt, pvalue->observationStartDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode informationSource_list */

   if (!(pvalue->informationSource_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FXBarrier.informationSource_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->informationSource_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->informationSource_list.tail;
   while (0 != pnode2) {
      ll = asn1E_InformationSource (pctxt, ((InformationSource*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode triggerRate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_real (pctxt, &pvalue->triggerRate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode quotedCurrencyPair */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_QuotedCurrencyPair (pctxt, &pvalue->quotedCurrencyPair, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode fxBarrierType */

   if (pvalue->m.fxBarrierTypePresent) {
      if(pvalue->fxBarrierType < 0 || pvalue->fxBarrierType > 3)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         asn1E_FxBarrierTypeEnum (pctxt, &pvalue->fxBarrierType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FXBarrier (OSCTXT* pctxt, FXBarrier* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode fxBarrierType */

   if (pvalue->m.fxBarrierTypePresent) {
      if(pvalue->fxBarrierType < 0 || pvalue->fxBarrierType > 3)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_FxBarrierTypeEnum (pctxt, pvalue->fxBarrierType
         , OSUTF8("fxBarrierType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quotedCurrencyPair */

   stat = XmlEnc_QuotedCurrencyPair (pctxt, &pvalue->quotedCurrencyPair
      , OSUTF8("quotedCurrencyPair"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode triggerRate */

   stat = rtXmlEncDouble (pctxt, pvalue->triggerRate
      , OSUTF8("triggerRate"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode informationSource_list */

   if (!(pvalue->informationSource_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FXBarrier.informationSource_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->informationSource_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->informationSource_list.head;
   while (0 != pnode) {
      stat = XmlEnc_InformationSource (pctxt, ((InformationSource*)pnode->data)
         , OSUTF8("informationSource"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode observationStartDate */

   if (pvalue->m.observationStartDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         observationStartDate, OSUTF8("observationStartDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode observationEndDate */

   if (pvalue->m.observationEndDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         observationEndDate, OSUTF8("observationEndDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FXBarrierOption                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FXBarrierOption (OSCTXT* pctxt,
   FXBarrierOption *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode triggerPayout */

   if (pvalue->m.triggerPayoutPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_FXOptionPayout (pctxt, &pvalue->triggerPayout, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode fxBarrier_list */

   if (!(pvalue->fxBarrier_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FXBarrierOption.fxBarrier_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->fxBarrier_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->fxBarrier_list.tail;
   while (0 != pnode2) {
      ll = asn1E_FXBarrier (pctxt, ((FXBarrier*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode spotRate */

   if (pvalue->m.spotRatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_real (pctxt, &pvalue->spotRate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode productId_list */

   pnode2 = pvalue->productId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ProductId (pctxt, ((ProductId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ProductType (pctxt, &pvalue->productType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FXBarrierOption (OSCTXT* pctxt, FXBarrierOption* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      stat = XmlEnc_ProductType (pctxt, &pvalue->productType
         , OSUTF8("productType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode productId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->productId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ProductId (pctxt, ((ProductId*)pnode->data)
         , OSUTF8("productId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode spotRate */

   if (pvalue->m.spotRatePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->spotRate
         , OSUTF8("spotRate"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fxBarrier_list */

   if (!(pvalue->fxBarrier_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FXBarrierOption.fxBarrier_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->fxBarrier_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->fxBarrier_list.head;
   while (0 != pnode) {
      stat = XmlEnc_FXBarrier (pctxt, ((FXBarrier*)pnode->data)
         , OSUTF8("fxBarrier"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode triggerPayout */

   if (pvalue->m.triggerPayoutPresent) {
      stat = XmlEnc_FXOptionPayout (pctxt, &pvalue->triggerPayout
         , OSUTF8("triggerPayout"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FxBarrierOption                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FxBarrierOption (OSCTXT* pctxt,
   FxBarrierOption *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_FXBarrierOption (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_FxBarrierOption (OSCTXT* pctxt, FxBarrierOption* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_FXBarrierOption (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TriggerConditionEnum                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TriggerConditionEnum (OSCTXT* pctxt,
   TriggerConditionEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_TriggerConditionEnum (OSCTXT* pctxt, TriggerConditionEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      TriggerConditionEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FXEuropeanTrigger                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FXEuropeanTrigger (OSCTXT* pctxt,
   FXEuropeanTrigger *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode informationSource_list */

   if (!(pvalue->informationSource_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FXEuropeanTrigger.informationSource_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->informationSource_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->informationSource_list.tail;
   while (0 != pnode2) {
      ll = asn1E_InformationSource (pctxt, ((InformationSource*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode triggerRate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_real (pctxt, &pvalue->triggerRate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode quotedCurrencyPair */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_QuotedCurrencyPair (pctxt, &pvalue->quotedCurrencyPair, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode triggerCondition */

   if(pvalue->triggerCondition < 0 || pvalue->triggerCondition > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_TriggerConditionEnum (pctxt, &pvalue->triggerCondition, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FXEuropeanTrigger (OSCTXT* pctxt, FXEuropeanTrigger* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode triggerCondition */

   if(pvalue->triggerCondition < 0 || pvalue->triggerCondition > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TriggerConditionEnum (pctxt, pvalue->triggerCondition
      , OSUTF8("triggerCondition"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode quotedCurrencyPair */

   stat = XmlEnc_QuotedCurrencyPair (pctxt, &pvalue->quotedCurrencyPair
      , OSUTF8("quotedCurrencyPair"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode triggerRate */

   stat = rtXmlEncDouble (pctxt, pvalue->triggerRate
      , OSUTF8("triggerRate"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode informationSource_list */

   if (!(pvalue->informationSource_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FXEuropeanTrigger.informationSource_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->informationSource_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->informationSource_list.head;
   while (0 != pnode) {
      stat = XmlEnc_InformationSource (pctxt, ((InformationSource*)pnode->data)
         , OSUTF8("informationSource"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TouchConditionEnum                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TouchConditionEnum (OSCTXT* pctxt,
   TouchConditionEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_TouchConditionEnum (OSCTXT* pctxt, TouchConditionEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      TouchConditionEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FXAmericanTrigger                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FXAmericanTrigger (OSCTXT* pctxt,
   FXAmericanTrigger *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode observationEndDate */

   if (pvalue->m.observationEndDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         xe_charstr (pctxt, pvalue->observationEndDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode observationStartDate */

   if (pvalue->m.observationStartDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_charstr (pctxt, pvalue->observationStartDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode informationSource_list */

   if (!(pvalue->informationSource_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FXAmericanTrigger.informationSource_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->informationSource_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->informationSource_list.tail;
   while (0 != pnode2) {
      ll = asn1E_InformationSource (pctxt, ((InformationSource*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode triggerRate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_real (pctxt, &pvalue->triggerRate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode quotedCurrencyPair */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_QuotedCurrencyPair (pctxt, &pvalue->quotedCurrencyPair, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode touchCondition */

   if(pvalue->touchCondition < 0 || pvalue->touchCondition > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_TouchConditionEnum (pctxt, &pvalue->touchCondition, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FXAmericanTrigger (OSCTXT* pctxt, FXAmericanTrigger* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode touchCondition */

   if(pvalue->touchCondition < 0 || pvalue->touchCondition > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TouchConditionEnum (pctxt, pvalue->touchCondition
      , OSUTF8("touchCondition"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode quotedCurrencyPair */

   stat = XmlEnc_QuotedCurrencyPair (pctxt, &pvalue->quotedCurrencyPair
      , OSUTF8("quotedCurrencyPair"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode triggerRate */

   stat = rtXmlEncDouble (pctxt, pvalue->triggerRate
      , OSUTF8("triggerRate"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode informationSource_list */

   if (!(pvalue->informationSource_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FXAmericanTrigger.informationSource_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->informationSource_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->informationSource_list.head;
   while (0 != pnode) {
      stat = XmlEnc_InformationSource (pctxt, ((InformationSource*)pnode->data)
         , OSUTF8("informationSource"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode observationStartDate */

   if (pvalue->m.observationStartDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         observationStartDate, OSUTF8("observationStartDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode observationEndDate */

   if (pvalue->m.observationEndDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         observationEndDate, OSUTF8("observationEndDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FXDigitalOption_choice                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FXDigitalOption_choice (OSCTXT* pctxt,
   FXDigitalOption_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         if (!(pvalue->u.fxEuropeanTrigger_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "FXDigitalOption_choice.u.fxEuropeanTrigger_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxEuropeanTrigger_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         pnode2 = pvalue->u.fxEuropeanTrigger_list->tail;
         while (0 != pnode2) {
            ll = asn1E_FXEuropeanTrigger (pctxt, ((FXEuropeanTrigger*)pnode2->data), ASN1EXPL);
            if (ll < 0) return LOG_RTERR (pctxt, ll);
            ll2 += ll;

            pnode2 = pnode2->prev;
         }
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else { ll1 += ll; ll2 = 0; }
         break;

      case 2:
         if (!(pvalue->u.fxAmericanTrigger_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "FXDigitalOption_choice.u.fxAmericanTrigger_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxAmericanTrigger_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         pnode2 = pvalue->u.fxAmericanTrigger_list->tail;
         while (0 != pnode2) {
            ll = asn1E_FXAmericanTrigger (pctxt, ((FXAmericanTrigger*)pnode2->data), ASN1EXPL);
            if (ll < 0) return LOG_RTERR (pctxt, ll);
            ll2 += ll;

            pnode2 = pnode2->prev;
         }
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else { ll1 += ll; ll2 = 0; }
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_FXDigitalOption_choice (OSCTXT* pctxt, 
   FXDigitalOption_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode fxEuropeanTrigger_list */

         if (!(pvalue->u.fxEuropeanTrigger_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "FXDigitalOption_choice.u.fxEuropeanTrigger_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxEuropeanTrigger_list->
               count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         { const OSUTF8CHAR* savedPrefix = nsPrefix;
         nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
            "http://www.fpml.org/2003/FpML-4-0"));

         { OSRTDListNode* pnode = pvalue->u.fxEuropeanTrigger_list->head;
         while (0 != pnode) {
            stat = XmlEnc_FXEuropeanTrigger (pctxt, 
               ((FXEuropeanTrigger*)pnode->data)
               , OSUTF8("fxEuropeanTrigger"), nsPrefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            pnode = pnode->next;
         }}
         nsPrefix = savedPrefix;
         }

         break;

      case 2:
         /* encode fxAmericanTrigger_list */

         if (!(pvalue->u.fxAmericanTrigger_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "FXDigitalOption_choice.u.fxAmericanTrigger_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxAmericanTrigger_list->
               count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         { const OSUTF8CHAR* savedPrefix = nsPrefix;
         nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
            "http://www.fpml.org/2003/FpML-4-0"));

         { OSRTDListNode* pnode = pvalue->u.fxAmericanTrigger_list->head;
         while (0 != pnode) {
            stat = XmlEnc_FXAmericanTrigger (pctxt, 
               ((FXAmericanTrigger*)pnode->data)
               , OSUTF8("fxAmericanTrigger"), nsPrefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            pnode = pnode->next;
         }}
         nsPrefix = savedPrefix;
         }

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FXDigitalOption                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FXDigitalOption (OSCTXT* pctxt,
   FXDigitalOption *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode triggerPayout */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10,
      asn1E_FXOptionPayout (pctxt, &pvalue->triggerPayout, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9,
      asn1E_FXDigitalOption_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode spotRate */

   if (pvalue->m.spotRatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|8,
         xe_real (pctxt, &pvalue->spotRate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode quotedCurrencyPair */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
      asn1E_QuotedCurrencyPair (pctxt, &pvalue->quotedCurrencyPair, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode valueDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
      xe_charstr (pctxt, pvalue->valueDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode fxOptionPremium_list */

   pnode2 = pvalue->fxOptionPremium_list.tail;
   while (0 != pnode2) {
      ll = asn1E_FXOptionPremium (pctxt, ((FXOptionPremium*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode expiryDateTime */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_ExpiryDateTime (pctxt, &pvalue->expiryDateTime, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode buyerSeller_model */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_BuyerSeller_model (pctxt, &pvalue->buyerSeller_model, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode productId_list */

   pnode2 = pvalue->productId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ProductId (pctxt, ((ProductId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ProductType (pctxt, &pvalue->productType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FXDigitalOption (OSCTXT* pctxt, FXDigitalOption* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      stat = XmlEnc_ProductType (pctxt, &pvalue->productType
         , OSUTF8("productType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode productId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->productId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ProductId (pctxt, ((ProductId*)pnode->data)
         , OSUTF8("productId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode buyerSeller_model */

   stat = XmlEnc_BuyerSeller_model (pctxt, &pvalue->buyerSeller_model
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode expiryDateTime */

   stat = XmlEnc_ExpiryDateTime (pctxt, &pvalue->expiryDateTime
      , OSUTF8("expiryDateTime"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode fxOptionPremium_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->fxOptionPremium_list.head;
   while (0 != pnode) {
      stat = XmlEnc_FXOptionPremium (pctxt, ((FXOptionPremium*)pnode->data)
         , OSUTF8("fxOptionPremium"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode valueDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->valueDate
      , OSUTF8("valueDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode quotedCurrencyPair */

   stat = XmlEnc_QuotedCurrencyPair (pctxt, &pvalue->quotedCurrencyPair
      , OSUTF8("quotedCurrencyPair"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode spotRate */

   if (pvalue->m.spotRatePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->spotRate
         , OSUTF8("spotRate"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode choice */

   stat = XmlEnc_FXDigitalOption_choice (pctxt, &pvalue->choice
      , OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode triggerPayout */

   stat = XmlEnc_FXOptionPayout (pctxt, &pvalue->triggerPayout
      , OSUTF8("triggerPayout"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FxDigitalOption                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FxDigitalOption (OSCTXT* pctxt,
   FxDigitalOption *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_FXDigitalOption (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_FxDigitalOption (OSCTXT* pctxt, FxDigitalOption* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_FXDigitalOption (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FXFixing                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FXFixing (OSCTXT* pctxt,
   FXFixing *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode fixingDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
      xe_charstr (pctxt, pvalue->fixingDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode quotedCurrencyPair */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_QuotedCurrencyPair (pctxt, &pvalue->quotedCurrencyPair, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode fixingTime */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_BusinessCenterTime (pctxt, &pvalue->fixingTime, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode secondaryRateSource */

   if (pvalue->m.secondaryRateSourcePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_InformationSource (pctxt, &pvalue->secondaryRateSource, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode primaryRateSource */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_InformationSource (pctxt, &pvalue->primaryRateSource, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FXFixing (OSCTXT* pctxt, FXFixing* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode primaryRateSource */

   stat = XmlEnc_InformationSource (pctxt, &pvalue->primaryRateSource
      , OSUTF8("primaryRateSource"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode secondaryRateSource */

   if (pvalue->m.secondaryRateSourcePresent) {
      stat = XmlEnc_InformationSource (pctxt, &pvalue->secondaryRateSource
         , OSUTF8("secondaryRateSource"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fixingTime */

   stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->fixingTime
      , OSUTF8("fixingTime"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode quotedCurrencyPair */

   stat = XmlEnc_QuotedCurrencyPair (pctxt, &pvalue->quotedCurrencyPair
      , OSUTF8("quotedCurrencyPair"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode fixingDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->fixingDate
      , OSUTF8("fixingDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FXCashSettlement                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FXCashSettlement (OSCTXT* pctxt,
   FXCashSettlement *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode fixing_list */

   if (!(pvalue->fixing_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FXCashSettlement.fixing_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->fixing_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->fixing_list.tail;
   while (0 != pnode2) {
      ll = asn1E_FXFixing (pctxt, ((FXFixing*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode settlementCurrency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Currency (pctxt, &pvalue->settlementCurrency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FXCashSettlement (OSCTXT* pctxt, FXCashSettlement* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode settlementCurrency */

   stat = XmlEnc_Currency (pctxt, &pvalue->settlementCurrency
      , OSUTF8("settlementCurrency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode fixing_list */

   if (!(pvalue->fixing_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FXCashSettlement.fixing_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->fixing_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->fixing_list.head;
   while (0 != pnode) {
      stat = XmlEnc_FXFixing (pctxt, ((FXFixing*)pnode->data)
         , OSUTF8("fixing"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Interval                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Interval (OSCTXT* pctxt,
   Interval *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode period */

   if(pvalue->period < 0 || pvalue->period > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      asn1E_PeriodEnum (pctxt, &pvalue->period, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode periodMultiplier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_integer (pctxt, &pvalue->periodMultiplier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Interval (OSCTXT* pctxt, Interval* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode periodMultiplier */

   stat = rtXmlEncInt (pctxt, pvalue->periodMultiplier
      , OSUTF8("periodMultiplier"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode period */

   if(pvalue->period < 0 || pvalue->period > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_PeriodEnum (pctxt, pvalue->period
      , OSUTF8("period"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DayTypeEnum                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DayTypeEnum (OSCTXT* pctxt,
   DayTypeEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 3)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_DayTypeEnum (OSCTXT* pctxt, DayTypeEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      DayTypeEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Offset                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Offset (OSCTXT* pctxt,
   Offset *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode dayType */

   if (pvalue->m.dayTypePresent) {
      if(pvalue->dayType < 0 || pvalue->dayType > 3)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         asn1E_DayTypeEnum (pctxt, &pvalue->dayType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode period */

   if(pvalue->period < 0 || pvalue->period > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      asn1E_PeriodEnum (pctxt, &pvalue->period, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode periodMultiplier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_integer (pctxt, &pvalue->periodMultiplier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Offset (OSCTXT* pctxt, Offset* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode periodMultiplier */

   stat = rtXmlEncInt (pctxt, pvalue->periodMultiplier
      , OSUTF8("periodMultiplier"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode period */

   if(pvalue->period < 0 || pvalue->period > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_PeriodEnum (pctxt, pvalue->period
      , OSUTF8("period"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dayType */

   if (pvalue->m.dayTypePresent) {
      if(pvalue->dayType < 0 || pvalue->dayType > 3)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_DayTypeEnum (pctxt, pvalue->dayType
         , OSUTF8("dayType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BusinessDayConventionEnum                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BusinessDayConventionEnum (OSCTXT* pctxt,
   BusinessDayConventionEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 6)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_BusinessDayConventionEnum (OSCTXT* pctxt, 
   BusinessDayConventionEnum value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      BusinessDayConventionEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BusinessCentersReference                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BusinessCentersReference (OSCTXT* pctxt,
   BusinessCentersReference *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode href */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->href, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BusinessCentersReference (OSCTXT* pctxt, 
   BusinessCentersReference* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->href, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BusinessCenters                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BusinessCenters (OSCTXT* pctxt,
   BusinessCenters *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode businessCenter_list */

   if (!(pvalue->businessCenter_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BusinessCenters.businessCenter_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->businessCenter_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->businessCenter_list.tail;
   while (0 != pnode2) {
      ll = asn1E_BusinessCenter (pctxt, ((BusinessCenter*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BusinessCenters (OSCTXT* pctxt, BusinessCenters* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode businessCenter_list */

   if (!(pvalue->businessCenter_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BusinessCenters.businessCenter_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->businessCenter_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->businessCenter_list.head;
   while (0 != pnode) {
      stat = XmlEnc_BusinessCenter (pctxt, ((BusinessCenter*)pnode->data)
         , OSUTF8("businessCenter"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BusinessCentersOrReference_model                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BusinessCentersOrReference_model (OSCTXT* pctxt,
   BusinessCentersOrReference_model *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_BusinessCentersReference (pctxt, pvalue->u.businessCentersReference, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_BusinessCenters (pctxt, pvalue->u.businessCenters, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_BusinessCentersOrReference_model (OSCTXT* pctxt, 
   BusinessCentersOrReference_model* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode businessCentersReference */

         stat = XmlEnc_BusinessCentersReference (pctxt, pvalue->
            u.businessCentersReference
            , OSUTF8("businessCentersReference"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode businessCenters */

         stat = XmlEnc_BusinessCenters (pctxt, pvalue->u.businessCenters
            , OSUTF8("businessCenters"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DateRelativeTo                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DateRelativeTo (OSCTXT* pctxt,
   DateRelativeTo *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode href */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->href, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DateRelativeTo (OSCTXT* pctxt, DateRelativeTo* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->href, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelativeDateOffset                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RelativeDateOffset (OSCTXT* pctxt,
   RelativeDateOffset *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode dateRelativeTo */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_DateRelativeTo (pctxt, &pvalue->dateRelativeTo, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode choice */

   if (pvalue->m.choicePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_BusinessCentersOrReference_model (pctxt, &pvalue->choice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode businessDayConvention */

   if(pvalue->businessDayConvention < 0 || pvalue->businessDayConvention > 6)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
      asn1E_BusinessDayConventionEnum (pctxt, &pvalue->businessDayConvention, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode period */

   if(pvalue->period < 0 || pvalue->period > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      asn1E_PeriodEnum (pctxt, &pvalue->period, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode periodMultiplier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_integer (pctxt, &pvalue->periodMultiplier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_RelativeDateOffset (OSCTXT* pctxt, RelativeDateOffset* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode periodMultiplier */

   stat = rtXmlEncInt (pctxt, pvalue->periodMultiplier
      , OSUTF8("periodMultiplier"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode period */

   if(pvalue->period < 0 || pvalue->period > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_PeriodEnum (pctxt, pvalue->period
      , OSUTF8("period"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode businessDayConvention */

   if(pvalue->businessDayConvention < 0 || pvalue->businessDayConvention > 6)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_BusinessDayConventionEnum (pctxt, pvalue->
      businessDayConvention, OSUTF8("businessDayConvention"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode choice */

   if (pvalue->m.choicePresent) {
      stat = XmlEnc_BusinessCentersOrReference_model (pctxt, &pvalue->choice
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode dateRelativeTo */

   stat = XmlEnc_DateRelativeTo (pctxt, &pvalue->dateRelativeTo
      , OSUTF8("dateRelativeTo"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DateRange                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DateRange (OSCTXT* pctxt,
   DateRange *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode unadjustedLastDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_charstr (pctxt, pvalue->unadjustedLastDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode unadjustedFirstDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_charstr (pctxt, pvalue->unadjustedFirstDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DateRange (OSCTXT* pctxt, DateRange* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode unadjustedFirstDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
      unadjustedFirstDate, OSUTF8("unadjustedFirstDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode unadjustedLastDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->unadjustedLastDate
      , OSUTF8("unadjustedLastDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BusinessDateRange_choice                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BusinessDateRange_choice (OSCTXT* pctxt,
   BusinessDateRange_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_BusinessCentersOrReference_model (pctxt, pvalue->u.choice, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_BusinessDateRange_choice (OSCTXT* pctxt, 
   BusinessDateRange_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode choice */

         stat = XmlEnc_BusinessCentersOrReference_model (pctxt, pvalue->
            u.choice, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BusinessDateRange                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BusinessDateRange (OSCTXT* pctxt,
   BusinessDateRange *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode choice */

   if (pvalue->m.choicePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_BusinessDateRange_choice (pctxt, &pvalue->choice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode businessDayConvention */

   if(pvalue->businessDayConvention < 0 || pvalue->businessDayConvention > 6)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      asn1E_BusinessDayConventionEnum (pctxt, &pvalue->businessDayConvention, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode unadjustedLastDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_charstr (pctxt, pvalue->unadjustedLastDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode unadjustedFirstDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_charstr (pctxt, pvalue->unadjustedFirstDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BusinessDateRange (OSCTXT* pctxt, BusinessDateRange* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode unadjustedFirstDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
      unadjustedFirstDate, OSUTF8("unadjustedFirstDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode unadjustedLastDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->unadjustedLastDate
      , OSUTF8("unadjustedLastDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode businessDayConvention */

   if(pvalue->businessDayConvention < 0 || pvalue->businessDayConvention > 6)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_BusinessDayConventionEnum (pctxt, pvalue->
      businessDayConvention, OSUTF8("businessDayConvention"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode choice */

   if (pvalue->m.choicePresent) {
      stat = XmlEnc_BusinessDateRange_choice (pctxt, &pvalue->choice
         , OSUTF8(""), 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DateRange_derivations                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DateRange_derivations (OSCTXT* pctxt,
   DateRange_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_DateRange (pctxt, pvalue->u.dateRange, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_BusinessDateRange (pctxt, pvalue->u.businessDateRange, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_DateRange_derivations (OSCTXT* pctxt, 
   DateRange_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode dateRange */

         stat = XmlEnc_DateRange (pctxt, pvalue->u.dateRange, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode businessDateRange */

         stat = XmlEnc_BusinessDateRange (pctxt, pvalue->u.businessDateRange
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelativeDates                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RelativeDates (OSCTXT* pctxt,
   RelativeDates *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode scheduleBounds */

   if (pvalue->m.scheduleBoundsPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_DateRange_derivations (pctxt, &pvalue->scheduleBounds, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode periodSkip */

   if (pvalue->m.periodSkipPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_unsigned (pctxt, &pvalue->periodSkip, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode period */

   if(pvalue->period < 0 || pvalue->period > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      asn1E_PeriodEnum (pctxt, &pvalue->period, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode periodMultiplier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_integer (pctxt, &pvalue->periodMultiplier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_RelativeDates (OSCTXT* pctxt, RelativeDates* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode periodMultiplier */

   stat = rtXmlEncInt (pctxt, pvalue->periodMultiplier
      , OSUTF8("periodMultiplier"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode period */

   if(pvalue->period < 0 || pvalue->period > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_PeriodEnum (pctxt, pvalue->period
      , OSUTF8("period"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode periodSkip */

   if (pvalue->m.periodSkipPresent) {
      stat = rtXmlEncUInt (pctxt, pvalue->periodSkip
         , OSUTF8("periodSkip"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode scheduleBounds */

   if (pvalue->m.scheduleBoundsPresent) {
      stat = XmlEnc_DateRange_derivations (pctxt, &pvalue->scheduleBounds
         , OSUTF8("scheduleBounds"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelativeDateOffset_derivations                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RelativeDateOffset_derivations (OSCTXT* pctxt,
   RelativeDateOffset_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_RelativeDateOffset (pctxt, pvalue->u.relativeDateOffset, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_RelativeDates (pctxt, pvalue->u.relativeDates, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_RelativeDateOffset_derivations (OSCTXT* pctxt, 
   RelativeDateOffset_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode relativeDateOffset */

         stat = XmlEnc_RelativeDateOffset (pctxt, pvalue->u.relativeDateOffset
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode relativeDates */

         stat = XmlEnc_RelativeDates (pctxt, pvalue->u.relativeDates
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Offset_derivations                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Offset_derivations (OSCTXT* pctxt,
   Offset_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_Offset (pctxt, pvalue->u.offset, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_RelativeDateOffset_derivations (pctxt, pvalue->u.relativeDateOffset, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Offset_derivations (OSCTXT* pctxt, Offset_derivations* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode offset */

         stat = XmlEnc_Offset (pctxt, pvalue->u.offset, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode relativeDateOffset */

         stat = XmlEnc_RelativeDateOffset_derivations (pctxt, pvalue->
            u.relativeDateOffset, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  WeeklyRollConventionEnum                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_WeeklyRollConventionEnum (OSCTXT* pctxt,
   WeeklyRollConventionEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 6)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_WeeklyRollConventionEnum (OSCTXT* pctxt, 
   WeeklyRollConventionEnum value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      WeeklyRollConventionEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetFrequency                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ResetFrequency (OSCTXT* pctxt,
   ResetFrequency *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode weeklyRollConvention */

   if (pvalue->m.weeklyRollConventionPresent) {
      if(pvalue->weeklyRollConvention < 0 || pvalue->weeklyRollConvention > 6)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         asn1E_WeeklyRollConventionEnum (pctxt, &pvalue->weeklyRollConvention, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode period */

   if(pvalue->period < 0 || pvalue->period > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      asn1E_PeriodEnum (pctxt, &pvalue->period, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode periodMultiplier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_integer (pctxt, &pvalue->periodMultiplier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ResetFrequency (OSCTXT* pctxt, ResetFrequency* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode periodMultiplier */

   stat = rtXmlEncInt (pctxt, pvalue->periodMultiplier
      , OSUTF8("periodMultiplier"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode period */

   if(pvalue->period < 0 || pvalue->period > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_PeriodEnum (pctxt, pvalue->period
      , OSUTF8("period"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode weeklyRollConvention */

   if (pvalue->m.weeklyRollConventionPresent) {
      if(pvalue->weeklyRollConvention < 0 || pvalue->weeklyRollConvention > 6)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_WeeklyRollConventionEnum (pctxt, pvalue->
         weeklyRollConvention, OSUTF8("weeklyRollConvention"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Interval_derivations                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Interval_derivations (OSCTXT* pctxt,
   Interval_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_Interval (pctxt, pvalue->u.interval, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_Offset_derivations (pctxt, pvalue->u.offset, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_CalculationPeriodFrequency (pctxt, pvalue->u.calculationPeriodFrequency, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 4:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
            asn1E_ResetFrequency (pctxt, pvalue->u.resetFrequency, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Interval_derivations (OSCTXT* pctxt, Interval_derivations* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode interval */

         stat = XmlEnc_Interval (pctxt, pvalue->u.interval, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode offset */

         stat = XmlEnc_Offset_derivations (pctxt, pvalue->u.offset
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode calculationPeriodFrequency */

         stat = XmlEnc_CalculationPeriodFrequency (pctxt, pvalue->
            u.calculationPeriodFrequency, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 4:
         /* encode resetFrequency */

         stat = XmlEnc_ResetFrequency (pctxt, pvalue->u.resetFrequency
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuotedAs                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuotedAs (OSCTXT* pctxt,
   QuotedAs *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quotedTenor */

   if (pvalue->m.quotedTenorPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Interval_derivations (pctxt, &pvalue->quotedTenor, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode faceOnCurrency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Currency (pctxt, &pvalue->faceOnCurrency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode optionOnCurrency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Currency (pctxt, &pvalue->optionOnCurrency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuotedAs (OSCTXT* pctxt, QuotedAs* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode optionOnCurrency */

   stat = XmlEnc_Currency (pctxt, &pvalue->optionOnCurrency
      , OSUTF8("optionOnCurrency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode faceOnCurrency */

   stat = XmlEnc_Currency (pctxt, &pvalue->faceOnCurrency
      , OSUTF8("faceOnCurrency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode quotedTenor */

   if (pvalue->m.quotedTenorPresent) {
      stat = XmlEnc_Interval_derivations (pctxt, &pvalue->quotedTenor
         , OSUTF8("quotedTenor"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FXOptionLeg                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FXOptionLeg (OSCTXT* pctxt,
   FXOptionLeg *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode quotedAs */

   if (pvalue->m.quotedAsPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|12,
         asn1E_QuotedAs (pctxt, &pvalue->quotedAs, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode fxStrikePrice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|11,
      asn1E_FXStrikePrice (pctxt, &pvalue->fxStrikePrice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode callCurrencyAmount */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10,
      asn1E_Money_derivations (pctxt, &pvalue->callCurrencyAmount, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode putCurrencyAmount */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9,
      asn1E_Money_derivations (pctxt, &pvalue->putCurrencyAmount, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode cashSettlementTerms */

   if (pvalue->m.cashSettlementTermsPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_FXCashSettlement (pctxt, &pvalue->cashSettlementTerms, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode valueDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
      xe_charstr (pctxt, pvalue->valueDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode fxOptionPremium_list */

   pnode2 = pvalue->fxOptionPremium_list.tail;
   while (0 != pnode2) {
      ll = asn1E_FXOptionPremium (pctxt, ((FXOptionPremium*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode exerciseStyle */

   if(pvalue->exerciseStyle < 0 || pvalue->exerciseStyle > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
      asn1E_ExerciseStyleEnum (pctxt, &pvalue->exerciseStyle, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode expiryDateTime */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_ExpiryDateTime (pctxt, &pvalue->expiryDateTime, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode buyerSeller_model */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_BuyerSeller_model (pctxt, &pvalue->buyerSeller_model, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode productId_list */

   pnode2 = pvalue->productId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ProductId (pctxt, ((ProductId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ProductType (pctxt, &pvalue->productType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FXOptionLeg (OSCTXT* pctxt, FXOptionLeg* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      stat = XmlEnc_ProductType (pctxt, &pvalue->productType
         , OSUTF8("productType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode productId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->productId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ProductId (pctxt, ((ProductId*)pnode->data)
         , OSUTF8("productId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode buyerSeller_model */

   stat = XmlEnc_BuyerSeller_model (pctxt, &pvalue->buyerSeller_model
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode expiryDateTime */

   stat = XmlEnc_ExpiryDateTime (pctxt, &pvalue->expiryDateTime
      , OSUTF8("expiryDateTime"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode exerciseStyle */

   if(pvalue->exerciseStyle < 0 || pvalue->exerciseStyle > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_ExerciseStyleEnum (pctxt, pvalue->exerciseStyle
      , OSUTF8("exerciseStyle"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode fxOptionPremium_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->fxOptionPremium_list.head;
   while (0 != pnode) {
      stat = XmlEnc_FXOptionPremium (pctxt, ((FXOptionPremium*)pnode->data)
         , OSUTF8("fxOptionPremium"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode valueDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->valueDate
      , OSUTF8("valueDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cashSettlementTerms */

   if (pvalue->m.cashSettlementTermsPresent) {
      stat = XmlEnc_FXCashSettlement (pctxt, &pvalue->cashSettlementTerms
         , OSUTF8("cashSettlementTerms"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode putCurrencyAmount */

   stat = XmlEnc_Money_derivations (pctxt, &pvalue->putCurrencyAmount
      , OSUTF8("putCurrencyAmount"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode callCurrencyAmount */

   stat = XmlEnc_Money_derivations (pctxt, &pvalue->callCurrencyAmount
      , OSUTF8("callCurrencyAmount"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode fxStrikePrice */

   stat = XmlEnc_FXStrikePrice (pctxt, &pvalue->fxStrikePrice
      , OSUTF8("fxStrikePrice"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode quotedAs */

   if (pvalue->m.quotedAsPresent) {
      stat = XmlEnc_QuotedAs (pctxt, &pvalue->quotedAs
         , OSUTF8("quotedAs"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FXOptionLeg_derivations                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FXOptionLeg_derivations (OSCTXT* pctxt,
   FXOptionLeg_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_FXOptionLeg (pctxt, pvalue->u.fXOptionLeg, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_FXBarrierOption (pctxt, pvalue->u.fXBarrierOption, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_FXOptionLeg_derivations (OSCTXT* pctxt, 
   FXOptionLeg_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode fXOptionLeg */

         stat = XmlEnc_FXOptionLeg (pctxt, pvalue->u.fXOptionLeg
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode fXBarrierOption */

         stat = XmlEnc_FXBarrierOption (pctxt, pvalue->u.fXBarrierOption
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FxSimpleOption                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FxSimpleOption (OSCTXT* pctxt,
   FxSimpleOption *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_FXOptionLeg_derivations (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_FxSimpleOption (OSCTXT* pctxt, FxSimpleOption* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_FXOptionLeg_derivations (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AdjustableDate_unadjustedDate                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AdjustableDate_unadjustedDate (OSCTXT* pctxt,
   AdjustableDate_unadjustedDate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_charstr (pctxt, pvalue->base, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_AdjustableDate_unadjustedDate (OSCTXT* pctxt, 
   AdjustableDate_unadjustedDate* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BusinessDayAdjustments_choice                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BusinessDayAdjustments_choice (OSCTXT* pctxt,
   BusinessDayAdjustments_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_BusinessCentersOrReference_model (pctxt, pvalue->u.choice, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_BusinessDayAdjustments_choice (OSCTXT* pctxt, 
   BusinessDayAdjustments_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode choice */

         stat = XmlEnc_BusinessCentersOrReference_model (pctxt, pvalue->
            u.choice, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BusinessDayAdjustments                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BusinessDayAdjustments (OSCTXT* pctxt,
   BusinessDayAdjustments *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode choice */

   if (pvalue->m.choicePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_BusinessDayAdjustments_choice (pctxt, &pvalue->choice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode businessDayConvention */

   if(pvalue->businessDayConvention < 0 || pvalue->businessDayConvention > 6)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_BusinessDayConventionEnum (pctxt, &pvalue->businessDayConvention, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BusinessDayAdjustments (OSCTXT* pctxt, 
   BusinessDayAdjustments* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode businessDayConvention */

   if(pvalue->businessDayConvention < 0 || pvalue->businessDayConvention > 6)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_BusinessDayConventionEnum (pctxt, pvalue->
      businessDayConvention, OSUTF8("businessDayConvention"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode choice */

   if (pvalue->m.choicePresent) {
      stat = XmlEnc_BusinessDayAdjustments_choice (pctxt, &pvalue->choice
         , OSUTF8(""), 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AdjustableDate                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AdjustableDate (OSCTXT* pctxt,
   AdjustableDate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode dateAdjustments */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_BusinessDayAdjustments (pctxt, &pvalue->dateAdjustments, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode unadjustedDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_AdjustableDate_unadjustedDate (pctxt, &pvalue->unadjustedDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_AdjustableDate (OSCTXT* pctxt, AdjustableDate* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode unadjustedDate */

   stat = XmlEnc_AdjustableDate_unadjustedDate (pctxt, &pvalue->unadjustedDate
      , OSUTF8("unadjustedDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dateAdjustments */

   stat = XmlEnc_BusinessDayAdjustments (pctxt, &pvalue->dateAdjustments
      , OSUTF8("dateAdjustments"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PaymentType                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PaymentType (OSCTXT* pctxt,
   PaymentType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode paymentTypeScheme */

   if (pvalue->m.paymentTypeSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->paymentTypeScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PaymentType (OSCTXT* pctxt, PaymentType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.paymentTypeSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" paymentTypeScheme=\""), 20);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->paymentTypeScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Payment                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Payment (OSCTXT* pctxt,
   Payment *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode settlementInformation */

   if (pvalue->m.settlementInformationPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_SettlementInformation (pctxt, &pvalue->settlementInformation, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode paymentType */

   if (pvalue->m.paymentTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_PaymentType (pctxt, &pvalue->paymentType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode adjustedPaymentDate */

   if (pvalue->m.adjustedPaymentDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_charstr (pctxt, pvalue->adjustedPaymentDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode paymentDate */

   if (pvalue->m.paymentDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_AdjustableDate (pctxt, &pvalue->paymentDate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode paymentAmount */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Money_derivations (pctxt, &pvalue->paymentAmount, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode payerReceiver_model */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Payment (OSCTXT* pctxt, Payment* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode payerReceiver_model */

   stat = XmlEnc_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode paymentAmount */

   stat = XmlEnc_Money_derivations (pctxt, &pvalue->paymentAmount
      , OSUTF8("paymentAmount"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode paymentDate */

   if (pvalue->m.paymentDatePresent) {
      stat = XmlEnc_AdjustableDate (pctxt, &pvalue->paymentDate
         , OSUTF8("paymentDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode adjustedPaymentDate */

   if (pvalue->m.adjustedPaymentDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         adjustedPaymentDate, OSUTF8("adjustedPaymentDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode paymentType */

   if (pvalue->m.paymentTypePresent) {
      stat = XmlEnc_PaymentType (pctxt, &pvalue->paymentType
         , OSUTF8("paymentType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode settlementInformation */

   if (pvalue->m.settlementInformationPresent) {
      stat = XmlEnc_SettlementInformation (pctxt, &pvalue->
         settlementInformation, OSUTF8("settlementInformation"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FXLeg_sequence                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FXLeg_sequence (OSCTXT* pctxt,
   FXLeg_sequence *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode currency2ValueDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_charstr (pctxt, pvalue->currency2ValueDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode currency1ValueDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_charstr (pctxt, pvalue->currency1ValueDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FXLeg_sequence (OSCTXT* pctxt, FXLeg_sequence* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode currency1ValueDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->currency1ValueDate
      , OSUTF8("currency1ValueDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode currency2ValueDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->currency2ValueDate
      , OSUTF8("currency2ValueDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FXLeg_choice                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FXLeg_choice (OSCTXT* pctxt,
   FXLeg_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            xe_charstr (pctxt, pvalue->u.valueDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_FXLeg_sequence (pctxt, pvalue->u.sequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_FXLeg_choice (OSCTXT* pctxt, FXLeg_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode valueDate */

         stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->u.valueDate
            , OSUTF8("valueDate"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode sequence */

         stat = XmlEnc_FXLeg_sequence (pctxt, pvalue->u.sequence
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SideRateBasisEnum                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SideRateBasisEnum (OSCTXT* pctxt,
   SideRateBasisEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 3)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_SideRateBasisEnum (OSCTXT* pctxt, SideRateBasisEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      SideRateBasisEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SideRate                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SideRate (OSCTXT* pctxt,
   SideRate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode forwardPoints */

   if (pvalue->m.forwardPointsPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_real (pctxt, &pvalue->forwardPoints, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode spotRate */

   if (pvalue->m.spotRatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_real (pctxt, &pvalue->spotRate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode rate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_real (pctxt, &pvalue->rate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode sideRateBasis */

   if(pvalue->sideRateBasis < 0 || pvalue->sideRateBasis > 3)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_SideRateBasisEnum (pctxt, &pvalue->sideRateBasis, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode currency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Currency (pctxt, &pvalue->currency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SideRate (OSCTXT* pctxt, SideRate* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode currency */

   stat = XmlEnc_Currency (pctxt, &pvalue->currency
      , OSUTF8("currency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode sideRateBasis */

   if(pvalue->sideRateBasis < 0 || pvalue->sideRateBasis > 3)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_SideRateBasisEnum (pctxt, pvalue->sideRateBasis
      , OSUTF8("sideRateBasis"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rate */

   stat = rtXmlEncDouble (pctxt, pvalue->rate, OSUTF8("rate"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode spotRate */

   if (pvalue->m.spotRatePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->spotRate
         , OSUTF8("spotRate"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode forwardPoints */

   if (pvalue->m.forwardPointsPresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->forwardPoints
         , OSUTF8("forwardPoints"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SideRates                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SideRates (OSCTXT* pctxt,
   SideRates *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode currency2SideRate */

   if (pvalue->m.currency2SideRatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_SideRate (pctxt, &pvalue->currency2SideRate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode currency1SideRate */

   if (pvalue->m.currency1SideRatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_SideRate (pctxt, &pvalue->currency1SideRate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode baseCurrency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Currency (pctxt, &pvalue->baseCurrency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SideRates (OSCTXT* pctxt, SideRates* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode baseCurrency */

   stat = XmlEnc_Currency (pctxt, &pvalue->baseCurrency
      , OSUTF8("baseCurrency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode currency1SideRate */

   if (pvalue->m.currency1SideRatePresent) {
      stat = XmlEnc_SideRate (pctxt, &pvalue->currency1SideRate
         , OSUTF8("currency1SideRate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode currency2SideRate */

   if (pvalue->m.currency2SideRatePresent) {
      stat = XmlEnc_SideRate (pctxt, &pvalue->currency2SideRate
         , OSUTF8("currency2SideRate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExchangeRate                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExchangeRate (OSCTXT* pctxt,
   ExchangeRate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode sideRates */

   if (pvalue->m.sideRatesPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_SideRates (pctxt, &pvalue->sideRates, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode forwardPoints */

   if (pvalue->m.forwardPointsPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_real (pctxt, &pvalue->forwardPoints, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode spotRate */

   if (pvalue->m.spotRatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_real (pctxt, &pvalue->spotRate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode rate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_real (pctxt, &pvalue->rate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode quotedCurrencyPair */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_QuotedCurrencyPair (pctxt, &pvalue->quotedCurrencyPair, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ExchangeRate (OSCTXT* pctxt, ExchangeRate* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode quotedCurrencyPair */

   stat = XmlEnc_QuotedCurrencyPair (pctxt, &pvalue->quotedCurrencyPair
      , OSUTF8("quotedCurrencyPair"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rate */

   stat = rtXmlEncDouble (pctxt, pvalue->rate, OSUTF8("rate"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode spotRate */

   if (pvalue->m.spotRatePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->spotRate
         , OSUTF8("spotRate"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode forwardPoints */

   if (pvalue->m.forwardPointsPresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->forwardPoints
         , OSUTF8("forwardPoints"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode sideRates */

   if (pvalue->m.sideRatesPresent) {
      stat = XmlEnc_SideRates (pctxt, &pvalue->sideRates
         , OSUTF8("sideRates"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FXLeg                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FXLeg (OSCTXT* pctxt,
   FXLeg *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode confirmationSenderPartyReference */

   if (pvalue->m.confirmationSenderPartyReferencePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_PartyReference (pctxt, &pvalue->confirmationSenderPartyReference, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode nonDeliverableForward */

   if (pvalue->m.nonDeliverableForwardPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_FXCashSettlement (pctxt, &pvalue->nonDeliverableForward, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode exchangeRate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_ExchangeRate (pctxt, &pvalue->exchangeRate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_FXLeg_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode exchangedCurrency2 */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_Payment (pctxt, &pvalue->exchangedCurrency2, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode exchangedCurrency1 */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_Payment (pctxt, &pvalue->exchangedCurrency1, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode productId_list */

   pnode2 = pvalue->productId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ProductId (pctxt, ((ProductId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ProductType (pctxt, &pvalue->productType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FXLeg (OSCTXT* pctxt, FXLeg* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      stat = XmlEnc_ProductType (pctxt, &pvalue->productType
         , OSUTF8("productType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode productId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->productId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ProductId (pctxt, ((ProductId*)pnode->data)
         , OSUTF8("productId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode exchangedCurrency1 */

   stat = XmlEnc_Payment (pctxt, &pvalue->exchangedCurrency1
      , OSUTF8("exchangedCurrency1"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode exchangedCurrency2 */

   stat = XmlEnc_Payment (pctxt, &pvalue->exchangedCurrency2
      , OSUTF8("exchangedCurrency2"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode choice */

   stat = XmlEnc_FXLeg_choice (pctxt, &pvalue->choice, OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode exchangeRate */

   stat = XmlEnc_ExchangeRate (pctxt, &pvalue->exchangeRate
      , OSUTF8("exchangeRate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode nonDeliverableForward */

   if (pvalue->m.nonDeliverableForwardPresent) {
      stat = XmlEnc_FXCashSettlement (pctxt, &pvalue->nonDeliverableForward
         , OSUTF8("nonDeliverableForward"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode confirmationSenderPartyReference */

   if (pvalue->m.confirmationSenderPartyReferencePresent) {
      stat = XmlEnc_PartyReference (pctxt, &pvalue->
         confirmationSenderPartyReference
         , OSUTF8("confirmationSenderPartyReference"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FxSingleLeg                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FxSingleLeg (OSCTXT* pctxt,
   FxSingleLeg *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_FXLeg (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_FxSingleLeg (OSCTXT* pctxt, FxSingleLeg* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_FXLeg (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FXSwap                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FXSwap (OSCTXT* pctxt,
   FXSwap *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode fxSingleLeg_list */

   if (!(pvalue->fxSingleLeg_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FXSwap.fxSingleLeg_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->fxSingleLeg_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->fxSingleLeg_list.tail;
   while (0 != pnode2) {
      ll = asn1E_FxSingleLeg (pctxt, ((FxSingleLeg*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode productId_list */

   pnode2 = pvalue->productId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ProductId (pctxt, ((ProductId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ProductType (pctxt, &pvalue->productType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FXSwap (OSCTXT* pctxt, FXSwap* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      stat = XmlEnc_ProductType (pctxt, &pvalue->productType
         , OSUTF8("productType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode productId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->productId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ProductId (pctxt, ((ProductId*)pnode->data)
         , OSUTF8("productId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode fxSingleLeg_list */

   if (!(pvalue->fxSingleLeg_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FXSwap.fxSingleLeg_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->fxSingleLeg_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->fxSingleLeg_list.head;
   while (0 != pnode) {
      stat = XmlEnc_FxSingleLeg (pctxt, ((FxSingleLeg*)pnode->data)
         , OSUTF8("fxSingleLeg"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FxSwap                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FxSwap (OSCTXT* pctxt,
   FxSwap *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_FXSwap (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_FxSwap (OSCTXT* pctxt, FxSwap* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_FXSwap (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuotablePayment_payerPartyReference                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuotablePayment_payerPartyReference (OSCTXT* pctxt,
   QuotablePayment_payerPartyReference *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode href */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->href, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuotablePayment_payerPartyReference (OSCTXT* pctxt, 
   QuotablePayment_payerPartyReference* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->href, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuotablePayment_receiverPartyReference                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuotablePayment_receiverPartyReference (OSCTXT* pctxt,
   QuotablePayment_receiverPartyReference *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode href */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->href, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuotablePayment_receiverPartyReference (OSCTXT* pctxt, 
   QuotablePayment_receiverPartyReference* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->href, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuotablePayment                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuotablePayment (OSCTXT* pctxt,
   QuotablePayment *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode paymentDate */

   if (pvalue->m.paymentDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_AdjustableDate (pctxt, &pvalue->paymentDate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode paymentAmount */

   if (pvalue->m.paymentAmountPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Money_derivations (pctxt, &pvalue->paymentAmount, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode receiverPartyReference */

   if (pvalue->m.receiverPartyReferencePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_QuotablePayment_receiverPartyReference (pctxt, &pvalue->receiverPartyReference, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode payerPartyReference */

   if (pvalue->m.payerPartyReferencePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_QuotablePayment_payerPartyReference (pctxt, &pvalue->payerPartyReference, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuotablePayment (OSCTXT* pctxt, QuotablePayment* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode payerPartyReference */

   if (pvalue->m.payerPartyReferencePresent) {
      stat = XmlEnc_QuotablePayment_payerPartyReference (pctxt, &pvalue->
         payerPartyReference, OSUTF8("payerPartyReference"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode receiverPartyReference */

   if (pvalue->m.receiverPartyReferencePresent) {
      stat = XmlEnc_QuotablePayment_receiverPartyReference (pctxt, &pvalue->
         receiverPartyReference, OSUTF8("receiverPartyReference"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode paymentAmount */

   if (pvalue->m.paymentAmountPresent) {
      stat = XmlEnc_Money_derivations (pctxt, &pvalue->paymentAmount
         , OSUTF8("paymentAmount"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode paymentDate */

   if (pvalue->m.paymentDatePresent) {
      stat = XmlEnc_AdjustableDate (pctxt, &pvalue->paymentDate
         , OSUTF8("paymentDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuotableFXRate                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuotableFXRate (OSCTXT* pctxt,
   QuotableFXRate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_QuotedCurrencyPair (pctxt, pvalue, ASN1IMPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   if (tagging == ASN1EXPL) {
      ll = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
   }
   ll0 += ll;

   return (ll0);
}

int XmlEnc_QuotableFXRate (OSCTXT* pctxt, QuotableFXRate* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   stat = XmlEnc_QuotedCurrencyPair (pctxt, pvalue
      , OSUTF8("quotedCurrencyPair"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuotableFXLeg                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuotableFXLeg (OSCTXT* pctxt,
   QuotableFXLeg *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode nonDeliverableForward */

   if (pvalue->m.nonDeliverableForwardPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_FXCashSettlement (pctxt, &pvalue->nonDeliverableForward, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode exchangeRate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_QuotableFXRate (pctxt, &pvalue->exchangeRate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode exchangedCurrency */

   if (pvalue->m.exchangedCurrencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_QuotablePayment (pctxt, &pvalue->exchangedCurrency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode productId_list */

   pnode2 = pvalue->productId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ProductId (pctxt, ((ProductId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ProductType (pctxt, &pvalue->productType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuotableFXLeg (OSCTXT* pctxt, QuotableFXLeg* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      stat = XmlEnc_ProductType (pctxt, &pvalue->productType
         , OSUTF8("productType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode productId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->productId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ProductId (pctxt, ((ProductId*)pnode->data)
         , OSUTF8("productId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode exchangedCurrency */

   if (pvalue->m.exchangedCurrencyPresent) {
      stat = XmlEnc_QuotablePayment (pctxt, &pvalue->exchangedCurrency
         , OSUTF8("exchangedCurrency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode exchangeRate */

   stat = XmlEnc_QuotableFXRate (pctxt, &pvalue->exchangeRate
      , OSUTF8("exchangeRate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode nonDeliverableForward */

   if (pvalue->m.nonDeliverableForwardPresent) {
      stat = XmlEnc_FXCashSettlement (pctxt, &pvalue->nonDeliverableForward
         , OSUTF8("nonDeliverableForward"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuotableFxSingleLeg                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuotableFxSingleLeg (OSCTXT* pctxt,
   QuotableFxSingleLeg *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_QuotableFXLeg (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_QuotableFxSingleLeg (OSCTXT* pctxt, QuotableFxSingleLeg* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_QuotableFXLeg (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataDocument_version                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DataDocument_version (OSCTXT* pctxt,
   DataDocument_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_DataDocument_version (OSCTXT* pctxt, DataDocument_version value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      DataDocument_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Validation                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Validation (OSCTXT* pctxt,
   Validation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode validationScheme */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->validationScheme, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Validation (OSCTXT* pctxt, Validation* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" validationScheme=\""), 19);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->validationScheme, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Validation_model                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Validation_model (OSCTXT* pctxt,
   Validation_model *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_Validation (pctxt, ((Validation*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Validation_model (OSCTXT* pctxt, Validation_model* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_Validation (pctxt, ((Validation*)pnode->data)
         , OSUTF8("validation"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeId                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeId (OSCTXT* pctxt,
   TradeId *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode tradeIdScheme */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->tradeIdScheme, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TradeId (OSCTXT* pctxt, TradeId* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" tradeIdScheme=\""), 16);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->tradeIdScheme, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PartyTradeIdentifier_linkId                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PartyTradeIdentifier_linkId (OSCTXT* pctxt,
   PartyTradeIdentifier_linkId *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode linkIdScheme */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->linkIdScheme, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PartyTradeIdentifier_linkId (OSCTXT* pctxt, 
   PartyTradeIdentifier_linkId* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" linkIdScheme=\""), 15);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->linkIdScheme, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PartyTradeIdentifier                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PartyTradeIdentifier (OSCTXT* pctxt,
   PartyTradeIdentifier *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode linkId_list */

   pnode2 = pvalue->linkId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PartyTradeIdentifier_linkId (pctxt, ((PartyTradeIdentifier_linkId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode tradeId_list */

   if (!(pvalue->tradeId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "PartyTradeIdentifier.tradeId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->tradeId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->tradeId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TradeId (pctxt, ((TradeId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode partyReference */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_PartyReference (pctxt, &pvalue->partyReference, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PartyTradeIdentifier (OSCTXT* pctxt, PartyTradeIdentifier* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode partyReference */

   stat = XmlEnc_PartyReference (pctxt, &pvalue->partyReference
      , OSUTF8("partyReference"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode tradeId_list */

   if (!(pvalue->tradeId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "PartyTradeIdentifier.tradeId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->tradeId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->tradeId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TradeId (pctxt, ((TradeId*)pnode->data)
         , OSUTF8("tradeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode linkId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->linkId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PartyTradeIdentifier_linkId (pctxt, 
         ((PartyTradeIdentifier_linkId*)pnode->data)
         , OSUTF8("linkId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PartyTradeInformation                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PartyTradeInformation (OSCTXT* pctxt,
   PartyTradeInformation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode trader_list */

   pnode2 = pvalue->trader_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode partyReference */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_PartyReference (pctxt, &pvalue->partyReference, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PartyTradeInformation (OSCTXT* pctxt, 
   PartyTradeInformation* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode partyReference */

   stat = XmlEnc_PartyReference (pctxt, &pvalue->partyReference
      , OSUTF8("partyReference"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode trader_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->trader_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("trader"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeDate                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeDate (OSCTXT* pctxt,
   TradeDate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_charstr (pctxt, pvalue->base, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TradeDate (OSCTXT* pctxt, TradeDate* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeHeader                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeHeader (OSCTXT* pctxt,
   TradeHeader *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode tradeDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_TradeDate (pctxt, &pvalue->tradeDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode partyTradeInformation_list */

   pnode2 = pvalue->partyTradeInformation_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PartyTradeInformation (pctxt, ((PartyTradeInformation*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode partyTradeIdentifier_list */

   if (!(pvalue->partyTradeIdentifier_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TradeHeader.partyTradeIdentifier_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->partyTradeIdentifier_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->partyTradeIdentifier_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PartyTradeIdentifier (pctxt, ((PartyTradeIdentifier*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TradeHeader (OSCTXT* pctxt, TradeHeader* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode partyTradeIdentifier_list */

   if (!(pvalue->partyTradeIdentifier_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TradeHeader.partyTradeIdentifier_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->partyTradeIdentifier_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->partyTradeIdentifier_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PartyTradeIdentifier (pctxt, 
         ((PartyTradeIdentifier*)pnode->data)
         , OSUTF8("partyTradeIdentifier"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode partyTradeInformation_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->partyTradeInformation_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PartyTradeInformation (pctxt, 
         ((PartyTradeInformation*)pnode->data)
         , OSUTF8("partyTradeInformation"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode tradeDate */

   stat = XmlEnc_TradeDate (pctxt, &pvalue->tradeDate
      , OSUTF8("tradeDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ProductReference                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ProductReference (OSCTXT* pctxt,
   ProductReference *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode href */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->href, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ProductReference (OSCTXT* pctxt, ProductReference* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->href, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Strategy                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Strategy (OSCTXT* pctxt,
   Strategy *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode product_list */

   if (!(pvalue->product_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Strategy.product_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->product_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->product_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Product_group (pctxt, (Product_group*)((Product_group*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode premiumProductReference */

   if (pvalue->m.premiumProductReferencePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_ProductReference (pctxt, &pvalue->premiumProductReference, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode productId_list */

   pnode2 = pvalue->productId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ProductId (pctxt, ((ProductId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ProductType (pctxt, &pvalue->productType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Strategy (OSCTXT* pctxt, Strategy* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      stat = XmlEnc_ProductType (pctxt, &pvalue->productType
         , OSUTF8("productType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode productId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->productId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ProductId (pctxt, ((ProductId*)pnode->data)
         , OSUTF8("productId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode premiumProductReference */

   if (pvalue->m.premiumProductReferencePresent) {
      stat = XmlEnc_ProductReference (pctxt, &pvalue->premiumProductReference
         , OSUTF8("premiumProductReference"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode product_list */

   if (!(pvalue->product_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Strategy.product_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->product_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->product_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Product_group (pctxt, ((Product_group*)pnode->data)
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DayCountFractionEnum                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DayCountFractionEnum (OSCTXT* pctxt,
   DayCountFractionEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 7)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_DayCountFractionEnum (OSCTXT* pctxt, DayCountFractionEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      DayCountFractionEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TermDeposit                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TermDeposit (OSCTXT* pctxt,
   TermDeposit *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode payment_list */

   pnode2 = pvalue->payment_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Payment (pctxt, ((Payment*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|11, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode interest */

   if (pvalue->m.interestPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10,
         asn1E_Money_derivations (pctxt, &pvalue->interest, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode fixedRate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|9,
      xe_real (pctxt, &pvalue->fixedRate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode principal */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
      asn1E_Money_derivations (pctxt, &pvalue->principal, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode dayCountFraction */

   if(pvalue->dayCountFraction < 0 || pvalue->dayCountFraction > 7)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
      asn1E_DayCountFractionEnum (pctxt, &pvalue->dayCountFraction, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode maturityDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
      xe_charstr (pctxt, pvalue->maturityDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode startDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
      xe_charstr (pctxt, pvalue->startDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode initialReceiverReference */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_PartyReference (pctxt, &pvalue->initialReceiverReference, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode initialPayerReference */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_PartyReference (pctxt, &pvalue->initialPayerReference, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode productId_list */

   pnode2 = pvalue->productId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ProductId (pctxt, ((ProductId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ProductType (pctxt, &pvalue->productType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TermDeposit (OSCTXT* pctxt, TermDeposit* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      stat = XmlEnc_ProductType (pctxt, &pvalue->productType
         , OSUTF8("productType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode productId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->productId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ProductId (pctxt, ((ProductId*)pnode->data)
         , OSUTF8("productId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode initialPayerReference */

   stat = XmlEnc_PartyReference (pctxt, &pvalue->initialPayerReference
      , OSUTF8("initialPayerReference"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode initialReceiverReference */

   stat = XmlEnc_PartyReference (pctxt, &pvalue->initialReceiverReference
      , OSUTF8("initialReceiverReference"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode startDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->startDate
      , OSUTF8("startDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode maturityDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->maturityDate
      , OSUTF8("maturityDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dayCountFraction */

   if(pvalue->dayCountFraction < 0 || pvalue->dayCountFraction > 7)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_DayCountFractionEnum (pctxt, pvalue->dayCountFraction
      , OSUTF8("dayCountFraction"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode principal */

   stat = XmlEnc_Money_derivations (pctxt, &pvalue->principal
      , OSUTF8("principal"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode fixedRate */

   stat = rtXmlEncDouble (pctxt, pvalue->fixedRate
      , OSUTF8("fixedRate"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode interest */

   if (pvalue->m.interestPresent) {
      stat = XmlEnc_Money_derivations (pctxt, &pvalue->interest
         , OSUTF8("interest"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode payment_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->payment_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Payment (pctxt, ((Payment*)pnode->data)
         , OSUTF8("payment"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BulletPayment                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BulletPayment (OSCTXT* pctxt,
   BulletPayment *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode payment */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_Payment (pctxt, &pvalue->payment, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode productId_list */

   pnode2 = pvalue->productId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ProductId (pctxt, ((ProductId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ProductType (pctxt, &pvalue->productType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BulletPayment (OSCTXT* pctxt, BulletPayment* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      stat = XmlEnc_ProductType (pctxt, &pvalue->productType
         , OSUTF8("productType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode productId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->productId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ProductId (pctxt, ((ProductId*)pnode->data)
         , OSUTF8("productId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode payment */

   stat = XmlEnc_Payment (pctxt, &pvalue->payment
      , OSUTF8("payment"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CalculationPeriodDates                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CalculationPeriodDates (OSCTXT* pctxt,
   CalculationPeriodDates *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode calculationPeriodFrequency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
      asn1E_CalculationPeriodFrequency (pctxt, &pvalue->calculationPeriodFrequency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode lastRegularPeriodEndDate */

   if (pvalue->m.lastRegularPeriodEndDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
         xe_charstr (pctxt, pvalue->lastRegularPeriodEndDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode firstRegularPeriodStartDate */

   if (pvalue->m.firstRegularPeriodStartDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         xe_charstr (pctxt, pvalue->firstRegularPeriodStartDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode firstPeriodStartDate */

   if (pvalue->m.firstPeriodStartDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_AdjustableDate (pctxt, &pvalue->firstPeriodStartDate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode calculationPeriodDatesAdjustments */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_BusinessDayAdjustments (pctxt, &pvalue->calculationPeriodDatesAdjustments, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode terminationDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_AdjustableDate (pctxt, &pvalue->terminationDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode effectiveDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_AdjustableDate (pctxt, &pvalue->effectiveDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CalculationPeriodDates (OSCTXT* pctxt, 
   CalculationPeriodDates* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode effectiveDate */

   stat = XmlEnc_AdjustableDate (pctxt, &pvalue->effectiveDate
      , OSUTF8("effectiveDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode terminationDate */

   stat = XmlEnc_AdjustableDate (pctxt, &pvalue->terminationDate
      , OSUTF8("terminationDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode calculationPeriodDatesAdjustments */

   stat = XmlEnc_BusinessDayAdjustments (pctxt, &pvalue->
      calculationPeriodDatesAdjustments
      , OSUTF8("calculationPeriodDatesAdjustments"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode firstPeriodStartDate */

   if (pvalue->m.firstPeriodStartDatePresent) {
      stat = XmlEnc_AdjustableDate (pctxt, &pvalue->firstPeriodStartDate
         , OSUTF8("firstPeriodStartDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode firstRegularPeriodStartDate */

   if (pvalue->m.firstRegularPeriodStartDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         firstRegularPeriodStartDate
         , OSUTF8("firstRegularPeriodStartDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode lastRegularPeriodEndDate */

   if (pvalue->m.lastRegularPeriodEndDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         lastRegularPeriodEndDate
         , OSUTF8("lastRegularPeriodEndDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode calculationPeriodFrequency */

   stat = XmlEnc_CalculationPeriodFrequency (pctxt, &pvalue->
      calculationPeriodFrequency
      , OSUTF8("calculationPeriodFrequency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DateReference                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DateReference (OSCTXT* pctxt,
   DateReference *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode href */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->href, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DateReference (OSCTXT* pctxt, DateReference* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->href, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PaymentDates_choice                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PaymentDates_choice (OSCTXT* pctxt,
   PaymentDates_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_DateReference (pctxt, pvalue->u.calculationPeriodDatesReference, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_DateReference (pctxt, pvalue->u.resetDatesReference, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_PaymentDates_choice (OSCTXT* pctxt, PaymentDates_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode calculationPeriodDatesReference */

         stat = XmlEnc_DateReference (pctxt, pvalue->
            u.calculationPeriodDatesReference
            , OSUTF8("calculationPeriodDatesReference"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode resetDatesReference */

         stat = XmlEnc_DateReference (pctxt, pvalue->u.resetDatesReference
            , OSUTF8("resetDatesReference"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PayRelativeToEnum                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PayRelativeToEnum (OSCTXT* pctxt,
   PayRelativeToEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_PayRelativeToEnum (OSCTXT* pctxt, PayRelativeToEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      PayRelativeToEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PaymentDates                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PaymentDates (OSCTXT* pctxt,
   PaymentDates *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode paymentDatesAdjustments */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
      asn1E_BusinessDayAdjustments (pctxt, &pvalue->paymentDatesAdjustments, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode paymentDaysOffset */

   if (pvalue->m.paymentDaysOffsetPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_Offset_derivations (pctxt, &pvalue->paymentDaysOffset, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode payRelativeTo */

   if(pvalue->payRelativeTo < 0 || pvalue->payRelativeTo > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
      asn1E_PayRelativeToEnum (pctxt, &pvalue->payRelativeTo, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode lastRegularPaymentDate */

   if (pvalue->m.lastRegularPaymentDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_charstr (pctxt, pvalue->lastRegularPaymentDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode firstPaymentDate */

   if (pvalue->m.firstPaymentDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_charstr (pctxt, pvalue->firstPaymentDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode paymentFrequency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_Interval_derivations (pctxt, &pvalue->paymentFrequency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_PaymentDates_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PaymentDates (OSCTXT* pctxt, PaymentDates* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode choice */

   stat = XmlEnc_PaymentDates_choice (pctxt, &pvalue->choice, OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode paymentFrequency */

   stat = XmlEnc_Interval_derivations (pctxt, &pvalue->paymentFrequency
      , OSUTF8("paymentFrequency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode firstPaymentDate */

   if (pvalue->m.firstPaymentDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         firstPaymentDate, OSUTF8("firstPaymentDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode lastRegularPaymentDate */

   if (pvalue->m.lastRegularPaymentDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         lastRegularPaymentDate, OSUTF8("lastRegularPaymentDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode payRelativeTo */

   if(pvalue->payRelativeTo < 0 || pvalue->payRelativeTo > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_PayRelativeToEnum (pctxt, pvalue->payRelativeTo
      , OSUTF8("payRelativeTo"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode paymentDaysOffset */

   if (pvalue->m.paymentDaysOffsetPresent) {
      stat = XmlEnc_Offset_derivations (pctxt, &pvalue->paymentDaysOffset
         , OSUTF8("paymentDaysOffset"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode paymentDatesAdjustments */

   stat = XmlEnc_BusinessDayAdjustments (pctxt, &pvalue->
      paymentDatesAdjustments, OSUTF8("paymentDatesAdjustments"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetRelativeToEnum                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ResetRelativeToEnum (OSCTXT* pctxt,
   ResetRelativeToEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ResetRelativeToEnum (OSCTXT* pctxt, ResetRelativeToEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      ResetRelativeToEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResetDates                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ResetDates (OSCTXT* pctxt,
   ResetDates *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode resetDatesAdjustments */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
      asn1E_BusinessDayAdjustments (pctxt, &pvalue->resetDatesAdjustments, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode resetFrequency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_ResetFrequency (pctxt, &pvalue->resetFrequency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode rateCutOffDaysOffset */

   if (pvalue->m.rateCutOffDaysOffsetPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_Offset_derivations (pctxt, &pvalue->rateCutOffDaysOffset, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode fixingDates */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_RelativeDateOffset_derivations (pctxt, &pvalue->fixingDates, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode initialFixingDate */

   if (pvalue->m.initialFixingDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_RelativeDateOffset_derivations (pctxt, &pvalue->initialFixingDate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode resetRelativeTo */

   if (pvalue->m.resetRelativeToPresent) {
      if(pvalue->resetRelativeTo < 0 || pvalue->resetRelativeTo > 1)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         asn1E_ResetRelativeToEnum (pctxt, &pvalue->resetRelativeTo, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode calculationPeriodDatesReference */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_DateReference (pctxt, &pvalue->calculationPeriodDatesReference, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ResetDates (OSCTXT* pctxt, ResetDates* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode calculationPeriodDatesReference */

   stat = XmlEnc_DateReference (pctxt, &pvalue->calculationPeriodDatesReference
      , OSUTF8("calculationPeriodDatesReference"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode resetRelativeTo */

   if (pvalue->m.resetRelativeToPresent) {
      if(pvalue->resetRelativeTo < 0 || pvalue->resetRelativeTo > 1)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_ResetRelativeToEnum (pctxt, pvalue->resetRelativeTo
         , OSUTF8("resetRelativeTo"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode initialFixingDate */

   if (pvalue->m.initialFixingDatePresent) {
      stat = XmlEnc_RelativeDateOffset_derivations (pctxt, &pvalue->
         initialFixingDate, OSUTF8("initialFixingDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fixingDates */

   stat = XmlEnc_RelativeDateOffset_derivations (pctxt, &pvalue->fixingDates
      , OSUTF8("fixingDates"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rateCutOffDaysOffset */

   if (pvalue->m.rateCutOffDaysOffsetPresent) {
      stat = XmlEnc_Offset_derivations (pctxt, &pvalue->rateCutOffDaysOffset
         , OSUTF8("rateCutOffDaysOffset"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode resetFrequency */

   stat = XmlEnc_ResetFrequency (pctxt, &pvalue->resetFrequency
      , OSUTF8("resetFrequency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode resetDatesAdjustments */

   stat = XmlEnc_BusinessDayAdjustments (pctxt, &pvalue->resetDatesAdjustments
      , OSUTF8("resetDatesAdjustments"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Step                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Step (OSCTXT* pctxt,
   Step *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode stepValue */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_real (pctxt, &pvalue->stepValue, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode stepDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_charstr (pctxt, pvalue->stepDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Step (OSCTXT* pctxt, Step* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode stepDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->stepDate
      , OSUTF8("stepDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode stepValue */

   stat = rtXmlEncDouble (pctxt, pvalue->stepValue
      , OSUTF8("stepValue"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AmountSchedule                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AmountSchedule (OSCTXT* pctxt,
   AmountSchedule *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode currency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_Currency (pctxt, &pvalue->currency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode step_list */

   pnode2 = pvalue->step_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Step (pctxt, ((Step*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode initialValue */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_real (pctxt, &pvalue->initialValue, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_AmountSchedule (OSCTXT* pctxt, AmountSchedule* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode initialValue */

   stat = rtXmlEncDouble (pctxt, pvalue->initialValue
      , OSUTF8("initialValue"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode step_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->step_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Step (pctxt, ((Step*)pnode->data)
         , OSUTF8("step"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode currency */

   stat = XmlEnc_Currency (pctxt, &pvalue->currency
      , OSUTF8("currency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  StepRelativeToEnum                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_StepRelativeToEnum (OSCTXT* pctxt,
   StepRelativeToEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_StepRelativeToEnum (OSCTXT* pctxt, StepRelativeToEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      StepRelativeToEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotionalStepRule_sequence                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_NotionalStepRule_sequence (OSCTXT* pctxt,
   NotionalStepRule_sequence *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode stepRelativeTo */

   if(pvalue->stepRelativeTo < 0 || pvalue->stepRelativeTo > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_StepRelativeToEnum (pctxt, &pvalue->stepRelativeTo, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode notionalStepRate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_real (pctxt, &pvalue->notionalStepRate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_NotionalStepRule_sequence (OSCTXT* pctxt, 
   NotionalStepRule_sequence* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode notionalStepRate */

   stat = rtXmlEncDouble (pctxt, pvalue->notionalStepRate
      , OSUTF8("notionalStepRate"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode stepRelativeTo */

   if(pvalue->stepRelativeTo < 0 || pvalue->stepRelativeTo > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_StepRelativeToEnum (pctxt, pvalue->stepRelativeTo
      , OSUTF8("stepRelativeTo"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotionalStepRule_choice                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_NotionalStepRule_choice (OSCTXT* pctxt,
   NotionalStepRule_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            xe_real (pctxt, &pvalue->u.notionalStepAmount, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_NotionalStepRule_sequence (pctxt, pvalue->u.sequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_NotionalStepRule_choice (OSCTXT* pctxt, 
   NotionalStepRule_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode notionalStepAmount */

         stat = rtXmlEncDouble (pctxt, pvalue->u.notionalStepAmount
            , OSUTF8("notionalStepAmount"), nsPrefix, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode sequence */

         stat = XmlEnc_NotionalStepRule_sequence (pctxt, pvalue->u.sequence
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotionalStepRule                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_NotionalStepRule (OSCTXT* pctxt,
   NotionalStepRule *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_NotionalStepRule_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode lastNotionalStepDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
      xe_charstr (pctxt, pvalue->lastNotionalStepDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode firstNotionalStepDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_charstr (pctxt, pvalue->firstNotionalStepDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode stepFrequency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Interval_derivations (pctxt, &pvalue->stepFrequency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode calculationPeriodDatesReference */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_DateReference (pctxt, &pvalue->calculationPeriodDatesReference, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_NotionalStepRule (OSCTXT* pctxt, NotionalStepRule* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode calculationPeriodDatesReference */

   stat = XmlEnc_DateReference (pctxt, &pvalue->calculationPeriodDatesReference
      , OSUTF8("calculationPeriodDatesReference"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode stepFrequency */

   stat = XmlEnc_Interval_derivations (pctxt, &pvalue->stepFrequency
      , OSUTF8("stepFrequency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode firstNotionalStepDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
      firstNotionalStepDate, OSUTF8("firstNotionalStepDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lastNotionalStepDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
      lastNotionalStepDate, OSUTF8("lastNotionalStepDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode choice */

   stat = XmlEnc_NotionalStepRule_choice (pctxt, &pvalue->choice
      , OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Notional                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Notional (OSCTXT* pctxt,
   Notional *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode notionalStepParameters */

   if (pvalue->m.notionalStepParametersPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_NotionalStepRule (pctxt, &pvalue->notionalStepParameters, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode notionalStepSchedule */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_AmountSchedule (pctxt, &pvalue->notionalStepSchedule, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Notional (OSCTXT* pctxt, Notional* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode notionalStepSchedule */

   stat = XmlEnc_AmountSchedule (pctxt, &pvalue->notionalStepSchedule
      , OSUTF8("notionalStepSchedule"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode notionalStepParameters */

   if (pvalue->m.notionalStepParametersPresent) {
      stat = XmlEnc_NotionalStepRule (pctxt, &pvalue->notionalStepParameters
         , OSUTF8("notionalStepParameters"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotionalReference                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_NotionalReference (OSCTXT* pctxt,
   NotionalReference *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode href */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->href, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_NotionalReference (OSCTXT* pctxt, NotionalReference* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->href, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FxSpotRateSource                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FxSpotRateSource (OSCTXT* pctxt,
   FxSpotRateSource *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode fixingTime */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_BusinessCenterTime (pctxt, &pvalue->fixingTime, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode secondaryRateSource */

   if (pvalue->m.secondaryRateSourcePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_InformationSource (pctxt, &pvalue->secondaryRateSource, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode primaryRateSource */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_InformationSource (pctxt, &pvalue->primaryRateSource, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FxSpotRateSource (OSCTXT* pctxt, FxSpotRateSource* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode primaryRateSource */

   stat = XmlEnc_InformationSource (pctxt, &pvalue->primaryRateSource
      , OSUTF8("primaryRateSource"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode secondaryRateSource */

   if (pvalue->m.secondaryRateSourcePresent) {
      stat = XmlEnc_InformationSource (pctxt, &pvalue->secondaryRateSource
         , OSUTF8("secondaryRateSource"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fixingTime */

   stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->fixingTime
      , OSUTF8("fixingTime"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FxSpotRateSource_derivations                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FxSpotRateSource_derivations (OSCTXT* pctxt,
   FxSpotRateSource_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_FxSpotRateSource (pctxt, pvalue->u.fxSpotRateSource, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_FXFixing (pctxt, pvalue->u.fXFixing, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_FxSpotRateSource_derivations (OSCTXT* pctxt, 
   FxSpotRateSource_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode fxSpotRateSource */

         stat = XmlEnc_FxSpotRateSource (pctxt, pvalue->u.fxSpotRateSource
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode fXFixing */

         stat = XmlEnc_FXFixing (pctxt, pvalue->u.fXFixing, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FxLinkedNotionalSchedule                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FxLinkedNotionalSchedule (OSCTXT* pctxt,
   FxLinkedNotionalSchedule *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode varyingNotionalInterimExchangePaymentDates */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_RelativeDateOffset_derivations (pctxt, &pvalue->varyingNotionalInterimExchangePaymentDates, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode fxSpotRateSource */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_FxSpotRateSource_derivations (pctxt, &pvalue->fxSpotRateSource, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode varyingNotionalFixingDates */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_RelativeDateOffset_derivations (pctxt, &pvalue->varyingNotionalFixingDates, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode varyingNotionalCurrency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_utf8str (pctxt, pvalue->varyingNotionalCurrency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode initialValue */

   if (pvalue->m.initialValuePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_real (pctxt, &pvalue->initialValue, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode constantNotionalScheduleReference */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_NotionalReference (pctxt, &pvalue->constantNotionalScheduleReference, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FxLinkedNotionalSchedule (OSCTXT* pctxt, 
   FxLinkedNotionalSchedule* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode constantNotionalScheduleReference */

   stat = XmlEnc_NotionalReference (pctxt, &pvalue->
      constantNotionalScheduleReference
      , OSUTF8("constantNotionalScheduleReference"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode initialValue */

   if (pvalue->m.initialValuePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->initialValue
         , OSUTF8("initialValue"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode varyingNotionalCurrency */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->varyingNotionalCurrency
      , OSUTF8("varyingNotionalCurrency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode varyingNotionalFixingDates */

   stat = XmlEnc_RelativeDateOffset_derivations (pctxt, &pvalue->
      varyingNotionalFixingDates
      , OSUTF8("varyingNotionalFixingDates"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode fxSpotRateSource */

   stat = XmlEnc_FxSpotRateSource_derivations (pctxt, &pvalue->fxSpotRateSource
      , OSUTF8("fxSpotRateSource"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode varyingNotionalInterimExchangePaymentDates */

   stat = XmlEnc_RelativeDateOffset_derivations (pctxt, &pvalue->
      varyingNotionalInterimExchangePaymentDates
      , OSUTF8("varyingNotionalInterimExchangePaymentDates"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Calculation_choice                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Calculation_choice (OSCTXT* pctxt,
   Calculation_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_Notional (pctxt, pvalue->u.notionalSchedule, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_FxLinkedNotionalSchedule (pctxt, pvalue->u.fxLinkedNotionalSchedule, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Calculation_choice (OSCTXT* pctxt, Calculation_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode notionalSchedule */

         stat = XmlEnc_Notional (pctxt, pvalue->u.notionalSchedule
            , OSUTF8("notionalSchedule"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode fxLinkedNotionalSchedule */

         stat = XmlEnc_FxLinkedNotionalSchedule (pctxt, pvalue->
            u.fxLinkedNotionalSchedule
            , OSUTF8("fxLinkedNotionalSchedule"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Schedule                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Schedule (OSCTXT* pctxt,
   Schedule *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode step_list */

   pnode2 = pvalue->step_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Step (pctxt, ((Step*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode initialValue */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_real (pctxt, &pvalue->initialValue, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Schedule (OSCTXT* pctxt, Schedule* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode initialValue */

   stat = rtXmlEncDouble (pctxt, pvalue->initialValue
      , OSUTF8("initialValue"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode step_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->step_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Step (pctxt, ((Step*)pnode->data)
         , OSUTF8("step"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PayerReceiverEnum                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PayerReceiverEnum (OSCTXT* pctxt,
   PayerReceiverEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_PayerReceiverEnum (OSCTXT* pctxt, PayerReceiverEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      PayerReceiverEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  StrikeSchedule_buyer                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_StrikeSchedule_buyer (OSCTXT* pctxt,
   StrikeSchedule_buyer *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   if(pvalue->base < 0 || pvalue->base > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_PayerReceiverEnum (pctxt, &pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_StrikeSchedule_buyer (OSCTXT* pctxt, StrikeSchedule_buyer* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   if(pvalue->base < 0 || pvalue->base > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_PayerReceiverEnum (pctxt, pvalue->base, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  StrikeSchedule_seller                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_StrikeSchedule_seller (OSCTXT* pctxt,
   StrikeSchedule_seller *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   if(pvalue->base < 0 || pvalue->base > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_PayerReceiverEnum (pctxt, &pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_StrikeSchedule_seller (OSCTXT* pctxt, 
   StrikeSchedule_seller* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   if(pvalue->base < 0 || pvalue->base > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_PayerReceiverEnum (pctxt, pvalue->base, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  StrikeSchedule                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_StrikeSchedule (OSCTXT* pctxt,
   StrikeSchedule *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode seller */

   if (pvalue->m.sellerPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_StrikeSchedule_seller (pctxt, &pvalue->seller, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode buyer */

   if (pvalue->m.buyerPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_StrikeSchedule_buyer (pctxt, &pvalue->buyer, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode step_list */

   pnode2 = pvalue->step_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Step (pctxt, ((Step*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode initialValue */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_real (pctxt, &pvalue->initialValue, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_StrikeSchedule (OSCTXT* pctxt, StrikeSchedule* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode initialValue */

   stat = rtXmlEncDouble (pctxt, pvalue->initialValue
      , OSUTF8("initialValue"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode step_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->step_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Step (pctxt, ((Step*)pnode->data)
         , OSUTF8("step"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode buyer */

   if (pvalue->m.buyerPresent) {
      stat = XmlEnc_StrikeSchedule_buyer (pctxt, &pvalue->buyer
         , OSUTF8("buyer"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode seller */

   if (pvalue->m.sellerPresent) {
      stat = XmlEnc_StrikeSchedule_seller (pctxt, &pvalue->seller
         , OSUTF8("seller"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Schedule_derivations                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Schedule_derivations (OSCTXT* pctxt,
   Schedule_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_Schedule (pctxt, pvalue->u.schedule, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_AmountSchedule (pctxt, pvalue->u.amountSchedule, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_StrikeSchedule (pctxt, pvalue->u.strikeSchedule, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Schedule_derivations (OSCTXT* pctxt, Schedule_derivations* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode schedule */

         stat = XmlEnc_Schedule (pctxt, pvalue->u.schedule, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode amountSchedule */

         stat = XmlEnc_AmountSchedule (pctxt, pvalue->u.amountSchedule
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode strikeSchedule */

         stat = XmlEnc_StrikeSchedule (pctxt, pvalue->u.strikeSchedule
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FloatingRateIndex                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FloatingRateIndex (OSCTXT* pctxt,
   FloatingRateIndex *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode floatingRateIndexScheme */

   if (pvalue->m.floatingRateIndexSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->floatingRateIndexScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FloatingRateIndex (OSCTXT* pctxt, FloatingRateIndex* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.floatingRateIndexSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" floatingRateIndexScheme=\""), 26);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->floatingRateIndexScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RateTreatmentEnum                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RateTreatmentEnum (OSCTXT* pctxt,
   RateTreatmentEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_RateTreatmentEnum (OSCTXT* pctxt, RateTreatmentEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      RateTreatmentEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RoundingDirectionEnum                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RoundingDirectionEnum (OSCTXT* pctxt,
   RoundingDirectionEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_RoundingDirectionEnum (OSCTXT* pctxt, RoundingDirectionEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      RoundingDirectionEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Rounding                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Rounding (OSCTXT* pctxt,
   Rounding *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode precision */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_unsigned (pctxt, &pvalue->precision, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode roundingDirection */

   if(pvalue->roundingDirection < 0 || pvalue->roundingDirection > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_RoundingDirectionEnum (pctxt, &pvalue->roundingDirection, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Rounding (OSCTXT* pctxt, Rounding* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode roundingDirection */

   if(pvalue->roundingDirection < 0 || pvalue->roundingDirection > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_RoundingDirectionEnum (pctxt, pvalue->roundingDirection
      , OSUTF8("roundingDirection"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode precision */

   stat = rtXmlEncUInt (pctxt, pvalue->precision, OSUTF8("precision"), nsPrefix
      );
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AveragingMethodEnum                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AveragingMethodEnum (OSCTXT* pctxt,
   AveragingMethodEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_AveragingMethodEnum (OSCTXT* pctxt, AveragingMethodEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      AveragingMethodEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NegativeInterestRateTreatmentEnum                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_NegativeInterestRateTreatmentEnum (OSCTXT* pctxt,
   NegativeInterestRateTreatmentEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_NegativeInterestRateTreatmentEnum (OSCTXT* pctxt, 
   NegativeInterestRateTreatmentEnum value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      NegativeInterestRateTreatmentEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FloatingRateCalculation                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FloatingRateCalculation (OSCTXT* pctxt,
   FloatingRateCalculation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode negativeInterestRateTreatment */

   if (pvalue->m.negativeInterestRateTreatmentPresent) {
      if(pvalue->negativeInterestRateTreatment < 0 || pvalue->negativeInterestRateTreatment > 1)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|11,
         asn1E_NegativeInterestRateTreatmentEnum (pctxt, &pvalue->negativeInterestRateTreatment, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode averagingMethod */

   if (pvalue->m.averagingMethodPresent) {
      if(pvalue->averagingMethod < 0 || pvalue->averagingMethod > 1)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|10,
         asn1E_AveragingMethodEnum (pctxt, &pvalue->averagingMethod, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode finalRateRounding */

   if (pvalue->m.finalRateRoundingPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9,
         asn1E_Rounding (pctxt, &pvalue->finalRateRounding, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode initialRate */

   if (pvalue->m.initialRatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|8,
         xe_real (pctxt, &pvalue->initialRate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode floorRateSchedule_list */

   pnode2 = pvalue->floorRateSchedule_list.tail;
   while (0 != pnode2) {
      ll = asn1E_StrikeSchedule (pctxt, ((StrikeSchedule*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode capRateSchedule_list */

   pnode2 = pvalue->capRateSchedule_list.tail;
   while (0 != pnode2) {
      ll = asn1E_StrikeSchedule (pctxt, ((StrikeSchedule*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode rateTreatment */

   if (pvalue->m.rateTreatmentPresent) {
      if(pvalue->rateTreatment < 0 || pvalue->rateTreatment > 1)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         asn1E_RateTreatmentEnum (pctxt, &pvalue->rateTreatment, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode spreadSchedule */

   if (pvalue->m.spreadSchedulePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Schedule_derivations (pctxt, &pvalue->spreadSchedule, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode floatingRateMultiplierSchedule */

   if (pvalue->m.floatingRateMultiplierSchedulePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Schedule_derivations (pctxt, &pvalue->floatingRateMultiplierSchedule, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode indexTenor */

   if (pvalue->m.indexTenorPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Interval_derivations (pctxt, &pvalue->indexTenor, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode floatingRateIndex */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_FloatingRateIndex (pctxt, &pvalue->floatingRateIndex, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FloatingRateCalculation (OSCTXT* pctxt, 
   FloatingRateCalculation* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode floatingRateIndex */

   stat = XmlEnc_FloatingRateIndex (pctxt, &pvalue->floatingRateIndex
      , OSUTF8("floatingRateIndex"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode indexTenor */

   if (pvalue->m.indexTenorPresent) {
      stat = XmlEnc_Interval_derivations (pctxt, &pvalue->indexTenor
         , OSUTF8("indexTenor"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode floatingRateMultiplierSchedule */

   if (pvalue->m.floatingRateMultiplierSchedulePresent) {
      stat = XmlEnc_Schedule_derivations (pctxt, &pvalue->
         floatingRateMultiplierSchedule
         , OSUTF8("floatingRateMultiplierSchedule"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode spreadSchedule */

   if (pvalue->m.spreadSchedulePresent) {
      stat = XmlEnc_Schedule_derivations (pctxt, &pvalue->spreadSchedule
         , OSUTF8("spreadSchedule"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode rateTreatment */

   if (pvalue->m.rateTreatmentPresent) {
      if(pvalue->rateTreatment < 0 || pvalue->rateTreatment > 1)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_RateTreatmentEnum (pctxt, pvalue->rateTreatment
         , OSUTF8("rateTreatment"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode capRateSchedule_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->capRateSchedule_list.head;
   while (0 != pnode) {
      stat = XmlEnc_StrikeSchedule (pctxt, ((StrikeSchedule*)pnode->data)
         , OSUTF8("capRateSchedule"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode floorRateSchedule_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->floorRateSchedule_list.head;
   while (0 != pnode) {
      stat = XmlEnc_StrikeSchedule (pctxt, ((StrikeSchedule*)pnode->data)
         , OSUTF8("floorRateSchedule"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode initialRate */

   if (pvalue->m.initialRatePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->initialRate
         , OSUTF8("initialRate"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode finalRateRounding */

   if (pvalue->m.finalRateRoundingPresent) {
      stat = XmlEnc_Rounding (pctxt, &pvalue->finalRateRounding
         , OSUTF8("finalRateRounding"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode averagingMethod */

   if (pvalue->m.averagingMethodPresent) {
      if(pvalue->averagingMethod < 0 || pvalue->averagingMethod > 1)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_AveragingMethodEnum (pctxt, pvalue->averagingMethod
         , OSUTF8("averagingMethod"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode negativeInterestRateTreatment */

   if (pvalue->m.negativeInterestRateTreatmentPresent) {
      if(pvalue->negativeInterestRateTreatment < 0 || pvalue->
         negativeInterestRateTreatment > 1)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_NegativeInterestRateTreatmentEnum (pctxt, pvalue->
         negativeInterestRateTreatment
         , OSUTF8("negativeInterestRateTreatment"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Calculation_choice_1                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Calculation_choice_1 (OSCTXT* pctxt,
   Calculation_choice_1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_Schedule_derivations (pctxt, pvalue->u.fixedRateSchedule, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_FloatingRateCalculation (pctxt, pvalue->u.floatingRateCalculation, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Calculation_choice_1 (OSCTXT* pctxt, Calculation_choice_1* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode fixedRateSchedule */

         stat = XmlEnc_Schedule_derivations (pctxt, pvalue->u.fixedRateSchedule
            , OSUTF8("fixedRateSchedule"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode floatingRateCalculation */

         stat = XmlEnc_FloatingRateCalculation (pctxt, pvalue->
            u.floatingRateCalculation
            , OSUTF8("floatingRateCalculation"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DiscountingTypeEnum                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DiscountingTypeEnum (OSCTXT* pctxt,
   DiscountingTypeEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_DiscountingTypeEnum (OSCTXT* pctxt, DiscountingTypeEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      DiscountingTypeEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Discounting                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Discounting (OSCTXT* pctxt,
   Discounting *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode discountRateDayCountFraction */

   if (pvalue->m.discountRateDayCountFractionPresent) {
      if(pvalue->discountRateDayCountFraction < 0 || pvalue->discountRateDayCountFraction > 7)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         asn1E_DayCountFractionEnum (pctxt, &pvalue->discountRateDayCountFraction, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode discountRate */

   if (pvalue->m.discountRatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_real (pctxt, &pvalue->discountRate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode discountingType */

   if(pvalue->discountingType < 0 || pvalue->discountingType > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_DiscountingTypeEnum (pctxt, &pvalue->discountingType, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Discounting (OSCTXT* pctxt, Discounting* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode discountingType */

   if(pvalue->discountingType < 0 || pvalue->discountingType > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_DiscountingTypeEnum (pctxt, pvalue->discountingType
      , OSUTF8("discountingType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode discountRate */

   if (pvalue->m.discountRatePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->discountRate
         , OSUTF8("discountRate"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode discountRateDayCountFraction */

   if (pvalue->m.discountRateDayCountFractionPresent) {
      if(pvalue->discountRateDayCountFraction < 0 || pvalue->
         discountRateDayCountFraction > 7)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_DayCountFractionEnum (pctxt, pvalue->
         discountRateDayCountFraction
         , OSUTF8("discountRateDayCountFraction"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CompoundingMethodEnum                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CompoundingMethodEnum (OSCTXT* pctxt,
   CompoundingMethodEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_CompoundingMethodEnum (OSCTXT* pctxt, CompoundingMethodEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      CompoundingMethodEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Calculation                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Calculation (OSCTXT* pctxt,
   Calculation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode compoundingMethod */

   if (pvalue->m.compoundingMethodPresent) {
      if(pvalue->compoundingMethod < 0 || pvalue->compoundingMethod > 2)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         asn1E_CompoundingMethodEnum (pctxt, &pvalue->compoundingMethod, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode discounting */

   if (pvalue->m.discountingPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Discounting (pctxt, &pvalue->discounting, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dayCountFraction */

   if(pvalue->dayCountFraction < 0 || pvalue->dayCountFraction > 7)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      asn1E_DayCountFractionEnum (pctxt, &pvalue->dayCountFraction, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode choice_1 */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Calculation_choice_1 (pctxt, &pvalue->choice_1, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Calculation_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Calculation (OSCTXT* pctxt, Calculation* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode choice */

   stat = XmlEnc_Calculation_choice (pctxt, &pvalue->choice, OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode choice_1 */

   stat = XmlEnc_Calculation_choice_1 (pctxt, &pvalue->choice_1
      , OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dayCountFraction */

   if(pvalue->dayCountFraction < 0 || pvalue->dayCountFraction > 7)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_DayCountFractionEnum (pctxt, pvalue->dayCountFraction
      , OSUTF8("dayCountFraction"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode discounting */

   if (pvalue->m.discountingPresent) {
      stat = XmlEnc_Discounting (pctxt, &pvalue->discounting
         , OSUTF8("discounting"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode compoundingMethod */

   if (pvalue->m.compoundingMethodPresent) {
      if(pvalue->compoundingMethod < 0 || pvalue->compoundingMethod > 2)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_CompoundingMethodEnum (pctxt, pvalue->compoundingMethod
         , OSUTF8("compoundingMethod"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CalculationPeriodAmount                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CalculationPeriodAmount (OSCTXT* pctxt,
   CalculationPeriodAmount *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_Calculation (pctxt, pvalue->u.calculation, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_AmountSchedule (pctxt, pvalue->u.knownAmountSchedule, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   if (tagging == ASN1EXPL) {
      ll1 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll1);
      if (ll1 < 0) return LOG_RTERR (pctxt, ll1);
   }

   ll0 += ll1;

   return (ll0);
}

int XmlEnc_CalculationPeriodAmount (OSCTXT* pctxt, 
   CalculationPeriodAmount* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode calculation */

         stat = XmlEnc_Calculation (pctxt, pvalue->u.calculation
            , OSUTF8("calculation"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode knownAmountSchedule */

         stat = XmlEnc_AmountSchedule (pctxt, pvalue->u.knownAmountSchedule
            , OSUTF8("knownAmountSchedule"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FloatingRate                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FloatingRate (OSCTXT* pctxt,
   FloatingRate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode floorRateSchedule_list */

   pnode2 = pvalue->floorRateSchedule_list.tail;
   while (0 != pnode2) {
      ll = asn1E_StrikeSchedule (pctxt, ((StrikeSchedule*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode capRateSchedule_list */

   pnode2 = pvalue->capRateSchedule_list.tail;
   while (0 != pnode2) {
      ll = asn1E_StrikeSchedule (pctxt, ((StrikeSchedule*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode rateTreatment */

   if (pvalue->m.rateTreatmentPresent) {
      if(pvalue->rateTreatment < 0 || pvalue->rateTreatment > 1)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         asn1E_RateTreatmentEnum (pctxt, &pvalue->rateTreatment, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode spreadSchedule */

   if (pvalue->m.spreadSchedulePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Schedule_derivations (pctxt, &pvalue->spreadSchedule, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode floatingRateMultiplierSchedule */

   if (pvalue->m.floatingRateMultiplierSchedulePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Schedule_derivations (pctxt, &pvalue->floatingRateMultiplierSchedule, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode indexTenor */

   if (pvalue->m.indexTenorPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Interval_derivations (pctxt, &pvalue->indexTenor, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode floatingRateIndex */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_FloatingRateIndex (pctxt, &pvalue->floatingRateIndex, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FloatingRate (OSCTXT* pctxt, FloatingRate* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode floatingRateIndex */

   stat = XmlEnc_FloatingRateIndex (pctxt, &pvalue->floatingRateIndex
      , OSUTF8("floatingRateIndex"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode indexTenor */

   if (pvalue->m.indexTenorPresent) {
      stat = XmlEnc_Interval_derivations (pctxt, &pvalue->indexTenor
         , OSUTF8("indexTenor"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode floatingRateMultiplierSchedule */

   if (pvalue->m.floatingRateMultiplierSchedulePresent) {
      stat = XmlEnc_Schedule_derivations (pctxt, &pvalue->
         floatingRateMultiplierSchedule
         , OSUTF8("floatingRateMultiplierSchedule"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode spreadSchedule */

   if (pvalue->m.spreadSchedulePresent) {
      stat = XmlEnc_Schedule_derivations (pctxt, &pvalue->spreadSchedule
         , OSUTF8("spreadSchedule"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode rateTreatment */

   if (pvalue->m.rateTreatmentPresent) {
      if(pvalue->rateTreatment < 0 || pvalue->rateTreatment > 1)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_RateTreatmentEnum (pctxt, pvalue->rateTreatment
         , OSUTF8("rateTreatment"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode capRateSchedule_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->capRateSchedule_list.head;
   while (0 != pnode) {
      stat = XmlEnc_StrikeSchedule (pctxt, ((StrikeSchedule*)pnode->data)
         , OSUTF8("capRateSchedule"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode floorRateSchedule_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->floorRateSchedule_list.head;
   while (0 != pnode) {
      stat = XmlEnc_StrikeSchedule (pctxt, ((StrikeSchedule*)pnode->data)
         , OSUTF8("floorRateSchedule"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FloatingRate_derivations                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FloatingRate_derivations (OSCTXT* pctxt,
   FloatingRate_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_FloatingRate (pctxt, pvalue->u.floatingRate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_FloatingRateCalculation (pctxt, pvalue->u.floatingRateCalculation, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_FloatingRate_derivations (OSCTXT* pctxt, 
   FloatingRate_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode floatingRate */

         stat = XmlEnc_FloatingRate (pctxt, pvalue->u.floatingRate
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode floatingRateCalculation */

         stat = XmlEnc_FloatingRateCalculation (pctxt, pvalue->
            u.floatingRateCalculation, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Stub                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Stub (OSCTXT* pctxt,
   Stub *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         if (!(pvalue->u.floatingRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "Stub.u.floatingRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.floatingRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         pnode2 = pvalue->u.floatingRate_list->tail;
         while (0 != pnode2) {
            ll = asn1E_FloatingRate_derivations (pctxt, ((FloatingRate_derivations*)pnode2->data), ASN1EXPL);
            if (ll < 0) return LOG_RTERR (pctxt, ll);
            ll2 += ll;

            pnode2 = pnode2->prev;
         }
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else { ll1 += ll; ll2 = 0; }
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
            xe_real (pctxt, &pvalue->u.stubRate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_Money_derivations (pctxt, pvalue->u.stubAmount, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   if (tagging == ASN1EXPL) {
      ll1 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll1);
      if (ll1 < 0) return LOG_RTERR (pctxt, ll1);
   }

   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Stub (OSCTXT* pctxt, Stub* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode floatingRate_list */

         if (!(pvalue->u.floatingRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "Stub.u.floatingRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.floatingRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         { const OSUTF8CHAR* savedPrefix = nsPrefix;
         nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
            "http://www.fpml.org/2003/FpML-4-0"));

         { OSRTDListNode* pnode = pvalue->u.floatingRate_list->head;
         while (0 != pnode) {
            stat = XmlEnc_FloatingRate_derivations (pctxt, 
               ((FloatingRate_derivations*)pnode->data)
               , OSUTF8("floatingRate"), nsPrefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            pnode = pnode->next;
         }}
         nsPrefix = savedPrefix;
         }

         break;

      case 2:
         /* encode stubRate */

         stat = rtXmlEncDouble (pctxt, pvalue->u.stubRate
            , OSUTF8("stubRate"), nsPrefix, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode stubAmount */

         stat = XmlEnc_Money_derivations (pctxt, pvalue->u.stubAmount
            , OSUTF8("stubAmount"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  StubCalculationPeriodAmount                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_StubCalculationPeriodAmount (OSCTXT* pctxt,
   StubCalculationPeriodAmount *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode finalStub */

   if (pvalue->m.finalStubPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Stub (pctxt, &pvalue->finalStub, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode initialStub */

   if (pvalue->m.initialStubPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Stub (pctxt, &pvalue->initialStub, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode calculationPeriodDatesReference */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_DateReference (pctxt, &pvalue->calculationPeriodDatesReference, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_StubCalculationPeriodAmount (OSCTXT* pctxt, 
   StubCalculationPeriodAmount* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode calculationPeriodDatesReference */

   stat = XmlEnc_DateReference (pctxt, &pvalue->calculationPeriodDatesReference
      , OSUTF8("calculationPeriodDatesReference"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode initialStub */

   if (pvalue->m.initialStubPresent) {
      stat = XmlEnc_Stub (pctxt, &pvalue->initialStub
         , OSUTF8("initialStub"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode finalStub */

   if (pvalue->m.finalStubPresent) {
      stat = XmlEnc_Stub (pctxt, &pvalue->finalStub
         , OSUTF8("finalStub"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrincipalExchanges                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PrincipalExchanges (OSCTXT* pctxt,
   PrincipalExchanges *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode intermediateExchange */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_boolean (pctxt, &pvalue->intermediateExchange, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode finalExchange */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_boolean (pctxt, &pvalue->finalExchange, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode initialExchange */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_boolean (pctxt, &pvalue->initialExchange, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PrincipalExchanges (OSCTXT* pctxt, PrincipalExchanges* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode initialExchange */

   stat = rtXmlEncBool (pctxt, pvalue->initialExchange
      , OSUTF8("initialExchange"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode finalExchange */

   stat = rtXmlEncBool (pctxt, pvalue->finalExchange
      , OSUTF8("finalExchange"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode intermediateExchange */

   stat = rtXmlEncBool (pctxt, pvalue->intermediateExchange
      , OSUTF8("intermediateExchange"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrincipalExchange                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PrincipalExchange (OSCTXT* pctxt,
   PrincipalExchange *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode principalExchangeAmount */

   if (pvalue->m.principalExchangeAmountPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_real (pctxt, &pvalue->principalExchangeAmount, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode adjustedPrincipalExchangeDate */

   if (pvalue->m.adjustedPrincipalExchangeDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_charstr (pctxt, pvalue->adjustedPrincipalExchangeDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode unadjustedPrincipalExchangeDate */

   if (pvalue->m.unadjustedPrincipalExchangeDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_charstr (pctxt, pvalue->unadjustedPrincipalExchangeDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PrincipalExchange (OSCTXT* pctxt, PrincipalExchange* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode unadjustedPrincipalExchangeDate */

   if (pvalue->m.unadjustedPrincipalExchangeDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         unadjustedPrincipalExchangeDate
         , OSUTF8("unadjustedPrincipalExchangeDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode adjustedPrincipalExchangeDate */

   if (pvalue->m.adjustedPrincipalExchangeDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         adjustedPrincipalExchangeDate
         , OSUTF8("adjustedPrincipalExchangeDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode principalExchangeAmount */

   if (pvalue->m.principalExchangeAmountPresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->principalExchangeAmount
         , OSUTF8("principalExchangeAmount"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FxLinkedNotionalAmount                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FxLinkedNotionalAmount (OSCTXT* pctxt,
   FxLinkedNotionalAmount *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode notionalAmount */

   if (pvalue->m.notionalAmountPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_real (pctxt, &pvalue->notionalAmount, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode observedFxSpotRate */

   if (pvalue->m.observedFxSpotRatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_real (pctxt, &pvalue->observedFxSpotRate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode adjustedFxSpotFixingDate */

   if (pvalue->m.adjustedFxSpotFixingDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_charstr (pctxt, pvalue->adjustedFxSpotFixingDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode resetDate */

   if (pvalue->m.resetDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_charstr (pctxt, pvalue->resetDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FxLinkedNotionalAmount (OSCTXT* pctxt, 
   FxLinkedNotionalAmount* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode resetDate */

   if (pvalue->m.resetDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->resetDate
         , OSUTF8("resetDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode adjustedFxSpotFixingDate */

   if (pvalue->m.adjustedFxSpotFixingDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         adjustedFxSpotFixingDate
         , OSUTF8("adjustedFxSpotFixingDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode observedFxSpotRate */

   if (pvalue->m.observedFxSpotRatePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->observedFxSpotRate
         , OSUTF8("observedFxSpotRate"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode notionalAmount */

   if (pvalue->m.notionalAmountPresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->notionalAmount
         , OSUTF8("notionalAmount"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CalculationPeriod_choice                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CalculationPeriod_choice (OSCTXT* pctxt,
   CalculationPeriod_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            xe_real (pctxt, &pvalue->u.notionalAmount, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_FxLinkedNotionalAmount (pctxt, pvalue->u.fxLinkedNotionalAmount, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_CalculationPeriod_choice (OSCTXT* pctxt, 
   CalculationPeriod_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode notionalAmount */

         stat = rtXmlEncDouble (pctxt, pvalue->u.notionalAmount
            , OSUTF8("notionalAmount"), nsPrefix, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode fxLinkedNotionalAmount */

         stat = XmlEnc_FxLinkedNotionalAmount (pctxt, pvalue->
            u.fxLinkedNotionalAmount
            , OSUTF8("fxLinkedNotionalAmount"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IntradocumentReference                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_IntradocumentReference (OSCTXT* pctxt,
   IntradocumentReference *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode href */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->href, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_IntradocumentReference (OSCTXT* pctxt, 
   IntradocumentReference* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->href, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RateObservation                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RateObservation (OSCTXT* pctxt,
   RateObservation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode rateReference */

   if (pvalue->m.rateReferencePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_IntradocumentReference (pctxt, &pvalue->rateReference, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode observationWeight */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
      xe_unsigned (pctxt, &pvalue->observationWeight, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode treatedRate */

   if (pvalue->m.treatedRatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_real (pctxt, &pvalue->treatedRate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode observedRate */

   if (pvalue->m.observedRatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_real (pctxt, &pvalue->observedRate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode adjustedFixingDate */

   if (pvalue->m.adjustedFixingDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_charstr (pctxt, pvalue->adjustedFixingDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode resetDate */

   if (pvalue->m.resetDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_charstr (pctxt, pvalue->resetDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_RateObservation (OSCTXT* pctxt, RateObservation* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode resetDate */

   if (pvalue->m.resetDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->resetDate
         , OSUTF8("resetDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode adjustedFixingDate */

   if (pvalue->m.adjustedFixingDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         adjustedFixingDate, OSUTF8("adjustedFixingDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode observedRate */

   if (pvalue->m.observedRatePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->observedRate
         , OSUTF8("observedRate"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode treatedRate */

   if (pvalue->m.treatedRatePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->treatedRate
         , OSUTF8("treatedRate"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode observationWeight */

   stat = rtXmlEncUInt (pctxt, pvalue->observationWeight
      , OSUTF8("observationWeight"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rateReference */

   if (pvalue->m.rateReferencePresent) {
      stat = XmlEnc_IntradocumentReference (pctxt, &pvalue->rateReference
         , OSUTF8("rateReference"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Strike_buyer                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Strike_buyer (OSCTXT* pctxt,
   Strike_buyer *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   if(pvalue->base < 0 || pvalue->base > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_PayerReceiverEnum (pctxt, &pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Strike_buyer (OSCTXT* pctxt, Strike_buyer* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   if(pvalue->base < 0 || pvalue->base > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_PayerReceiverEnum (pctxt, pvalue->base, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Strike_seller                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Strike_seller (OSCTXT* pctxt,
   Strike_seller *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   if(pvalue->base < 0 || pvalue->base > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_PayerReceiverEnum (pctxt, &pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Strike_seller (OSCTXT* pctxt, Strike_seller* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   if(pvalue->base < 0 || pvalue->base > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_PayerReceiverEnum (pctxt, pvalue->base, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Strike                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Strike (OSCTXT* pctxt,
   Strike *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode seller */

   if (pvalue->m.sellerPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Strike_seller (pctxt, &pvalue->seller, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode buyer */

   if (pvalue->m.buyerPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Strike_buyer (pctxt, &pvalue->buyer, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode strikeRate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_real (pctxt, &pvalue->strikeRate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Strike (OSCTXT* pctxt, Strike* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode strikeRate */

   stat = rtXmlEncDouble (pctxt, pvalue->strikeRate
      , OSUTF8("strikeRate"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode buyer */

   if (pvalue->m.buyerPresent) {
      stat = XmlEnc_Strike_buyer (pctxt, &pvalue->buyer
         , OSUTF8("buyer"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode seller */

   if (pvalue->m.sellerPresent) {
      stat = XmlEnc_Strike_seller (pctxt, &pvalue->seller
         , OSUTF8("seller"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FloatingRateDefinition                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FloatingRateDefinition (OSCTXT* pctxt,
   FloatingRateDefinition *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode floorRate_list */

   pnode2 = pvalue->floorRate_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Strike (pctxt, ((Strike*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode capRate_list */

   pnode2 = pvalue->capRate_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Strike (pctxt, ((Strike*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode spread */

   if (pvalue->m.spreadPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_real (pctxt, &pvalue->spread, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode floatingRateMultiplier */

   if (pvalue->m.floatingRateMultiplierPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_real (pctxt, &pvalue->floatingRateMultiplier, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode rateObservation_list */

   pnode2 = pvalue->rateObservation_list.tail;
   while (0 != pnode2) {
      ll = asn1E_RateObservation (pctxt, ((RateObservation*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode calculatedRate */

   if (pvalue->m.calculatedRatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_real (pctxt, &pvalue->calculatedRate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FloatingRateDefinition (OSCTXT* pctxt, 
   FloatingRateDefinition* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode calculatedRate */

   if (pvalue->m.calculatedRatePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->calculatedRate
         , OSUTF8("calculatedRate"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode rateObservation_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->rateObservation_list.head;
   while (0 != pnode) {
      stat = XmlEnc_RateObservation (pctxt, ((RateObservation*)pnode->data)
         , OSUTF8("rateObservation"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode floatingRateMultiplier */

   if (pvalue->m.floatingRateMultiplierPresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->floatingRateMultiplier
         , OSUTF8("floatingRateMultiplier"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode spread */

   if (pvalue->m.spreadPresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->spread, OSUTF8("spread"), nsPrefix
         , 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode capRate_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->capRate_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Strike (pctxt, ((Strike*)pnode->data)
         , OSUTF8("capRate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode floorRate_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->floorRate_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Strike (pctxt, ((Strike*)pnode->data)
         , OSUTF8("floorRate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CalculationPeriod_choice_1                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CalculationPeriod_choice_1 (OSCTXT* pctxt,
   CalculationPeriod_choice_1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_FloatingRateDefinition (pctxt, pvalue->u.floatingRateDefinition, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
            xe_real (pctxt, &pvalue->u.fixedRate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_CalculationPeriod_choice_1 (OSCTXT* pctxt, 
   CalculationPeriod_choice_1* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode floatingRateDefinition */

         stat = XmlEnc_FloatingRateDefinition (pctxt, pvalue->
            u.floatingRateDefinition
            , OSUTF8("floatingRateDefinition"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode fixedRate */

         stat = rtXmlEncDouble (pctxt, pvalue->u.fixedRate
            , OSUTF8("fixedRate"), nsPrefix, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CalculationPeriod                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CalculationPeriod (OSCTXT* pctxt,
   CalculationPeriod *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode choice_1 */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
      asn1E_CalculationPeriod_choice_1 (pctxt, &pvalue->choice_1, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_CalculationPeriod_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode calculationPeriodNumberOfDays */

   if (pvalue->m.calculationPeriodNumberOfDaysPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         xe_unsigned (pctxt, &pvalue->calculationPeriodNumberOfDays, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode adjustedEndDate */

   if (pvalue->m.adjustedEndDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_charstr (pctxt, pvalue->adjustedEndDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode adjustedStartDate */

   if (pvalue->m.adjustedStartDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_charstr (pctxt, pvalue->adjustedStartDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode unadjustedEndDate */

   if (pvalue->m.unadjustedEndDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_charstr (pctxt, pvalue->unadjustedEndDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode unadjustedStartDate */

   if (pvalue->m.unadjustedStartDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_charstr (pctxt, pvalue->unadjustedStartDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CalculationPeriod (OSCTXT* pctxt, CalculationPeriod* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode unadjustedStartDate */

   if (pvalue->m.unadjustedStartDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         unadjustedStartDate, OSUTF8("unadjustedStartDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode unadjustedEndDate */

   if (pvalue->m.unadjustedEndDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         unadjustedEndDate, OSUTF8("unadjustedEndDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode adjustedStartDate */

   if (pvalue->m.adjustedStartDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         adjustedStartDate, OSUTF8("adjustedStartDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode adjustedEndDate */

   if (pvalue->m.adjustedEndDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->adjustedEndDate
         , OSUTF8("adjustedEndDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode calculationPeriodNumberOfDays */

   if (pvalue->m.calculationPeriodNumberOfDaysPresent) {
      stat = rtXmlEncUInt (pctxt, pvalue->calculationPeriodNumberOfDays
         , OSUTF8("calculationPeriodNumberOfDays"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode choice */

   stat = XmlEnc_CalculationPeriod_choice (pctxt, &pvalue->choice
      , OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode choice_1 */

   stat = XmlEnc_CalculationPeriod_choice_1 (pctxt, &pvalue->choice_1
      , OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PaymentCalculationPeriod_choice                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PaymentCalculationPeriod_choice (OSCTXT* pctxt,
   PaymentCalculationPeriod_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         if (!(pvalue->u.calculationPeriod_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "PaymentCalculationPeriod_choice.u.calculationPeriod_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.calculationPeriod_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         pnode2 = pvalue->u.calculationPeriod_list->tail;
         while (0 != pnode2) {
            ll = asn1E_CalculationPeriod (pctxt, ((CalculationPeriod*)pnode2->data), ASN1EXPL);
            if (ll < 0) return LOG_RTERR (pctxt, ll);
            ll2 += ll;

            pnode2 = pnode2->prev;
         }
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else { ll1 += ll; ll2 = 0; }
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
            xe_real (pctxt, &pvalue->u.fixedPaymentAmount, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_PaymentCalculationPeriod_choice (OSCTXT* pctxt, 
   PaymentCalculationPeriod_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode calculationPeriod_list */

         if (!(pvalue->u.calculationPeriod_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "PaymentCalculationPeriod_choice.u.calculationPeriod_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.calculationPeriod_list->
               count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         { const OSUTF8CHAR* savedPrefix = nsPrefix;
         nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
            "http://www.fpml.org/2003/FpML-4-0"));

         { OSRTDListNode* pnode = pvalue->u.calculationPeriod_list->head;
         while (0 != pnode) {
            stat = XmlEnc_CalculationPeriod (pctxt, 
               ((CalculationPeriod*)pnode->data)
               , OSUTF8("calculationPeriod"), nsPrefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            pnode = pnode->next;
         }}
         nsPrefix = savedPrefix;
         }

         break;

      case 2:
         /* encode fixedPaymentAmount */

         stat = rtXmlEncDouble (pctxt, pvalue->u.fixedPaymentAmount
            , OSUTF8("fixedPaymentAmount"), nsPrefix, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PaymentCalculationPeriod                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PaymentCalculationPeriod (OSCTXT* pctxt,
   PaymentCalculationPeriod *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_PaymentCalculationPeriod_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode adjustedPaymentDate */

   if (pvalue->m.adjustedPaymentDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_charstr (pctxt, pvalue->adjustedPaymentDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode unadjustedPaymentDate */

   if (pvalue->m.unadjustedPaymentDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_charstr (pctxt, pvalue->unadjustedPaymentDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PaymentCalculationPeriod (OSCTXT* pctxt, 
   PaymentCalculationPeriod* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode unadjustedPaymentDate */

   if (pvalue->m.unadjustedPaymentDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         unadjustedPaymentDate, OSUTF8("unadjustedPaymentDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode adjustedPaymentDate */

   if (pvalue->m.adjustedPaymentDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         adjustedPaymentDate, OSUTF8("adjustedPaymentDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode choice */

   stat = XmlEnc_PaymentCalculationPeriod_choice (pctxt, &pvalue->choice
      , OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cashflows                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Cashflows (OSCTXT* pctxt,
   Cashflows *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode paymentCalculationPeriod_list */

   pnode2 = pvalue->paymentCalculationPeriod_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PaymentCalculationPeriod (pctxt, ((PaymentCalculationPeriod*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode principalExchange_list */

   pnode2 = pvalue->principalExchange_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PrincipalExchange (pctxt, ((PrincipalExchange*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode cashflowsMatchParameters */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_boolean (pctxt, &pvalue->cashflowsMatchParameters, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Cashflows (OSCTXT* pctxt, Cashflows* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode cashflowsMatchParameters */

   stat = rtXmlEncBool (pctxt, pvalue->cashflowsMatchParameters
      , OSUTF8("cashflowsMatchParameters"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode principalExchange_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->principalExchange_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PrincipalExchange (pctxt, ((PrincipalExchange*)pnode->data)
         , OSUTF8("principalExchange"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode paymentCalculationPeriod_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->paymentCalculationPeriod_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PaymentCalculationPeriod (pctxt, 
         ((PaymentCalculationPeriod*)pnode->data)
         , OSUTF8("paymentCalculationPeriod"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterestRateStream                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_InterestRateStream (OSCTXT* pctxt,
   InterestRateStream *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode cashflows */

   if (pvalue->m.cashflowsPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_Cashflows (pctxt, &pvalue->cashflows, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode principalExchanges */

   if (pvalue->m.principalExchangesPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_PrincipalExchanges (pctxt, &pvalue->principalExchanges, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode stubCalculationPeriodAmount */

   if (pvalue->m.stubCalculationPeriodAmountPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_StubCalculationPeriodAmount (pctxt, &pvalue->stubCalculationPeriodAmount, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode calculationPeriodAmount */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_CalculationPeriodAmount (pctxt, &pvalue->calculationPeriodAmount, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode resetDates */

   if (pvalue->m.resetDatesPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_ResetDates (pctxt, &pvalue->resetDates, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode paymentDates */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_PaymentDates (pctxt, &pvalue->paymentDates, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode calculationPeriodDates */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_CalculationPeriodDates (pctxt, &pvalue->calculationPeriodDates, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode payerReceiver_model */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_InterestRateStream (OSCTXT* pctxt, InterestRateStream* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode payerReceiver_model */

   stat = XmlEnc_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode calculationPeriodDates */

   stat = XmlEnc_CalculationPeriodDates (pctxt, &pvalue->calculationPeriodDates
      , OSUTF8("calculationPeriodDates"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode paymentDates */

   stat = XmlEnc_PaymentDates (pctxt, &pvalue->paymentDates
      , OSUTF8("paymentDates"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode resetDates */

   if (pvalue->m.resetDatesPresent) {
      stat = XmlEnc_ResetDates (pctxt, &pvalue->resetDates
         , OSUTF8("resetDates"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode calculationPeriodAmount */

   stat = XmlEnc_CalculationPeriodAmount (pctxt, &pvalue->
      calculationPeriodAmount, OSUTF8("calculationPeriodAmount"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode stubCalculationPeriodAmount */

   if (pvalue->m.stubCalculationPeriodAmountPresent) {
      stat = XmlEnc_StubCalculationPeriodAmount (pctxt, &pvalue->
         stubCalculationPeriodAmount
         , OSUTF8("stubCalculationPeriodAmount"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode principalExchanges */

   if (pvalue->m.principalExchangesPresent) {
      stat = XmlEnc_PrincipalExchanges (pctxt, &pvalue->principalExchanges
         , OSUTF8("principalExchanges"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode cashflows */

   if (pvalue->m.cashflowsPresent) {
      stat = XmlEnc_Cashflows (pctxt, &pvalue->cashflows
         , OSUTF8("cashflows"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CapFloor                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CapFloor (OSCTXT* pctxt,
   CapFloor *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode additionalPayment_list */

   pnode2 = pvalue->additionalPayment_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Payment (pctxt, ((Payment*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode premium_list */

   pnode2 = pvalue->premium_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Payment (pctxt, ((Payment*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode capFloorStream */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_InterestRateStream (pctxt, &pvalue->capFloorStream, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode productId_list */

   pnode2 = pvalue->productId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ProductId (pctxt, ((ProductId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ProductType (pctxt, &pvalue->productType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CapFloor (OSCTXT* pctxt, CapFloor* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      stat = XmlEnc_ProductType (pctxt, &pvalue->productType
         , OSUTF8("productType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode productId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->productId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ProductId (pctxt, ((ProductId*)pnode->data)
         , OSUTF8("productId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode capFloorStream */

   stat = XmlEnc_InterestRateStream (pctxt, &pvalue->capFloorStream
      , OSUTF8("capFloorStream"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode premium_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->premium_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Payment (pctxt, ((Payment*)pnode->data)
         , OSUTF8("premium"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode additionalPayment_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->additionalPayment_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Payment (pctxt, ((Payment*)pnode->data)
         , OSUTF8("additionalPayment"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Fra_adjustedEffectiveDate                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Fra_adjustedEffectiveDate (OSCTXT* pctxt,
   Fra_adjustedEffectiveDate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_charstr (pctxt, pvalue->base, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Fra_adjustedEffectiveDate (OSCTXT* pctxt, 
   Fra_adjustedEffectiveDate* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FraDiscountingEnum                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FraDiscountingEnum (OSCTXT* pctxt,
   FraDiscountingEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_FraDiscountingEnum (OSCTXT* pctxt, FraDiscountingEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      FraDiscountingEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Fra                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Fra (OSCTXT* pctxt,
   Fra *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode fraDiscounting */

   if(pvalue->fraDiscounting < 0 || pvalue->fraDiscounting > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|14,
      asn1E_FraDiscountingEnum (pctxt, &pvalue->fraDiscounting, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode indexTenor */

   if (pvalue->m.indexTenorPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|13,
         asn1E_Interval_derivations (pctxt, &pvalue->indexTenor, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode floatingRateIndex */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|12,
      asn1E_FloatingRateIndex (pctxt, &pvalue->floatingRateIndex, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode fixedRate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|11,
      xe_real (pctxt, &pvalue->fixedRate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode notional */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10,
      asn1E_Money_derivations (pctxt, &pvalue->notional, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode calculationPeriodNumberOfDays */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|9,
      xe_unsigned (pctxt, &pvalue->calculationPeriodNumberOfDays, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode dayCountFraction */

   if(pvalue->dayCountFraction < 0 || pvalue->dayCountFraction > 7)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|8,
      asn1E_DayCountFractionEnum (pctxt, &pvalue->dayCountFraction, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode fixingDateOffset */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
      asn1E_RelativeDateOffset_derivations (pctxt, &pvalue->fixingDateOffset, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode paymentDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_AdjustableDate (pctxt, &pvalue->paymentDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode adjustedTerminationDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
      xe_charstr (pctxt, pvalue->adjustedTerminationDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode adjustedEffectiveDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_Fra_adjustedEffectiveDate (pctxt, &pvalue->adjustedEffectiveDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode buyerSeller_model */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_BuyerSeller_model (pctxt, &pvalue->buyerSeller_model, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode productId_list */

   pnode2 = pvalue->productId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ProductId (pctxt, ((ProductId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ProductType (pctxt, &pvalue->productType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Fra (OSCTXT* pctxt, Fra* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      stat = XmlEnc_ProductType (pctxt, &pvalue->productType
         , OSUTF8("productType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode productId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->productId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ProductId (pctxt, ((ProductId*)pnode->data)
         , OSUTF8("productId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode buyerSeller_model */

   stat = XmlEnc_BuyerSeller_model (pctxt, &pvalue->buyerSeller_model
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode adjustedEffectiveDate */

   stat = XmlEnc_Fra_adjustedEffectiveDate (pctxt, &pvalue->
      adjustedEffectiveDate, OSUTF8("adjustedEffectiveDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode adjustedTerminationDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
      adjustedTerminationDate, OSUTF8("adjustedTerminationDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode paymentDate */

   stat = XmlEnc_AdjustableDate (pctxt, &pvalue->paymentDate
      , OSUTF8("paymentDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode fixingDateOffset */

   stat = XmlEnc_RelativeDateOffset_derivations (pctxt, &pvalue->
      fixingDateOffset, OSUTF8("fixingDateOffset"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dayCountFraction */

   if(pvalue->dayCountFraction < 0 || pvalue->dayCountFraction > 7)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_DayCountFractionEnum (pctxt, pvalue->dayCountFraction
      , OSUTF8("dayCountFraction"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode calculationPeriodNumberOfDays */

   stat = rtXmlEncUInt (pctxt, pvalue->calculationPeriodNumberOfDays
      , OSUTF8("calculationPeriodNumberOfDays"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode notional */

   stat = XmlEnc_Money_derivations (pctxt, &pvalue->notional
      , OSUTF8("notional"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode fixedRate */

   stat = rtXmlEncDouble (pctxt, pvalue->fixedRate
      , OSUTF8("fixedRate"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode floatingRateIndex */

   stat = XmlEnc_FloatingRateIndex (pctxt, &pvalue->floatingRateIndex
      , OSUTF8("floatingRateIndex"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode indexTenor */

   if (pvalue->m.indexTenorPresent) {
      stat = XmlEnc_Interval_derivations (pctxt, &pvalue->indexTenor
         , OSUTF8("indexTenor"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fraDiscounting */

   if(pvalue->fraDiscounting < 0 || pvalue->fraDiscounting > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_FraDiscountingEnum (pctxt, pvalue->fraDiscounting
      , OSUTF8("fraDiscounting"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CalculationAgentPartyEnum                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CalculationAgentPartyEnum (OSCTXT* pctxt,
   CalculationAgentPartyEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_CalculationAgentPartyEnum (OSCTXT* pctxt, 
   CalculationAgentPartyEnum value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      CalculationAgentPartyEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CalculationAgent                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CalculationAgent (OSCTXT* pctxt,
   CalculationAgent *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         if (!(pvalue->u.calculationAgentPartyReference_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "CalculationAgent.u.calculationAgentPartyReference_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.calculationAgentPartyReference_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         pnode2 = pvalue->u.calculationAgentPartyReference_list->tail;
         while (0 != pnode2) {
            ll = asn1E_PartyReference (pctxt, ((PartyReference*)pnode2->data), ASN1EXPL);
            if (ll < 0) return LOG_RTERR (pctxt, ll);
            ll2 += ll;

            pnode2 = pnode2->prev;
         }
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else { ll1 += ll; ll2 = 0; }
         break;

      case 2:
         if(pvalue->u.calculationAgentParty < 0 || pvalue->u.calculationAgentParty > 2)
            return LOG_RTERR (pctxt, RTERR_INVENUM);

         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
            asn1E_CalculationAgentPartyEnum (pctxt, &pvalue->u.calculationAgentParty, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   if (tagging == ASN1EXPL) {
      ll1 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll1);
      if (ll1 < 0) return LOG_RTERR (pctxt, ll1);
   }

   ll0 += ll1;

   return (ll0);
}

int XmlEnc_CalculationAgent (OSCTXT* pctxt, CalculationAgent* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode calculationAgentPartyReference_list */

         if (!(pvalue->u.calculationAgentPartyReference_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "CalculationAgent.u.calculationAgentPartyReference_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->
               u.calculationAgentPartyReference_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         { const OSUTF8CHAR* savedPrefix = nsPrefix;
         nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
            "http://www.fpml.org/2003/FpML-4-0"));

         { OSRTDListNode* pnode = pvalue->u.calculationAgentPartyReference_list
            ->head;
         while (0 != pnode) {
            stat = XmlEnc_PartyReference (pctxt, ((PartyReference*)pnode->data)
               , OSUTF8("calculationAgentPartyReference"), nsPrefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            pnode = pnode->next;
         }}
         nsPrefix = savedPrefix;
         }

         break;

      case 2:
         /* encode calculationAgentParty */

         if(pvalue->u.calculationAgentParty < 0 || pvalue->
            u.calculationAgentParty > 2)
            return LOG_RTERR (pctxt, RTERR_INVENUM);

         stat = XmlEnc_CalculationAgentPartyEnum (pctxt, pvalue->
            u.calculationAgentParty
            , OSUTF8("calculationAgentParty"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AdjustableDates_unadjustedDate                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AdjustableDates_unadjustedDate (OSCTXT* pctxt,
   AdjustableDates_unadjustedDate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_charstr (pctxt, pvalue->base, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_AdjustableDates_unadjustedDate (OSCTXT* pctxt, 
   AdjustableDates_unadjustedDate* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AdjustableDates                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AdjustableDates (OSCTXT* pctxt,
   AdjustableDates *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode dateAdjustments */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_BusinessDayAdjustments (pctxt, &pvalue->dateAdjustments, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode unadjustedDate_list */

   if (!(pvalue->unadjustedDate_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "AdjustableDates.unadjustedDate_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->unadjustedDate_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->unadjustedDate_list.tail;
   while (0 != pnode2) {
      ll = asn1E_AdjustableDates_unadjustedDate (pctxt, ((AdjustableDates_unadjustedDate*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_AdjustableDates (OSCTXT* pctxt, AdjustableDates* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode unadjustedDate_list */

   if (!(pvalue->unadjustedDate_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "AdjustableDates.unadjustedDate_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->unadjustedDate_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->unadjustedDate_list.head;
   while (0 != pnode) {
      stat = XmlEnc_AdjustableDates_unadjustedDate (pctxt, 
         ((AdjustableDates_unadjustedDate*)pnode->data)
         , OSUTF8("unadjustedDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode dateAdjustments */

   stat = XmlEnc_BusinessDayAdjustments (pctxt, &pvalue->dateAdjustments
      , OSUTF8("dateAdjustments"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CashSettlementPaymentDate_choice                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CashSettlementPaymentDate_choice (OSCTXT* pctxt,
   CashSettlementPaymentDate_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AdjustableDates (pctxt, pvalue->u.adjustableDates, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_RelativeDateOffset_derivations (pctxt, pvalue->u.relativeDate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_BusinessDateRange (pctxt, pvalue->u.businessDateRange, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_CashSettlementPaymentDate_choice (OSCTXT* pctxt, 
   CashSettlementPaymentDate_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode adjustableDates */

         stat = XmlEnc_AdjustableDates (pctxt, pvalue->u.adjustableDates
            , OSUTF8("adjustableDates"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode relativeDate */

         stat = XmlEnc_RelativeDateOffset_derivations (pctxt, pvalue->
            u.relativeDate, OSUTF8("relativeDate"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode businessDateRange */

         stat = XmlEnc_BusinessDateRange (pctxt, pvalue->u.businessDateRange
            , OSUTF8("businessDateRange"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CashSettlementPaymentDate                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CashSettlementPaymentDate (OSCTXT* pctxt,
   CashSettlementPaymentDate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_CashSettlementPaymentDate_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CashSettlementPaymentDate (OSCTXT* pctxt, 
   CashSettlementPaymentDate* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode choice */

   stat = XmlEnc_CashSettlementPaymentDate_choice (pctxt, &pvalue->choice
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReferenceBankId                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ReferenceBankId (OSCTXT* pctxt,
   ReferenceBankId *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode referenceBankIdScheme */

   if (pvalue->m.referenceBankIdSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->referenceBankIdScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ReferenceBankId (OSCTXT* pctxt, ReferenceBankId* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.referenceBankIdSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" referenceBankIdScheme=\""), 24);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->referenceBankIdScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReferenceBank                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ReferenceBank (OSCTXT* pctxt,
   ReferenceBank *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode referenceBankName */

   if (pvalue->m.referenceBankNamePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->referenceBankName, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode referenceBankId */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_ReferenceBankId (pctxt, &pvalue->referenceBankId, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ReferenceBank (OSCTXT* pctxt, ReferenceBank* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode referenceBankId */

   stat = XmlEnc_ReferenceBankId (pctxt, &pvalue->referenceBankId
      , OSUTF8("referenceBankId"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode referenceBankName */

   if (pvalue->m.referenceBankNamePresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->referenceBankName
         , OSUTF8("referenceBankName"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CashSettlementReferenceBanks                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CashSettlementReferenceBanks (OSCTXT* pctxt,
   CashSettlementReferenceBanks *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode referenceBank_list */

   if (!(pvalue->referenceBank_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "CashSettlementReferenceBanks.referenceBank_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->referenceBank_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->referenceBank_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ReferenceBank (pctxt, ((ReferenceBank*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CashSettlementReferenceBanks (OSCTXT* pctxt, 
   CashSettlementReferenceBanks* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode referenceBank_list */

   if (!(pvalue->referenceBank_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "CashSettlementReferenceBanks.referenceBank_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->referenceBank_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->referenceBank_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ReferenceBank (pctxt, ((ReferenceBank*)pnode->data)
         , OSUTF8("referenceBank"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuotationRateTypeEnum                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuotationRateTypeEnum (OSCTXT* pctxt,
   QuotationRateTypeEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 3)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_QuotationRateTypeEnum (OSCTXT* pctxt, QuotationRateTypeEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      QuotationRateTypeEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CashPriceMethod                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CashPriceMethod (OSCTXT* pctxt,
   CashPriceMethod *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quotationRateType */

   if(pvalue->quotationRateType < 0 || pvalue->quotationRateType > 3)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      asn1E_QuotationRateTypeEnum (pctxt, &pvalue->quotationRateType, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode cashSettlementCurrency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Currency (pctxt, &pvalue->cashSettlementCurrency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode cashSettlementReferenceBanks */

   if (pvalue->m.cashSettlementReferenceBanksPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_CashSettlementReferenceBanks (pctxt, &pvalue->cashSettlementReferenceBanks, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CashPriceMethod (OSCTXT* pctxt, CashPriceMethod* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode cashSettlementReferenceBanks */

   if (pvalue->m.cashSettlementReferenceBanksPresent) {
      stat = XmlEnc_CashSettlementReferenceBanks (pctxt, &pvalue->
         cashSettlementReferenceBanks
         , OSUTF8("cashSettlementReferenceBanks"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode cashSettlementCurrency */

   stat = XmlEnc_Currency (pctxt, &pvalue->cashSettlementCurrency
      , OSUTF8("cashSettlementCurrency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode quotationRateType */

   if(pvalue->quotationRateType < 0 || pvalue->quotationRateType > 3)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_QuotationRateTypeEnum (pctxt, pvalue->quotationRateType
      , OSUTF8("quotationRateType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SettlementRateSource                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SettlementRateSource (OSCTXT* pctxt,
   SettlementRateSource *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_InformationSource (pctxt, pvalue->u.informationSource, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_CashSettlementReferenceBanks (pctxt, pvalue->u.cashSettlementReferenceBanks, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   if (tagging == ASN1EXPL) {
      ll1 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll1);
      if (ll1 < 0) return LOG_RTERR (pctxt, ll1);
   }

   ll0 += ll1;

   return (ll0);
}

int XmlEnc_SettlementRateSource (OSCTXT* pctxt, SettlementRateSource* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode informationSource */

         stat = XmlEnc_InformationSource (pctxt, pvalue->u.informationSource
            , OSUTF8("informationSource"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode cashSettlementReferenceBanks */

         stat = XmlEnc_CashSettlementReferenceBanks (pctxt, pvalue->
            u.cashSettlementReferenceBanks
            , OSUTF8("cashSettlementReferenceBanks"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  YieldCurveMethod                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_YieldCurveMethod (OSCTXT* pctxt,
   YieldCurveMethod *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quotationRateType */

   if(pvalue->quotationRateType < 0 || pvalue->quotationRateType > 3)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_QuotationRateTypeEnum (pctxt, &pvalue->quotationRateType, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode settlementRateSource */

   if (pvalue->m.settlementRateSourcePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_SettlementRateSource (pctxt, &pvalue->settlementRateSource, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_YieldCurveMethod (OSCTXT* pctxt, YieldCurveMethod* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode settlementRateSource */

   if (pvalue->m.settlementRateSourcePresent) {
      stat = XmlEnc_SettlementRateSource (pctxt, &pvalue->settlementRateSource
         , OSUTF8("settlementRateSource"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quotationRateType */

   if(pvalue->quotationRateType < 0 || pvalue->quotationRateType > 3)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_QuotationRateTypeEnum (pctxt, pvalue->quotationRateType
      , OSUTF8("quotationRateType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CashSettlement_choice                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CashSettlement_choice (OSCTXT* pctxt,
   CashSettlement_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_CashPriceMethod (pctxt, pvalue->u.cashPriceMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_CashPriceMethod (pctxt, pvalue->u.cashPriceAlternateMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_YieldCurveMethod (pctxt, pvalue->u.parYieldCurveAdjustedMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 4:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
            asn1E_YieldCurveMethod (pctxt, pvalue->u.zeroCouponYieldAdjustedMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 5:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
            asn1E_YieldCurveMethod (pctxt, pvalue->u.parYieldCurveUnadjustedMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_CashSettlement_choice (OSCTXT* pctxt, 
   CashSettlement_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode cashPriceMethod */

         stat = XmlEnc_CashPriceMethod (pctxt, pvalue->u.cashPriceMethod
            , OSUTF8("cashPriceMethod"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode cashPriceAlternateMethod */

         stat = XmlEnc_CashPriceMethod (pctxt, pvalue->
            u.cashPriceAlternateMethod
            , OSUTF8("cashPriceAlternateMethod"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode parYieldCurveAdjustedMethod */

         stat = XmlEnc_YieldCurveMethod (pctxt, pvalue->
            u.parYieldCurveAdjustedMethod
            , OSUTF8("parYieldCurveAdjustedMethod"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 4:
         /* encode zeroCouponYieldAdjustedMethod */

         stat = XmlEnc_YieldCurveMethod (pctxt, pvalue->
            u.zeroCouponYieldAdjustedMethod
            , OSUTF8("zeroCouponYieldAdjustedMethod"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 5:
         /* encode parYieldCurveUnadjustedMethod */

         stat = XmlEnc_YieldCurveMethod (pctxt, pvalue->
            u.parYieldCurveUnadjustedMethod
            , OSUTF8("parYieldCurveUnadjustedMethod"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CashSettlement                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CashSettlement (OSCTXT* pctxt,
   CashSettlement *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_CashSettlement_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode cashSettlementPaymentDate */

   if (pvalue->m.cashSettlementPaymentDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_CashSettlementPaymentDate (pctxt, &pvalue->cashSettlementPaymentDate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode cashSettlementValuationDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_RelativeDateOffset_derivations (pctxt, &pvalue->cashSettlementValuationDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode cashSettlementValuationTime */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_BusinessCenterTime (pctxt, &pvalue->cashSettlementValuationTime, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CashSettlement (OSCTXT* pctxt, CashSettlement* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode cashSettlementValuationTime */

   stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->
      cashSettlementValuationTime
      , OSUTF8("cashSettlementValuationTime"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cashSettlementValuationDate */

   stat = XmlEnc_RelativeDateOffset_derivations (pctxt, &pvalue->
      cashSettlementValuationDate
      , OSUTF8("cashSettlementValuationDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cashSettlementPaymentDate */

   if (pvalue->m.cashSettlementPaymentDatePresent) {
      stat = XmlEnc_CashSettlementPaymentDate (pctxt, &pvalue->
         cashSettlementPaymentDate
         , OSUTF8("cashSettlementPaymentDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode choice */

   stat = XmlEnc_CashSettlement_choice (pctxt, &pvalue->choice
      , OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MandatoryEarlyTerminationAdjustedDates                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MandatoryEarlyTerminationAdjustedDates (OSCTXT* pctxt,
   MandatoryEarlyTerminationAdjustedDates *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode adjustedCashSettlementPaymentDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_charstr (pctxt, pvalue->adjustedCashSettlementPaymentDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode adjustedCashSettlementValuationDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_charstr (pctxt, pvalue->adjustedCashSettlementValuationDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode adjustedEarlyTerminationDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_charstr (pctxt, pvalue->adjustedEarlyTerminationDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MandatoryEarlyTerminationAdjustedDates (OSCTXT* pctxt, 
   MandatoryEarlyTerminationAdjustedDates* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode adjustedEarlyTerminationDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
      adjustedEarlyTerminationDate
      , OSUTF8("adjustedEarlyTerminationDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode adjustedCashSettlementValuationDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
      adjustedCashSettlementValuationDate
      , OSUTF8("adjustedCashSettlementValuationDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode adjustedCashSettlementPaymentDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
      adjustedCashSettlementPaymentDate
      , OSUTF8("adjustedCashSettlementPaymentDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MandatoryEarlyTermination                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MandatoryEarlyTermination (OSCTXT* pctxt,
   MandatoryEarlyTermination *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode mandatoryEarlyTerminationAdjustedDates */

   if (pvalue->m.mandatoryEarlyTerminationAdjustedDatesPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_MandatoryEarlyTerminationAdjustedDates (pctxt, &pvalue->mandatoryEarlyTerminationAdjustedDates, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode cashSettlement */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_CashSettlement (pctxt, &pvalue->cashSettlement, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode calculationAgent */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_CalculationAgent (pctxt, &pvalue->calculationAgent, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode mandatoryEarlyTerminationDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_AdjustableDate (pctxt, &pvalue->mandatoryEarlyTerminationDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MandatoryEarlyTermination (OSCTXT* pctxt, 
   MandatoryEarlyTermination* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode mandatoryEarlyTerminationDate */

   stat = XmlEnc_AdjustableDate (pctxt, &pvalue->mandatoryEarlyTerminationDate
      , OSUTF8("mandatoryEarlyTerminationDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode calculationAgent */

   stat = XmlEnc_CalculationAgent (pctxt, &pvalue->calculationAgent
      , OSUTF8("calculationAgent"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cashSettlement */

   stat = XmlEnc_CashSettlement (pctxt, &pvalue->cashSettlement
      , OSUTF8("cashSettlement"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode mandatoryEarlyTerminationAdjustedDates */

   if (pvalue->m.mandatoryEarlyTerminationAdjustedDatesPresent) {
      stat = XmlEnc_MandatoryEarlyTerminationAdjustedDates (pctxt, &pvalue->
         mandatoryEarlyTerminationAdjustedDates
         , OSUTF8("mandatoryEarlyTerminationAdjustedDates"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SinglePartyOption                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SinglePartyOption (OSCTXT* pctxt,
   SinglePartyOption *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_BuyerSeller_model (pctxt, pvalue, ASN1IMPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   if (tagging == ASN1EXPL) {
      ll = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
   }
   ll0 += ll;

   return (ll0);
}

int XmlEnc_SinglePartyOption (OSCTXT* pctxt, SinglePartyOption* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_BuyerSeller_model (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AdjustableOrRelativeDate_choice                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AdjustableOrRelativeDate_choice (OSCTXT* pctxt,
   AdjustableOrRelativeDate_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AdjustableDate (pctxt, pvalue->u.adjustableDate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_RelativeDateOffset_derivations (pctxt, pvalue->u.relativeDate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_AdjustableOrRelativeDate_choice (OSCTXT* pctxt, 
   AdjustableOrRelativeDate_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode adjustableDate */

         stat = XmlEnc_AdjustableDate (pctxt, pvalue->u.adjustableDate
            , OSUTF8("adjustableDate"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode relativeDate */

         stat = XmlEnc_RelativeDateOffset_derivations (pctxt, pvalue->
            u.relativeDate, OSUTF8("relativeDate"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AdjustableOrRelativeDate                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AdjustableOrRelativeDate (OSCTXT* pctxt,
   AdjustableOrRelativeDate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_AdjustableOrRelativeDate_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_AdjustableOrRelativeDate (OSCTXT* pctxt, 
   AdjustableOrRelativeDate* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode choice */

   stat = XmlEnc_AdjustableOrRelativeDate_choice (pctxt, &pvalue->choice
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AdjustableOrRelativeDates_choice                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AdjustableOrRelativeDates_choice (OSCTXT* pctxt,
   AdjustableOrRelativeDates_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AdjustableDates (pctxt, pvalue->u.adjustableDates, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_RelativeDates (pctxt, pvalue->u.relativeDates, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_AdjustableOrRelativeDates_choice (OSCTXT* pctxt, 
   AdjustableOrRelativeDates_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode adjustableDates */

         stat = XmlEnc_AdjustableDates (pctxt, pvalue->u.adjustableDates
            , OSUTF8("adjustableDates"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode relativeDates */

         stat = XmlEnc_RelativeDates (pctxt, pvalue->u.relativeDates
            , OSUTF8("relativeDates"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AdjustableOrRelativeDates                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AdjustableOrRelativeDates (OSCTXT* pctxt,
   AdjustableOrRelativeDates *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_AdjustableOrRelativeDates_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_AdjustableOrRelativeDates (OSCTXT* pctxt, 
   AdjustableOrRelativeDates* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode choice */

   stat = XmlEnc_AdjustableOrRelativeDates_choice (pctxt, &pvalue->choice
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultipleExercise                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MultipleExercise (OSCTXT* pctxt,
   MultipleExercise *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode maximumNotionalAmount */

   if (pvalue->m.maximumNotionalAmountPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_real (pctxt, &pvalue->maximumNotionalAmount, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode minimumNotionalAmount */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_real (pctxt, &pvalue->minimumNotionalAmount, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode integralMultipleAmount */

   if (pvalue->m.integralMultipleAmountPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_real (pctxt, &pvalue->integralMultipleAmount, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode notionalReference_list */

   if (!(pvalue->notionalReference_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "MultipleExercise.notionalReference_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->notionalReference_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->notionalReference_list.tail;
   while (0 != pnode2) {
      ll = asn1E_NotionalReference (pctxt, ((NotionalReference*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MultipleExercise (OSCTXT* pctxt, MultipleExercise* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode notionalReference_list */

   if (!(pvalue->notionalReference_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "MultipleExercise.notionalReference_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->notionalReference_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->notionalReference_list.head;
   while (0 != pnode) {
      stat = XmlEnc_NotionalReference (pctxt, ((NotionalReference*)pnode->data)
         , OSUTF8("notionalReference"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode integralMultipleAmount */

   if (pvalue->m.integralMultipleAmountPresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->integralMultipleAmount
         , OSUTF8("integralMultipleAmount"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode minimumNotionalAmount */

   stat = rtXmlEncDouble (pctxt, pvalue->minimumNotionalAmount
      , OSUTF8("minimumNotionalAmount"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode maximumNotionalAmount */

   if (pvalue->m.maximumNotionalAmountPresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->maximumNotionalAmount
         , OSUTF8("maximumNotionalAmount"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExerciseFeeSchedule_choice                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExerciseFeeSchedule_choice (OSCTXT* pctxt,
   ExerciseFeeSchedule_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AmountSchedule (pctxt, pvalue->u.feeAmountSchedule, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_Schedule_derivations (pctxt, pvalue->u.feeRateSchedule, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_ExerciseFeeSchedule_choice (OSCTXT* pctxt, 
   ExerciseFeeSchedule_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode feeAmountSchedule */

         stat = XmlEnc_AmountSchedule (pctxt, pvalue->u.feeAmountSchedule
            , OSUTF8("feeAmountSchedule"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode feeRateSchedule */

         stat = XmlEnc_Schedule_derivations (pctxt, pvalue->u.feeRateSchedule
            , OSUTF8("feeRateSchedule"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExerciseFeeSchedule                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExerciseFeeSchedule (OSCTXT* pctxt,
   ExerciseFeeSchedule *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode feePaymentDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_RelativeDateOffset_derivations (pctxt, &pvalue->feePaymentDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_ExerciseFeeSchedule_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode notionalReference */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_NotionalReference (pctxt, &pvalue->notionalReference, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode payerReceiver_model */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ExerciseFeeSchedule (OSCTXT* pctxt, ExerciseFeeSchedule* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode payerReceiver_model */

   stat = XmlEnc_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode notionalReference */

   stat = XmlEnc_NotionalReference (pctxt, &pvalue->notionalReference
      , OSUTF8("notionalReference"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode choice */

   stat = XmlEnc_ExerciseFeeSchedule_choice (pctxt, &pvalue->choice
      , OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode feePaymentDate */

   stat = XmlEnc_RelativeDateOffset_derivations (pctxt, &pvalue->feePaymentDate
      , OSUTF8("feePaymentDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AmericanExercise                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AmericanExercise (OSCTXT* pctxt,
   AmericanExercise *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode exerciseFeeSchedule */

   if (pvalue->m.exerciseFeeSchedulePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_ExerciseFeeSchedule (pctxt, &pvalue->exerciseFeeSchedule, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode multipleExercise */

   if (pvalue->m.multipleExercisePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_MultipleExercise (pctxt, &pvalue->multipleExercise, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode expirationTime */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_BusinessCenterTime (pctxt, &pvalue->expirationTime, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode latestExerciseTime */

   if (pvalue->m.latestExerciseTimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_BusinessCenterTime (pctxt, &pvalue->latestExerciseTime, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode earliestExerciseTime */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_BusinessCenterTime (pctxt, &pvalue->earliestExerciseTime, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode relevantUnderlyingDate */

   if (pvalue->m.relevantUnderlyingDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_AdjustableOrRelativeDates (pctxt, &pvalue->relevantUnderlyingDate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode expirationDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_AdjustableOrRelativeDate (pctxt, &pvalue->expirationDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode commencementDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_AdjustableOrRelativeDate (pctxt, &pvalue->commencementDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_AmericanExercise (OSCTXT* pctxt, AmericanExercise* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode commencementDate */

   stat = XmlEnc_AdjustableOrRelativeDate (pctxt, &pvalue->commencementDate
      , OSUTF8("commencementDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode expirationDate */

   stat = XmlEnc_AdjustableOrRelativeDate (pctxt, &pvalue->expirationDate
      , OSUTF8("expirationDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode relevantUnderlyingDate */

   if (pvalue->m.relevantUnderlyingDatePresent) {
      stat = XmlEnc_AdjustableOrRelativeDates (pctxt, &pvalue->
         relevantUnderlyingDate, OSUTF8("relevantUnderlyingDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode earliestExerciseTime */

   stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->earliestExerciseTime
      , OSUTF8("earliestExerciseTime"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode latestExerciseTime */

   if (pvalue->m.latestExerciseTimePresent) {
      stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->latestExerciseTime
         , OSUTF8("latestExerciseTime"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode expirationTime */

   stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->expirationTime
      , OSUTF8("expirationTime"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode multipleExercise */

   if (pvalue->m.multipleExercisePresent) {
      stat = XmlEnc_MultipleExercise (pctxt, &pvalue->multipleExercise
         , OSUTF8("multipleExercise"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode exerciseFeeSchedule */

   if (pvalue->m.exerciseFeeSchedulePresent) {
      stat = XmlEnc_ExerciseFeeSchedule (pctxt, &pvalue->exerciseFeeSchedule
         , OSUTF8("exerciseFeeSchedule"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BermudaExercise                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BermudaExercise (OSCTXT* pctxt,
   BermudaExercise *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode exerciseFeeSchedule */

   if (pvalue->m.exerciseFeeSchedulePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_ExerciseFeeSchedule (pctxt, &pvalue->exerciseFeeSchedule, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode multipleExercise */

   if (pvalue->m.multipleExercisePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_MultipleExercise (pctxt, &pvalue->multipleExercise, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode expirationTime */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_BusinessCenterTime (pctxt, &pvalue->expirationTime, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode latestExerciseTime */

   if (pvalue->m.latestExerciseTimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_BusinessCenterTime (pctxt, &pvalue->latestExerciseTime, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode earliestExerciseTime */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_BusinessCenterTime (pctxt, &pvalue->earliestExerciseTime, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode relevantUnderlyingDate */

   if (pvalue->m.relevantUnderlyingDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_AdjustableOrRelativeDates (pctxt, &pvalue->relevantUnderlyingDate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bermudaExerciseDates */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_AdjustableOrRelativeDates (pctxt, &pvalue->bermudaExerciseDates, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BermudaExercise (OSCTXT* pctxt, BermudaExercise* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode bermudaExerciseDates */

   stat = XmlEnc_AdjustableOrRelativeDates (pctxt, &pvalue->
      bermudaExerciseDates, OSUTF8("bermudaExerciseDates"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode relevantUnderlyingDate */

   if (pvalue->m.relevantUnderlyingDatePresent) {
      stat = XmlEnc_AdjustableOrRelativeDates (pctxt, &pvalue->
         relevantUnderlyingDate, OSUTF8("relevantUnderlyingDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode earliestExerciseTime */

   stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->earliestExerciseTime
      , OSUTF8("earliestExerciseTime"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode latestExerciseTime */

   if (pvalue->m.latestExerciseTimePresent) {
      stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->latestExerciseTime
         , OSUTF8("latestExerciseTime"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode expirationTime */

   stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->expirationTime
      , OSUTF8("expirationTime"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode multipleExercise */

   if (pvalue->m.multipleExercisePresent) {
      stat = XmlEnc_MultipleExercise (pctxt, &pvalue->multipleExercise
         , OSUTF8("multipleExercise"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode exerciseFeeSchedule */

   if (pvalue->m.exerciseFeeSchedulePresent) {
      stat = XmlEnc_ExerciseFeeSchedule (pctxt, &pvalue->exerciseFeeSchedule
         , OSUTF8("exerciseFeeSchedule"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PartialExercise                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PartialExercise (OSCTXT* pctxt,
   PartialExercise *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode minimumNotionalAmount */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_real (pctxt, &pvalue->minimumNotionalAmount, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode integralMultipleAmount */

   if (pvalue->m.integralMultipleAmountPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_real (pctxt, &pvalue->integralMultipleAmount, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode notionalReference_list */

   if (!(pvalue->notionalReference_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "PartialExercise.notionalReference_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->notionalReference_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->notionalReference_list.tail;
   while (0 != pnode2) {
      ll = asn1E_NotionalReference (pctxt, ((NotionalReference*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PartialExercise (OSCTXT* pctxt, PartialExercise* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode notionalReference_list */

   if (!(pvalue->notionalReference_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "PartialExercise.notionalReference_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->notionalReference_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->notionalReference_list.head;
   while (0 != pnode) {
      stat = XmlEnc_NotionalReference (pctxt, ((NotionalReference*)pnode->data)
         , OSUTF8("notionalReference"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode integralMultipleAmount */

   if (pvalue->m.integralMultipleAmountPresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->integralMultipleAmount
         , OSUTF8("integralMultipleAmount"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode minimumNotionalAmount */

   stat = rtXmlEncDouble (pctxt, pvalue->minimumNotionalAmount
      , OSUTF8("minimumNotionalAmount"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PartialExercise_derivations                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PartialExercise_derivations (OSCTXT* pctxt,
   PartialExercise_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_PartialExercise (pctxt, pvalue->u.partialExercise, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_MultipleExercise (pctxt, pvalue->u.multipleExercise, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_PartialExercise_derivations (OSCTXT* pctxt, 
   PartialExercise_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode partialExercise */

         stat = XmlEnc_PartialExercise (pctxt, pvalue->u.partialExercise
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode multipleExercise */

         stat = XmlEnc_MultipleExercise (pctxt, pvalue->u.multipleExercise
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExerciseFee_choice                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExerciseFee_choice (OSCTXT* pctxt,
   ExerciseFee_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            xe_real (pctxt, &pvalue->u.feeAmount, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
            xe_real (pctxt, &pvalue->u.feeRate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_ExerciseFee_choice (OSCTXT* pctxt, ExerciseFee_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode feeAmount */

         stat = rtXmlEncDouble (pctxt, pvalue->u.feeAmount
            , OSUTF8("feeAmount"), nsPrefix, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode feeRate */

         stat = rtXmlEncDouble (pctxt, pvalue->u.feeRate
            , OSUTF8("feeRate"), nsPrefix, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExerciseFee                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExerciseFee (OSCTXT* pctxt,
   ExerciseFee *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode feePaymentDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_RelativeDateOffset_derivations (pctxt, &pvalue->feePaymentDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_ExerciseFee_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode notionalReference */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_NotionalReference (pctxt, &pvalue->notionalReference, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode payerReceiver_model */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ExerciseFee (OSCTXT* pctxt, ExerciseFee* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode payerReceiver_model */

   stat = XmlEnc_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode notionalReference */

   stat = XmlEnc_NotionalReference (pctxt, &pvalue->notionalReference
      , OSUTF8("notionalReference"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode choice */

   stat = XmlEnc_ExerciseFee_choice (pctxt, &pvalue->choice, OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode feePaymentDate */

   stat = XmlEnc_RelativeDateOffset_derivations (pctxt, &pvalue->feePaymentDate
      , OSUTF8("feePaymentDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EuropeanExercise                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EuropeanExercise (OSCTXT* pctxt,
   EuropeanExercise *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode exerciseFee */

   if (pvalue->m.exerciseFeePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_ExerciseFee (pctxt, &pvalue->exerciseFee, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode partialExercise */

   if (pvalue->m.partialExercisePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_PartialExercise_derivations (pctxt, &pvalue->partialExercise, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode expirationTime */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_BusinessCenterTime (pctxt, &pvalue->expirationTime, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode earliestExerciseTime */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_BusinessCenterTime (pctxt, &pvalue->earliestExerciseTime, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode relevantUnderlyingDate */

   if (pvalue->m.relevantUnderlyingDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_AdjustableOrRelativeDates (pctxt, &pvalue->relevantUnderlyingDate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode expirationDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_AdjustableOrRelativeDate (pctxt, &pvalue->expirationDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EuropeanExercise (OSCTXT* pctxt, EuropeanExercise* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode expirationDate */

   stat = XmlEnc_AdjustableOrRelativeDate (pctxt, &pvalue->expirationDate
      , OSUTF8("expirationDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode relevantUnderlyingDate */

   if (pvalue->m.relevantUnderlyingDatePresent) {
      stat = XmlEnc_AdjustableOrRelativeDates (pctxt, &pvalue->
         relevantUnderlyingDate, OSUTF8("relevantUnderlyingDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode earliestExerciseTime */

   stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->earliestExerciseTime
      , OSUTF8("earliestExerciseTime"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode expirationTime */

   stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->expirationTime
      , OSUTF8("expirationTime"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode partialExercise */

   if (pvalue->m.partialExercisePresent) {
      stat = XmlEnc_PartialExercise_derivations (pctxt, &pvalue->
         partialExercise, OSUTF8("partialExercise"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode exerciseFee */

   if (pvalue->m.exerciseFeePresent) {
      stat = XmlEnc_ExerciseFee (pctxt, &pvalue->exerciseFee
         , OSUTF8("exerciseFee"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Exercise_group                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Exercise_group (OSCTXT* pctxt,
   Exercise_group *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AmericanExercise (pctxt, pvalue->u.americanExercise, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_BermudaExercise (pctxt, pvalue->u.bermudaExercise, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_EuropeanExercise (pctxt, pvalue->u.europeanExercise, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Exercise_group (OSCTXT* pctxt, Exercise_group* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode americanExercise */

         stat = XmlEnc_AmericanExercise (pctxt, pvalue->u.americanExercise
            , OSUTF8("americanExercise"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode bermudaExercise */

         stat = XmlEnc_BermudaExercise (pctxt, pvalue->u.bermudaExercise
            , OSUTF8("bermudaExercise"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode europeanExercise */

         stat = XmlEnc_EuropeanExercise (pctxt, pvalue->u.europeanExercise
            , OSUTF8("europeanExercise"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExerciseNotice                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExerciseNotice (OSCTXT* pctxt,
   ExerciseNotice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode businessCenter */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_BusinessCenter (pctxt, &pvalue->businessCenter, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode exerciseNoticePartyReference */

   if (pvalue->m.exerciseNoticePartyReferencePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_PartyReference (pctxt, &pvalue->exerciseNoticePartyReference, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode partyReference */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_PartyReference (pctxt, &pvalue->partyReference, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ExerciseNotice (OSCTXT* pctxt, ExerciseNotice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode partyReference */

   stat = XmlEnc_PartyReference (pctxt, &pvalue->partyReference
      , OSUTF8("partyReference"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode exerciseNoticePartyReference */

   if (pvalue->m.exerciseNoticePartyReferencePresent) {
      stat = XmlEnc_PartyReference (pctxt, &pvalue->
         exerciseNoticePartyReference
         , OSUTF8("exerciseNoticePartyReference"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode businessCenter */

   stat = XmlEnc_BusinessCenter (pctxt, &pvalue->businessCenter
      , OSUTF8("businessCenter"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EarlyTerminationEvent                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EarlyTerminationEvent (OSCTXT* pctxt,
   EarlyTerminationEvent *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode adjustedExerciseFeePaymentDate */

   if (pvalue->m.adjustedExerciseFeePaymentDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         xe_charstr (pctxt, pvalue->adjustedExerciseFeePaymentDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode adjustedCashSettlementPaymentDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
      xe_charstr (pctxt, pvalue->adjustedCashSettlementPaymentDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode adjustedCashSettlementValuationDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
      xe_charstr (pctxt, pvalue->adjustedCashSettlementValuationDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode adjustedEarlyTerminationDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_charstr (pctxt, pvalue->adjustedEarlyTerminationDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode adjustedExerciseDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_charstr (pctxt, pvalue->adjustedExerciseDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EarlyTerminationEvent (OSCTXT* pctxt, 
   EarlyTerminationEvent* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode adjustedExerciseDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
      adjustedExerciseDate, OSUTF8("adjustedExerciseDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode adjustedEarlyTerminationDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
      adjustedEarlyTerminationDate
      , OSUTF8("adjustedEarlyTerminationDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode adjustedCashSettlementValuationDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
      adjustedCashSettlementValuationDate
      , OSUTF8("adjustedCashSettlementValuationDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode adjustedCashSettlementPaymentDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
      adjustedCashSettlementPaymentDate
      , OSUTF8("adjustedCashSettlementPaymentDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode adjustedExerciseFeePaymentDate */

   if (pvalue->m.adjustedExerciseFeePaymentDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         adjustedExerciseFeePaymentDate
         , OSUTF8("adjustedExerciseFeePaymentDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  OptionalEarlyTerminationAdjustedDates                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_OptionalEarlyTerminationAdjustedDates (OSCTXT* pctxt,
   OptionalEarlyTerminationAdjustedDates *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "OptionalEarlyTerminationAdjustedDates.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_EarlyTerminationEvent (pctxt, ((EarlyTerminationEvent*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_OptionalEarlyTerminationAdjustedDates (OSCTXT* pctxt, 
   OptionalEarlyTerminationAdjustedDates* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "OptionalEarlyTerminationAdjustedDates.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_EarlyTerminationEvent (pctxt, 
         ((EarlyTerminationEvent*)pnode->data)
         , OSUTF8("earlyTerminationEvent"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  OptionalEarlyTermination                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_OptionalEarlyTermination (OSCTXT* pctxt,
   OptionalEarlyTermination *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode optionalEarlyTerminationAdjustedDates */

   if (pvalue->m.optionalEarlyTerminationAdjustedDatesPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_OptionalEarlyTerminationAdjustedDates (pctxt, &pvalue->optionalEarlyTerminationAdjustedDates, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode cashSettlement */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_CashSettlement (pctxt, &pvalue->cashSettlement, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode calculationAgent */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_CalculationAgent (pctxt, &pvalue->calculationAgent, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode followUpConfirmation */

   if (pvalue->m.followUpConfirmationPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_boolean (pctxt, &pvalue->followUpConfirmation, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode exerciseNotice_list */

   pnode2 = pvalue->exerciseNotice_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ExerciseNotice (pctxt, ((ExerciseNotice*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode exercise */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Exercise_group (pctxt, &pvalue->exercise, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode singlePartyOption */

   if (pvalue->m.singlePartyOptionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_SinglePartyOption (pctxt, &pvalue->singlePartyOption, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_OptionalEarlyTermination (OSCTXT* pctxt, 
   OptionalEarlyTermination* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode singlePartyOption */

   if (pvalue->m.singlePartyOptionPresent) {
      stat = XmlEnc_SinglePartyOption (pctxt, &pvalue->singlePartyOption
         , OSUTF8("singlePartyOption"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode exercise */

   stat = XmlEnc_Exercise_group (pctxt, &pvalue->exercise
      , OSUTF8(""), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode exerciseNotice_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->exerciseNotice_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ExerciseNotice (pctxt, ((ExerciseNotice*)pnode->data)
         , OSUTF8("exerciseNotice"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode followUpConfirmation */

   if (pvalue->m.followUpConfirmationPresent) {
      stat = rtXmlEncBool (pctxt, pvalue->followUpConfirmation
         , OSUTF8("followUpConfirmation"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode calculationAgent */

   stat = XmlEnc_CalculationAgent (pctxt, &pvalue->calculationAgent
      , OSUTF8("calculationAgent"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cashSettlement */

   stat = XmlEnc_CashSettlement (pctxt, &pvalue->cashSettlement
      , OSUTF8("cashSettlement"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode optionalEarlyTerminationAdjustedDates */

   if (pvalue->m.optionalEarlyTerminationAdjustedDatesPresent) {
      stat = XmlEnc_OptionalEarlyTerminationAdjustedDates (pctxt, &pvalue->
         optionalEarlyTerminationAdjustedDates
         , OSUTF8("optionalEarlyTerminationAdjustedDates"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EarlyTerminationProvision_choice                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EarlyTerminationProvision_choice (OSCTXT* pctxt,
   EarlyTerminationProvision_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_MandatoryEarlyTermination (pctxt, pvalue->u.mandatoryEarlyTermination, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_OptionalEarlyTermination (pctxt, pvalue->u.optionalEarlyTermination, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EarlyTerminationProvision_choice (OSCTXT* pctxt, 
   EarlyTerminationProvision_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode mandatoryEarlyTermination */

         stat = XmlEnc_MandatoryEarlyTermination (pctxt, pvalue->
            u.mandatoryEarlyTermination
            , OSUTF8("mandatoryEarlyTermination"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode optionalEarlyTermination */

         stat = XmlEnc_OptionalEarlyTermination (pctxt, pvalue->
            u.optionalEarlyTermination
            , OSUTF8("optionalEarlyTermination"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EarlyTerminationProvision                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EarlyTerminationProvision (OSCTXT* pctxt,
   EarlyTerminationProvision *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_EarlyTerminationProvision_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EarlyTerminationProvision (OSCTXT* pctxt, 
   EarlyTerminationProvision* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode choice */

   stat = XmlEnc_EarlyTerminationProvision_choice (pctxt, &pvalue->choice
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CancellationEvent                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CancellationEvent (OSCTXT* pctxt,
   CancellationEvent *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode adjustedEarlyTerminationDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_charstr (pctxt, pvalue->adjustedEarlyTerminationDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode adjustedExerciseDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_charstr (pctxt, pvalue->adjustedExerciseDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CancellationEvent (OSCTXT* pctxt, CancellationEvent* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode adjustedExerciseDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
      adjustedExerciseDate, OSUTF8("adjustedExerciseDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode adjustedEarlyTerminationDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
      adjustedEarlyTerminationDate
      , OSUTF8("adjustedEarlyTerminationDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CancelableProvisionAdjustedDates                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CancelableProvisionAdjustedDates (OSCTXT* pctxt,
   CancelableProvisionAdjustedDates *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "CancelableProvisionAdjustedDates.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_CancellationEvent (pctxt, ((CancellationEvent*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CancelableProvisionAdjustedDates (OSCTXT* pctxt, 
   CancelableProvisionAdjustedDates* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "CancelableProvisionAdjustedDates.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_CancellationEvent (pctxt, ((CancellationEvent*)pnode->data)
         , OSUTF8("cancellationEvent"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CancelableProvision                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CancelableProvision (OSCTXT* pctxt,
   CancelableProvision *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode cancelableProvisionAdjustedDates */

   if (pvalue->m.cancelableProvisionAdjustedDatesPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_CancelableProvisionAdjustedDates (pctxt, &pvalue->cancelableProvisionAdjustedDates, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode followUpConfirmation */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
      xe_boolean (pctxt, &pvalue->followUpConfirmation, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode exerciseNotice */

   if (pvalue->m.exerciseNoticePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_ExerciseNotice (pctxt, &pvalue->exerciseNotice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode exercise */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Exercise_group (pctxt, &pvalue->exercise, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode buyerSeller_model */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_BuyerSeller_model (pctxt, &pvalue->buyerSeller_model, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CancelableProvision (OSCTXT* pctxt, CancelableProvision* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode buyerSeller_model */

   stat = XmlEnc_BuyerSeller_model (pctxt, &pvalue->buyerSeller_model
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode exercise */

   stat = XmlEnc_Exercise_group (pctxt, &pvalue->exercise
      , OSUTF8(""), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode exerciseNotice */

   if (pvalue->m.exerciseNoticePresent) {
      stat = XmlEnc_ExerciseNotice (pctxt, &pvalue->exerciseNotice
         , OSUTF8("exerciseNotice"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode followUpConfirmation */

   stat = rtXmlEncBool (pctxt, pvalue->followUpConfirmation
      , OSUTF8("followUpConfirmation"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cancelableProvisionAdjustedDates */

   if (pvalue->m.cancelableProvisionAdjustedDatesPresent) {
      stat = XmlEnc_CancelableProvisionAdjustedDates (pctxt, &pvalue->
         cancelableProvisionAdjustedDates
         , OSUTF8("cancelableProvisionAdjustedDates"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExtensionEvent                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExtensionEvent (OSCTXT* pctxt,
   ExtensionEvent *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode adjustedExtendedTerminationDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_charstr (pctxt, pvalue->adjustedExtendedTerminationDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode adjustedExerciseDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_charstr (pctxt, pvalue->adjustedExerciseDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ExtensionEvent (OSCTXT* pctxt, ExtensionEvent* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode adjustedExerciseDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
      adjustedExerciseDate, OSUTF8("adjustedExerciseDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode adjustedExtendedTerminationDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
      adjustedExtendedTerminationDate
      , OSUTF8("adjustedExtendedTerminationDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExtendibleProvisionAdjustedDates                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExtendibleProvisionAdjustedDates (OSCTXT* pctxt,
   ExtendibleProvisionAdjustedDates *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ExtendibleProvisionAdjustedDates.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_ExtensionEvent (pctxt, ((ExtensionEvent*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ExtendibleProvisionAdjustedDates (OSCTXT* pctxt, 
   ExtendibleProvisionAdjustedDates* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ExtendibleProvisionAdjustedDates.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_ExtensionEvent (pctxt, ((ExtensionEvent*)pnode->data)
         , OSUTF8("extensionEvent"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExtendibleProvision                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExtendibleProvision (OSCTXT* pctxt,
   ExtendibleProvision *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode extendibleProvisionAdjustedDates */

   if (pvalue->m.extendibleProvisionAdjustedDatesPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_ExtendibleProvisionAdjustedDates (pctxt, &pvalue->extendibleProvisionAdjustedDates, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode followUpConfirmation */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
      xe_boolean (pctxt, &pvalue->followUpConfirmation, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode exerciseNotice */

   if (pvalue->m.exerciseNoticePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_ExerciseNotice (pctxt, &pvalue->exerciseNotice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode exercise */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Exercise_group (pctxt, &pvalue->exercise, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode buyerSeller_model */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_BuyerSeller_model (pctxt, &pvalue->buyerSeller_model, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ExtendibleProvision (OSCTXT* pctxt, ExtendibleProvision* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode buyerSeller_model */

   stat = XmlEnc_BuyerSeller_model (pctxt, &pvalue->buyerSeller_model
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode exercise */

   stat = XmlEnc_Exercise_group (pctxt, &pvalue->exercise
      , OSUTF8(""), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode exerciseNotice */

   if (pvalue->m.exerciseNoticePresent) {
      stat = XmlEnc_ExerciseNotice (pctxt, &pvalue->exerciseNotice
         , OSUTF8("exerciseNotice"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode followUpConfirmation */

   stat = rtXmlEncBool (pctxt, pvalue->followUpConfirmation
      , OSUTF8("followUpConfirmation"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode extendibleProvisionAdjustedDates */

   if (pvalue->m.extendibleProvisionAdjustedDatesPresent) {
      stat = XmlEnc_ExtendibleProvisionAdjustedDates (pctxt, &pvalue->
         extendibleProvisionAdjustedDates
         , OSUTF8("extendibleProvisionAdjustedDates"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Swap                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Swap (OSCTXT* pctxt,
   Swap *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode additionalPayment_list */

   pnode2 = pvalue->additionalPayment_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Payment (pctxt, ((Payment*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode extendibleProvision */

   if (pvalue->m.extendibleProvisionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_ExtendibleProvision (pctxt, &pvalue->extendibleProvision, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode cancelableProvision */

   if (pvalue->m.cancelableProvisionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_CancelableProvision (pctxt, &pvalue->cancelableProvision, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode earlyTerminationProvision */

   if (pvalue->m.earlyTerminationProvisionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_EarlyTerminationProvision (pctxt, &pvalue->earlyTerminationProvision, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode swapStream_list */

   if (!(pvalue->swapStream_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Swap.swapStream_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->swapStream_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->swapStream_list.tail;
   while (0 != pnode2) {
      ll = asn1E_InterestRateStream (pctxt, ((InterestRateStream*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode productId_list */

   pnode2 = pvalue->productId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ProductId (pctxt, ((ProductId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ProductType (pctxt, &pvalue->productType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Swap (OSCTXT* pctxt, Swap* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      stat = XmlEnc_ProductType (pctxt, &pvalue->productType
         , OSUTF8("productType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode productId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->productId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ProductId (pctxt, ((ProductId*)pnode->data)
         , OSUTF8("productId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode swapStream_list */

   if (!(pvalue->swapStream_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Swap.swapStream_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->swapStream_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->swapStream_list.head;
   while (0 != pnode) {
      stat = XmlEnc_InterestRateStream (pctxt, 
         ((InterestRateStream*)pnode->data), OSUTF8("swapStream"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode earlyTerminationProvision */

   if (pvalue->m.earlyTerminationProvisionPresent) {
      stat = XmlEnc_EarlyTerminationProvision (pctxt, &pvalue->
         earlyTerminationProvision
         , OSUTF8("earlyTerminationProvision"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode cancelableProvision */

   if (pvalue->m.cancelableProvisionPresent) {
      stat = XmlEnc_CancelableProvision (pctxt, &pvalue->cancelableProvision
         , OSUTF8("cancelableProvision"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode extendibleProvision */

   if (pvalue->m.extendibleProvisionPresent) {
      stat = XmlEnc_ExtendibleProvision (pctxt, &pvalue->extendibleProvision
         , OSUTF8("extendibleProvision"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode additionalPayment_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->additionalPayment_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Payment (pctxt, ((Payment*)pnode->data)
         , OSUTF8("additionalPayment"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ManualExercise                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ManualExercise (OSCTXT* pctxt,
   ManualExercise *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode fallbackExercise */

   if (pvalue->m.fallbackExercisePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_boolean (pctxt, &pvalue->fallbackExercise, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode exerciseNotice */

   if (pvalue->m.exerciseNoticePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ExerciseNotice (pctxt, &pvalue->exerciseNotice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ManualExercise (OSCTXT* pctxt, ManualExercise* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode exerciseNotice */

   if (pvalue->m.exerciseNoticePresent) {
      stat = XmlEnc_ExerciseNotice (pctxt, &pvalue->exerciseNotice
         , OSUTF8("exerciseNotice"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fallbackExercise */

   if (pvalue->m.fallbackExercisePresent) {
      stat = rtXmlEncBool (pctxt, pvalue->fallbackExercise
         , OSUTF8("fallbackExercise"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AutomaticExercise                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AutomaticExercise (OSCTXT* pctxt,
   AutomaticExercise *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_real (pctxt, pvalue, ASN1IMPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0, ll);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   if (tagging == ASN1EXPL) {
      ll = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
   }
   ll0 += ll;

   return (ll0);
}

int XmlEnc_AutomaticExercise (OSCTXT* pctxt, AutomaticExercise value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   stat = rtXmlEncDouble (pctxt, value, OSUTF8("thresholdRate"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExerciseProcedure_choice                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExerciseProcedure_choice (OSCTXT* pctxt,
   ExerciseProcedure_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_ManualExercise (pctxt, pvalue->u.manualExercise, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_AutomaticExercise (pctxt, &pvalue->u.automaticExercise, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_ExerciseProcedure_choice (OSCTXT* pctxt, 
   ExerciseProcedure_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode manualExercise */

         stat = XmlEnc_ManualExercise (pctxt, pvalue->u.manualExercise
            , OSUTF8("manualExercise"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode automaticExercise */

         stat = XmlEnc_AutomaticExercise (pctxt, pvalue->u.automaticExercise
            , OSUTF8("automaticExercise"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExerciseProcedure                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExerciseProcedure (OSCTXT* pctxt,
   ExerciseProcedure *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode followUpConfirmation */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_boolean (pctxt, &pvalue->followUpConfirmation, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_ExerciseProcedure_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ExerciseProcedure (OSCTXT* pctxt, ExerciseProcedure* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode choice */

   stat = XmlEnc_ExerciseProcedure_choice (pctxt, &pvalue->choice
      , OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode followUpConfirmation */

   stat = rtXmlEncBool (pctxt, pvalue->followUpConfirmation
      , OSUTF8("followUpConfirmation"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExerciseEvent                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExerciseEvent (OSCTXT* pctxt,
   ExerciseEvent *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode adjustedExerciseFeePaymentDate */

   if (pvalue->m.adjustedExerciseFeePaymentDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         xe_charstr (pctxt, pvalue->adjustedExerciseFeePaymentDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode adjustedCashSettlementPaymentDate */

   if (pvalue->m.adjustedCashSettlementPaymentDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_charstr (pctxt, pvalue->adjustedCashSettlementPaymentDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode adjustedCashSettlementValuationDate */

   if (pvalue->m.adjustedCashSettlementValuationDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_charstr (pctxt, pvalue->adjustedCashSettlementValuationDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode adjustedRelevantSwapEffectiveDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_charstr (pctxt, pvalue->adjustedRelevantSwapEffectiveDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode adjustedExerciseDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_charstr (pctxt, pvalue->adjustedExerciseDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ExerciseEvent (OSCTXT* pctxt, ExerciseEvent* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode adjustedExerciseDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
      adjustedExerciseDate, OSUTF8("adjustedExerciseDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode adjustedRelevantSwapEffectiveDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
      adjustedRelevantSwapEffectiveDate
      , OSUTF8("adjustedRelevantSwapEffectiveDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode adjustedCashSettlementValuationDate */

   if (pvalue->m.adjustedCashSettlementValuationDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         adjustedCashSettlementValuationDate
         , OSUTF8("adjustedCashSettlementValuationDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode adjustedCashSettlementPaymentDate */

   if (pvalue->m.adjustedCashSettlementPaymentDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         adjustedCashSettlementPaymentDate
         , OSUTF8("adjustedCashSettlementPaymentDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode adjustedExerciseFeePaymentDate */

   if (pvalue->m.adjustedExerciseFeePaymentDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         adjustedExerciseFeePaymentDate
         , OSUTF8("adjustedExerciseFeePaymentDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SwaptionAdjustedDates                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SwaptionAdjustedDates (OSCTXT* pctxt,
   SwaptionAdjustedDates *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SwaptionAdjustedDates.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_ExerciseEvent (pctxt, ((ExerciseEvent*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SwaptionAdjustedDates (OSCTXT* pctxt, 
   SwaptionAdjustedDates* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SwaptionAdjustedDates.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_ExerciseEvent (pctxt, ((ExerciseEvent*)pnode->data)
         , OSUTF8("exerciseEvent"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Swaption                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Swaption (OSCTXT* pctxt,
   Swaption *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode swap */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|11,
      asn1E_Swap (pctxt, &pvalue->swap, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode swaptionAdjustedDates */

   if (pvalue->m.swaptionAdjustedDatesPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10,
         asn1E_SwaptionAdjustedDates (pctxt, &pvalue->swaptionAdjustedDates, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode swaptionStraddle */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|9,
      xe_boolean (pctxt, &pvalue->swaptionStraddle, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode cashSettlement */

   if (pvalue->m.cashSettlementPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_CashSettlement (pctxt, &pvalue->cashSettlement, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode calculationAgentPartyReference_list */

   if (!(pvalue->calculationAgentPartyReference_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Swaption.calculationAgentPartyReference_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->calculationAgentPartyReference_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->calculationAgentPartyReference_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PartyReference (pctxt, ((PartyReference*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode exerciseProcedure */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_ExerciseProcedure (pctxt, &pvalue->exerciseProcedure, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode exercise */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_Exercise_group (pctxt, &pvalue->exercise, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode premium_list */

   pnode2 = pvalue->premium_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Payment (pctxt, ((Payment*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode buyerSeller_model */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_BuyerSeller_model (pctxt, &pvalue->buyerSeller_model, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode productId_list */

   pnode2 = pvalue->productId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ProductId (pctxt, ((ProductId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ProductType (pctxt, &pvalue->productType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Swaption (OSCTXT* pctxt, Swaption* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      stat = XmlEnc_ProductType (pctxt, &pvalue->productType
         , OSUTF8("productType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode productId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->productId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ProductId (pctxt, ((ProductId*)pnode->data)
         , OSUTF8("productId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode buyerSeller_model */

   stat = XmlEnc_BuyerSeller_model (pctxt, &pvalue->buyerSeller_model
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode premium_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->premium_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Payment (pctxt, ((Payment*)pnode->data)
         , OSUTF8("premium"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode exercise */

   stat = XmlEnc_Exercise_group (pctxt, &pvalue->exercise
      , OSUTF8(""), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode exerciseProcedure */

   stat = XmlEnc_ExerciseProcedure (pctxt, &pvalue->exerciseProcedure
      , OSUTF8("exerciseProcedure"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode calculationAgentPartyReference_list */

   if (!(pvalue->calculationAgentPartyReference_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Swaption.calculationAgentPartyReference_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->calculationAgentPartyReference_list
         .count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->calculationAgentPartyReference_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PartyReference (pctxt, ((PartyReference*)pnode->data)
         , OSUTF8("calculationAgentPartyReference"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode cashSettlement */

   if (pvalue->m.cashSettlementPresent) {
      stat = XmlEnc_CashSettlement (pctxt, &pvalue->cashSettlement
         , OSUTF8("cashSettlement"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode swaptionStraddle */

   stat = rtXmlEncBool (pctxt, pvalue->swaptionStraddle
      , OSUTF8("swaptionStraddle"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode swaptionAdjustedDates */

   if (pvalue->m.swaptionAdjustedDatesPresent) {
      stat = XmlEnc_SwaptionAdjustedDates (pctxt, &pvalue->
         swaptionAdjustedDates, OSUTF8("swaptionAdjustedDates"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode swap */

   stat = XmlEnc_Swap (pctxt, &pvalue->swap, OSUTF8("swap"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  OptionTypeEnum                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_OptionTypeEnum (OSCTXT* pctxt,
   OptionTypeEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_OptionTypeEnum (OSCTXT* pctxt, OptionTypeEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      OptionTypeEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InstrumentId                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_InstrumentId (OSCTXT* pctxt,
   InstrumentId *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode instrumentIdScheme */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->instrumentIdScheme, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_InstrumentId (OSCTXT* pctxt, InstrumentId* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" instrumentIdScheme=\""), 21);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->instrumentIdScheme, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExchangeId                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExchangeId (OSCTXT* pctxt,
   ExchangeId *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode exchangeIdScheme */

   if (pvalue->m.exchangeIdSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->exchangeIdScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ExchangeId (OSCTXT* pctxt, ExchangeId* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.exchangeIdSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" exchangeIdScheme=\""), 19);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->exchangeIdScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ClearanceSystem                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ClearanceSystem (OSCTXT* pctxt,
   ClearanceSystem *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode clearanceSystemIdScheme */

   if (pvalue->m.clearanceSystemIdSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->clearanceSystemIdScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ClearanceSystem (OSCTXT* pctxt, ClearanceSystem* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.clearanceSystemIdSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" clearanceSystemIdScheme=\""), 26);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->clearanceSystemIdScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Bond                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Bond (OSCTXT* pctxt,
   Bond *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode faceAmount */

   if (pvalue->m.faceAmountPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|10,
         xe_real (pctxt, &pvalue->faceAmount, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode parValue */

   if (pvalue->m.parValuePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|9,
         xe_real (pctxt, &pvalue->parValue, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode maturity */

   if (pvalue->m.maturityPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|8,
         xe_charstr (pctxt, pvalue->maturity, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode couponRate */

   if (pvalue->m.couponRatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
         xe_real (pctxt, &pvalue->couponRate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode issuerName */

   if (pvalue->m.issuerNamePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
         xe_utf8str (pctxt, pvalue->issuerName, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode relatedExchangeId */

   if (pvalue->m.relatedExchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_ExchangeId (pctxt, &pvalue->relatedExchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_ClearanceSystem (pctxt, &pvalue->clearanceSystem, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_ExchangeId (pctxt, &pvalue->exchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Currency (pctxt, &pvalue->currency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode description */

   if (pvalue->m.descriptionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->description, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Bond.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->instrumentId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_InstrumentId (pctxt, ((InstrumentId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Bond (OSCTXT* pctxt, Bond* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Bond.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->instrumentId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_InstrumentId (pctxt, ((InstrumentId*)pnode->data)
         , OSUTF8("instrumentId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode description */

   if (pvalue->m.descriptionPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->description
         , OSUTF8("description"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      stat = XmlEnc_Currency (pctxt, &pvalue->currency
         , OSUTF8("currency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->exchangeId
         , OSUTF8("exchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      stat = XmlEnc_ClearanceSystem (pctxt, &pvalue->clearanceSystem
         , OSUTF8("clearanceSystem"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode relatedExchangeId */

   if (pvalue->m.relatedExchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->relatedExchangeId
         , OSUTF8("relatedExchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode issuerName */

   if (pvalue->m.issuerNamePresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->issuerName
         , OSUTF8("issuerName"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode couponRate */

   if (pvalue->m.couponRatePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->couponRate
         , OSUTF8("couponRate"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode maturity */

   if (pvalue->m.maturityPresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->maturity
         , OSUTF8("maturity"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode parValue */

   if (pvalue->m.parValuePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->parValue
         , OSUTF8("parValue"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode faceAmount */

   if (pvalue->m.faceAmountPresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->faceAmount
         , OSUTF8("faceAmount"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnderlyingAsset_1                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_UnderlyingAsset_1 (OSCTXT* pctxt,
   UnderlyingAsset_1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_ClearanceSystem (pctxt, &pvalue->clearanceSystem, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_ExchangeId (pctxt, &pvalue->exchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Currency (pctxt, &pvalue->currency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode description */

   if (pvalue->m.descriptionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->description, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "UnderlyingAsset_1.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->instrumentId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_InstrumentId (pctxt, ((InstrumentId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_UnderlyingAsset_1 (OSCTXT* pctxt, UnderlyingAsset_1* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "UnderlyingAsset_1.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->instrumentId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_InstrumentId (pctxt, ((InstrumentId*)pnode->data)
         , OSUTF8("instrumentId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode description */

   if (pvalue->m.descriptionPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->description
         , OSUTF8("description"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      stat = XmlEnc_Currency (pctxt, &pvalue->currency
         , OSUTF8("currency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->exchangeId
         , OSUTF8("exchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      stat = XmlEnc_ClearanceSystem (pctxt, &pvalue->clearanceSystem
         , OSUTF8("clearanceSystem"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnderlyingAsset_derivations_bond                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_UnderlyingAsset_derivations_bond (OSCTXT* pctxt,
   UnderlyingAsset_derivations_bond *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode faceAmount */

   if (pvalue->m.faceAmountPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|10,
         xe_real (pctxt, &pvalue->faceAmount, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode parValue */

   if (pvalue->m.parValuePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|9,
         xe_real (pctxt, &pvalue->parValue, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode maturity */

   if (pvalue->m.maturityPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|8,
         xe_charstr (pctxt, pvalue->maturity, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode couponRate */

   if (pvalue->m.couponRatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
         xe_real (pctxt, &pvalue->couponRate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode issuerName */

   if (pvalue->m.issuerNamePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
         xe_utf8str (pctxt, pvalue->issuerName, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode relatedExchangeId */

   if (pvalue->m.relatedExchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_ExchangeId (pctxt, &pvalue->relatedExchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_ClearanceSystem (pctxt, &pvalue->clearanceSystem, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_ExchangeId (pctxt, &pvalue->exchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Currency (pctxt, &pvalue->currency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode description */

   if (pvalue->m.descriptionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->description, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "UnderlyingAsset_derivations_bond.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->instrumentId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_InstrumentId (pctxt, ((InstrumentId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_UnderlyingAsset_derivations_bond (OSCTXT* pctxt, 
   UnderlyingAsset_derivations_bond* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "UnderlyingAsset_derivations_bond.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->instrumentId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_InstrumentId (pctxt, ((InstrumentId*)pnode->data)
         , OSUTF8("instrumentId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode description */

   if (pvalue->m.descriptionPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->description
         , OSUTF8("description"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      stat = XmlEnc_Currency (pctxt, &pvalue->currency
         , OSUTF8("currency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->exchangeId
         , OSUTF8("exchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      stat = XmlEnc_ClearanceSystem (pctxt, &pvalue->clearanceSystem
         , OSUTF8("clearanceSystem"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode relatedExchangeId */

   if (pvalue->m.relatedExchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->relatedExchangeId
         , OSUTF8("relatedExchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode issuerName */

   if (pvalue->m.issuerNamePresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->issuerName
         , OSUTF8("issuerName"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode couponRate */

   if (pvalue->m.couponRatePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->couponRate
         , OSUTF8("couponRate"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode maturity */

   if (pvalue->m.maturityPresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->maturity
         , OSUTF8("maturity"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode parValue */

   if (pvalue->m.parValuePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->parValue
         , OSUTF8("parValue"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode faceAmount */

   if (pvalue->m.faceAmountPresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->faceAmount
         , OSUTF8("faceAmount"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnderlyingAsset_derivations_convertibleBond               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_UnderlyingAsset_derivations_convertibleBond (OSCTXT* pctxt,
   UnderlyingAsset_derivations_convertibleBond *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode underlyingEquity */

   if (pvalue->underlyingEquity == NULL) {
      rtxErrAddStrParm (pctxt, "pvalue->underlyingEquity");
      return LOG_RTERR (pctxt, RTERR_NULLPTR);
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|11,
      asn1E_UnderlyingAsset_derivations (pctxt, (UnderlyingAsset_derivations*)pvalue->underlyingEquity, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode faceAmount */

   if (pvalue->m.faceAmountPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|10,
         xe_real (pctxt, &pvalue->faceAmount, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode parValue */

   if (pvalue->m.parValuePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|9,
         xe_real (pctxt, &pvalue->parValue, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode maturity */

   if (pvalue->m.maturityPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|8,
         xe_charstr (pctxt, pvalue->maturity, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode couponRate */

   if (pvalue->m.couponRatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
         xe_real (pctxt, &pvalue->couponRate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode issuerName */

   if (pvalue->m.issuerNamePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
         xe_utf8str (pctxt, pvalue->issuerName, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode relatedExchangeId_list */

   pnode2 = pvalue->relatedExchangeId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ExchangeId (pctxt, ((ExchangeId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_ClearanceSystem (pctxt, &pvalue->clearanceSystem, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_ExchangeId (pctxt, &pvalue->exchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Currency (pctxt, &pvalue->currency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode description */

   if (pvalue->m.descriptionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->description, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "UnderlyingAsset_derivations_convertibleBond.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->instrumentId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_InstrumentId (pctxt, ((InstrumentId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_UnderlyingAsset_derivations_convertibleBond (OSCTXT* pctxt, 
   UnderlyingAsset_derivations_convertibleBond* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "UnderlyingAsset_derivations_convertibleBond.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->instrumentId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_InstrumentId (pctxt, ((InstrumentId*)pnode->data)
         , OSUTF8("instrumentId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode description */

   if (pvalue->m.descriptionPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->description
         , OSUTF8("description"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      stat = XmlEnc_Currency (pctxt, &pvalue->currency
         , OSUTF8("currency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->exchangeId
         , OSUTF8("exchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      stat = XmlEnc_ClearanceSystem (pctxt, &pvalue->clearanceSystem
         , OSUTF8("clearanceSystem"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode relatedExchangeId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->relatedExchangeId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ExchangeId (pctxt, ((ExchangeId*)pnode->data)
         , OSUTF8("relatedExchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode issuerName */

   if (pvalue->m.issuerNamePresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->issuerName
         , OSUTF8("issuerName"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode couponRate */

   if (pvalue->m.couponRatePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->couponRate
         , OSUTF8("couponRate"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode maturity */

   if (pvalue->m.maturityPresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->maturity
         , OSUTF8("maturity"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode parValue */

   if (pvalue->m.parValuePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->parValue
         , OSUTF8("parValue"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode faceAmount */

   if (pvalue->m.faceAmountPresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->faceAmount
         , OSUTF8("faceAmount"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode underlyingEquity */

   stat = XmlEnc_UnderlyingAsset_derivations (pctxt, pvalue->underlyingEquity
      , OSUTF8("underlyingEquity"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnderlyingAsset_derivations_equity                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_UnderlyingAsset_derivations_equity (OSCTXT* pctxt,
   UnderlyingAsset_derivations_equity *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode optionsExchangeId */

   if (pvalue->m.optionsExchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_ExchangeId (pctxt, &pvalue->optionsExchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode relatedExchangeId_list */

   pnode2 = pvalue->relatedExchangeId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ExchangeId (pctxt, ((ExchangeId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_ClearanceSystem (pctxt, &pvalue->clearanceSystem, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_ExchangeId (pctxt, &pvalue->exchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Currency (pctxt, &pvalue->currency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode description */

   if (pvalue->m.descriptionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->description, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "UnderlyingAsset_derivations_equity.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->instrumentId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_InstrumentId (pctxt, ((InstrumentId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_UnderlyingAsset_derivations_equity (OSCTXT* pctxt, 
   UnderlyingAsset_derivations_equity* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "UnderlyingAsset_derivations_equity.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->instrumentId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_InstrumentId (pctxt, ((InstrumentId*)pnode->data)
         , OSUTF8("instrumentId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode description */

   if (pvalue->m.descriptionPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->description
         , OSUTF8("description"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      stat = XmlEnc_Currency (pctxt, &pvalue->currency
         , OSUTF8("currency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->exchangeId
         , OSUTF8("exchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      stat = XmlEnc_ClearanceSystem (pctxt, &pvalue->clearanceSystem
         , OSUTF8("clearanceSystem"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode relatedExchangeId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->relatedExchangeId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ExchangeId (pctxt, ((ExchangeId*)pnode->data)
         , OSUTF8("relatedExchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode optionsExchangeId */

   if (pvalue->m.optionsExchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->optionsExchangeId
         , OSUTF8("optionsExchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnderlyingAsset_derivations_exchangeTradedFund            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_UnderlyingAsset_derivations_exchangeTradedFund (OSCTXT* pctxt,
   UnderlyingAsset_derivations_exchangeTradedFund *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode fundManager */

   if (pvalue->m.fundManagerPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
         xe_utf8str (pctxt, pvalue->fundManager, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode optionsExchangeId */

   if (pvalue->m.optionsExchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_ExchangeId (pctxt, &pvalue->optionsExchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode relatedExchangeId */

   if (pvalue->m.relatedExchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_ExchangeId (pctxt, &pvalue->relatedExchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_ClearanceSystem (pctxt, &pvalue->clearanceSystem, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_ExchangeId (pctxt, &pvalue->exchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Currency (pctxt, &pvalue->currency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode description */

   if (pvalue->m.descriptionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->description, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "UnderlyingAsset_derivations_exchangeTradedFund.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->instrumentId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_InstrumentId (pctxt, ((InstrumentId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_UnderlyingAsset_derivations_exchangeTradedFund (OSCTXT* pctxt, 
   UnderlyingAsset_derivations_exchangeTradedFund* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "UnderlyingAsset_derivations_exchangeTradedFund.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->instrumentId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_InstrumentId (pctxt, ((InstrumentId*)pnode->data)
         , OSUTF8("instrumentId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode description */

   if (pvalue->m.descriptionPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->description
         , OSUTF8("description"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      stat = XmlEnc_Currency (pctxt, &pvalue->currency
         , OSUTF8("currency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->exchangeId
         , OSUTF8("exchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      stat = XmlEnc_ClearanceSystem (pctxt, &pvalue->clearanceSystem
         , OSUTF8("clearanceSystem"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode relatedExchangeId */

   if (pvalue->m.relatedExchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->relatedExchangeId
         , OSUTF8("relatedExchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode optionsExchangeId */

   if (pvalue->m.optionsExchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->optionsExchangeId
         , OSUTF8("optionsExchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fundManager */

   if (pvalue->m.fundManagerPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->fundManager
         , OSUTF8("fundManager"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnderlyingAsset_derivations_future                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_UnderlyingAsset_derivations_future (OSCTXT* pctxt,
   UnderlyingAsset_derivations_future *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode futureContractReference */

   if (pvalue->m.futureContractReferencePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|8,
         xe_utf8str (pctxt, pvalue->futureContractReference, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode multiplier */

   if (pvalue->m.multiplierPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
         xe_integer (pctxt, &pvalue->multiplier, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode optionsExchangeId */

   if (pvalue->m.optionsExchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_ExchangeId (pctxt, &pvalue->optionsExchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode relatedExchangeId */

   if (pvalue->m.relatedExchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_ExchangeId (pctxt, &pvalue->relatedExchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_ClearanceSystem (pctxt, &pvalue->clearanceSystem, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_ExchangeId (pctxt, &pvalue->exchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Currency (pctxt, &pvalue->currency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode description */

   if (pvalue->m.descriptionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->description, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "UnderlyingAsset_derivations_future.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->instrumentId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_InstrumentId (pctxt, ((InstrumentId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_UnderlyingAsset_derivations_future (OSCTXT* pctxt, 
   UnderlyingAsset_derivations_future* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "UnderlyingAsset_derivations_future.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->instrumentId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_InstrumentId (pctxt, ((InstrumentId*)pnode->data)
         , OSUTF8("instrumentId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode description */

   if (pvalue->m.descriptionPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->description
         , OSUTF8("description"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      stat = XmlEnc_Currency (pctxt, &pvalue->currency
         , OSUTF8("currency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->exchangeId
         , OSUTF8("exchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      stat = XmlEnc_ClearanceSystem (pctxt, &pvalue->clearanceSystem
         , OSUTF8("clearanceSystem"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode relatedExchangeId */

   if (pvalue->m.relatedExchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->relatedExchangeId
         , OSUTF8("relatedExchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode optionsExchangeId */

   if (pvalue->m.optionsExchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->optionsExchangeId
         , OSUTF8("optionsExchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode multiplier */

   if (pvalue->m.multiplierPresent) {
      stat = rtXmlEncInt (pctxt, pvalue->multiplier
         , OSUTF8("multiplier"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode futureContractReference */

   if (pvalue->m.futureContractReferencePresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->futureContractReference
         , OSUTF8("futureContractReference"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnderlyingAsset_derivations_index_futureId                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_UnderlyingAsset_derivations_index_futureId (OSCTXT* pctxt,
   UnderlyingAsset_derivations_index_futureId *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode futureIdScheme */

   if (pvalue->m.futureIdSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->futureIdScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_UnderlyingAsset_derivations_index_futureId (OSCTXT* pctxt, 
   UnderlyingAsset_derivations_index_futureId* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.futureIdSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" futureIdScheme=\""), 17);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->futureIdScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnderlyingAsset_derivations_index                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_UnderlyingAsset_derivations_index (OSCTXT* pctxt,
   UnderlyingAsset_derivations_index *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode futureId */

   if (pvalue->m.futureIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_UnderlyingAsset_derivations_index_futureId (pctxt, &pvalue->futureId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode relatedExchangeId_list */

   pnode2 = pvalue->relatedExchangeId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ExchangeId (pctxt, ((ExchangeId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_ClearanceSystem (pctxt, &pvalue->clearanceSystem, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_ExchangeId (pctxt, &pvalue->exchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Currency (pctxt, &pvalue->currency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode description */

   if (pvalue->m.descriptionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->description, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "UnderlyingAsset_derivations_index.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->instrumentId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_InstrumentId (pctxt, ((InstrumentId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_UnderlyingAsset_derivations_index (OSCTXT* pctxt, 
   UnderlyingAsset_derivations_index* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "UnderlyingAsset_derivations_index.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->instrumentId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_InstrumentId (pctxt, ((InstrumentId*)pnode->data)
         , OSUTF8("instrumentId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode description */

   if (pvalue->m.descriptionPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->description
         , OSUTF8("description"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      stat = XmlEnc_Currency (pctxt, &pvalue->currency
         , OSUTF8("currency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->exchangeId
         , OSUTF8("exchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      stat = XmlEnc_ClearanceSystem (pctxt, &pvalue->clearanceSystem
         , OSUTF8("clearanceSystem"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode relatedExchangeId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->relatedExchangeId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ExchangeId (pctxt, ((ExchangeId*)pnode->data)
         , OSUTF8("relatedExchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode futureId */

   if (pvalue->m.futureIdPresent) {
      stat = XmlEnc_UnderlyingAsset_derivations_index_futureId (pctxt, &pvalue
         ->futureId, OSUTF8("futureId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnderlyingAsset_derivations_mutualFund                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_UnderlyingAsset_derivations_mutualFund (OSCTXT* pctxt,
   UnderlyingAsset_derivations_mutualFund *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode fundManager */

   if (pvalue->m.fundManagerPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
         xe_utf8str (pctxt, pvalue->fundManager, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode openEndedFund */

   if (pvalue->m.openEndedFundPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         xe_boolean (pctxt, &pvalue->openEndedFund, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_ClearanceSystem (pctxt, &pvalue->clearanceSystem, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_ExchangeId (pctxt, &pvalue->exchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Currency (pctxt, &pvalue->currency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode description */

   if (pvalue->m.descriptionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->description, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "UnderlyingAsset_derivations_mutualFund.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->instrumentId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_InstrumentId (pctxt, ((InstrumentId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_UnderlyingAsset_derivations_mutualFund (OSCTXT* pctxt, 
   UnderlyingAsset_derivations_mutualFund* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "UnderlyingAsset_derivations_mutualFund.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->instrumentId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_InstrumentId (pctxt, ((InstrumentId*)pnode->data)
         , OSUTF8("instrumentId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode description */

   if (pvalue->m.descriptionPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->description
         , OSUTF8("description"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      stat = XmlEnc_Currency (pctxt, &pvalue->currency
         , OSUTF8("currency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->exchangeId
         , OSUTF8("exchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      stat = XmlEnc_ClearanceSystem (pctxt, &pvalue->clearanceSystem
         , OSUTF8("clearanceSystem"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode openEndedFund */

   if (pvalue->m.openEndedFundPresent) {
      stat = rtXmlEncBool (pctxt, pvalue->openEndedFund
         , OSUTF8("openEndedFund"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fundManager */

   if (pvalue->m.fundManagerPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->fundManager
         , OSUTF8("fundManager"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnderlyingAsset_derivations                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_UnderlyingAsset_derivations (OSCTXT* pctxt,
   UnderlyingAsset_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_UnderlyingAsset_1 (pctxt, pvalue->u.underlyingAsset, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_UnderlyingAsset_derivations_bond (pctxt, pvalue->u.bond, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_UnderlyingAsset_derivations_convertibleBond (pctxt, pvalue->u.convertibleBond, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 4:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
            asn1E_UnderlyingAsset_derivations_equity (pctxt, pvalue->u.equity, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 5:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
            asn1E_UnderlyingAsset_derivations_exchangeTradedFund (pctxt, pvalue->u.exchangeTradedFund, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 6:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
            asn1E_UnderlyingAsset_derivations_future (pctxt, pvalue->u.future, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 7:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
            asn1E_UnderlyingAsset_derivations_index (pctxt, pvalue->u.index, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 8:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
            asn1E_UnderlyingAsset_derivations_mutualFund (pctxt, pvalue->u.mutualFund, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_UnderlyingAsset_derivations (OSCTXT* pctxt, 
   UnderlyingAsset_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode underlyingAsset */

         stat = XmlEnc_UnderlyingAsset_1 (pctxt, pvalue->u.underlyingAsset
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode bond */

         stat = XmlEnc_UnderlyingAsset_derivations_bond (pctxt, pvalue->u.bond
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode convertibleBond */

         stat = XmlEnc_UnderlyingAsset_derivations_convertibleBond (pctxt, 
            pvalue->u.convertibleBond, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 4:
         /* encode equity */

         stat = XmlEnc_UnderlyingAsset_derivations_equity (pctxt, pvalue->
            u.equity, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 5:
         /* encode exchangeTradedFund */

         stat = XmlEnc_UnderlyingAsset_derivations_exchangeTradedFund (pctxt, 
            pvalue->u.exchangeTradedFund, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 6:
         /* encode future */

         stat = XmlEnc_UnderlyingAsset_derivations_future (pctxt, pvalue->
            u.future, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 7:
         /* encode index */

         stat = XmlEnc_UnderlyingAsset_derivations_index (pctxt, pvalue->
            u.index, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 8:
         /* encode mutualFund */

         stat = XmlEnc_UnderlyingAsset_derivations_mutualFund (pctxt, pvalue->
            u.mutualFund, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConvertibleBond                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ConvertibleBond (OSCTXT* pctxt,
   ConvertibleBond *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode underlyingEquity */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|11,
      asn1E_UnderlyingAsset_derivations (pctxt, &pvalue->underlyingEquity, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode faceAmount */

   if (pvalue->m.faceAmountPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|10,
         xe_real (pctxt, &pvalue->faceAmount, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode parValue */

   if (pvalue->m.parValuePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|9,
         xe_real (pctxt, &pvalue->parValue, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode maturity */

   if (pvalue->m.maturityPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|8,
         xe_charstr (pctxt, pvalue->maturity, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode couponRate */

   if (pvalue->m.couponRatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
         xe_real (pctxt, &pvalue->couponRate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode issuerName */

   if (pvalue->m.issuerNamePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
         xe_utf8str (pctxt, pvalue->issuerName, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode relatedExchangeId_list */

   pnode2 = pvalue->relatedExchangeId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ExchangeId (pctxt, ((ExchangeId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_ClearanceSystem (pctxt, &pvalue->clearanceSystem, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_ExchangeId (pctxt, &pvalue->exchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Currency (pctxt, &pvalue->currency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode description */

   if (pvalue->m.descriptionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->description, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ConvertibleBond.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->instrumentId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_InstrumentId (pctxt, ((InstrumentId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ConvertibleBond (OSCTXT* pctxt, ConvertibleBond* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ConvertibleBond.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->instrumentId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_InstrumentId (pctxt, ((InstrumentId*)pnode->data)
         , OSUTF8("instrumentId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode description */

   if (pvalue->m.descriptionPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->description
         , OSUTF8("description"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      stat = XmlEnc_Currency (pctxt, &pvalue->currency
         , OSUTF8("currency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->exchangeId
         , OSUTF8("exchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      stat = XmlEnc_ClearanceSystem (pctxt, &pvalue->clearanceSystem
         , OSUTF8("clearanceSystem"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode relatedExchangeId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->relatedExchangeId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ExchangeId (pctxt, ((ExchangeId*)pnode->data)
         , OSUTF8("relatedExchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode issuerName */

   if (pvalue->m.issuerNamePresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->issuerName
         , OSUTF8("issuerName"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode couponRate */

   if (pvalue->m.couponRatePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->couponRate
         , OSUTF8("couponRate"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode maturity */

   if (pvalue->m.maturityPresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->maturity
         , OSUTF8("maturity"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode parValue */

   if (pvalue->m.parValuePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->parValue
         , OSUTF8("parValue"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode faceAmount */

   if (pvalue->m.faceAmountPresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->faceAmount
         , OSUTF8("faceAmount"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode underlyingEquity */

   stat = XmlEnc_UnderlyingAsset_derivations (pctxt, &pvalue->underlyingEquity
      , OSUTF8("underlyingEquity"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Equity                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Equity (OSCTXT* pctxt,
   Equity *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode optionsExchangeId */

   if (pvalue->m.optionsExchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_ExchangeId (pctxt, &pvalue->optionsExchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode relatedExchangeId_list */

   pnode2 = pvalue->relatedExchangeId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ExchangeId (pctxt, ((ExchangeId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_ClearanceSystem (pctxt, &pvalue->clearanceSystem, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_ExchangeId (pctxt, &pvalue->exchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Currency (pctxt, &pvalue->currency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode description */

   if (pvalue->m.descriptionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->description, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Equity.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->instrumentId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_InstrumentId (pctxt, ((InstrumentId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Equity (OSCTXT* pctxt, Equity* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Equity.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->instrumentId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_InstrumentId (pctxt, ((InstrumentId*)pnode->data)
         , OSUTF8("instrumentId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode description */

   if (pvalue->m.descriptionPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->description
         , OSUTF8("description"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      stat = XmlEnc_Currency (pctxt, &pvalue->currency
         , OSUTF8("currency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->exchangeId
         , OSUTF8("exchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      stat = XmlEnc_ClearanceSystem (pctxt, &pvalue->clearanceSystem
         , OSUTF8("clearanceSystem"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode relatedExchangeId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->relatedExchangeId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ExchangeId (pctxt, ((ExchangeId*)pnode->data)
         , OSUTF8("relatedExchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode optionsExchangeId */

   if (pvalue->m.optionsExchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->optionsExchangeId
         , OSUTF8("optionsExchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExchangeTradedFund                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExchangeTradedFund (OSCTXT* pctxt,
   ExchangeTradedFund *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode fundManager */

   if (pvalue->m.fundManagerPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
         xe_utf8str (pctxt, pvalue->fundManager, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode optionsExchangeId */

   if (pvalue->m.optionsExchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_ExchangeId (pctxt, &pvalue->optionsExchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode relatedExchangeId */

   if (pvalue->m.relatedExchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_ExchangeId (pctxt, &pvalue->relatedExchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_ClearanceSystem (pctxt, &pvalue->clearanceSystem, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_ExchangeId (pctxt, &pvalue->exchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Currency (pctxt, &pvalue->currency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode description */

   if (pvalue->m.descriptionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->description, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ExchangeTradedFund.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->instrumentId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_InstrumentId (pctxt, ((InstrumentId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ExchangeTradedFund (OSCTXT* pctxt, ExchangeTradedFund* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ExchangeTradedFund.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->instrumentId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_InstrumentId (pctxt, ((InstrumentId*)pnode->data)
         , OSUTF8("instrumentId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode description */

   if (pvalue->m.descriptionPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->description
         , OSUTF8("description"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      stat = XmlEnc_Currency (pctxt, &pvalue->currency
         , OSUTF8("currency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->exchangeId
         , OSUTF8("exchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      stat = XmlEnc_ClearanceSystem (pctxt, &pvalue->clearanceSystem
         , OSUTF8("clearanceSystem"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode relatedExchangeId */

   if (pvalue->m.relatedExchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->relatedExchangeId
         , OSUTF8("relatedExchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode optionsExchangeId */

   if (pvalue->m.optionsExchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->optionsExchangeId
         , OSUTF8("optionsExchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fundManager */

   if (pvalue->m.fundManagerPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->fundManager
         , OSUTF8("fundManager"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Future                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Future (OSCTXT* pctxt,
   Future *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode futureContractReference */

   if (pvalue->m.futureContractReferencePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|8,
         xe_utf8str (pctxt, pvalue->futureContractReference, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode multiplier */

   if (pvalue->m.multiplierPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
         xe_integer (pctxt, &pvalue->multiplier, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode optionsExchangeId */

   if (pvalue->m.optionsExchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_ExchangeId (pctxt, &pvalue->optionsExchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode relatedExchangeId */

   if (pvalue->m.relatedExchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_ExchangeId (pctxt, &pvalue->relatedExchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_ClearanceSystem (pctxt, &pvalue->clearanceSystem, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_ExchangeId (pctxt, &pvalue->exchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Currency (pctxt, &pvalue->currency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode description */

   if (pvalue->m.descriptionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->description, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Future.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->instrumentId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_InstrumentId (pctxt, ((InstrumentId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Future (OSCTXT* pctxt, Future* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Future.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->instrumentId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_InstrumentId (pctxt, ((InstrumentId*)pnode->data)
         , OSUTF8("instrumentId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode description */

   if (pvalue->m.descriptionPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->description
         , OSUTF8("description"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      stat = XmlEnc_Currency (pctxt, &pvalue->currency
         , OSUTF8("currency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->exchangeId
         , OSUTF8("exchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      stat = XmlEnc_ClearanceSystem (pctxt, &pvalue->clearanceSystem
         , OSUTF8("clearanceSystem"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode relatedExchangeId */

   if (pvalue->m.relatedExchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->relatedExchangeId
         , OSUTF8("relatedExchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode optionsExchangeId */

   if (pvalue->m.optionsExchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->optionsExchangeId
         , OSUTF8("optionsExchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode multiplier */

   if (pvalue->m.multiplierPresent) {
      stat = rtXmlEncInt (pctxt, pvalue->multiplier
         , OSUTF8("multiplier"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode futureContractReference */

   if (pvalue->m.futureContractReferencePresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->futureContractReference
         , OSUTF8("futureContractReference"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_futureId                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Index_futureId (OSCTXT* pctxt,
   Index_futureId *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode futureIdScheme */

   if (pvalue->m.futureIdSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->futureIdScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Index_futureId (OSCTXT* pctxt, Index_futureId* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.futureIdSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" futureIdScheme=\""), 17);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->futureIdScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Index (OSCTXT* pctxt,
   Index *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode futureId */

   if (pvalue->m.futureIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_Index_futureId (pctxt, &pvalue->futureId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode relatedExchangeId_list */

   pnode2 = pvalue->relatedExchangeId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ExchangeId (pctxt, ((ExchangeId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_ClearanceSystem (pctxt, &pvalue->clearanceSystem, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_ExchangeId (pctxt, &pvalue->exchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Currency (pctxt, &pvalue->currency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode description */

   if (pvalue->m.descriptionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->description, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Index.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->instrumentId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_InstrumentId (pctxt, ((InstrumentId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Index (OSCTXT* pctxt, Index* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Index.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->instrumentId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_InstrumentId (pctxt, ((InstrumentId*)pnode->data)
         , OSUTF8("instrumentId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode description */

   if (pvalue->m.descriptionPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->description
         , OSUTF8("description"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      stat = XmlEnc_Currency (pctxt, &pvalue->currency
         , OSUTF8("currency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->exchangeId
         , OSUTF8("exchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      stat = XmlEnc_ClearanceSystem (pctxt, &pvalue->clearanceSystem
         , OSUTF8("clearanceSystem"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode relatedExchangeId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->relatedExchangeId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ExchangeId (pctxt, ((ExchangeId*)pnode->data)
         , OSUTF8("relatedExchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode futureId */

   if (pvalue->m.futureIdPresent) {
      stat = XmlEnc_Index_futureId (pctxt, &pvalue->futureId
         , OSUTF8("futureId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MutualFund                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MutualFund (OSCTXT* pctxt,
   MutualFund *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode fundManager */

   if (pvalue->m.fundManagerPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
         xe_utf8str (pctxt, pvalue->fundManager, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode openEndedFund */

   if (pvalue->m.openEndedFundPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         xe_boolean (pctxt, &pvalue->openEndedFund, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_ClearanceSystem (pctxt, &pvalue->clearanceSystem, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_ExchangeId (pctxt, &pvalue->exchangeId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Currency (pctxt, &pvalue->currency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode description */

   if (pvalue->m.descriptionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->description, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "MutualFund.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->instrumentId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_InstrumentId (pctxt, ((InstrumentId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MutualFund (OSCTXT* pctxt, MutualFund* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "MutualFund.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->instrumentId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_InstrumentId (pctxt, ((InstrumentId*)pnode->data)
         , OSUTF8("instrumentId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode description */

   if (pvalue->m.descriptionPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->description
         , OSUTF8("description"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      stat = XmlEnc_Currency (pctxt, &pvalue->currency
         , OSUTF8("currency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode exchangeId */

   if (pvalue->m.exchangeIdPresent) {
      stat = XmlEnc_ExchangeId (pctxt, &pvalue->exchangeId
         , OSUTF8("exchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      stat = XmlEnc_ClearanceSystem (pctxt, &pvalue->clearanceSystem
         , OSUTF8("clearanceSystem"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode openEndedFund */

   if (pvalue->m.openEndedFundPresent) {
      stat = rtXmlEncBool (pctxt, pvalue->openEndedFund
         , OSUTF8("openEndedFund"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fundManager */

   if (pvalue->m.fundManagerPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->fundManager
         , OSUTF8("fundManager"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnderlyingAsset_group                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_UnderlyingAsset_group (OSCTXT* pctxt,
   UnderlyingAsset_group *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_Bond (pctxt, pvalue->u.bond, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_ConvertibleBond (pctxt, pvalue->u.convertibleBond, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_Equity (pctxt, pvalue->u.equity, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 4:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
            asn1E_ExchangeTradedFund (pctxt, pvalue->u.exchangeTradedFund, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 5:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
            asn1E_Future (pctxt, pvalue->u.future, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 6:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
            asn1E_Index (pctxt, pvalue->u.index, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 7:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
            asn1E_MutualFund (pctxt, pvalue->u.mutualFund, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_UnderlyingAsset_group (OSCTXT* pctxt, 
   UnderlyingAsset_group* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode bond */

         stat = XmlEnc_Bond (pctxt, pvalue->u.bond, OSUTF8("bond"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode convertibleBond */

         stat = XmlEnc_ConvertibleBond (pctxt, pvalue->u.convertibleBond
            , OSUTF8("convertibleBond"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode equity */

         stat = XmlEnc_Equity (pctxt, pvalue->u.equity
            , OSUTF8("equity"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 4:
         /* encode exchangeTradedFund */

         stat = XmlEnc_ExchangeTradedFund (pctxt, pvalue->u.exchangeTradedFund
            , OSUTF8("exchangeTradedFund"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 5:
         /* encode future */

         stat = XmlEnc_Future (pctxt, pvalue->u.future
            , OSUTF8("future"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 6:
         /* encode index */

         stat = XmlEnc_Index (pctxt, pvalue->u.index
            , OSUTF8("index"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 7:
         /* encode mutualFund */

         stat = XmlEnc_MutualFund (pctxt, pvalue->u.mutualFund
            , OSUTF8("mutualFund"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DividendPayout                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DividendPayout (OSCTXT* pctxt,
   DividendPayout *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            xe_real (pctxt, &pvalue->u.dividendPayoutRatio, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
            xe_utf8str (pctxt, pvalue->u.dividendPayoutConditions, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   if (tagging == ASN1EXPL) {
      ll1 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll1);
      if (ll1 < 0) return LOG_RTERR (pctxt, ll1);
   }

   ll0 += ll1;

   return (ll0);
}

int XmlEnc_DividendPayout (OSCTXT* pctxt, DividendPayout* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode dividendPayoutRatio */

         stat = rtXmlEncDouble (pctxt, pvalue->u.dividendPayoutRatio
            , OSUTF8("dividendPayoutRatio"), nsPrefix, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode dividendPayoutConditions */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.dividendPayoutConditions
            , OSUTF8("dividendPayoutConditions"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SingleUnderlyer                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SingleUnderlyer (OSCTXT* pctxt,
   SingleUnderlyer *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode dividendPayout */

   if (pvalue->m.dividendPayoutPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_DividendPayout (pctxt, &pvalue->dividendPayout, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode openUnits */

   if (pvalue->m.openUnitsPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_real (pctxt, &pvalue->openUnits, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode underlyingAsset */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_UnderlyingAsset_group (pctxt, &pvalue->underlyingAsset, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SingleUnderlyer (OSCTXT* pctxt, SingleUnderlyer* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode underlyingAsset */

   stat = XmlEnc_UnderlyingAsset_group (pctxt, &pvalue->underlyingAsset
      , OSUTF8(""), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode openUnits */

   if (pvalue->m.openUnitsPresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->openUnits
         , OSUTF8("openUnits"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode dividendPayout */

   if (pvalue->m.dividendPayoutPresent) {
      stat = XmlEnc_DividendPayout (pctxt, &pvalue->dividendPayout
         , OSUTF8("dividendPayout"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConstituentWeight                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ConstituentWeight (OSCTXT* pctxt,
   ConstituentWeight *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode basketPercentage */

   if (pvalue->m.basketPercentagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_real (pctxt, &pvalue->basketPercentage, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode openUnits */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_real (pctxt, &pvalue->openUnits, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ConstituentWeight (OSCTXT* pctxt, ConstituentWeight* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode openUnits */

   stat = rtXmlEncDouble (pctxt, pvalue->openUnits
      , OSUTF8("openUnits"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode basketPercentage */

   if (pvalue->m.basketPercentagePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->basketPercentage
         , OSUTF8("basketPercentage"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommissionDenominationEnum                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CommissionDenominationEnum (OSCTXT* pctxt,
   CommissionDenominationEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 3)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_CommissionDenominationEnum (OSCTXT* pctxt, 
   CommissionDenominationEnum value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      CommissionDenominationEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Commission                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Commission (OSCTXT* pctxt,
   Commission *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode currency */

   if (pvalue->m.currencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Currency (pctxt, &pvalue->currency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode commissionAmount */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_real (pctxt, &pvalue->commissionAmount, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode commissionDenomination */

   if(pvalue->commissionDenomination < 0 || pvalue->commissionDenomination > 3)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_CommissionDenominationEnum (pctxt, &pvalue->commissionDenomination, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Commission (OSCTXT* pctxt, Commission* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode commissionDenomination */

   if(pvalue->commissionDenomination < 0 || pvalue->commissionDenomination
       > 3)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_CommissionDenominationEnum (pctxt, pvalue->
      commissionDenomination, OSUTF8("commissionDenomination"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode commissionAmount */

   stat = rtXmlEncDouble (pctxt, pvalue->commissionAmount
      , OSUTF8("commissionAmount"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode currency */

   if (pvalue->m.currencyPresent) {
      stat = XmlEnc_Currency (pctxt, &pvalue->currency
         , OSUTF8("currency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AmountRelativeTo                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AmountRelativeTo (OSCTXT* pctxt,
   AmountRelativeTo *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode href */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->href, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_AmountRelativeTo (OSCTXT* pctxt, AmountRelativeTo* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->href, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PriceExpressionEnum                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PriceExpressionEnum (OSCTXT* pctxt,
   PriceExpressionEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_PriceExpressionEnum (OSCTXT* pctxt, PriceExpressionEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      PriceExpressionEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ActualPrice                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ActualPrice (OSCTXT* pctxt,
   ActualPrice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode priceExpression */

   if(pvalue->priceExpression < 0 || pvalue->priceExpression > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      asn1E_PriceExpressionEnum (pctxt, &pvalue->priceExpression, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode amount */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_real (pctxt, &pvalue->amount, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode currency */

   if (pvalue->m.currencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Currency (pctxt, &pvalue->currency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ActualPrice (OSCTXT* pctxt, ActualPrice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode currency */

   if (pvalue->m.currencyPresent) {
      stat = XmlEnc_Currency (pctxt, &pvalue->currency
         , OSUTF8("currency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode amount */

   stat = rtXmlEncDouble (pctxt, pvalue->amount, OSUTF8("amount"), nsPrefix
      , 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode priceExpression */

   if(pvalue->priceExpression < 0 || pvalue->priceExpression > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_PriceExpressionEnum (pctxt, pvalue->priceExpression
      , OSUTF8("priceExpression"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FxRate                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FxRate (OSCTXT* pctxt,
   FxRate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode rate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_real (pctxt, &pvalue->rate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode quotedCurrencyPair */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_QuotedCurrencyPair (pctxt, &pvalue->quotedCurrencyPair, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FxRate (OSCTXT* pctxt, FxRate* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode quotedCurrencyPair */

   stat = XmlEnc_QuotedCurrencyPair (pctxt, &pvalue->quotedCurrencyPair
      , OSUTF8("quotedCurrencyPair"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rate */

   stat = rtXmlEncDouble (pctxt, pvalue->rate, OSUTF8("rate"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FxRate_derivations                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FxRate_derivations (OSCTXT* pctxt,
   FxRate_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_FxRate (pctxt, pvalue->u.fxRate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_ExchangeRate (pctxt, pvalue->u.exchangeRate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_FxRate_derivations (OSCTXT* pctxt, FxRate_derivations* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode fxRate */

         stat = XmlEnc_FxRate (pctxt, pvalue->u.fxRate, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode exchangeRate */

         stat = XmlEnc_ExchangeRate (pctxt, pvalue->u.exchangeRate
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Price_sequence_fxConversion                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Price_sequence_fxConversion (OSCTXT* pctxt,
   Price_sequence_fxConversion *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         if (!(pvalue->u.fxRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "Price_sequence_fxConversion.u.fxRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         pnode2 = pvalue->u.fxRate_list->tail;
         while (0 != pnode2) {
            ll = asn1E_FxRate_derivations (pctxt, ((FxRate_derivations*)pnode2->data), ASN1EXPL);
            if (ll < 0) return LOG_RTERR (pctxt, ll);
            ll2 += ll;

            pnode2 = pnode2->prev;
         }
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else { ll1 += ll; ll2 = 0; }
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Price_sequence_fxConversion (OSCTXT* pctxt, 
   Price_sequence_fxConversion* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode fxRate_list */

         if (!(pvalue->u.fxRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "Price_sequence_fxConversion.u.fxRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         { const OSUTF8CHAR* savedPrefix = nsPrefix;
         nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
            "http://www.fpml.org/2003/FpML-4-0"));

         { OSRTDListNode* pnode = pvalue->u.fxRate_list->head;
         while (0 != pnode) {
            stat = XmlEnc_FxRate_derivations (pctxt, 
               ((FxRate_derivations*)pnode->data)
               , OSUTF8("fxRate"), nsPrefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            pnode = pnode->next;
         }}
         nsPrefix = savedPrefix;
         }

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Price_sequence                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Price_sequence (OSCTXT* pctxt,
   Price_sequence *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode fxConversion */

   if (pvalue->m.fxConversionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Price_sequence_fxConversion (pctxt, &pvalue->fxConversion, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode accruedInterestPrice */

   if (pvalue->m.accruedInterestPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_real (pctxt, &pvalue->accruedInterestPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode netPrice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_ActualPrice (pctxt, &pvalue->netPrice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode grossPrice */

   if (pvalue->m.grossPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ActualPrice (pctxt, &pvalue->grossPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Price_sequence (OSCTXT* pctxt, Price_sequence* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode grossPrice */

   if (pvalue->m.grossPricePresent) {
      stat = XmlEnc_ActualPrice (pctxt, &pvalue->grossPrice
         , OSUTF8("grossPrice"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode netPrice */

   stat = XmlEnc_ActualPrice (pctxt, &pvalue->netPrice
      , OSUTF8("netPrice"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode accruedInterestPrice */

   if (pvalue->m.accruedInterestPricePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->accruedInterestPrice
         , OSUTF8("accruedInterestPrice"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fxConversion */

   if (pvalue->m.fxConversionPresent) {
      stat = XmlEnc_Price_sequence_fxConversion (pctxt, &pvalue->fxConversion
         , OSUTF8("fxConversion"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Price_choice                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Price_choice (OSCTXT* pctxt,
   Price_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            xe_utf8str (pctxt, pvalue->u.determinationMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_Price_sequence (pctxt, pvalue->u.sequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Price_choice (OSCTXT* pctxt, Price_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode determinationMethod */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.determinationMethod
            , OSUTF8("determinationMethod"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode sequence */

         stat = XmlEnc_Price_sequence (pctxt, pvalue->u.sequence
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Price                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Price (OSCTXT* pctxt,
   Price *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Price_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode commission */

   if (pvalue->m.commissionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Commission (pctxt, &pvalue->commission, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Price (OSCTXT* pctxt, Price* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode commission */

   if (pvalue->m.commissionPresent) {
      stat = XmlEnc_Commission (pctxt, &pvalue->commission
         , OSUTF8("commission"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode choice */

   stat = XmlEnc_Price_choice (pctxt, &pvalue->choice, OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Price_derivations_equitySwapValuation_initialPrice_seque  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Price_derivations_equitySwapValuation_initialPrice_sequence_fxConversion (OSCTXT* pctxt,
   Price_derivations_equitySwapValuation_initialPrice_sequence_fxConversion *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         if (!(pvalue->u.fxRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "Price_derivations_equitySwapValuation_initialPrice_sequence_fxConversion.u.fxRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         pnode2 = pvalue->u.fxRate_list->tail;
         while (0 != pnode2) {
            ll = asn1E_FxRate_derivations (pctxt, ((FxRate_derivations*)pnode2->data), ASN1EXPL);
            if (ll < 0) return LOG_RTERR (pctxt, ll);
            ll2 += ll;

            pnode2 = pnode2->prev;
         }
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else { ll1 += ll; ll2 = 0; }
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Price_derivations_equitySwapValuation_initialPrice_sequence_fxConversion 
   (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_initialPrice_sequence_fxConversion* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode fxRate_list */

         if (!(pvalue->u.fxRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "Price_derivations_equitySwapValuation_initialPrice_sequence_fxConversion.u.fxRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         { const OSUTF8CHAR* savedPrefix = nsPrefix;
         nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
            "http://www.fpml.org/2003/FpML-4-0"));

         { OSRTDListNode* pnode = pvalue->u.fxRate_list->head;
         while (0 != pnode) {
            stat = XmlEnc_FxRate_derivations (pctxt, 
               ((FxRate_derivations*)pnode->data)
               , OSUTF8("fxRate"), nsPrefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            pnode = pnode->next;
         }}
         nsPrefix = savedPrefix;
         }

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Price_derivations_equitySwapValuation_initialPrice_seque  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Price_derivations_equitySwapValuation_initialPrice_sequence (OSCTXT* pctxt,
   Price_derivations_equitySwapValuation_initialPrice_sequence *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode fxConversion */

   if (pvalue->m.fxConversionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Price_derivations_equitySwapValuation_initialPrice_sequence_fxConversion (pctxt, &pvalue->fxConversion, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode accruedInterestPrice */

   if (pvalue->m.accruedInterestPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_real (pctxt, &pvalue->accruedInterestPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode netPrice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_ActualPrice (pctxt, &pvalue->netPrice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode grossPrice */

   if (pvalue->m.grossPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ActualPrice (pctxt, &pvalue->grossPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Price_derivations_equitySwapValuation_initialPrice_sequence 
   (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_initialPrice_sequence* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode grossPrice */

   if (pvalue->m.grossPricePresent) {
      stat = XmlEnc_ActualPrice (pctxt, &pvalue->grossPrice
         , OSUTF8("grossPrice"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode netPrice */

   stat = XmlEnc_ActualPrice (pctxt, &pvalue->netPrice
      , OSUTF8("netPrice"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode accruedInterestPrice */

   if (pvalue->m.accruedInterestPricePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->accruedInterestPrice
         , OSUTF8("accruedInterestPrice"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fxConversion */

   if (pvalue->m.fxConversionPresent) {
      stat = XmlEnc_Price_derivations_equitySwapValuation_initialPrice_sequence_fxConversion (pctxt
         , &pvalue->fxConversion, OSUTF8("fxConversion"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Price_derivations_equitySwapValuation_initialPrice_choic  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Price_derivations_equitySwapValuation_initialPrice_choice (OSCTXT* pctxt,
   Price_derivations_equitySwapValuation_initialPrice_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            xe_utf8str (pctxt, pvalue->u.determinationMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_Price_derivations_equitySwapValuation_initialPrice_sequence (pctxt, pvalue->u.sequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Price_derivations_equitySwapValuation_initialPrice_choice 
   (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_initialPrice_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode determinationMethod */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.determinationMethod
            , OSUTF8("determinationMethod"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode sequence */

         stat = XmlEnc_Price_derivations_equitySwapValuation_initialPrice_sequence (pctxt
            , pvalue->u.sequence, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeTypeEnum                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TimeTypeEnum (OSCTXT* pctxt,
   TimeTypeEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_TimeTypeEnum (OSCTXT* pctxt, TimeTypeEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      TimeTypeEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelativeDateSequence_dateOffset                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RelativeDateSequence_dateOffset (OSCTXT* pctxt,
   RelativeDateSequence_dateOffset *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode sequence */

   if (pvalue->m.sequencePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_integer (pctxt, &pvalue->sequence, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode businessDayConvention */

   if(pvalue->businessDayConvention < 0 || pvalue->businessDayConvention > 6)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
      asn1E_BusinessDayConventionEnum (pctxt, &pvalue->businessDayConvention, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode dayType */

   if (pvalue->m.dayTypePresent) {
      if(pvalue->dayType < 0 || pvalue->dayType > 3)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         asn1E_DayTypeEnum (pctxt, &pvalue->dayType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode period */

   if(pvalue->period < 0 || pvalue->period > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_PeriodEnum (pctxt, &pvalue->period, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode periodMultiplier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_integer (pctxt, &pvalue->periodMultiplier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_RelativeDateSequence_dateOffset (OSCTXT* pctxt, 
   RelativeDateSequence_dateOffset* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode periodMultiplier */

   stat = rtXmlEncInt (pctxt, pvalue->periodMultiplier
      , OSUTF8("periodMultiplier"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode period */

   if(pvalue->period < 0 || pvalue->period > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_PeriodEnum (pctxt, pvalue->period
      , OSUTF8("period"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dayType */

   if (pvalue->m.dayTypePresent) {
      if(pvalue->dayType < 0 || pvalue->dayType > 3)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_DayTypeEnum (pctxt, pvalue->dayType
         , OSUTF8("dayType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode businessDayConvention */

   if(pvalue->businessDayConvention < 0 || pvalue->businessDayConvention > 6)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_BusinessDayConventionEnum (pctxt, pvalue->
      businessDayConvention, OSUTF8("businessDayConvention"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode sequence */

   if (pvalue->m.sequencePresent) {
      stat = rtXmlEncInt (pctxt, pvalue->sequence, OSUTF8("sequence"), nsPrefix
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelativeDateSequence_choice                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RelativeDateSequence_choice (OSCTXT* pctxt,
   RelativeDateSequence_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_BusinessCentersReference (pctxt, pvalue->u.businessCentersReference, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_BusinessCenters (pctxt, pvalue->u.businessCenters, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_RelativeDateSequence_choice (OSCTXT* pctxt, 
   RelativeDateSequence_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode businessCentersReference */

         stat = XmlEnc_BusinessCentersReference (pctxt, pvalue->
            u.businessCentersReference
            , OSUTF8("businessCentersReference"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode businessCenters */

         stat = XmlEnc_BusinessCenters (pctxt, pvalue->u.businessCenters
            , OSUTF8("businessCenters"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelativeDateSequence                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RelativeDateSequence (OSCTXT* pctxt,
   RelativeDateSequence *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode choice */

   if (pvalue->m.choicePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_RelativeDateSequence_choice (pctxt, &pvalue->choice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dateOffset_list */

   if (!(pvalue->dateOffset_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "RelativeDateSequence.dateOffset_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->dateOffset_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->dateOffset_list.tail;
   while (0 != pnode2) {
      ll = asn1E_RelativeDateSequence_dateOffset (pctxt, ((RelativeDateSequence_dateOffset*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode dateRelativeTo */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_DateRelativeTo (pctxt, &pvalue->dateRelativeTo, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_RelativeDateSequence (OSCTXT* pctxt, RelativeDateSequence* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode dateRelativeTo */

   stat = XmlEnc_DateRelativeTo (pctxt, &pvalue->dateRelativeTo
      , OSUTF8("dateRelativeTo"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dateOffset_list */

   if (!(pvalue->dateOffset_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "RelativeDateSequence.dateOffset_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->dateOffset_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->dateOffset_list.head;
   while (0 != pnode) {
      stat = XmlEnc_RelativeDateSequence_dateOffset (pctxt, 
         ((RelativeDateSequence_dateOffset*)pnode->data)
         , OSUTF8("dateOffset"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode choice */

   if (pvalue->m.choicePresent) {
      stat = XmlEnc_RelativeDateSequence_choice (pctxt, &pvalue->choice
         , OSUTF8(""), 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Price_derivations_equitySwapValuation_initialPrice_equit  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Price_derivations_equitySwapValuation_initialPrice_equityValuationDate (OSCTXT* pctxt,
   Price_derivations_equitySwapValuation_initialPrice_equityValuationDate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AdjustableDate (pctxt, pvalue->u.adjustableDate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_RelativeDateSequence (pctxt, pvalue->u.relativeDateSequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Price_derivations_equitySwapValuation_initialPrice_equityValuationDate 
   (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_initialPrice_equityValuationDate* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode adjustableDate */

         stat = XmlEnc_AdjustableDate (pctxt, pvalue->u.adjustableDate
            , OSUTF8("adjustableDate"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode relativeDateSequence */

         stat = XmlEnc_RelativeDateSequence (pctxt, pvalue->
            u.relativeDateSequence, OSUTF8("relativeDateSequence"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Price_derivations_equitySwapValuation_initialPrice        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Price_derivations_equitySwapValuation_initialPrice (OSCTXT* pctxt,
   Price_derivations_equitySwapValuation_initialPrice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode equityValuationDate */

   if (pvalue->m.equityValuationDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Price_derivations_equitySwapValuation_initialPrice_equityValuationDate (pctxt, &pvalue->equityValuationDate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_BusinessCenterTime (pctxt, &pvalue->valuationTime, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode valuationTimeType */

   if (pvalue->m.valuationTimeTypePresent) {
      if(pvalue->valuationTimeType < 0 || pvalue->valuationTimeType > 4)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         asn1E_TimeTypeEnum (pctxt, &pvalue->valuationTimeType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Price_derivations_equitySwapValuation_initialPrice_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode commission */

   if (pvalue->m.commissionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Commission (pctxt, &pvalue->commission, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Price_derivations_equitySwapValuation_initialPrice (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_initialPrice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode commission */

   if (pvalue->m.commissionPresent) {
      stat = XmlEnc_Commission (pctxt, &pvalue->commission
         , OSUTF8("commission"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode choice */

   stat = XmlEnc_Price_derivations_equitySwapValuation_initialPrice_choice (pctxt
      , &pvalue->choice, OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode valuationTimeType */

   if (pvalue->m.valuationTimeTypePresent) {
      if(pvalue->valuationTimeType < 0 || pvalue->valuationTimeType > 4)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_TimeTypeEnum (pctxt, pvalue->valuationTimeType
         , OSUTF8("valuationTimeType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->valuationTime
         , OSUTF8("valuationTime"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode equityValuationDate */

   if (pvalue->m.equityValuationDatePresent) {
      stat = XmlEnc_Price_derivations_equitySwapValuation_initialPrice_equityValuationDate (pctxt
         , &pvalue->equityValuationDate
         , OSUTF8("equityValuationDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Price_derivations_equitySwapValuation_valuationPriceInte  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Price_derivations_equitySwapValuation_valuationPriceInterim_sequence_fxConversion (OSCTXT* pctxt,
   Price_derivations_equitySwapValuation_valuationPriceInterim_sequence_fxConversion *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         if (!(pvalue->u.fxRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "Price_derivations_equitySwapValuation_valuationPriceInterim_sequence_fxConversion.u.fxRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         pnode2 = pvalue->u.fxRate_list->tail;
         while (0 != pnode2) {
            ll = asn1E_FxRate_derivations (pctxt, ((FxRate_derivations*)pnode2->data), ASN1EXPL);
            if (ll < 0) return LOG_RTERR (pctxt, ll);
            ll2 += ll;

            pnode2 = pnode2->prev;
         }
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else { ll1 += ll; ll2 = 0; }
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Price_derivations_equitySwapValuation_valuationPriceInterim_sequence_fxConversion 
   (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_valuationPriceInterim_sequence_fxConversion* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode fxRate_list */

         if (!(pvalue->u.fxRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "Price_derivations_equitySwapValuation_valuationPriceInterim_sequence_fxConversion.u.fxRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         { const OSUTF8CHAR* savedPrefix = nsPrefix;
         nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
            "http://www.fpml.org/2003/FpML-4-0"));

         { OSRTDListNode* pnode = pvalue->u.fxRate_list->head;
         while (0 != pnode) {
            stat = XmlEnc_FxRate_derivations (pctxt, 
               ((FxRate_derivations*)pnode->data)
               , OSUTF8("fxRate"), nsPrefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            pnode = pnode->next;
         }}
         nsPrefix = savedPrefix;
         }

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Price_derivations_equitySwapValuation_valuationPriceInte  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Price_derivations_equitySwapValuation_valuationPriceInterim_sequence (OSCTXT* pctxt,
   Price_derivations_equitySwapValuation_valuationPriceInterim_sequence *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode fxConversion */

   if (pvalue->m.fxConversionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Price_derivations_equitySwapValuation_valuationPriceInterim_sequence_fxConversion (pctxt, &pvalue->fxConversion, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode accruedInterestPrice */

   if (pvalue->m.accruedInterestPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_real (pctxt, &pvalue->accruedInterestPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode netPrice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_ActualPrice (pctxt, &pvalue->netPrice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode grossPrice */

   if (pvalue->m.grossPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ActualPrice (pctxt, &pvalue->grossPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Price_derivations_equitySwapValuation_valuationPriceInterim_sequence 
   (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_valuationPriceInterim_sequence* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode grossPrice */

   if (pvalue->m.grossPricePresent) {
      stat = XmlEnc_ActualPrice (pctxt, &pvalue->grossPrice
         , OSUTF8("grossPrice"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode netPrice */

   stat = XmlEnc_ActualPrice (pctxt, &pvalue->netPrice
      , OSUTF8("netPrice"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode accruedInterestPrice */

   if (pvalue->m.accruedInterestPricePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->accruedInterestPrice
         , OSUTF8("accruedInterestPrice"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fxConversion */

   if (pvalue->m.fxConversionPresent) {
      stat = XmlEnc_Price_derivations_equitySwapValuation_valuationPriceInterim_sequence_fxConversion (pctxt
         , &pvalue->fxConversion, OSUTF8("fxConversion"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Price_derivations_equitySwapValuation_valuationPriceInte  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Price_derivations_equitySwapValuation_valuationPriceInterim_choice (OSCTXT* pctxt,
   Price_derivations_equitySwapValuation_valuationPriceInterim_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            xe_utf8str (pctxt, pvalue->u.determinationMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_Price_derivations_equitySwapValuation_valuationPriceInterim_sequence (pctxt, pvalue->u.sequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Price_derivations_equitySwapValuation_valuationPriceInterim_choice 
   (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_valuationPriceInterim_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode determinationMethod */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.determinationMethod
            , OSUTF8("determinationMethod"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode sequence */

         stat = XmlEnc_Price_derivations_equitySwapValuation_valuationPriceInterim_sequence (pctxt
            , pvalue->u.sequence, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AdjustableRelativeOrPeriodicDates_periodicDates           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AdjustableRelativeOrPeriodicDates_periodicDates (OSCTXT* pctxt,
   AdjustableRelativeOrPeriodicDates_periodicDates *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode calculationPeriodDatesAdjustments */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_BusinessDayAdjustments (pctxt, &pvalue->calculationPeriodDatesAdjustments, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode calculationPeriodFrequency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_CalculationPeriodFrequency (pctxt, &pvalue->calculationPeriodFrequency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode calculationEndDate */

   if (pvalue->m.calculationEndDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_AdjustableOrRelativeDate (pctxt, &pvalue->calculationEndDate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode calculationStartDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_AdjustableOrRelativeDate (pctxt, &pvalue->calculationStartDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_AdjustableRelativeOrPeriodicDates_periodicDates (OSCTXT* pctxt, 
   AdjustableRelativeOrPeriodicDates_periodicDates* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode calculationStartDate */

   stat = XmlEnc_AdjustableOrRelativeDate (pctxt, &pvalue->calculationStartDate
      , OSUTF8("calculationStartDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode calculationEndDate */

   if (pvalue->m.calculationEndDatePresent) {
      stat = XmlEnc_AdjustableOrRelativeDate (pctxt, &pvalue->
         calculationEndDate, OSUTF8("calculationEndDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode calculationPeriodFrequency */

   stat = XmlEnc_CalculationPeriodFrequency (pctxt, &pvalue->
      calculationPeriodFrequency
      , OSUTF8("calculationPeriodFrequency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode calculationPeriodDatesAdjustments */

   stat = XmlEnc_BusinessDayAdjustments (pctxt, &pvalue->
      calculationPeriodDatesAdjustments
      , OSUTF8("calculationPeriodDatesAdjustments"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AdjustableRelativeOrPeriodicDates_choice                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AdjustableRelativeOrPeriodicDates_choice (OSCTXT* pctxt,
   AdjustableRelativeOrPeriodicDates_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AdjustableDates (pctxt, pvalue->u.adjustableDates, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_RelativeDateSequence (pctxt, pvalue->u.relativeDateSequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_AdjustableRelativeOrPeriodicDates_periodicDates (pctxt, pvalue->u.periodicDates, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_AdjustableRelativeOrPeriodicDates_choice (OSCTXT* pctxt, 
   AdjustableRelativeOrPeriodicDates_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode adjustableDates */

         stat = XmlEnc_AdjustableDates (pctxt, pvalue->u.adjustableDates
            , OSUTF8("adjustableDates"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode relativeDateSequence */

         stat = XmlEnc_RelativeDateSequence (pctxt, pvalue->
            u.relativeDateSequence, OSUTF8("relativeDateSequence"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode periodicDates */

         stat = XmlEnc_AdjustableRelativeOrPeriodicDates_periodicDates (pctxt, 
            pvalue->u.periodicDates, OSUTF8("periodicDates"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AdjustableRelativeOrPeriodicDates                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AdjustableRelativeOrPeriodicDates (OSCTXT* pctxt,
   AdjustableRelativeOrPeriodicDates *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_AdjustableRelativeOrPeriodicDates_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_AdjustableRelativeOrPeriodicDates (OSCTXT* pctxt, 
   AdjustableRelativeOrPeriodicDates* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode choice */

   stat = XmlEnc_AdjustableRelativeOrPeriodicDates_choice (pctxt, &pvalue->
      choice, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Price_derivations_equitySwapValuation_valuationPriceInte  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Price_derivations_equitySwapValuation_valuationPriceInterim (OSCTXT* pctxt,
   Price_derivations_equitySwapValuation_valuationPriceInterim *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode equityValuationDates */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_AdjustableRelativeOrPeriodicDates (pctxt, &pvalue->equityValuationDates, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_BusinessCenterTime (pctxt, &pvalue->valuationTime, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode valuationTimeType */

   if(pvalue->valuationTimeType < 0 || pvalue->valuationTimeType > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      asn1E_TimeTypeEnum (pctxt, &pvalue->valuationTimeType, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Price_derivations_equitySwapValuation_valuationPriceInterim_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode commission */

   if (pvalue->m.commissionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Commission (pctxt, &pvalue->commission, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Price_derivations_equitySwapValuation_valuationPriceInterim 
   (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_valuationPriceInterim* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode commission */

   if (pvalue->m.commissionPresent) {
      stat = XmlEnc_Commission (pctxt, &pvalue->commission
         , OSUTF8("commission"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode choice */

   stat = XmlEnc_Price_derivations_equitySwapValuation_valuationPriceInterim_choice (pctxt
      , &pvalue->choice, OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode valuationTimeType */

   if(pvalue->valuationTimeType < 0 || pvalue->valuationTimeType > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TimeTypeEnum (pctxt, pvalue->valuationTimeType
      , OSUTF8("valuationTimeType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->valuationTime
         , OSUTF8("valuationTime"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode equityValuationDates */

   stat = XmlEnc_AdjustableRelativeOrPeriodicDates (pctxt, &pvalue->
      equityValuationDates, OSUTF8("equityValuationDates"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Price_derivations_equitySwapValuation_valuationPriceFina  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Price_derivations_equitySwapValuation_valuationPriceFinal_sequence_fxConversion (OSCTXT* pctxt,
   Price_derivations_equitySwapValuation_valuationPriceFinal_sequence_fxConversion *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         if (!(pvalue->u.fxRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "Price_derivations_equitySwapValuation_valuationPriceFinal_sequence_fxConversion.u.fxRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         pnode2 = pvalue->u.fxRate_list->tail;
         while (0 != pnode2) {
            ll = asn1E_FxRate_derivations (pctxt, ((FxRate_derivations*)pnode2->data), ASN1EXPL);
            if (ll < 0) return LOG_RTERR (pctxt, ll);
            ll2 += ll;

            pnode2 = pnode2->prev;
         }
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else { ll1 += ll; ll2 = 0; }
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Price_derivations_equitySwapValuation_valuationPriceFinal_sequence_fxConversion 
   (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_valuationPriceFinal_sequence_fxConversion* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode fxRate_list */

         if (!(pvalue->u.fxRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "Price_derivations_equitySwapValuation_valuationPriceFinal_sequence_fxConversion.u.fxRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         { const OSUTF8CHAR* savedPrefix = nsPrefix;
         nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
            "http://www.fpml.org/2003/FpML-4-0"));

         { OSRTDListNode* pnode = pvalue->u.fxRate_list->head;
         while (0 != pnode) {
            stat = XmlEnc_FxRate_derivations (pctxt, 
               ((FxRate_derivations*)pnode->data)
               , OSUTF8("fxRate"), nsPrefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            pnode = pnode->next;
         }}
         nsPrefix = savedPrefix;
         }

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Price_derivations_equitySwapValuation_valuationPriceFina  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Price_derivations_equitySwapValuation_valuationPriceFinal_sequence (OSCTXT* pctxt,
   Price_derivations_equitySwapValuation_valuationPriceFinal_sequence *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode fxConversion */

   if (pvalue->m.fxConversionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Price_derivations_equitySwapValuation_valuationPriceFinal_sequence_fxConversion (pctxt, &pvalue->fxConversion, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode accruedInterestPrice */

   if (pvalue->m.accruedInterestPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_real (pctxt, &pvalue->accruedInterestPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode netPrice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_ActualPrice (pctxt, &pvalue->netPrice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode grossPrice */

   if (pvalue->m.grossPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ActualPrice (pctxt, &pvalue->grossPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Price_derivations_equitySwapValuation_valuationPriceFinal_sequence 
   (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_valuationPriceFinal_sequence* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode grossPrice */

   if (pvalue->m.grossPricePresent) {
      stat = XmlEnc_ActualPrice (pctxt, &pvalue->grossPrice
         , OSUTF8("grossPrice"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode netPrice */

   stat = XmlEnc_ActualPrice (pctxt, &pvalue->netPrice
      , OSUTF8("netPrice"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode accruedInterestPrice */

   if (pvalue->m.accruedInterestPricePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->accruedInterestPrice
         , OSUTF8("accruedInterestPrice"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fxConversion */

   if (pvalue->m.fxConversionPresent) {
      stat = XmlEnc_Price_derivations_equitySwapValuation_valuationPriceFinal_sequence_fxConversion (pctxt
         , &pvalue->fxConversion, OSUTF8("fxConversion"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Price_derivations_equitySwapValuation_valuationPriceFina  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Price_derivations_equitySwapValuation_valuationPriceFinal_choice (OSCTXT* pctxt,
   Price_derivations_equitySwapValuation_valuationPriceFinal_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            xe_utf8str (pctxt, pvalue->u.determinationMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_Price_derivations_equitySwapValuation_valuationPriceFinal_sequence (pctxt, pvalue->u.sequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Price_derivations_equitySwapValuation_valuationPriceFinal_choice 
   (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_valuationPriceFinal_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode determinationMethod */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.determinationMethod
            , OSUTF8("determinationMethod"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode sequence */

         stat = XmlEnc_Price_derivations_equitySwapValuation_valuationPriceFinal_sequence (pctxt
            , pvalue->u.sequence, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Price_derivations_equitySwapValuation_valuationPriceFina  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Price_derivations_equitySwapValuation_valuationPriceFinal_equityValuationDate (OSCTXT* pctxt,
   Price_derivations_equitySwapValuation_valuationPriceFinal_equityValuationDate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AdjustableDate (pctxt, pvalue->u.adjustableDate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_RelativeDateSequence (pctxt, pvalue->u.relativeDateSequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Price_derivations_equitySwapValuation_valuationPriceFinal_equityValuationDate 
   (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_valuationPriceFinal_equityValuationDate* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode adjustableDate */

         stat = XmlEnc_AdjustableDate (pctxt, pvalue->u.adjustableDate
            , OSUTF8("adjustableDate"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode relativeDateSequence */

         stat = XmlEnc_RelativeDateSequence (pctxt, pvalue->
            u.relativeDateSequence, OSUTF8("relativeDateSequence"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Price_derivations_equitySwapValuation_valuationPriceFina  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Price_derivations_equitySwapValuation_valuationPriceFinal (OSCTXT* pctxt,
   Price_derivations_equitySwapValuation_valuationPriceFinal *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode equityValuationDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_Price_derivations_equitySwapValuation_valuationPriceFinal_equityValuationDate (pctxt, &pvalue->equityValuationDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_BusinessCenterTime (pctxt, &pvalue->valuationTime, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode valuationTimeType */

   if (pvalue->m.valuationTimeTypePresent) {
      if(pvalue->valuationTimeType < 0 || pvalue->valuationTimeType > 4)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         asn1E_TimeTypeEnum (pctxt, &pvalue->valuationTimeType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Price_derivations_equitySwapValuation_valuationPriceFinal_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode commission */

   if (pvalue->m.commissionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Commission (pctxt, &pvalue->commission, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Price_derivations_equitySwapValuation_valuationPriceFinal 
   (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_valuationPriceFinal* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode commission */

   if (pvalue->m.commissionPresent) {
      stat = XmlEnc_Commission (pctxt, &pvalue->commission
         , OSUTF8("commission"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode choice */

   stat = XmlEnc_Price_derivations_equitySwapValuation_valuationPriceFinal_choice (pctxt
      , &pvalue->choice, OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode valuationTimeType */

   if (pvalue->m.valuationTimeTypePresent) {
      if(pvalue->valuationTimeType < 0 || pvalue->valuationTimeType > 4)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_TimeTypeEnum (pctxt, pvalue->valuationTimeType
         , OSUTF8("valuationTimeType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->valuationTime
         , OSUTF8("valuationTime"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode equityValuationDate */

   stat = XmlEnc_Price_derivations_equitySwapValuation_valuationPriceFinal_equityValuationDate (pctxt
      , &pvalue->equityValuationDate
      , OSUTF8("equityValuationDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Price_derivations                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Price_derivations (OSCTXT* pctxt,
   Price_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_Price (pctxt, pvalue->u.price, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_Price_derivations_equitySwapValuation_initialPrice (pctxt, pvalue->u.equitySwapValuation_initialPrice, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_Price_derivations_equitySwapValuation_valuationPriceInterim (pctxt, pvalue->u.equitySwapValuation_valuationPriceInterim, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 4:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
            asn1E_Price_derivations_equitySwapValuation_valuationPriceFinal (pctxt, pvalue->u.equitySwapValuation_valuationPriceFinal, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Price_derivations (OSCTXT* pctxt, Price_derivations* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode price */

         stat = XmlEnc_Price (pctxt, pvalue->u.price, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode equitySwapValuation_initialPrice */

         stat = XmlEnc_Price_derivations_equitySwapValuation_initialPrice (pctxt
            , pvalue->u.equitySwapValuation_initialPrice, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode equitySwapValuation_valuationPriceInterim */

         stat = XmlEnc_Price_derivations_equitySwapValuation_valuationPriceInterim (pctxt
            , pvalue->u.equitySwapValuation_valuationPriceInterim
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 4:
         /* encode equitySwapValuation_valuationPriceFinal */

         stat = XmlEnc_Price_derivations_equitySwapValuation_valuationPriceFinal (pctxt
            , pvalue->u.equitySwapValuation_valuationPriceFinal, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BasketConstituent                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BasketConstituent (OSCTXT* pctxt,
   BasketConstituent *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode underlyerNotional */

   if (pvalue->m.underlyerNotionalPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Money_derivations (pctxt, &pvalue->underlyerNotional, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode underlyerPrice */

   if (pvalue->m.underlyerPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Price_derivations (pctxt, &pvalue->underlyerPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dividendPayout */

   if (pvalue->m.dividendPayoutPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_DividendPayout (pctxt, &pvalue->dividendPayout, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode constituentWeight */

   if (pvalue->m.constituentWeightPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ConstituentWeight (pctxt, &pvalue->constituentWeight, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode underlyingAsset */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_UnderlyingAsset_group (pctxt, &pvalue->underlyingAsset, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BasketConstituent (OSCTXT* pctxt, BasketConstituent* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode underlyingAsset */

   stat = XmlEnc_UnderlyingAsset_group (pctxt, &pvalue->underlyingAsset
      , OSUTF8(""), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode constituentWeight */

   if (pvalue->m.constituentWeightPresent) {
      stat = XmlEnc_ConstituentWeight (pctxt, &pvalue->constituentWeight
         , OSUTF8("constituentWeight"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode dividendPayout */

   if (pvalue->m.dividendPayoutPresent) {
      stat = XmlEnc_DividendPayout (pctxt, &pvalue->dividendPayout
         , OSUTF8("dividendPayout"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode underlyerPrice */

   if (pvalue->m.underlyerPricePresent) {
      stat = XmlEnc_Price_derivations (pctxt, &pvalue->underlyerPrice
         , OSUTF8("underlyerPrice"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode underlyerNotional */

   if (pvalue->m.underlyerNotionalPresent) {
      stat = XmlEnc_Money_derivations (pctxt, &pvalue->underlyerNotional
         , OSUTF8("underlyerNotional"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Basket                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Basket (OSCTXT* pctxt,
   Basket *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode basketConstituent_list */

   if (!(pvalue->basketConstituent_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Basket.basketConstituent_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->basketConstituent_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->basketConstituent_list.tail;
   while (0 != pnode2) {
      ll = asn1E_BasketConstituent (pctxt, ((BasketConstituent*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode openUnits */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_real (pctxt, &pvalue->openUnits, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Basket (OSCTXT* pctxt, Basket* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode openUnits */

   stat = rtXmlEncDouble (pctxt, pvalue->openUnits
      , OSUTF8("openUnits"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode basketConstituent_list */

   if (!(pvalue->basketConstituent_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Basket.basketConstituent_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->basketConstituent_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->basketConstituent_list.head;
   while (0 != pnode) {
      stat = XmlEnc_BasketConstituent (pctxt, ((BasketConstituent*)pnode->data)
         , OSUTF8("basketConstituent"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Underlyer                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Underlyer (OSCTXT* pctxt,
   Underlyer *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_SingleUnderlyer (pctxt, pvalue->u.singleUnderlyer, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_Basket (pctxt, pvalue->u.basket, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   if (tagging == ASN1EXPL) {
      ll1 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll1);
      if (ll1 < 0) return LOG_RTERR (pctxt, ll1);
   }

   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Underlyer (OSCTXT* pctxt, Underlyer* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode singleUnderlyer */

         stat = XmlEnc_SingleUnderlyer (pctxt, pvalue->u.singleUnderlyer
            , OSUTF8("singleUnderlyer"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode basket */

         stat = XmlEnc_Basket (pctxt, pvalue->u.basket
            , OSUTF8("basket"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityStrike_choice                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityStrike_choice (OSCTXT* pctxt,
   EquityStrike_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            xe_real (pctxt, &pvalue->u.strikePrice, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
            xe_real (pctxt, &pvalue->u.strikePercentage, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquityStrike_choice (OSCTXT* pctxt, EquityStrike_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode strikePrice */

         stat = rtXmlEncDouble (pctxt, pvalue->u.strikePrice
            , OSUTF8("strikePrice"), nsPrefix, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode strikePercentage */

         stat = rtXmlEncDouble (pctxt, pvalue->u.strikePercentage
            , OSUTF8("strikePercentage"), nsPrefix, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityStrike                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityStrike (OSCTXT* pctxt,
   EquityStrike *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode currency */

   if (pvalue->m.currencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Currency (pctxt, &pvalue->currency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_EquityStrike_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityStrike (OSCTXT* pctxt, EquityStrike* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode choice */

   stat = XmlEnc_EquityStrike_choice (pctxt, &pvalue->choice, OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode currency */

   if (pvalue->m.currencyPresent) {
      stat = XmlEnc_Currency (pctxt, &pvalue->currency
         , OSUTF8("currency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityEuropeanExercise                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityEuropeanExercise (OSCTXT* pctxt,
   EquityEuropeanExercise *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode equityExpirationTime */

   if (pvalue->m.equityExpirationTimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_BusinessCenterTime (pctxt, &pvalue->equityExpirationTime, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode equityExpirationTimeType */

   if(pvalue->equityExpirationTimeType < 0 || pvalue->equityExpirationTimeType > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      asn1E_TimeTypeEnum (pctxt, &pvalue->equityExpirationTimeType, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode expirationDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_AdjustableOrRelativeDate (pctxt, &pvalue->expirationDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityEuropeanExercise (OSCTXT* pctxt, 
   EquityEuropeanExercise* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode expirationDate */

   stat = XmlEnc_AdjustableOrRelativeDate (pctxt, &pvalue->expirationDate
      , OSUTF8("expirationDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode equityExpirationTimeType */

   if(pvalue->equityExpirationTimeType < 0 || pvalue->equityExpirationTimeType
       > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TimeTypeEnum (pctxt, pvalue->equityExpirationTimeType
      , OSUTF8("equityExpirationTimeType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode equityExpirationTime */

   if (pvalue->m.equityExpirationTimePresent) {
      stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->equityExpirationTime
         , OSUTF8("equityExpirationTime"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityMultipleExercise                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityMultipleExercise (OSCTXT* pctxt,
   EquityMultipleExercise *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode maximumNumberOfOptions */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_real (pctxt, &pvalue->maximumNumberOfOptions, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode minimumNumberOfOptions */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_real (pctxt, &pvalue->minimumNumberOfOptions, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode integralMultipleExercise */

   if (pvalue->m.integralMultipleExercisePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_real (pctxt, &pvalue->integralMultipleExercise, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityMultipleExercise (OSCTXT* pctxt, 
   EquityMultipleExercise* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode integralMultipleExercise */

   if (pvalue->m.integralMultipleExercisePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->integralMultipleExercise
         , OSUTF8("integralMultipleExercise"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode minimumNumberOfOptions */

   stat = rtXmlEncDouble (pctxt, pvalue->minimumNumberOfOptions
      , OSUTF8("minimumNumberOfOptions"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode maximumNumberOfOptions */

   stat = rtXmlEncDouble (pctxt, pvalue->maximumNumberOfOptions
      , OSUTF8("maximumNumberOfOptions"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityAmericanExercise                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityAmericanExercise (OSCTXT* pctxt,
   EquityAmericanExercise *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode equityMultipleExercise */

   if (pvalue->m.equityMultipleExercisePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_EquityMultipleExercise (pctxt, &pvalue->equityMultipleExercise, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode equityExpirationTime */

   if (pvalue->m.equityExpirationTimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_BusinessCenterTime (pctxt, &pvalue->equityExpirationTime, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode equityExpirationTimeType */

   if(pvalue->equityExpirationTimeType < 0 || pvalue->equityExpirationTimeType > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      asn1E_TimeTypeEnum (pctxt, &pvalue->equityExpirationTimeType, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode latestExerciseTimeType */

   if(pvalue->latestExerciseTimeType < 0 || pvalue->latestExerciseTimeType > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_TimeTypeEnum (pctxt, &pvalue->latestExerciseTimeType, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityAmericanExercise (OSCTXT* pctxt, 
   EquityAmericanExercise* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode latestExerciseTimeType */

   if(pvalue->latestExerciseTimeType < 0 || pvalue->latestExerciseTimeType
       > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TimeTypeEnum (pctxt, pvalue->latestExerciseTimeType
      , OSUTF8("latestExerciseTimeType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode equityExpirationTimeType */

   if(pvalue->equityExpirationTimeType < 0 || pvalue->equityExpirationTimeType
       > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TimeTypeEnum (pctxt, pvalue->equityExpirationTimeType
      , OSUTF8("equityExpirationTimeType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode equityExpirationTime */

   if (pvalue->m.equityExpirationTimePresent) {
      stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->equityExpirationTime
         , OSUTF8("equityExpirationTime"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode equityMultipleExercise */

   if (pvalue->m.equityMultipleExercisePresent) {
      stat = XmlEnc_EquityMultipleExercise (pctxt, &pvalue->
         equityMultipleExercise, OSUTF8("equityMultipleExercise"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DateList                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DateList (OSCTXT* pctxt,
   DateList *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DateList.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = xe_charstr (pctxt, ((const char*)pnode1->data), ASN1EXPL, TM_UNIV|TM_PRIM|26);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DateList (OSCTXT* pctxt, DateList* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DateList.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)
         ((const char*)pnode->data), OSUTF8("date"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityBermudanExercise                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityBermudanExercise (OSCTXT* pctxt,
   EquityBermudanExercise *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode equityMultipleExercise */

   if (pvalue->m.equityMultipleExercisePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_EquityMultipleExercise (pctxt, &pvalue->equityMultipleExercise, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode equityExpirationTime */

   if (pvalue->m.equityExpirationTimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_BusinessCenterTime (pctxt, &pvalue->equityExpirationTime, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode equityExpirationTimeType */

   if(pvalue->equityExpirationTimeType < 0 || pvalue->equityExpirationTimeType > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
      asn1E_TimeTypeEnum (pctxt, &pvalue->equityExpirationTimeType, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode latestExerciseTimeType */

   if(pvalue->latestExerciseTimeType < 0 || pvalue->latestExerciseTimeType > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
      asn1E_TimeTypeEnum (pctxt, &pvalue->latestExerciseTimeType, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode bermudanExerciseDates */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_DateList (pctxt, &pvalue->bermudanExerciseDates, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode latestExerciseTime */

   if (pvalue->m.latestExerciseTimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_BusinessCenterTime (pctxt, &pvalue->latestExerciseTime, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode expirationDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_AdjustableOrRelativeDate (pctxt, &pvalue->expirationDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode commencementDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_AdjustableOrRelativeDate (pctxt, &pvalue->commencementDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityBermudanExercise (OSCTXT* pctxt, 
   EquityBermudanExercise* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode commencementDate */

   stat = XmlEnc_AdjustableOrRelativeDate (pctxt, &pvalue->commencementDate
      , OSUTF8("commencementDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode expirationDate */

   stat = XmlEnc_AdjustableOrRelativeDate (pctxt, &pvalue->expirationDate
      , OSUTF8("expirationDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode latestExerciseTime */

   if (pvalue->m.latestExerciseTimePresent) {
      stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->latestExerciseTime
         , OSUTF8("latestExerciseTime"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bermudanExerciseDates */

   stat = XmlEnc_DateList (pctxt, &pvalue->bermudanExerciseDates
      , OSUTF8("bermudanExerciseDates"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode latestExerciseTimeType */

   if(pvalue->latestExerciseTimeType < 0 || pvalue->latestExerciseTimeType
       > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TimeTypeEnum (pctxt, pvalue->latestExerciseTimeType
      , OSUTF8("latestExerciseTimeType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode equityExpirationTimeType */

   if(pvalue->equityExpirationTimeType < 0 || pvalue->equityExpirationTimeType
       > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TimeTypeEnum (pctxt, pvalue->equityExpirationTimeType
      , OSUTF8("equityExpirationTimeType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode equityExpirationTime */

   if (pvalue->m.equityExpirationTimePresent) {
      stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->equityExpirationTime
         , OSUTF8("equityExpirationTime"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode equityMultipleExercise */

   if (pvalue->m.equityMultipleExercisePresent) {
      stat = XmlEnc_EquityMultipleExercise (pctxt, &pvalue->
         equityMultipleExercise, OSUTF8("equityMultipleExercise"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityExercise_choice                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityExercise_choice (OSCTXT* pctxt,
   EquityExercise_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_EquityEuropeanExercise (pctxt, pvalue->u.equityEuropeanExercise, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_EquityAmericanExercise (pctxt, pvalue->u.equityAmericanExercise, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_EquityBermudanExercise (pctxt, pvalue->u.equityBermudanExercise, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquityExercise_choice (OSCTXT* pctxt, 
   EquityExercise_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode equityEuropeanExercise */

         stat = XmlEnc_EquityEuropeanExercise (pctxt, pvalue->
            u.equityEuropeanExercise
            , OSUTF8("equityEuropeanExercise"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode equityAmericanExercise */

         stat = XmlEnc_EquityAmericanExercise (pctxt, pvalue->
            u.equityAmericanExercise
            , OSUTF8("equityAmericanExercise"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode equityBermudanExercise */

         stat = XmlEnc_EquityBermudanExercise (pctxt, pvalue->
            u.equityBermudanExercise
            , OSUTF8("equityBermudanExercise"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityValuation                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityValuation (OSCTXT* pctxt,
   EquityValuation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode futuresPriceValuationApplicable */

   if (pvalue->m.futuresPriceValuationApplicablePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_boolean (pctxt, &pvalue->futuresPriceValuationApplicable, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_BusinessCenterTime (pctxt, &pvalue->valuationTime, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode valuationTimeType */

   if(pvalue->valuationTimeType < 0 || pvalue->valuationTimeType > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      asn1E_TimeTypeEnum (pctxt, &pvalue->valuationTimeType, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode valuationDate */

   if (pvalue->m.valuationDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_charstr (pctxt, pvalue->valuationDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityValuation (OSCTXT* pctxt, EquityValuation* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode valuationDate */

   if (pvalue->m.valuationDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->valuationDate
         , OSUTF8("valuationDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode valuationTimeType */

   if(pvalue->valuationTimeType < 0 || pvalue->valuationTimeType > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TimeTypeEnum (pctxt, pvalue->valuationTimeType
      , OSUTF8("valuationTimeType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->valuationTime
         , OSUTF8("valuationTime"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode futuresPriceValuationApplicable */

   if (pvalue->m.futuresPriceValuationApplicablePresent) {
      stat = rtXmlEncBool (pctxt, pvalue->futuresPriceValuationApplicable
         , OSUTF8("futuresPriceValuationApplicable"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SettlementPriceSource                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SettlementPriceSource (OSCTXT* pctxt,
   SettlementPriceSource *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode settlementPriceSourceScheme */

   if (pvalue->m.settlementPriceSourceSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->settlementPriceSourceScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SettlementPriceSource (OSCTXT* pctxt, 
   SettlementPriceSource* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.settlementPriceSourceSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" settlementPriceSourceScheme=\""), 30);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->settlementPriceSourceScheme
         , 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SettlementTypeEnum                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SettlementTypeEnum (OSCTXT* pctxt,
   SettlementTypeEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_SettlementTypeEnum (OSCTXT* pctxt, SettlementTypeEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      SettlementTypeEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityExercise                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityExercise (OSCTXT* pctxt,
   EquityExercise *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode failureToDeliverApplicable */

   if (pvalue->m.failureToDeliverApplicablePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
         xe_boolean (pctxt, &pvalue->failureToDeliverApplicable, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode settlementType */

   if(pvalue->settlementType < 0 || pvalue->settlementType > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
      asn1E_SettlementTypeEnum (pctxt, &pvalue->settlementType, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode settlementPriceSource */

   if (pvalue->m.settlementPriceSourcePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_SettlementPriceSource (pctxt, &pvalue->settlementPriceSource, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode settlementCurrency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_Currency (pctxt, &pvalue->settlementCurrency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode settlementDate */

   if (pvalue->m.settlementDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_AdjustableOrRelativeDate (pctxt, &pvalue->settlementDate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode equityValuation */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_EquityValuation (pctxt, &pvalue->equityValuation, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode automaticExerciseApplicable */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_boolean (pctxt, &pvalue->automaticExerciseApplicable, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_EquityExercise_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityExercise (OSCTXT* pctxt, EquityExercise* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode choice */

   stat = XmlEnc_EquityExercise_choice (pctxt, &pvalue->choice
      , OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode automaticExerciseApplicable */

   stat = rtXmlEncBool (pctxt, pvalue->automaticExerciseApplicable
      , OSUTF8("automaticExerciseApplicable"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode equityValuation */

   stat = XmlEnc_EquityValuation (pctxt, &pvalue->equityValuation
      , OSUTF8("equityValuation"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode settlementDate */

   if (pvalue->m.settlementDatePresent) {
      stat = XmlEnc_AdjustableOrRelativeDate (pctxt, &pvalue->settlementDate
         , OSUTF8("settlementDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode settlementCurrency */

   stat = XmlEnc_Currency (pctxt, &pvalue->settlementCurrency
      , OSUTF8("settlementCurrency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode settlementPriceSource */

   if (pvalue->m.settlementPriceSourcePresent) {
      stat = XmlEnc_SettlementPriceSource (pctxt, &pvalue->
         settlementPriceSource, OSUTF8("settlementPriceSource"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode settlementType */

   if(pvalue->settlementType < 0 || pvalue->settlementType > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_SettlementTypeEnum (pctxt, pvalue->settlementType
      , OSUTF8("settlementType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode failureToDeliverApplicable */

   if (pvalue->m.failureToDeliverApplicablePresent) {
      stat = rtXmlEncBool (pctxt, pvalue->failureToDeliverApplicable
         , OSUTF8("failureToDeliverApplicable"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FXFeature_fxFeatureType                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FXFeature_fxFeatureType (OSCTXT* pctxt,
   FXFeature_fxFeatureType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode fxFeatureTypeScheme */

   if (pvalue->m.fxFeatureTypeSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->fxFeatureTypeScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FXFeature_fxFeatureType (OSCTXT* pctxt, 
   FXFeature_fxFeatureType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.fxFeatureTypeSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" fxFeatureTypeScheme=\""), 22);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->fxFeatureTypeScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FXFeature                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FXFeature (OSCTXT* pctxt,
   FXFeature *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode fxSource */

   if (pvalue->m.fxSourcePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_FxSpotRateSource_derivations (pctxt, &pvalue->fxSource, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode fxRate */

   if (pvalue->m.fxRatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_real (pctxt, &pvalue->fxRate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode fxFeatureType */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_FXFeature_fxFeatureType (pctxt, &pvalue->fxFeatureType, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FXFeature (OSCTXT* pctxt, FXFeature* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode fxFeatureType */

   stat = XmlEnc_FXFeature_fxFeatureType (pctxt, &pvalue->fxFeatureType
      , OSUTF8("fxFeatureType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode fxRate */

   if (pvalue->m.fxRatePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->fxRate, OSUTF8("fxRate"), nsPrefix
         , 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fxSource */

   if (pvalue->m.fxSourcePresent) {
      stat = XmlEnc_FxSpotRateSource_derivations (pctxt, &pvalue->fxSource
         , OSUTF8("fxSource"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AveragingInOutEnum                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AveragingInOutEnum (OSCTXT* pctxt,
   AveragingInOutEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_AveragingInOutEnum (OSCTXT* pctxt, AveragingInOutEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      AveragingInOutEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FrequencyTypeEnum                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FrequencyTypeEnum (OSCTXT* pctxt,
   FrequencyTypeEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_FrequencyTypeEnum (OSCTXT* pctxt, FrequencyTypeEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      FrequencyTypeEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySchedule                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySchedule (OSCTXT* pctxt,
   EquitySchedule *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode dayOfWeek */

   if (pvalue->m.dayOfWeekPresent) {
      if(pvalue->dayOfWeek < 0 || pvalue->dayOfWeek > 6)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         asn1E_WeeklyRollConventionEnum (pctxt, &pvalue->dayOfWeek, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode weekNumber */

   if (pvalue->m.weekNumberPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_real (pctxt, &pvalue->weekNumber, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode frequencyType */

   if(pvalue->frequencyType < 0 || pvalue->frequencyType > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
      asn1E_FrequencyTypeEnum (pctxt, &pvalue->frequencyType, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode frequency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_real (pctxt, &pvalue->frequency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode endDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_charstr (pctxt, pvalue->endDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode startDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_charstr (pctxt, pvalue->startDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquitySchedule (OSCTXT* pctxt, EquitySchedule* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode startDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->startDate
      , OSUTF8("startDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode endDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->endDate
      , OSUTF8("endDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode frequency */

   stat = rtXmlEncDouble (pctxt, pvalue->frequency
      , OSUTF8("frequency"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode frequencyType */

   if(pvalue->frequencyType < 0 || pvalue->frequencyType > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_FrequencyTypeEnum (pctxt, pvalue->frequencyType
      , OSUTF8("frequencyType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode weekNumber */

   if (pvalue->m.weekNumberPresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->weekNumber
         , OSUTF8("weekNumber"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode dayOfWeek */

   if (pvalue->m.dayOfWeekPresent) {
      if(pvalue->dayOfWeek < 0 || pvalue->dayOfWeek > 6)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_WeeklyRollConventionEnum (pctxt, pvalue->dayOfWeek
         , OSUTF8("dayOfWeek"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DateTimeList                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DateTimeList (OSCTXT* pctxt,
   DateTimeList *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DateTimeList.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = xe_charstr (pctxt, ((const char*)pnode1->data), ASN1EXPL, TM_UNIV|TM_PRIM|26);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DateTimeList (OSCTXT* pctxt, DateTimeList* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DateTimeList.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)
         ((const char*)pnode->data), OSUTF8("dateTime"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityAveragingPeriod_marketDisruption                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityAveragingPeriod_marketDisruption (OSCTXT* pctxt,
   EquityAveragingPeriod_marketDisruption *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode marketDisruptionScheme */

   if (pvalue->m.marketDisruptionSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->marketDisruptionScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityAveragingPeriod_marketDisruption (OSCTXT* pctxt, 
   EquityAveragingPeriod_marketDisruption* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.marketDisruptionSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" marketDisruptionScheme=\""), 25);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->marketDisruptionScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityAveragingPeriod                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityAveragingPeriod (OSCTXT* pctxt,
   EquityAveragingPeriod *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode marketDisruption */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_EquityAveragingPeriod_marketDisruption (pctxt, &pvalue->marketDisruption, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode averagingDateTimes */

   if (pvalue->m.averagingDateTimesPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_DateTimeList (pctxt, &pvalue->averagingDateTimes, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode schedule_list */

   pnode2 = pvalue->schedule_list.tail;
   while (0 != pnode2) {
      ll = asn1E_EquitySchedule (pctxt, ((EquitySchedule*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityAveragingPeriod (OSCTXT* pctxt, 
   EquityAveragingPeriod* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode schedule_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->schedule_list.head;
   while (0 != pnode) {
      stat = XmlEnc_EquitySchedule (pctxt, ((EquitySchedule*)pnode->data)
         , OSUTF8("schedule"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode averagingDateTimes */

   if (pvalue->m.averagingDateTimesPresent) {
      stat = XmlEnc_DateTimeList (pctxt, &pvalue->averagingDateTimes
         , OSUTF8("averagingDateTimes"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode marketDisruption */

   stat = XmlEnc_EquityAveragingPeriod_marketDisruption (pctxt, &pvalue->
      marketDisruption, OSUTF8("marketDisruption"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Asian                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Asian (OSCTXT* pctxt,
   Asian *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode averagingPeriodOut */

   if (pvalue->m.averagingPeriodOutPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_EquityAveragingPeriod (pctxt, &pvalue->averagingPeriodOut, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode averagingPeriodIn */

   if (pvalue->m.averagingPeriodInPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_EquityAveragingPeriod (pctxt, &pvalue->averagingPeriodIn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode strikeFactor */

   if (pvalue->m.strikeFactorPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_real (pctxt, &pvalue->strikeFactor, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode averagingInOut */

   if(pvalue->averagingInOut < 0 || pvalue->averagingInOut > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_AveragingInOutEnum (pctxt, &pvalue->averagingInOut, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Asian (OSCTXT* pctxt, Asian* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode averagingInOut */

   if(pvalue->averagingInOut < 0 || pvalue->averagingInOut > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_AveragingInOutEnum (pctxt, pvalue->averagingInOut
      , OSUTF8("averagingInOut"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode strikeFactor */

   if (pvalue->m.strikeFactorPresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->strikeFactor
         , OSUTF8("strikeFactor"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode averagingPeriodIn */

   if (pvalue->m.averagingPeriodInPresent) {
      stat = XmlEnc_EquityAveragingPeriod (pctxt, &pvalue->averagingPeriodIn
         , OSUTF8("averagingPeriodIn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode averagingPeriodOut */

   if (pvalue->m.averagingPeriodOutPresent) {
      stat = XmlEnc_EquityAveragingPeriod (pctxt, &pvalue->averagingPeriodOut
         , OSUTF8("averagingPeriodOut"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Trigger                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Trigger (OSCTXT* pctxt,
   Trigger *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            xe_real (pctxt, &pvalue->u.level, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
            xe_real (pctxt, &pvalue->u.levelPercentage, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   if (tagging == ASN1EXPL) {
      ll1 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll1);
      if (ll1 < 0) return LOG_RTERR (pctxt, ll1);
   }

   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Trigger (OSCTXT* pctxt, Trigger* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode level */

         stat = rtXmlEncDouble (pctxt, pvalue->u.level
            , OSUTF8("level"), nsPrefix, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode levelPercentage */

         stat = rtXmlEncDouble (pctxt, pvalue->u.levelPercentage
            , OSUTF8("levelPercentage"), nsPrefix, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeaturePayment_choice                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FeaturePayment_choice (OSCTXT* pctxt,
   FeaturePayment_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            xe_real (pctxt, &pvalue->u.levelPercentage, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
            xe_real (pctxt, &pvalue->u.amount, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_FeaturePayment_choice (OSCTXT* pctxt, 
   FeaturePayment_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode levelPercentage */

         stat = rtXmlEncDouble (pctxt, pvalue->u.levelPercentage
            , OSUTF8("levelPercentage"), nsPrefix, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode amount */

         stat = rtXmlEncDouble (pctxt, pvalue->u.amount
            , OSUTF8("amount"), nsPrefix, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeaturePayment                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FeaturePayment (OSCTXT* pctxt,
   FeaturePayment *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode featurePaymentDate */

   if (pvalue->m.featurePaymentDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_AdjustableOrRelativeDate (pctxt, &pvalue->featurePaymentDate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Currency (pctxt, &pvalue->currency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode time_ */

   if (pvalue->m.time_Present) {
      if(pvalue->time_ < 0 || pvalue->time_ > 4)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         asn1E_TimeTypeEnum (pctxt, &pvalue->time_, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_FeaturePayment_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode payerReceiver_model */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FeaturePayment (OSCTXT* pctxt, FeaturePayment* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode payerReceiver_model */

   stat = XmlEnc_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode choice */

   stat = XmlEnc_FeaturePayment_choice (pctxt, &pvalue->choice
      , OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode time_ */

   if (pvalue->m.time_Present) {
      if(pvalue->time_ < 0 || pvalue->time_ > 4)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_TimeTypeEnum (pctxt, pvalue->time_
         , OSUTF8("time"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode currency */

   if (pvalue->m.currencyPresent) {
      stat = XmlEnc_Currency (pctxt, &pvalue->currency
         , OSUTF8("currency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode featurePaymentDate */

   if (pvalue->m.featurePaymentDatePresent) {
      stat = XmlEnc_AdjustableOrRelativeDate (pctxt, &pvalue->
         featurePaymentDate, OSUTF8("featurePaymentDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TriggerEvent                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TriggerEvent (OSCTXT* pctxt,
   TriggerEvent *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode featurePayment */

   if (pvalue->m.featurePaymentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_FeaturePayment (pctxt, &pvalue->featurePayment, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode trigger */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_Trigger (pctxt, &pvalue->trigger, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode triggerDates */

   if (pvalue->m.triggerDatesPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_DateList (pctxt, &pvalue->triggerDates, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode schedule_list */

   pnode2 = pvalue->schedule_list.tail;
   while (0 != pnode2) {
      ll = asn1E_EquitySchedule (pctxt, ((EquitySchedule*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TriggerEvent (OSCTXT* pctxt, TriggerEvent* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode schedule_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->schedule_list.head;
   while (0 != pnode) {
      stat = XmlEnc_EquitySchedule (pctxt, ((EquitySchedule*)pnode->data)
         , OSUTF8("schedule"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode triggerDates */

   if (pvalue->m.triggerDatesPresent) {
      stat = XmlEnc_DateList (pctxt, &pvalue->triggerDates
         , OSUTF8("triggerDates"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode trigger */

   stat = XmlEnc_Trigger (pctxt, &pvalue->trigger
      , OSUTF8("trigger"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode featurePayment */

   if (pvalue->m.featurePaymentPresent) {
      stat = XmlEnc_FeaturePayment (pctxt, &pvalue->featurePayment
         , OSUTF8("featurePayment"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Barrier                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Barrier (OSCTXT* pctxt,
   Barrier *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode barrierFloor */

   if (pvalue->m.barrierFloorPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_TriggerEvent (pctxt, &pvalue->barrierFloor, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode barrierCap */

   if (pvalue->m.barrierCapPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_TriggerEvent (pctxt, &pvalue->barrierCap, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Barrier (OSCTXT* pctxt, Barrier* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode barrierCap */

   if (pvalue->m.barrierCapPresent) {
      stat = XmlEnc_TriggerEvent (pctxt, &pvalue->barrierCap
         , OSUTF8("barrierCap"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode barrierFloor */

   if (pvalue->m.barrierFloorPresent) {
      stat = XmlEnc_TriggerEvent (pctxt, &pvalue->barrierFloor
         , OSUTF8("barrierFloor"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Knock                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Knock (OSCTXT* pctxt,
   Knock *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode knockOut */

   if (pvalue->m.knockOutPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_TriggerEvent (pctxt, &pvalue->knockOut, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode knockIn */

   if (pvalue->m.knockInPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_TriggerEvent (pctxt, &pvalue->knockIn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Knock (OSCTXT* pctxt, Knock* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode knockIn */

   if (pvalue->m.knockInPresent) {
      stat = XmlEnc_TriggerEvent (pctxt, &pvalue->knockIn
         , OSUTF8("knockIn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode knockOut */

   if (pvalue->m.knockOutPresent) {
      stat = XmlEnc_TriggerEvent (pctxt, &pvalue->knockOut
         , OSUTF8("knockOut"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityOptionFeatures                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityOptionFeatures (OSCTXT* pctxt,
   EquityOptionFeatures *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode knock */

   if (pvalue->m.knockPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Knock (pctxt, &pvalue->knock, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode barrier */

   if (pvalue->m.barrierPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Barrier (pctxt, &pvalue->barrier, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode asian */

   if (pvalue->m.asianPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Asian (pctxt, &pvalue->asian, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityOptionFeatures (OSCTXT* pctxt, EquityOptionFeatures* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode asian */

   if (pvalue->m.asianPresent) {
      stat = XmlEnc_Asian (pctxt, &pvalue->asian, OSUTF8("asian"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode barrier */

   if (pvalue->m.barrierPresent) {
      stat = XmlEnc_Barrier (pctxt, &pvalue->barrier
         , OSUTF8("barrier"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode knock */

   if (pvalue->m.knockPresent) {
      stat = XmlEnc_Knock (pctxt, &pvalue->knock, OSUTF8("knock"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityPremium                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityPremium (OSCTXT* pctxt,
   EquityPremium *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode percentageOfNotional */

   if (pvalue->m.percentageOfNotionalPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         xe_real (pctxt, &pvalue->percentageOfNotional, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode pricePerOption */

   if (pvalue->m.pricePerOptionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_real (pctxt, &pvalue->pricePerOption, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode swapPremium */

   if (pvalue->m.swapPremiumPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_boolean (pctxt, &pvalue->swapPremium, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode paymentDate */

   if (pvalue->m.paymentDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_AdjustableDate (pctxt, &pvalue->paymentDate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode paymentAmount */

   if (pvalue->m.paymentAmountPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Money_derivations (pctxt, &pvalue->paymentAmount, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode payerReceiver_model */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityPremium (OSCTXT* pctxt, EquityPremium* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode payerReceiver_model */

   stat = XmlEnc_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode paymentAmount */

   if (pvalue->m.paymentAmountPresent) {
      stat = XmlEnc_Money_derivations (pctxt, &pvalue->paymentAmount
         , OSUTF8("paymentAmount"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode paymentDate */

   if (pvalue->m.paymentDatePresent) {
      stat = XmlEnc_AdjustableDate (pctxt, &pvalue->paymentDate
         , OSUTF8("paymentDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode swapPremium */

   if (pvalue->m.swapPremiumPresent) {
      stat = rtXmlEncBool (pctxt, pvalue->swapPremium
         , OSUTF8("swapPremium"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode pricePerOption */

   if (pvalue->m.pricePerOptionPresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->pricePerOption
         , OSUTF8("pricePerOption"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode percentageOfNotional */

   if (pvalue->m.percentageOfNotionalPresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->percentageOfNotional
         , OSUTF8("percentageOfNotional"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MethodOfAdjustmentEnum                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MethodOfAdjustmentEnum (OSCTXT* pctxt,
   MethodOfAdjustmentEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_MethodOfAdjustmentEnum (OSCTXT* pctxt, 
   MethodOfAdjustmentEnum value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      MethodOfAdjustmentEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ShareExtraordinaryEventEnum                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ShareExtraordinaryEventEnum (OSCTXT* pctxt,
   ShareExtraordinaryEventEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ShareExtraordinaryEventEnum (OSCTXT* pctxt, 
   ShareExtraordinaryEventEnum value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      ShareExtraordinaryEventEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MergerEvents                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MergerEvents (OSCTXT* pctxt,
   MergerEvents *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode shareForCombined */

   if(pvalue->shareForCombined < 0 || pvalue->shareForCombined > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      asn1E_ShareExtraordinaryEventEnum (pctxt, &pvalue->shareForCombined, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode shareForOther */

   if(pvalue->shareForOther < 0 || pvalue->shareForOther > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_ShareExtraordinaryEventEnum (pctxt, &pvalue->shareForOther, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode shareForShare */

   if(pvalue->shareForShare < 0 || pvalue->shareForShare > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_ShareExtraordinaryEventEnum (pctxt, &pvalue->shareForShare, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MergerEvents (OSCTXT* pctxt, MergerEvents* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode shareForShare */

   if(pvalue->shareForShare < 0 || pvalue->shareForShare > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_ShareExtraordinaryEventEnum (pctxt, pvalue->shareForShare
      , OSUTF8("shareForShare"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode shareForOther */

   if(pvalue->shareForOther < 0 || pvalue->shareForOther > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_ShareExtraordinaryEventEnum (pctxt, pvalue->shareForOther
      , OSUTF8("shareForOther"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode shareForCombined */

   if(pvalue->shareForCombined < 0 || pvalue->shareForCombined > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_ShareExtraordinaryEventEnum (pctxt, pvalue->shareForCombined
      , OSUTF8("shareForCombined"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NationalisationOrInsolvencyOrDelistingEventEnum           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_NationalisationOrInsolvencyOrDelistingEventEnum (OSCTXT* pctxt,
   NationalisationOrInsolvencyOrDelistingEventEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_NationalisationOrInsolvencyOrDelistingEventEnum (OSCTXT* pctxt, 
   NationalisationOrInsolvencyOrDelistingEventEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      NationalisationOrInsolvencyOrDelistingEventEnum_ToString (value)
         , elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExtraordinaryEvents                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExtraordinaryEvents (OSCTXT* pctxt,
   ExtraordinaryEvents *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode delisting */

   if (pvalue->m.delistingPresent) {
      if(pvalue->delisting < 0 || pvalue->delisting > 1)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         asn1E_NationalisationOrInsolvencyOrDelistingEventEnum (pctxt, &pvalue->delisting, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode nationalisationOrInsolvency */

   if(pvalue->nationalisationOrInsolvency < 0 || pvalue->nationalisationOrInsolvency > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_NationalisationOrInsolvencyOrDelistingEventEnum (pctxt, &pvalue->nationalisationOrInsolvency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode mergerEvents */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_MergerEvents (pctxt, &pvalue->mergerEvents, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ExtraordinaryEvents (OSCTXT* pctxt, ExtraordinaryEvents* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode mergerEvents */

   stat = XmlEnc_MergerEvents (pctxt, &pvalue->mergerEvents
      , OSUTF8("mergerEvents"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode nationalisationOrInsolvency */

   if(pvalue->nationalisationOrInsolvency < 0 || pvalue->
      nationalisationOrInsolvency > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_NationalisationOrInsolvencyOrDelistingEventEnum (pctxt, pvalue
      ->nationalisationOrInsolvency
      , OSUTF8("nationalisationOrInsolvency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode delisting */

   if (pvalue->m.delistingPresent) {
      if(pvalue->delisting < 0 || pvalue->delisting > 1)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_NationalisationOrInsolvencyOrDelistingEventEnum (pctxt, 
         pvalue->delisting, OSUTF8("delisting"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityOption                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityOption (OSCTXT* pctxt,
   EquityOption *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode extraordinaryEvents */

   if (pvalue->m.extraordinaryEventsPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|17,
         asn1E_ExtraordinaryEvents (pctxt, &pvalue->extraordinaryEvents, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode methodOfAdjustment */

   if (pvalue->m.methodOfAdjustmentPresent) {
      if(pvalue->methodOfAdjustment < 0 || pvalue->methodOfAdjustment > 1)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|16,
         asn1E_MethodOfAdjustmentEnum (pctxt, &pvalue->methodOfAdjustment, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode equityPremium */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|15,
      asn1E_EquityPremium (pctxt, &pvalue->equityPremium, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode equityOptionFeatures */

   if (pvalue->m.equityOptionFeaturesPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|14,
         asn1E_EquityOptionFeatures (pctxt, &pvalue->equityOptionFeatures, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode fxFeature */

   if (pvalue->m.fxFeaturePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|13,
         asn1E_FXFeature (pctxt, &pvalue->fxFeature, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode equityExercise */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|12,
      asn1E_EquityExercise (pctxt, &pvalue->equityExercise, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode optionEntitlement */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|11,
      xe_real (pctxt, &pvalue->optionEntitlement, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode numberOfOptions */

   if (pvalue->m.numberOfOptionsPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|10,
         xe_real (pctxt, &pvalue->numberOfOptions, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode notional */

   if (pvalue->m.notionalPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9,
         asn1E_Money_derivations (pctxt, &pvalue->notional, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode spotPrice */

   if (pvalue->m.spotPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|8,
         xe_real (pctxt, &pvalue->spotPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode strike */

   if (pvalue->m.strikePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_EquityStrike (pctxt, &pvalue->strike, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode underlyer */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_Underlyer (pctxt, &pvalue->underlyer, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode equityEffectiveDate */

   if (pvalue->m.equityEffectiveDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         xe_charstr (pctxt, pvalue->equityEffectiveDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode optionType */

   if(pvalue->optionType < 0 || pvalue->optionType > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
      asn1E_OptionTypeEnum (pctxt, &pvalue->optionType, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode buyerSeller_model */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_BuyerSeller_model (pctxt, &pvalue->buyerSeller_model, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode productId_list */

   pnode2 = pvalue->productId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ProductId (pctxt, ((ProductId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ProductType (pctxt, &pvalue->productType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityOption (OSCTXT* pctxt, EquityOption* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      stat = XmlEnc_ProductType (pctxt, &pvalue->productType
         , OSUTF8("productType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode productId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->productId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ProductId (pctxt, ((ProductId*)pnode->data)
         , OSUTF8("productId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode buyerSeller_model */

   stat = XmlEnc_BuyerSeller_model (pctxt, &pvalue->buyerSeller_model
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode optionType */

   if(pvalue->optionType < 0 || pvalue->optionType > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_OptionTypeEnum (pctxt, pvalue->optionType
      , OSUTF8("optionType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode equityEffectiveDate */

   if (pvalue->m.equityEffectiveDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         equityEffectiveDate, OSUTF8("equityEffectiveDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode underlyer */

   stat = XmlEnc_Underlyer (pctxt, &pvalue->underlyer
      , OSUTF8("underlyer"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode strike */

   if (pvalue->m.strikePresent) {
      stat = XmlEnc_EquityStrike (pctxt, &pvalue->strike
         , OSUTF8("strike"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode spotPrice */

   if (pvalue->m.spotPricePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->spotPrice
         , OSUTF8("spotPrice"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode notional */

   if (pvalue->m.notionalPresent) {
      stat = XmlEnc_Money_derivations (pctxt, &pvalue->notional
         , OSUTF8("notional"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode numberOfOptions */

   if (pvalue->m.numberOfOptionsPresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->numberOfOptions
         , OSUTF8("numberOfOptions"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode optionEntitlement */

   stat = rtXmlEncDouble (pctxt, pvalue->optionEntitlement
      , OSUTF8("optionEntitlement"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode equityExercise */

   stat = XmlEnc_EquityExercise (pctxt, &pvalue->equityExercise
      , OSUTF8("equityExercise"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode fxFeature */

   if (pvalue->m.fxFeaturePresent) {
      stat = XmlEnc_FXFeature (pctxt, &pvalue->fxFeature
         , OSUTF8("fxFeature"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode equityOptionFeatures */

   if (pvalue->m.equityOptionFeaturesPresent) {
      stat = XmlEnc_EquityOptionFeatures (pctxt, &pvalue->equityOptionFeatures
         , OSUTF8("equityOptionFeatures"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode equityPremium */

   stat = XmlEnc_EquityPremium (pctxt, &pvalue->equityPremium
      , OSUTF8("equityPremium"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode methodOfAdjustment */

   if (pvalue->m.methodOfAdjustmentPresent) {
      if(pvalue->methodOfAdjustment < 0 || pvalue->methodOfAdjustment > 1)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_MethodOfAdjustmentEnum (pctxt, pvalue->methodOfAdjustment
         , OSUTF8("methodOfAdjustment"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode extraordinaryEvents */

   if (pvalue->m.extraordinaryEventsPresent) {
      stat = XmlEnc_ExtraordinaryEvents (pctxt, &pvalue->extraordinaryEvents
         , OSUTF8("extraordinaryEvents"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg_valuation_initialPrice_sequence_fxConversion    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg_valuation_initialPrice_sequence_fxConversion (OSCTXT* pctxt,
   EquityLeg_valuation_initialPrice_sequence_fxConversion *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         if (!(pvalue->u.fxRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "EquityLeg_valuation_initialPrice_sequence_fxConversion.u.fxRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         pnode2 = pvalue->u.fxRate_list->tail;
         while (0 != pnode2) {
            ll = asn1E_FxRate_derivations (pctxt, ((FxRate_derivations*)pnode2->data), ASN1EXPL);
            if (ll < 0) return LOG_RTERR (pctxt, ll);
            ll2 += ll;

            pnode2 = pnode2->prev;
         }
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else { ll1 += ll; ll2 = 0; }
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquityLeg_valuation_initialPrice_sequence_fxConversion 
   (OSCTXT* pctxt, 
   EquityLeg_valuation_initialPrice_sequence_fxConversion* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode fxRate_list */

         if (!(pvalue->u.fxRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "EquityLeg_valuation_initialPrice_sequence_fxConversion.u.fxRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         { const OSUTF8CHAR* savedPrefix = nsPrefix;
         nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
            "http://www.fpml.org/2003/FpML-4-0"));

         { OSRTDListNode* pnode = pvalue->u.fxRate_list->head;
         while (0 != pnode) {
            stat = XmlEnc_FxRate_derivations (pctxt, 
               ((FxRate_derivations*)pnode->data)
               , OSUTF8("fxRate"), nsPrefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            pnode = pnode->next;
         }}
         nsPrefix = savedPrefix;
         }

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg_valuation_initialPrice_sequence                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg_valuation_initialPrice_sequence (OSCTXT* pctxt,
   EquityLeg_valuation_initialPrice_sequence *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode fxConversion */

   if (pvalue->m.fxConversionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_EquityLeg_valuation_initialPrice_sequence_fxConversion (pctxt, &pvalue->fxConversion, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode accruedInterestPrice */

   if (pvalue->m.accruedInterestPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_real (pctxt, &pvalue->accruedInterestPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode netPrice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_ActualPrice (pctxt, &pvalue->netPrice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode grossPrice */

   if (pvalue->m.grossPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ActualPrice (pctxt, &pvalue->grossPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityLeg_valuation_initialPrice_sequence (OSCTXT* pctxt, 
   EquityLeg_valuation_initialPrice_sequence* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode grossPrice */

   if (pvalue->m.grossPricePresent) {
      stat = XmlEnc_ActualPrice (pctxt, &pvalue->grossPrice
         , OSUTF8("grossPrice"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode netPrice */

   stat = XmlEnc_ActualPrice (pctxt, &pvalue->netPrice
      , OSUTF8("netPrice"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode accruedInterestPrice */

   if (pvalue->m.accruedInterestPricePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->accruedInterestPrice
         , OSUTF8("accruedInterestPrice"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fxConversion */

   if (pvalue->m.fxConversionPresent) {
      stat = XmlEnc_EquityLeg_valuation_initialPrice_sequence_fxConversion (pctxt
         , &pvalue->fxConversion, OSUTF8("fxConversion"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg_valuation_initialPrice_choice                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg_valuation_initialPrice_choice (OSCTXT* pctxt,
   EquityLeg_valuation_initialPrice_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            xe_utf8str (pctxt, pvalue->u.determinationMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_EquityLeg_valuation_initialPrice_sequence (pctxt, pvalue->u.sequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquityLeg_valuation_initialPrice_choice (OSCTXT* pctxt, 
   EquityLeg_valuation_initialPrice_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode determinationMethod */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.determinationMethod
            , OSUTF8("determinationMethod"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode sequence */

         stat = XmlEnc_EquityLeg_valuation_initialPrice_sequence (pctxt, pvalue
            ->u.sequence, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg_valuation_initialPrice_equityValuationDate      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg_valuation_initialPrice_equityValuationDate (OSCTXT* pctxt,
   EquityLeg_valuation_initialPrice_equityValuationDate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AdjustableDate (pctxt, pvalue->u.adjustableDate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_RelativeDateSequence (pctxt, pvalue->u.relativeDateSequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquityLeg_valuation_initialPrice_equityValuationDate 
   (OSCTXT* pctxt, 
   EquityLeg_valuation_initialPrice_equityValuationDate* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode adjustableDate */

         stat = XmlEnc_AdjustableDate (pctxt, pvalue->u.adjustableDate
            , OSUTF8("adjustableDate"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode relativeDateSequence */

         stat = XmlEnc_RelativeDateSequence (pctxt, pvalue->
            u.relativeDateSequence, OSUTF8("relativeDateSequence"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg_valuation_initialPrice                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg_valuation_initialPrice (OSCTXT* pctxt,
   EquityLeg_valuation_initialPrice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode equityValuationDate */

   if (pvalue->m.equityValuationDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_EquityLeg_valuation_initialPrice_equityValuationDate (pctxt, &pvalue->equityValuationDate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_BusinessCenterTime (pctxt, &pvalue->valuationTime, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode valuationTimeType */

   if (pvalue->m.valuationTimeTypePresent) {
      if(pvalue->valuationTimeType < 0 || pvalue->valuationTimeType > 4)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         asn1E_TimeTypeEnum (pctxt, &pvalue->valuationTimeType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_EquityLeg_valuation_initialPrice_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode commission */

   if (pvalue->m.commissionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Commission (pctxt, &pvalue->commission, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityLeg_valuation_initialPrice (OSCTXT* pctxt, 
   EquityLeg_valuation_initialPrice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode commission */

   if (pvalue->m.commissionPresent) {
      stat = XmlEnc_Commission (pctxt, &pvalue->commission
         , OSUTF8("commission"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode choice */

   stat = XmlEnc_EquityLeg_valuation_initialPrice_choice (pctxt, &pvalue->
      choice, OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode valuationTimeType */

   if (pvalue->m.valuationTimeTypePresent) {
      if(pvalue->valuationTimeType < 0 || pvalue->valuationTimeType > 4)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_TimeTypeEnum (pctxt, pvalue->valuationTimeType
         , OSUTF8("valuationTimeType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->valuationTime
         , OSUTF8("valuationTime"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode equityValuationDate */

   if (pvalue->m.equityValuationDatePresent) {
      stat = XmlEnc_EquityLeg_valuation_initialPrice_equityValuationDate (pctxt
         , &pvalue->equityValuationDate
         , OSUTF8("equityValuationDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg_valuation_valuationPriceInterim_sequence_fxCon  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg_valuation_valuationPriceInterim_sequence_fxConversion (OSCTXT* pctxt,
   EquityLeg_valuation_valuationPriceInterim_sequence_fxConversion *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         if (!(pvalue->u.fxRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "EquityLeg_valuation_valuationPriceInterim_sequence_fxConversion.u.fxRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         pnode2 = pvalue->u.fxRate_list->tail;
         while (0 != pnode2) {
            ll = asn1E_FxRate_derivations (pctxt, ((FxRate_derivations*)pnode2->data), ASN1EXPL);
            if (ll < 0) return LOG_RTERR (pctxt, ll);
            ll2 += ll;

            pnode2 = pnode2->prev;
         }
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else { ll1 += ll; ll2 = 0; }
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquityLeg_valuation_valuationPriceInterim_sequence_fxConversion 
   (OSCTXT* pctxt, 
   EquityLeg_valuation_valuationPriceInterim_sequence_fxConversion* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode fxRate_list */

         if (!(pvalue->u.fxRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "EquityLeg_valuation_valuationPriceInterim_sequence_fxConversion.u.fxRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         { const OSUTF8CHAR* savedPrefix = nsPrefix;
         nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
            "http://www.fpml.org/2003/FpML-4-0"));

         { OSRTDListNode* pnode = pvalue->u.fxRate_list->head;
         while (0 != pnode) {
            stat = XmlEnc_FxRate_derivations (pctxt, 
               ((FxRate_derivations*)pnode->data)
               , OSUTF8("fxRate"), nsPrefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            pnode = pnode->next;
         }}
         nsPrefix = savedPrefix;
         }

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg_valuation_valuationPriceInterim_sequence        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg_valuation_valuationPriceInterim_sequence (OSCTXT* pctxt,
   EquityLeg_valuation_valuationPriceInterim_sequence *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode fxConversion */

   if (pvalue->m.fxConversionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_EquityLeg_valuation_valuationPriceInterim_sequence_fxConversion (pctxt, &pvalue->fxConversion, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode accruedInterestPrice */

   if (pvalue->m.accruedInterestPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_real (pctxt, &pvalue->accruedInterestPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode netPrice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_ActualPrice (pctxt, &pvalue->netPrice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode grossPrice */

   if (pvalue->m.grossPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ActualPrice (pctxt, &pvalue->grossPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityLeg_valuation_valuationPriceInterim_sequence (OSCTXT* pctxt, 
   EquityLeg_valuation_valuationPriceInterim_sequence* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode grossPrice */

   if (pvalue->m.grossPricePresent) {
      stat = XmlEnc_ActualPrice (pctxt, &pvalue->grossPrice
         , OSUTF8("grossPrice"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode netPrice */

   stat = XmlEnc_ActualPrice (pctxt, &pvalue->netPrice
      , OSUTF8("netPrice"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode accruedInterestPrice */

   if (pvalue->m.accruedInterestPricePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->accruedInterestPrice
         , OSUTF8("accruedInterestPrice"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fxConversion */

   if (pvalue->m.fxConversionPresent) {
      stat = XmlEnc_EquityLeg_valuation_valuationPriceInterim_sequence_fxConversion (pctxt
         , &pvalue->fxConversion, OSUTF8("fxConversion"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg_valuation_valuationPriceInterim_choice          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg_valuation_valuationPriceInterim_choice (OSCTXT* pctxt,
   EquityLeg_valuation_valuationPriceInterim_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            xe_utf8str (pctxt, pvalue->u.determinationMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_EquityLeg_valuation_valuationPriceInterim_sequence (pctxt, pvalue->u.sequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquityLeg_valuation_valuationPriceInterim_choice (OSCTXT* pctxt, 
   EquityLeg_valuation_valuationPriceInterim_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode determinationMethod */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.determinationMethod
            , OSUTF8("determinationMethod"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode sequence */

         stat = XmlEnc_EquityLeg_valuation_valuationPriceInterim_sequence (pctxt
            , pvalue->u.sequence, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg_valuation_valuationPriceInterim                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg_valuation_valuationPriceInterim (OSCTXT* pctxt,
   EquityLeg_valuation_valuationPriceInterim *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode equityValuationDates */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_AdjustableRelativeOrPeriodicDates (pctxt, &pvalue->equityValuationDates, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_BusinessCenterTime (pctxt, &pvalue->valuationTime, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode valuationTimeType */

   if(pvalue->valuationTimeType < 0 || pvalue->valuationTimeType > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      asn1E_TimeTypeEnum (pctxt, &pvalue->valuationTimeType, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_EquityLeg_valuation_valuationPriceInterim_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode commission */

   if (pvalue->m.commissionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Commission (pctxt, &pvalue->commission, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityLeg_valuation_valuationPriceInterim (OSCTXT* pctxt, 
   EquityLeg_valuation_valuationPriceInterim* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode commission */

   if (pvalue->m.commissionPresent) {
      stat = XmlEnc_Commission (pctxt, &pvalue->commission
         , OSUTF8("commission"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode choice */

   stat = XmlEnc_EquityLeg_valuation_valuationPriceInterim_choice (pctxt, &
      pvalue->choice, OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode valuationTimeType */

   if(pvalue->valuationTimeType < 0 || pvalue->valuationTimeType > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TimeTypeEnum (pctxt, pvalue->valuationTimeType
      , OSUTF8("valuationTimeType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->valuationTime
         , OSUTF8("valuationTime"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode equityValuationDates */

   stat = XmlEnc_AdjustableRelativeOrPeriodicDates (pctxt, &pvalue->
      equityValuationDates, OSUTF8("equityValuationDates"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg_valuation_valuationPriceFinal_sequence_fxConve  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg_valuation_valuationPriceFinal_sequence_fxConversion (OSCTXT* pctxt,
   EquityLeg_valuation_valuationPriceFinal_sequence_fxConversion *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         if (!(pvalue->u.fxRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "EquityLeg_valuation_valuationPriceFinal_sequence_fxConversion.u.fxRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         pnode2 = pvalue->u.fxRate_list->tail;
         while (0 != pnode2) {
            ll = asn1E_FxRate_derivations (pctxt, ((FxRate_derivations*)pnode2->data), ASN1EXPL);
            if (ll < 0) return LOG_RTERR (pctxt, ll);
            ll2 += ll;

            pnode2 = pnode2->prev;
         }
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else { ll1 += ll; ll2 = 0; }
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquityLeg_valuation_valuationPriceFinal_sequence_fxConversion 
   (OSCTXT* pctxt, 
   EquityLeg_valuation_valuationPriceFinal_sequence_fxConversion* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode fxRate_list */

         if (!(pvalue->u.fxRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "EquityLeg_valuation_valuationPriceFinal_sequence_fxConversion.u.fxRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         { const OSUTF8CHAR* savedPrefix = nsPrefix;
         nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
            "http://www.fpml.org/2003/FpML-4-0"));

         { OSRTDListNode* pnode = pvalue->u.fxRate_list->head;
         while (0 != pnode) {
            stat = XmlEnc_FxRate_derivations (pctxt, 
               ((FxRate_derivations*)pnode->data)
               , OSUTF8("fxRate"), nsPrefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            pnode = pnode->next;
         }}
         nsPrefix = savedPrefix;
         }

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg_valuation_valuationPriceFinal_sequence          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg_valuation_valuationPriceFinal_sequence (OSCTXT* pctxt,
   EquityLeg_valuation_valuationPriceFinal_sequence *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode fxConversion */

   if (pvalue->m.fxConversionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_EquityLeg_valuation_valuationPriceFinal_sequence_fxConversion (pctxt, &pvalue->fxConversion, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode accruedInterestPrice */

   if (pvalue->m.accruedInterestPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_real (pctxt, &pvalue->accruedInterestPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode netPrice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_ActualPrice (pctxt, &pvalue->netPrice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode grossPrice */

   if (pvalue->m.grossPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ActualPrice (pctxt, &pvalue->grossPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityLeg_valuation_valuationPriceFinal_sequence (OSCTXT* pctxt, 
   EquityLeg_valuation_valuationPriceFinal_sequence* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode grossPrice */

   if (pvalue->m.grossPricePresent) {
      stat = XmlEnc_ActualPrice (pctxt, &pvalue->grossPrice
         , OSUTF8("grossPrice"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode netPrice */

   stat = XmlEnc_ActualPrice (pctxt, &pvalue->netPrice
      , OSUTF8("netPrice"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode accruedInterestPrice */

   if (pvalue->m.accruedInterestPricePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->accruedInterestPrice
         , OSUTF8("accruedInterestPrice"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fxConversion */

   if (pvalue->m.fxConversionPresent) {
      stat = XmlEnc_EquityLeg_valuation_valuationPriceFinal_sequence_fxConversion (pctxt
         , &pvalue->fxConversion, OSUTF8("fxConversion"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg_valuation_valuationPriceFinal_choice            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg_valuation_valuationPriceFinal_choice (OSCTXT* pctxt,
   EquityLeg_valuation_valuationPriceFinal_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            xe_utf8str (pctxt, pvalue->u.determinationMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_EquityLeg_valuation_valuationPriceFinal_sequence (pctxt, pvalue->u.sequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquityLeg_valuation_valuationPriceFinal_choice (OSCTXT* pctxt, 
   EquityLeg_valuation_valuationPriceFinal_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode determinationMethod */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.determinationMethod
            , OSUTF8("determinationMethod"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode sequence */

         stat = XmlEnc_EquityLeg_valuation_valuationPriceFinal_sequence (pctxt
            , pvalue->u.sequence, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg_valuation_valuationPriceFinal_equityValuationD  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg_valuation_valuationPriceFinal_equityValuationDate (OSCTXT* pctxt,
   EquityLeg_valuation_valuationPriceFinal_equityValuationDate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AdjustableDate (pctxt, pvalue->u.adjustableDate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_RelativeDateSequence (pctxt, pvalue->u.relativeDateSequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquityLeg_valuation_valuationPriceFinal_equityValuationDate 
   (OSCTXT* pctxt, 
   EquityLeg_valuation_valuationPriceFinal_equityValuationDate* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode adjustableDate */

         stat = XmlEnc_AdjustableDate (pctxt, pvalue->u.adjustableDate
            , OSUTF8("adjustableDate"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode relativeDateSequence */

         stat = XmlEnc_RelativeDateSequence (pctxt, pvalue->
            u.relativeDateSequence, OSUTF8("relativeDateSequence"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg_valuation_valuationPriceFinal                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg_valuation_valuationPriceFinal (OSCTXT* pctxt,
   EquityLeg_valuation_valuationPriceFinal *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode equityValuationDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_EquityLeg_valuation_valuationPriceFinal_equityValuationDate (pctxt, &pvalue->equityValuationDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_BusinessCenterTime (pctxt, &pvalue->valuationTime, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode valuationTimeType */

   if (pvalue->m.valuationTimeTypePresent) {
      if(pvalue->valuationTimeType < 0 || pvalue->valuationTimeType > 4)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         asn1E_TimeTypeEnum (pctxt, &pvalue->valuationTimeType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_EquityLeg_valuation_valuationPriceFinal_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode commission */

   if (pvalue->m.commissionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Commission (pctxt, &pvalue->commission, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityLeg_valuation_valuationPriceFinal (OSCTXT* pctxt, 
   EquityLeg_valuation_valuationPriceFinal* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode commission */

   if (pvalue->m.commissionPresent) {
      stat = XmlEnc_Commission (pctxt, &pvalue->commission
         , OSUTF8("commission"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode choice */

   stat = XmlEnc_EquityLeg_valuation_valuationPriceFinal_choice (pctxt, &pvalue
      ->choice, OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode valuationTimeType */

   if (pvalue->m.valuationTimeTypePresent) {
      if(pvalue->valuationTimeType < 0 || pvalue->valuationTimeType > 4)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_TimeTypeEnum (pctxt, pvalue->valuationTimeType
         , OSUTF8("valuationTimeType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->valuationTime
         , OSUTF8("valuationTime"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode equityValuationDate */

   stat = XmlEnc_EquityLeg_valuation_valuationPriceFinal_equityValuationDate (pctxt
      , &pvalue->equityValuationDate
      , OSUTF8("equityValuationDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityPaymentDates                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityPaymentDates (OSCTXT* pctxt,
   EquityPaymentDates *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode equityPaymentDateFinal */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_AdjustableOrRelativeDate (pctxt, &pvalue->equityPaymentDateFinal, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode equityPaymentDatesInterim */

   if (pvalue->m.equityPaymentDatesInterimPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_AdjustableOrRelativeDates (pctxt, &pvalue->equityPaymentDatesInterim, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityPaymentDates (OSCTXT* pctxt, EquityPaymentDates* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode equityPaymentDatesInterim */

   if (pvalue->m.equityPaymentDatesInterimPresent) {
      stat = XmlEnc_AdjustableOrRelativeDates (pctxt, &pvalue->
         equityPaymentDatesInterim
         , OSUTF8("equityPaymentDatesInterim"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode equityPaymentDateFinal */

   stat = XmlEnc_AdjustableOrRelativeDate (pctxt, &pvalue->
      equityPaymentDateFinal, OSUTF8("equityPaymentDateFinal"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg_valuation                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg_valuation (OSCTXT* pctxt,
   EquityLeg_valuation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode equityPaymentDates */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_EquityPaymentDates (pctxt, &pvalue->equityPaymentDates, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode valuationPriceFinal */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_EquityLeg_valuation_valuationPriceFinal (pctxt, &pvalue->valuationPriceFinal, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode valuationPriceInterim */

   if (pvalue->m.valuationPriceInterimPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_EquityLeg_valuation_valuationPriceInterim (pctxt, &pvalue->valuationPriceInterim, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode equityNotionalReset */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_boolean (pctxt, &pvalue->equityNotionalReset, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode initialPrice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_EquityLeg_valuation_initialPrice (pctxt, &pvalue->initialPrice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityLeg_valuation (OSCTXT* pctxt, EquityLeg_valuation* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode initialPrice */

   stat = XmlEnc_EquityLeg_valuation_initialPrice (pctxt, &pvalue->initialPrice
      , OSUTF8("initialPrice"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode equityNotionalReset */

   stat = rtXmlEncBool (pctxt, pvalue->equityNotionalReset
      , OSUTF8("equityNotionalReset"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode valuationPriceInterim */

   if (pvalue->m.valuationPriceInterimPresent) {
      stat = XmlEnc_EquityLeg_valuation_valuationPriceInterim (pctxt, &pvalue->
         valuationPriceInterim, OSUTF8("valuationPriceInterim"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode valuationPriceFinal */

   stat = XmlEnc_EquityLeg_valuation_valuationPriceFinal (pctxt, &pvalue->
      valuationPriceFinal, OSUTF8("valuationPriceFinal"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode equityPaymentDates */

   stat = XmlEnc_EquityPaymentDates (pctxt, &pvalue->equityPaymentDates
      , OSUTF8("equityPaymentDates"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg_notional                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg_notional (OSCTXT* pctxt,
   EquityLeg_notional *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            xe_utf8str (pctxt, pvalue->u.determinationMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_Money_derivations (pctxt, pvalue->u.notionalAmount, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquityLeg_notional (OSCTXT* pctxt, EquityLeg_notional* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode determinationMethod */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.determinationMethod
            , OSUTF8("determinationMethod"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode notionalAmount */

         stat = XmlEnc_Money_derivations (pctxt, pvalue->u.notionalAmount
            , OSUTF8("notionalAmount"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg_equityAmount_paymentCurrency_choice             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg_equityAmount_paymentCurrency_choice (OSCTXT* pctxt,
   EquityLeg_equityAmount_paymentCurrency_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_Currency (pctxt, pvalue->u.currency, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
            xe_utf8str (pctxt, pvalue->u.determinationMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquityLeg_equityAmount_paymentCurrency_choice (OSCTXT* pctxt, 
   EquityLeg_equityAmount_paymentCurrency_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode currency */

         stat = XmlEnc_Currency (pctxt, pvalue->u.currency
            , OSUTF8("currency"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode determinationMethod */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.determinationMethod
            , OSUTF8("determinationMethod"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg_equityAmount_paymentCurrency                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg_equityAmount_paymentCurrency (OSCTXT* pctxt,
   EquityLeg_equityAmount_paymentCurrency *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode choice */

   if (pvalue->m.choicePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_EquityLeg_equityAmount_paymentCurrency_choice (pctxt, &pvalue->choice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode href */

   if (pvalue->m.hrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->href, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityLeg_equityAmount_paymentCurrency (OSCTXT* pctxt, 
   EquityLeg_equityAmount_paymentCurrency* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.hrefPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->href, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode choice */

   if (pvalue->m.choicePresent) {
      stat = XmlEnc_EquityLeg_equityAmount_paymentCurrency_choice (pctxt, &
         pvalue->choice, OSUTF8(""), 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg_equityAmount_referenceAmount                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg_equityAmount_referenceAmount (OSCTXT* pctxt,
   EquityLeg_equityAmount_referenceAmount *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode href */

   if (pvalue->m.hrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->href, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityLeg_equityAmount_referenceAmount (OSCTXT* pctxt, 
   EquityLeg_equityAmount_referenceAmount* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.hrefPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->href, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Formula_formulaComponent                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Formula_formulaComponent (OSCTXT* pctxt,
   Formula_formulaComponent *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode formula */

   if (pvalue->m.formulaPresent) {
      if (pvalue->formula == NULL) {
         rtxErrAddStrParm (pctxt, "pvalue->formula");
         return LOG_RTERR (pctxt, RTERR_NULLPTR);
      }
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Formula (pctxt, (Formula*)pvalue->formula, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode componentDescription */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_utf8str (pctxt, pvalue->componentDescription, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode href */

   if (pvalue->m.hrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->href, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Formula_formulaComponent (OSCTXT* pctxt, 
   Formula_formulaComponent* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.hrefPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->href, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode componentDescription */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->componentDescription
      , OSUTF8("componentDescription"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode formula */

   if (pvalue->m.formulaPresent) {
      stat = XmlEnc_Formula (pctxt, pvalue->formula
         , OSUTF8("formula"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Formula                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Formula (OSCTXT* pctxt,
   Formula *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode formulaComponent_list */

   pnode2 = pvalue->formulaComponent_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Formula_formulaComponent (pctxt, ((Formula_formulaComponent*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode math */

   if (pvalue->m.mathPresent) {
      if (!(pvalue->math.count >= 1U)) {
         rtxErrAddStrParm (pctxt, "Formula.math.count");
         rtxErrAddIntParm (pctxt, (int)pvalue->math.count);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      pnode2 = pvalue->math.tail;
      while (0 != pnode2) {
         switch (((OSXSDAny*)pnode2->data)->t) {
         case OSXSDAny_binary:
            ll = xe_OpenType (pctxt, ((OSXSDAny*)pnode2->data)->
               u.binary->data, ((OSXSDAny*)pnode2->data)->u.binary->numocts);
            break;
         case OSXSDAny_xmlText:
            ll = xe_utf8str (pctxt, ((OSXSDAny*)pnode2->data)->
               u.xmlText, ASN1EXPL);
            break;
         }
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else ll2 += ll;

         pnode2 = pnode2->prev;
      }
      ll2 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
      if (ll2 < 0) return LOG_RTERR (pctxt, ll2);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      else { ll1 += ll; ll2 = 0; }
   }
   /* encode formulaDescription */

   if (pvalue->m.formulaDescriptionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->formulaDescription, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Formula (OSCTXT* pctxt, Formula* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode formulaDescription */

   if (pvalue->m.formulaDescriptionPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->formulaDescription
         , OSUTF8("formulaDescription"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode math */

   if (pvalue->m.mathPresent) {
      if (!(pvalue->math.count >= 1U)) {
         rtxErrAddStrParm (pctxt, "Formula.math.count");
         rtxErrAddIntParm (pctxt, (int)pvalue->math.count);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      if (OSUTF8("math") != 0) {
         stat = rtXmlEncStartElement (pctxt, OSUTF8("math"), nsPrefix, TRUE);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      { const OSUTF8CHAR* savedPrefix = nsPrefix;
      nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
         "http://www.fpml.org/2003/FpML-4-0"));

      { OSRTDListNode* pnode = pvalue->math.head;
      while (0 != pnode) {
         if (((OSXSDAny*)pnode->data)->t == OSXSDAny_xmlText) {
            stat = rtXmlEncAnyStr (pctxt, ((OSXSDAny*)pnode->data)->u.xmlText
               , OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
         }
         else {
            char buf[40];
            os_snprintf (buf, 40, "%d", ((OSXSDAny*)pnode->data)->t);
            rtxErrAddStrParm (pctxt, buf);
            return LOG_RTERR (pctxt, RTERR_INVOPT);
         }
         pnode = pnode->next;
      }}
      nsPrefix = savedPrefix;
      }

      stat = rtXmlEncEndElement (pctxt, OSUTF8("math"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode formulaComponent_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->formulaComponent_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Formula_formulaComponent (pctxt, 
         ((Formula_formulaComponent*)pnode->data)
         , OSUTF8("formulaComponent"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg_equityAmount_choice                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg_equityAmount_choice (OSCTXT* pctxt,
   EquityLeg_equityAmount_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_EquityLeg_equityAmount_referenceAmount (pctxt, pvalue->u.referenceAmount, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_Formula (pctxt, pvalue->u.formula, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
            xe_octstr (pctxt, pvalue->u.encodedDescription->data, pvalue->u.encodedDescription->numocts, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquityLeg_equityAmount_choice (OSCTXT* pctxt, 
   EquityLeg_equityAmount_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode referenceAmount */

         stat = XmlEnc_EquityLeg_equityAmount_referenceAmount (pctxt, pvalue->
            u.referenceAmount, OSUTF8("referenceAmount"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode formula */

         stat = XmlEnc_Formula (pctxt, pvalue->u.formula
            , OSUTF8("formula"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode encodedDescription */

         stat = rtXmlEncBase64Binary
            (pctxt, pvalue->u.encodedDescription->numocts, pvalue->
               u.encodedDescription->data, 
               OSUTF8("encodedDescription"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg_equityAmount                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg_equityAmount (OSCTXT* pctxt,
   EquityLeg_equityAmount *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode cashSettlement */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
      xe_boolean (pctxt, &pvalue->cashSettlement, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode calculationDates */

   if (pvalue->m.calculationDatesPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_AdjustableRelativeOrPeriodicDates (pctxt, &pvalue->calculationDates, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_EquityLeg_equityAmount_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode paymentCurrency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_EquityLeg_equityAmount_paymentCurrency (pctxt, &pvalue->paymentCurrency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityLeg_equityAmount (OSCTXT* pctxt, 
   EquityLeg_equityAmount* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode paymentCurrency */

   stat = XmlEnc_EquityLeg_equityAmount_paymentCurrency (pctxt, &pvalue->
      paymentCurrency, OSUTF8("paymentCurrency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode choice */

   stat = XmlEnc_EquityLeg_equityAmount_choice (pctxt, &pvalue->choice
      , OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode calculationDates */

   if (pvalue->m.calculationDatesPresent) {
      stat = XmlEnc_AdjustableRelativeOrPeriodicDates (pctxt, &pvalue->
         calculationDates, OSUTF8("calculationDates"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode cashSettlement */

   stat = rtXmlEncBool (pctxt, pvalue->cashSettlement
      , OSUTF8("cashSettlement"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReturnTypeEnum                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ReturnTypeEnum (OSCTXT* pctxt,
   ReturnTypeEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ReturnTypeEnum (OSCTXT* pctxt, ReturnTypeEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      ReturnTypeEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DividendEntitlementEnum                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DividendEntitlementEnum (OSCTXT* pctxt,
   DividendEntitlementEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_DividendEntitlementEnum (OSCTXT* pctxt, 
   DividendEntitlementEnum value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      DividendEntitlementEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DividendDateReferenceEnum                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DividendDateReferenceEnum (OSCTXT* pctxt,
   DividendDateReferenceEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 5)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_DividendDateReferenceEnum (OSCTXT* pctxt, 
   DividendDateReferenceEnum value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      DividendDateReferenceEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DividendPaymentDate                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DividendPaymentDate (OSCTXT* pctxt,
   DividendPaymentDate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         if(pvalue->u.dividendDateReference < 0 || pvalue->u.dividendDateReference > 5)
            return LOG_RTERR (pctxt, RTERR_INVENUM);

         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            asn1E_DividendDateReferenceEnum (pctxt, &pvalue->u.dividendDateReference, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_AdjustableDate (pctxt, pvalue->u.adjustableDate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   if (tagging == ASN1EXPL) {
      ll1 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll1);
      if (ll1 < 0) return LOG_RTERR (pctxt, ll1);
   }

   ll0 += ll1;

   return (ll0);
}

int XmlEnc_DividendPaymentDate (OSCTXT* pctxt, DividendPaymentDate* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode dividendDateReference */

         if(pvalue->u.dividendDateReference < 0 || pvalue->
            u.dividendDateReference > 5)
            return LOG_RTERR (pctxt, RTERR_INVENUM);

         stat = XmlEnc_DividendDateReferenceEnum (pctxt, pvalue->
            u.dividendDateReference
            , OSUTF8("dividendDateReference"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode adjustableDate */

         stat = XmlEnc_AdjustableDate (pctxt, pvalue->u.adjustableDate
            , OSUTF8("adjustableDate"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DividendConditions_dividendPeriodEffectiveDate            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DividendConditions_dividendPeriodEffectiveDate (OSCTXT* pctxt,
   DividendConditions_dividendPeriodEffectiveDate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode href */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->href, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DividendConditions_dividendPeriodEffectiveDate (OSCTXT* pctxt, 
   DividendConditions_dividendPeriodEffectiveDate* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->href, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DividendConditions_dividendPeriodEndDate                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DividendConditions_dividendPeriodEndDate (OSCTXT* pctxt,
   DividendConditions_dividendPeriodEndDate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode href */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->href, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DividendConditions_dividendPeriodEndDate (OSCTXT* pctxt, 
   DividendConditions_dividendPeriodEndDate* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->href, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DividendConditions_paymentCurrency_choice                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DividendConditions_paymentCurrency_choice (OSCTXT* pctxt,
   DividendConditions_paymentCurrency_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_Currency (pctxt, pvalue->u.currency, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
            xe_utf8str (pctxt, pvalue->u.determinationMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_DividendConditions_paymentCurrency_choice (OSCTXT* pctxt, 
   DividendConditions_paymentCurrency_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode currency */

         stat = XmlEnc_Currency (pctxt, pvalue->u.currency
            , OSUTF8("currency"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode determinationMethod */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.determinationMethod
            , OSUTF8("determinationMethod"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DividendConditions_paymentCurrency                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DividendConditions_paymentCurrency (OSCTXT* pctxt,
   DividendConditions_paymentCurrency *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode choice */

   if (pvalue->m.choicePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_DividendConditions_paymentCurrency_choice (pctxt, &pvalue->choice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode href */

   if (pvalue->m.hrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->href, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DividendConditions_paymentCurrency (OSCTXT* pctxt, 
   DividendConditions_paymentCurrency* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.hrefPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->href, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode choice */

   if (pvalue->m.choicePresent) {
      stat = XmlEnc_DividendConditions_paymentCurrency_choice (pctxt, &pvalue->
         choice, OSUTF8(""), 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DividendConditions_interestAccrualsMethod_choice          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DividendConditions_interestAccrualsMethod_choice (OSCTXT* pctxt,
   DividendConditions_interestAccrualsMethod_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_FloatingRateCalculation (pctxt, pvalue->u.floatingRateCalculation, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
            xe_real (pctxt, &pvalue->u.fixedRate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_DividendConditions_interestAccrualsMethod_choice (OSCTXT* pctxt, 
   DividendConditions_interestAccrualsMethod_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode floatingRateCalculation */

         stat = XmlEnc_FloatingRateCalculation (pctxt, pvalue->
            u.floatingRateCalculation
            , OSUTF8("floatingRateCalculation"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode fixedRate */

         stat = rtXmlEncDouble (pctxt, pvalue->u.fixedRate
            , OSUTF8("fixedRate"), nsPrefix, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DividendConditions_interestAccrualsMethod                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DividendConditions_interestAccrualsMethod (OSCTXT* pctxt,
   DividendConditions_interestAccrualsMethod *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode compoundingMethod */

   if(pvalue->compoundingMethod < 0 || pvalue->compoundingMethod > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_CompoundingMethodEnum (pctxt, &pvalue->compoundingMethod, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_DividendConditions_interestAccrualsMethod_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DividendConditions_interestAccrualsMethod (OSCTXT* pctxt, 
   DividendConditions_interestAccrualsMethod* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode choice */

   stat = XmlEnc_DividendConditions_interestAccrualsMethod_choice (pctxt, &
      pvalue->choice, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode compoundingMethod */

   if(pvalue->compoundingMethod < 0 || pvalue->compoundingMethod > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_CompoundingMethodEnum (pctxt, pvalue->compoundingMethod
      , OSUTF8("compoundingMethod"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DividendConditions                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DividendConditions (OSCTXT* pctxt,
   DividendConditions *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode interestAccrualsMethod */

   if (pvalue->m.interestAccrualsMethodPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_DividendConditions_interestAccrualsMethod (pctxt, &pvalue->interestAccrualsMethod, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dividendFxTriggerDate */

   if (pvalue->m.dividendFxTriggerDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_DividendPaymentDate (pctxt, &pvalue->dividendFxTriggerDate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode paymentCurrency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_DividendConditions_paymentCurrency (pctxt, &pvalue->paymentCurrency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode dividendPeriodEndDate */

   if (pvalue->m.dividendPeriodEndDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_DividendConditions_dividendPeriodEndDate (pctxt, &pvalue->dividendPeriodEndDate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dividendPeriodEffectiveDate */

   if (pvalue->m.dividendPeriodEffectiveDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_DividendConditions_dividendPeriodEffectiveDate (pctxt, &pvalue->dividendPeriodEffectiveDate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dividendPaymentDate */

   if (pvalue->m.dividendPaymentDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_DividendPaymentDate (pctxt, &pvalue->dividendPaymentDate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dividendEntitlement */

   if(pvalue->dividendEntitlement < 0 || pvalue->dividendEntitlement > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_DividendEntitlementEnum (pctxt, &pvalue->dividendEntitlement, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode dividendReinvestment */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_boolean (pctxt, &pvalue->dividendReinvestment, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DividendConditions (OSCTXT* pctxt, DividendConditions* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode dividendReinvestment */

   stat = rtXmlEncBool (pctxt, pvalue->dividendReinvestment
      , OSUTF8("dividendReinvestment"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dividendEntitlement */

   if(pvalue->dividendEntitlement < 0 || pvalue->dividendEntitlement > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_DividendEntitlementEnum (pctxt, pvalue->dividendEntitlement
      , OSUTF8("dividendEntitlement"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dividendPaymentDate */

   if (pvalue->m.dividendPaymentDatePresent) {
      stat = XmlEnc_DividendPaymentDate (pctxt, &pvalue->dividendPaymentDate
         , OSUTF8("dividendPaymentDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode dividendPeriodEffectiveDate */

   if (pvalue->m.dividendPeriodEffectiveDatePresent) {
      stat = XmlEnc_DividendConditions_dividendPeriodEffectiveDate (pctxt, &
         pvalue->dividendPeriodEffectiveDate
         , OSUTF8("dividendPeriodEffectiveDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode dividendPeriodEndDate */

   if (pvalue->m.dividendPeriodEndDatePresent) {
      stat = XmlEnc_DividendConditions_dividendPeriodEndDate (pctxt, &pvalue->
         dividendPeriodEndDate, OSUTF8("dividendPeriodEndDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode paymentCurrency */

   stat = XmlEnc_DividendConditions_paymentCurrency (pctxt, &pvalue->
      paymentCurrency, OSUTF8("paymentCurrency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dividendFxTriggerDate */

   if (pvalue->m.dividendFxTriggerDatePresent) {
      stat = XmlEnc_DividendPaymentDate (pctxt, &pvalue->dividendFxTriggerDate
         , OSUTF8("dividendFxTriggerDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode interestAccrualsMethod */

   if (pvalue->m.interestAccrualsMethodPresent) {
      stat = XmlEnc_DividendConditions_interestAccrualsMethod (pctxt, &pvalue->
         interestAccrualsMethod, OSUTF8("interestAccrualsMethod"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Return                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Return (OSCTXT* pctxt,
   Return *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode dividendConditions */

   if (pvalue->m.dividendConditionsPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_DividendConditions (pctxt, &pvalue->dividendConditions, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode returnType */

   if(pvalue->returnType < 0 || pvalue->returnType > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_ReturnTypeEnum (pctxt, &pvalue->returnType, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Return (OSCTXT* pctxt, Return* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode returnType */

   if(pvalue->returnType < 0 || pvalue->returnType > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_ReturnTypeEnum (pctxt, pvalue->returnType
      , OSUTF8("returnType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dividendConditions */

   if (pvalue->m.dividendConditionsPresent) {
      stat = XmlEnc_DividendConditions (pctxt, &pvalue->dividendConditions
         , OSUTF8("dividendConditions"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotionalAdjustmentEnum                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_NotionalAdjustmentEnum (OSCTXT* pctxt,
   NotionalAdjustmentEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_NotionalAdjustmentEnum (OSCTXT* pctxt, 
   NotionalAdjustmentEnum value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      NotionalAdjustmentEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg_fxTerms_quanto_referenceCurrency                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg_fxTerms_quanto_referenceCurrency (OSCTXT* pctxt,
   EquityLeg_fxTerms_quanto_referenceCurrency *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode currencyScheme */

   if (pvalue->m.currencySchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->currencyScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityLeg_fxTerms_quanto_referenceCurrency (OSCTXT* pctxt, 
   EquityLeg_fxTerms_quanto_referenceCurrency* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.currencySchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" currencyScheme=\""), 17);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->currencyScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg_fxTerms_quanto                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg_fxTerms_quanto (OSCTXT* pctxt,
   EquityLeg_fxTerms_quanto *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode fxRate_list */

   if (!(pvalue->fxRate_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "EquityLeg_fxTerms_quanto.fxRate_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->fxRate_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->fxRate_list.tail;
   while (0 != pnode2) {
      ll = asn1E_FxRate_derivations (pctxt, ((FxRate_derivations*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode referenceCurrency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_EquityLeg_fxTerms_quanto_referenceCurrency (pctxt, &pvalue->referenceCurrency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityLeg_fxTerms_quanto (OSCTXT* pctxt, 
   EquityLeg_fxTerms_quanto* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode referenceCurrency */

   stat = XmlEnc_EquityLeg_fxTerms_quanto_referenceCurrency (pctxt, &pvalue->
      referenceCurrency, OSUTF8("referenceCurrency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode fxRate_list */

   if (!(pvalue->fxRate_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "EquityLeg_fxTerms_quanto.fxRate_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->fxRate_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->fxRate_list.head;
   while (0 != pnode) {
      stat = XmlEnc_FxRate_derivations (pctxt, 
         ((FxRate_derivations*)pnode->data), OSUTF8("fxRate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg_fxTerms_compositeFx_referenceCurrency           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg_fxTerms_compositeFx_referenceCurrency (OSCTXT* pctxt,
   EquityLeg_fxTerms_compositeFx_referenceCurrency *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode currencyScheme */

   if (pvalue->m.currencySchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->currencyScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityLeg_fxTerms_compositeFx_referenceCurrency (OSCTXT* pctxt, 
   EquityLeg_fxTerms_compositeFx_referenceCurrency* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.currencySchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" currencyScheme=\""), 17);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->currencyScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg_fxTerms_compositeFx                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg_fxTerms_compositeFx (OSCTXT* pctxt,
   EquityLeg_fxTerms_compositeFx *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode fxDetermination */

   if (pvalue->m.fxDeterminationPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_FxSpotRateSource_derivations (pctxt, &pvalue->fxDetermination, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode relativeDate */

   if (pvalue->m.relativeDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_RelativeDateOffset_derivations (pctxt, &pvalue->relativeDate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode determinationMethod */

   if (pvalue->m.determinationMethodPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->determinationMethod, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode referenceCurrency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_EquityLeg_fxTerms_compositeFx_referenceCurrency (pctxt, &pvalue->referenceCurrency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityLeg_fxTerms_compositeFx (OSCTXT* pctxt, 
   EquityLeg_fxTerms_compositeFx* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode referenceCurrency */

   stat = XmlEnc_EquityLeg_fxTerms_compositeFx_referenceCurrency (pctxt, &
      pvalue->referenceCurrency, OSUTF8("referenceCurrency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode determinationMethod */

   if (pvalue->m.determinationMethodPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->determinationMethod
         , OSUTF8("determinationMethod"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode relativeDate */

   if (pvalue->m.relativeDatePresent) {
      stat = XmlEnc_RelativeDateOffset_derivations (pctxt, &pvalue->
         relativeDate, OSUTF8("relativeDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fxDetermination */

   if (pvalue->m.fxDeterminationPresent) {
      stat = XmlEnc_FxSpotRateSource_derivations (pctxt, &pvalue->
         fxDetermination, OSUTF8("fxDetermination"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg_fxTerms                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg_fxTerms (OSCTXT* pctxt,
   EquityLeg_fxTerms *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_EquityLeg_fxTerms_quanto (pctxt, pvalue->u.quanto, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_EquityLeg_fxTerms_compositeFx (pctxt, pvalue->u.compositeFx, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquityLeg_fxTerms (OSCTXT* pctxt, EquityLeg_fxTerms* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode quanto */

         stat = XmlEnc_EquityLeg_fxTerms_quanto (pctxt, pvalue->u.quanto
            , OSUTF8("quanto"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode compositeFx */

         stat = XmlEnc_EquityLeg_fxTerms_compositeFx (pctxt, pvalue->
            u.compositeFx, OSUTF8("compositeFx"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquityLeg                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquityLeg (OSCTXT* pctxt,
   EquityLeg *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode fxTerms */

   if (pvalue->m.fxTermsPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10,
         asn1E_EquityLeg_fxTerms (pctxt, &pvalue->fxTerms, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode notionalAdjustments */

   if(pvalue->notionalAdjustments < 0 || pvalue->notionalAdjustments > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|9,
      asn1E_NotionalAdjustmentEnum (pctxt, &pvalue->notionalAdjustments, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode return_ */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
      asn1E_Return (pctxt, &pvalue->return_, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode equityAmount */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
      asn1E_EquityLeg_equityAmount (pctxt, &pvalue->equityAmount, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode notional */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_EquityLeg_notional (pctxt, &pvalue->notional, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode valuation */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_EquityLeg_valuation (pctxt, &pvalue->valuation, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode underlyer */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_Underlyer (pctxt, &pvalue->underlyer, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode terminationDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_AdjustableOrRelativeDate (pctxt, &pvalue->terminationDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode effectiveDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_AdjustableOrRelativeDate (pctxt, &pvalue->effectiveDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode payerReceiver_model */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode legIdentifier */

   if (pvalue->m.legIdentifierPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->legIdentifier, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquityLeg (OSCTXT* pctxt, EquityLeg* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.legIdentifierPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" legIdentifier=\""), 16);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->legIdentifier, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode payerReceiver_model */

   stat = XmlEnc_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode effectiveDate */

   stat = XmlEnc_AdjustableOrRelativeDate (pctxt, &pvalue->effectiveDate
      , OSUTF8("effectiveDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode terminationDate */

   stat = XmlEnc_AdjustableOrRelativeDate (pctxt, &pvalue->terminationDate
      , OSUTF8("terminationDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode underlyer */

   stat = XmlEnc_Underlyer (pctxt, &pvalue->underlyer
      , OSUTF8("underlyer"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode valuation */

   stat = XmlEnc_EquityLeg_valuation (pctxt, &pvalue->valuation
      , OSUTF8("valuation"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode notional */

   stat = XmlEnc_EquityLeg_notional (pctxt, &pvalue->notional
      , OSUTF8("notional"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode equityAmount */

   stat = XmlEnc_EquityLeg_equityAmount (pctxt, &pvalue->equityAmount
      , OSUTF8("equityAmount"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode return_ */

   stat = XmlEnc_Return (pctxt, &pvalue->return_, OSUTF8("return"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode notionalAdjustments */

   if(pvalue->notionalAdjustments < 0 || pvalue->notionalAdjustments > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_NotionalAdjustmentEnum (pctxt, pvalue->notionalAdjustments
      , OSUTF8("notionalAdjustments"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode fxTerms */

   if (pvalue->m.fxTermsPresent) {
      stat = XmlEnc_EquityLeg_fxTerms (pctxt, &pvalue->fxTerms
         , OSUTF8("fxTerms"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterestLeg_interestLegCalculationPeriodDates_interestLe  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates_calculationPeriodDatesReference (OSCTXT* pctxt,
   InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates_calculationPeriodDatesReference *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode href */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->href, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates_calculationPeriodDatesReference 
   (OSCTXT* pctxt, 
   InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates_calculationPeriodDatesReference* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->href, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterestLeg_interestLegCalculationPeriodDates_interestLe  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates_choice (OSCTXT* pctxt,
   InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         if(pvalue->u.resetRelativeTo < 0 || pvalue->u.resetRelativeTo > 1)
            return LOG_RTERR (pctxt, RTERR_INVENUM);

         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            asn1E_ResetRelativeToEnum (pctxt, &pvalue->u.resetRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_ResetFrequency (pctxt, pvalue->u.resetFrequency, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates_choice 
   (OSCTXT* pctxt, 
   InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode resetRelativeTo */

         if(pvalue->u.resetRelativeTo < 0 || pvalue->u.resetRelativeTo > 1)
            return LOG_RTERR (pctxt, RTERR_INVENUM);

         stat = XmlEnc_ResetRelativeToEnum (pctxt, pvalue->u.resetRelativeTo
            , OSUTF8("resetRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode resetFrequency */

         stat = XmlEnc_ResetFrequency (pctxt, pvalue->u.resetFrequency
            , OSUTF8("resetFrequency"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterestLeg_interestLegCalculationPeriodDates_interestLe  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates (OSCTXT* pctxt,
   InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode calculationPeriodDatesReference */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates_calculationPeriodDatesReference (pctxt, &pvalue->calculationPeriodDatesReference, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates 
   (OSCTXT* pctxt, 
   InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode calculationPeriodDatesReference */

   stat = XmlEnc_InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates_calculationPeriodDatesReference (pctxt
      , &pvalue->calculationPeriodDatesReference
      , OSUTF8("calculationPeriodDatesReference"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode choice */

   stat = XmlEnc_InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates_choice (pctxt
      , &pvalue->choice, OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterestLeg_interestLegCalculationPeriodDates             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_InterestLeg_interestLegCalculationPeriodDates (OSCTXT* pctxt,
   InterestLeg_interestLegCalculationPeriodDates *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode interestLegPaymentDates */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_AdjustableOrRelativeDates (pctxt, &pvalue->interestLegPaymentDates, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode interestLegResetDates */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates (pctxt, &pvalue->interestLegResetDates, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode terminationDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_AdjustableOrRelativeDate (pctxt, &pvalue->terminationDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode effectiveDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_AdjustableOrRelativeDate (pctxt, &pvalue->effectiveDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_InterestLeg_interestLegCalculationPeriodDates (OSCTXT* pctxt, 
   InterestLeg_interestLegCalculationPeriodDates* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode effectiveDate */

   stat = XmlEnc_AdjustableOrRelativeDate (pctxt, &pvalue->effectiveDate
      , OSUTF8("effectiveDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode terminationDate */

   stat = XmlEnc_AdjustableOrRelativeDate (pctxt, &pvalue->terminationDate
      , OSUTF8("terminationDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode interestLegResetDates */

   stat = XmlEnc_InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates (pctxt
      , &pvalue->interestLegResetDates
      , OSUTF8("interestLegResetDates"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode interestLegPaymentDates */

   stat = XmlEnc_AdjustableOrRelativeDates (pctxt, &pvalue->
      interestLegPaymentDates, OSUTF8("interestLegPaymentDates"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterestLeg_notional                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_InterestLeg_notional (OSCTXT* pctxt,
   InterestLeg_notional *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            xe_utf8str (pctxt, pvalue->u.determinationMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_Money_derivations (pctxt, pvalue->u.notionalAmount, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_InterestLeg_notional (OSCTXT* pctxt, InterestLeg_notional* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode determinationMethod */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.determinationMethod
            , OSUTF8("determinationMethod"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode notionalAmount */

         stat = XmlEnc_Money_derivations (pctxt, pvalue->u.notionalAmount
            , OSUTF8("notionalAmount"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LegAmount_paymentCurrency_choice                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_LegAmount_paymentCurrency_choice (OSCTXT* pctxt,
   LegAmount_paymentCurrency_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_Currency (pctxt, pvalue->u.currency, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
            xe_utf8str (pctxt, pvalue->u.determinationMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_LegAmount_paymentCurrency_choice (OSCTXT* pctxt, 
   LegAmount_paymentCurrency_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode currency */

         stat = XmlEnc_Currency (pctxt, pvalue->u.currency
            , OSUTF8("currency"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode determinationMethod */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.determinationMethod
            , OSUTF8("determinationMethod"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LegAmount_paymentCurrency                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_LegAmount_paymentCurrency (OSCTXT* pctxt,
   LegAmount_paymentCurrency *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode choice */

   if (pvalue->m.choicePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_LegAmount_paymentCurrency_choice (pctxt, &pvalue->choice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode href */

   if (pvalue->m.hrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->href, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_LegAmount_paymentCurrency (OSCTXT* pctxt, 
   LegAmount_paymentCurrency* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.hrefPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->href, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode choice */

   if (pvalue->m.choicePresent) {
      stat = XmlEnc_LegAmount_paymentCurrency_choice (pctxt, &pvalue->choice
         , OSUTF8(""), 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LegAmount_referenceAmount                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_LegAmount_referenceAmount (OSCTXT* pctxt,
   LegAmount_referenceAmount *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode href */

   if (pvalue->m.hrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->href, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_LegAmount_referenceAmount (OSCTXT* pctxt, 
   LegAmount_referenceAmount* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.hrefPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->href, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LegAmount_choice                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_LegAmount_choice (OSCTXT* pctxt,
   LegAmount_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_LegAmount_referenceAmount (pctxt, pvalue->u.referenceAmount, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_Formula (pctxt, pvalue->u.formula, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
            xe_octstr (pctxt, pvalue->u.encodedDescription->data, pvalue->u.encodedDescription->numocts, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_LegAmount_choice (OSCTXT* pctxt, LegAmount_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode referenceAmount */

         stat = XmlEnc_LegAmount_referenceAmount (pctxt, pvalue->
            u.referenceAmount, OSUTF8("referenceAmount"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode formula */

         stat = XmlEnc_Formula (pctxt, pvalue->u.formula
            , OSUTF8("formula"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode encodedDescription */

         stat = rtXmlEncBase64Binary
            (pctxt, pvalue->u.encodedDescription->numocts, pvalue->
               u.encodedDescription->data, 
               OSUTF8("encodedDescription"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LegAmount                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_LegAmount (OSCTXT* pctxt,
   LegAmount *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode calculationDates */

   if (pvalue->m.calculationDatesPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_AdjustableRelativeOrPeriodicDates (pctxt, &pvalue->calculationDates, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_LegAmount_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode paymentCurrency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_LegAmount_paymentCurrency (pctxt, &pvalue->paymentCurrency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_LegAmount (OSCTXT* pctxt, LegAmount* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode paymentCurrency */

   stat = XmlEnc_LegAmount_paymentCurrency (pctxt, &pvalue->paymentCurrency
      , OSUTF8("paymentCurrency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode choice */

   stat = XmlEnc_LegAmount_choice (pctxt, &pvalue->choice, OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode calculationDates */

   if (pvalue->m.calculationDatesPresent) {
      stat = XmlEnc_AdjustableRelativeOrPeriodicDates (pctxt, &pvalue->
         calculationDates, OSUTF8("calculationDates"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LegAmount_derivations_equityLeg_equityAmount_paymentCurr  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_LegAmount_derivations_equityLeg_equityAmount_paymentCurrency_choice (OSCTXT* pctxt,
   LegAmount_derivations_equityLeg_equityAmount_paymentCurrency_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_Currency (pctxt, pvalue->u.currency, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
            xe_utf8str (pctxt, pvalue->u.determinationMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_LegAmount_derivations_equityLeg_equityAmount_paymentCurrency_choice 
   (OSCTXT* pctxt, 
   LegAmount_derivations_equityLeg_equityAmount_paymentCurrency_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode currency */

         stat = XmlEnc_Currency (pctxt, pvalue->u.currency
            , OSUTF8("currency"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode determinationMethod */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.determinationMethod
            , OSUTF8("determinationMethod"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LegAmount_derivations_equityLeg_equityAmount_paymentCurr  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_LegAmount_derivations_equityLeg_equityAmount_paymentCurrency (OSCTXT* pctxt,
   LegAmount_derivations_equityLeg_equityAmount_paymentCurrency *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode choice */

   if (pvalue->m.choicePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_LegAmount_derivations_equityLeg_equityAmount_paymentCurrency_choice (pctxt, &pvalue->choice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode href */

   if (pvalue->m.hrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->href, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_LegAmount_derivations_equityLeg_equityAmount_paymentCurrency 
   (OSCTXT* pctxt, 
   LegAmount_derivations_equityLeg_equityAmount_paymentCurrency* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.hrefPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->href, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode choice */

   if (pvalue->m.choicePresent) {
      stat = XmlEnc_LegAmount_derivations_equityLeg_equityAmount_paymentCurrency_choice (pctxt
         , &pvalue->choice, OSUTF8(""), 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LegAmount_derivations_equityLeg_equityAmount_referenceAm  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_LegAmount_derivations_equityLeg_equityAmount_referenceAmount (OSCTXT* pctxt,
   LegAmount_derivations_equityLeg_equityAmount_referenceAmount *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode href */

   if (pvalue->m.hrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->href, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_LegAmount_derivations_equityLeg_equityAmount_referenceAmount 
   (OSCTXT* pctxt, 
   LegAmount_derivations_equityLeg_equityAmount_referenceAmount* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.hrefPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->href, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LegAmount_derivations_equityLeg_equityAmount_choice       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_LegAmount_derivations_equityLeg_equityAmount_choice (OSCTXT* pctxt,
   LegAmount_derivations_equityLeg_equityAmount_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_LegAmount_derivations_equityLeg_equityAmount_referenceAmount (pctxt, pvalue->u.referenceAmount, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_Formula (pctxt, pvalue->u.formula, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
            xe_octstr (pctxt, pvalue->u.encodedDescription->data, pvalue->u.encodedDescription->numocts, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_LegAmount_derivations_equityLeg_equityAmount_choice (OSCTXT* pctxt, 
   LegAmount_derivations_equityLeg_equityAmount_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode referenceAmount */

         stat = XmlEnc_LegAmount_derivations_equityLeg_equityAmount_referenceAmount (pctxt
            , pvalue->u.referenceAmount, OSUTF8("referenceAmount"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode formula */

         stat = XmlEnc_Formula (pctxt, pvalue->u.formula
            , OSUTF8("formula"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode encodedDescription */

         stat = rtXmlEncBase64Binary
            (pctxt, pvalue->u.encodedDescription->numocts, pvalue->
               u.encodedDescription->data, 
               OSUTF8("encodedDescription"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LegAmount_derivations_equityLeg_equityAmount              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_LegAmount_derivations_equityLeg_equityAmount (OSCTXT* pctxt,
   LegAmount_derivations_equityLeg_equityAmount *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode cashSettlement */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
      xe_boolean (pctxt, &pvalue->cashSettlement, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode calculationDates */

   if (pvalue->m.calculationDatesPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_AdjustableRelativeOrPeriodicDates (pctxt, &pvalue->calculationDates, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_LegAmount_derivations_equityLeg_equityAmount_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode paymentCurrency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_LegAmount_derivations_equityLeg_equityAmount_paymentCurrency (pctxt, &pvalue->paymentCurrency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_LegAmount_derivations_equityLeg_equityAmount (OSCTXT* pctxt, 
   LegAmount_derivations_equityLeg_equityAmount* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode paymentCurrency */

   stat = XmlEnc_LegAmount_derivations_equityLeg_equityAmount_paymentCurrency (pctxt
      , &pvalue->paymentCurrency, OSUTF8("paymentCurrency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode choice */

   stat = XmlEnc_LegAmount_derivations_equityLeg_equityAmount_choice (pctxt, &
      pvalue->choice, OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode calculationDates */

   if (pvalue->m.calculationDatesPresent) {
      stat = XmlEnc_AdjustableRelativeOrPeriodicDates (pctxt, &pvalue->
         calculationDates, OSUTF8("calculationDates"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode cashSettlement */

   stat = rtXmlEncBool (pctxt, pvalue->cashSettlement
      , OSUTF8("cashSettlement"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LegAmount_derivations                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_LegAmount_derivations (OSCTXT* pctxt,
   LegAmount_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_LegAmount (pctxt, pvalue->u.legAmount, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_LegAmount_derivations_equityLeg_equityAmount (pctxt, pvalue->u.equityLeg_equityAmount, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_LegAmount_derivations (OSCTXT* pctxt, 
   LegAmount_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode legAmount */

         stat = XmlEnc_LegAmount (pctxt, pvalue->u.legAmount, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode equityLeg_equityAmount */

         stat = XmlEnc_LegAmount_derivations_equityLeg_equityAmount (pctxt, 
            pvalue->u.equityLeg_equityAmount, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterestLeg_interestCalculation_choice                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_InterestLeg_interestCalculation_choice (OSCTXT* pctxt,
   InterestLeg_interestCalculation_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_FloatingRateCalculation (pctxt, pvalue->u.floatingRateCalculation, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
            xe_real (pctxt, &pvalue->u.fixedRate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_InterestLeg_interestCalculation_choice (OSCTXT* pctxt, 
   InterestLeg_interestCalculation_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode floatingRateCalculation */

         stat = XmlEnc_FloatingRateCalculation (pctxt, pvalue->
            u.floatingRateCalculation
            , OSUTF8("floatingRateCalculation"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode fixedRate */

         stat = rtXmlEncDouble (pctxt, pvalue->u.fixedRate
            , OSUTF8("fixedRate"), nsPrefix, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterestLeg_interestCalculation                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_InterestLeg_interestCalculation (OSCTXT* pctxt,
   InterestLeg_interestCalculation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode dayCountFraction */

   if(pvalue->dayCountFraction < 0 || pvalue->dayCountFraction > 7)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_DayCountFractionEnum (pctxt, &pvalue->dayCountFraction, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_InterestLeg_interestCalculation_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_InterestLeg_interestCalculation (OSCTXT* pctxt, 
   InterestLeg_interestCalculation* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode choice */

   stat = XmlEnc_InterestLeg_interestCalculation_choice (pctxt, &pvalue->choice
      , OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dayCountFraction */

   if(pvalue->dayCountFraction < 0 || pvalue->dayCountFraction > 7)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_DayCountFractionEnum (pctxt, pvalue->dayCountFraction
      , OSUTF8("dayCountFraction"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterestLeg                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_InterestLeg (OSCTXT* pctxt,
   InterestLeg *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode interestCalculation */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_InterestLeg_interestCalculation (pctxt, &pvalue->interestCalculation, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode interestAmount */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_LegAmount_derivations (pctxt, &pvalue->interestAmount, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode notional */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_InterestLeg_notional (pctxt, &pvalue->notional, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode interestLegCalculationPeriodDates */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_InterestLeg_interestLegCalculationPeriodDates (pctxt, &pvalue->interestLegCalculationPeriodDates, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode payerReceiver_model */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode legIdentifier */

   if (pvalue->m.legIdentifierPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->legIdentifier, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_InterestLeg (OSCTXT* pctxt, InterestLeg* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.legIdentifierPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" legIdentifier=\""), 16);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->legIdentifier, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode payerReceiver_model */

   stat = XmlEnc_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode interestLegCalculationPeriodDates */

   stat = XmlEnc_InterestLeg_interestLegCalculationPeriodDates (pctxt, &pvalue
      ->interestLegCalculationPeriodDates
      , OSUTF8("interestLegCalculationPeriodDates"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode notional */

   stat = XmlEnc_InterestLeg_notional (pctxt, &pvalue->notional
      , OSUTF8("notional"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode interestAmount */

   stat = XmlEnc_LegAmount_derivations (pctxt, &pvalue->interestAmount
      , OSUTF8("interestAmount"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode interestCalculation */

   stat = XmlEnc_InterestLeg_interestCalculation (pctxt, &pvalue->
      interestCalculation, OSUTF8("interestCalculation"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrincipalExchangeFeatures_principalExchangeDescriptions_  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PrincipalExchangeFeatures_principalExchangeDescriptions_principalExchangeAmount (OSCTXT* pctxt,
   PrincipalExchangeFeatures_principalExchangeDescriptions_principalExchangeAmount *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
            xe_utf8str (pctxt, pvalue->u.determinationMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_Money_derivations (pctxt, pvalue->u.principalAmount, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_PrincipalExchangeFeatures_principalExchangeDescriptions_principalExchangeAmount 
   (OSCTXT* pctxt, 
   PrincipalExchangeFeatures_principalExchangeDescriptions_principalExchangeAmount* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode determinationMethod */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.determinationMethod
            , OSUTF8("determinationMethod"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode principalAmount */

         stat = XmlEnc_Money_derivations (pctxt, pvalue->u.principalAmount
            , OSUTF8("principalAmount"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrincipalExchangeFeatures_principalExchangeDescriptions   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PrincipalExchangeFeatures_principalExchangeDescriptions (OSCTXT* pctxt,
   PrincipalExchangeFeatures_principalExchangeDescriptions *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode principalExchangeDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_AdjustableOrRelativeDate (pctxt, &pvalue->principalExchangeDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode principalExchangeAmount */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_PrincipalExchangeFeatures_principalExchangeDescriptions_principalExchangeAmount (pctxt, &pvalue->principalExchangeAmount, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode payerReceiver_model */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PrincipalExchangeFeatures_principalExchangeDescriptions 
   (OSCTXT* pctxt, 
   PrincipalExchangeFeatures_principalExchangeDescriptions* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode payerReceiver_model */

   stat = XmlEnc_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode principalExchangeAmount */

   stat = XmlEnc_PrincipalExchangeFeatures_principalExchangeDescriptions_principalExchangeAmount (pctxt
      , &pvalue->principalExchangeAmount
      , OSUTF8("principalExchangeAmount"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode principalExchangeDate */

   stat = XmlEnc_AdjustableOrRelativeDate (pctxt, &pvalue->
      principalExchangeDate, OSUTF8("principalExchangeDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrincipalExchangeFeatures                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PrincipalExchangeFeatures (OSCTXT* pctxt,
   PrincipalExchangeFeatures *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode principalExchangeDescriptions_list */

   if (!(pvalue->principalExchangeDescriptions_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "PrincipalExchangeFeatures.principalExchangeDescriptions_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->principalExchangeDescriptions_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->principalExchangeDescriptions_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PrincipalExchangeFeatures_principalExchangeDescriptions (pctxt, ((PrincipalExchangeFeatures_principalExchangeDescriptions*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode principalExchanges */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_PrincipalExchanges (pctxt, &pvalue->principalExchanges, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PrincipalExchangeFeatures (OSCTXT* pctxt, 
   PrincipalExchangeFeatures* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode principalExchanges */

   stat = XmlEnc_PrincipalExchanges (pctxt, &pvalue->principalExchanges
      , OSUTF8("principalExchanges"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode principalExchangeDescriptions_list */

   if (!(pvalue->principalExchangeDescriptions_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "PrincipalExchangeFeatures.principalExchangeDescriptions_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->principalExchangeDescriptions_list.
         count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->principalExchangeDescriptions_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PrincipalExchangeFeatures_principalExchangeDescriptions (pctxt
         , 
         ((PrincipalExchangeFeatures_principalExchangeDescriptions*)pnode->data)
         , OSUTF8("principalExchangeDescriptions"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapAdditionalPayment_additionalPaymentAmount       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapAdditionalPayment_additionalPaymentAmount (OSCTXT* pctxt,
   EquitySwapAdditionalPayment_additionalPaymentAmount *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode formula */

   if (pvalue->m.formulaPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Formula (pctxt, &pvalue->formula, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode paymentAmount */

   if (pvalue->m.paymentAmountPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Money_derivations (pctxt, &pvalue->paymentAmount, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquitySwapAdditionalPayment_additionalPaymentAmount (OSCTXT* pctxt, 
   EquitySwapAdditionalPayment_additionalPaymentAmount* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode paymentAmount */

   if (pvalue->m.paymentAmountPresent) {
      stat = XmlEnc_Money_derivations (pctxt, &pvalue->paymentAmount
         , OSUTF8("paymentAmount"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode formula */

   if (pvalue->m.formulaPresent) {
      stat = XmlEnc_Formula (pctxt, &pvalue->formula
         , OSUTF8("formula"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapAdditionalPayment_additionalPaymentDate         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapAdditionalPayment_additionalPaymentDate (OSCTXT* pctxt,
   EquitySwapAdditionalPayment_additionalPaymentDate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AdjustableDate (pctxt, pvalue->u.adjustableDate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_RelativeDateOffset_derivations (pctxt, pvalue->u.relativeDate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquitySwapAdditionalPayment_additionalPaymentDate (OSCTXT* pctxt, 
   EquitySwapAdditionalPayment_additionalPaymentDate* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode adjustableDate */

         stat = XmlEnc_AdjustableDate (pctxt, pvalue->u.adjustableDate
            , OSUTF8("adjustableDate"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode relativeDate */

         stat = XmlEnc_RelativeDateOffset_derivations (pctxt, pvalue->
            u.relativeDate, OSUTF8("relativeDate"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapAdditionalPayment                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapAdditionalPayment (OSCTXT* pctxt,
   EquitySwapAdditionalPayment *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode paymentType */

   if (pvalue->m.paymentTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_PaymentType (pctxt, &pvalue->paymentType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode additionalPaymentDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_EquitySwapAdditionalPayment_additionalPaymentDate (pctxt, &pvalue->additionalPaymentDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode additionalPaymentAmount */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_EquitySwapAdditionalPayment_additionalPaymentAmount (pctxt, &pvalue->additionalPaymentAmount, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode payerReceiver_model */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquitySwapAdditionalPayment (OSCTXT* pctxt, 
   EquitySwapAdditionalPayment* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode payerReceiver_model */

   stat = XmlEnc_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode additionalPaymentAmount */

   stat = XmlEnc_EquitySwapAdditionalPayment_additionalPaymentAmount (pctxt, &
      pvalue->additionalPaymentAmount
      , OSUTF8("additionalPaymentAmount"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode additionalPaymentDate */

   stat = XmlEnc_EquitySwapAdditionalPayment_additionalPaymentDate (pctxt, &
      pvalue->additionalPaymentDate
      , OSUTF8("additionalPaymentDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode paymentType */

   if (pvalue->m.paymentTypePresent) {
      stat = XmlEnc_PaymentType (pctxt, &pvalue->paymentType
         , OSUTF8("paymentType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapEarlyTerminationType_startingDate               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapEarlyTerminationType_startingDate (OSCTXT* pctxt,
   EquitySwapEarlyTerminationType_startingDate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_DateRelativeTo (pctxt, pvalue->u.dateRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_AdjustableDate (pctxt, pvalue->u.adjustableDate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquitySwapEarlyTerminationType_startingDate (OSCTXT* pctxt, 
   EquitySwapEarlyTerminationType_startingDate* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode dateRelativeTo */

         stat = XmlEnc_DateRelativeTo (pctxt, pvalue->u.dateRelativeTo
            , OSUTF8("dateRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode adjustableDate */

         stat = XmlEnc_AdjustableDate (pctxt, pvalue->u.adjustableDate
            , OSUTF8("adjustableDate"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapEarlyTerminationType                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapEarlyTerminationType (OSCTXT* pctxt,
   EquitySwapEarlyTerminationType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode startingDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_EquitySwapEarlyTerminationType_startingDate (pctxt, &pvalue->startingDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode partyReference */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_PartyReference (pctxt, &pvalue->partyReference, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquitySwapEarlyTerminationType (OSCTXT* pctxt, 
   EquitySwapEarlyTerminationType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode partyReference */

   stat = XmlEnc_PartyReference (pctxt, &pvalue->partyReference
      , OSUTF8("partyReference"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode startingDate */

   stat = XmlEnc_EquitySwapEarlyTerminationType_startingDate (pctxt, &pvalue->
      startingDate, OSUTF8("startingDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwap                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwap (OSCTXT* pctxt,
   EquitySwap *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode earlyTermination_list */

   pnode2 = pvalue->earlyTermination_list.tail;
   while (0 != pnode2) {
      ll = asn1E_EquitySwapEarlyTerminationType (pctxt, ((EquitySwapEarlyTerminationType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode additionalPayment_list */

   pnode2 = pvalue->additionalPayment_list.tail;
   while (0 != pnode2) {
      ll = asn1E_EquitySwapAdditionalPayment (pctxt, ((EquitySwapAdditionalPayment*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode principalExchangeFeatures */

   if (pvalue->m.principalExchangeFeaturesPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_PrincipalExchangeFeatures (pctxt, &pvalue->principalExchangeFeatures, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode interestLeg_list */

   pnode2 = pvalue->interestLeg_list.tail;
   while (0 != pnode2) {
      ll = asn1E_InterestLeg (pctxt, ((InterestLeg*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode equityLeg_list */

   if (!(pvalue->equityLeg_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "EquitySwap.equityLeg_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->equityLeg_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->equityLeg_list.tail;
   while (0 != pnode2) {
      ll = asn1E_EquityLeg (pctxt, ((EquityLeg*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode productId_list */

   pnode2 = pvalue->productId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ProductId (pctxt, ((ProductId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ProductType (pctxt, &pvalue->productType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquitySwap (OSCTXT* pctxt, EquitySwap* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      stat = XmlEnc_ProductType (pctxt, &pvalue->productType
         , OSUTF8("productType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode productId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->productId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ProductId (pctxt, ((ProductId*)pnode->data)
         , OSUTF8("productId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode equityLeg_list */

   if (!(pvalue->equityLeg_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "EquitySwap.equityLeg_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->equityLeg_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->equityLeg_list.head;
   while (0 != pnode) {
      stat = XmlEnc_EquityLeg (pctxt, ((EquityLeg*)pnode->data)
         , OSUTF8("equityLeg"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode interestLeg_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->interestLeg_list.head;
   while (0 != pnode) {
      stat = XmlEnc_InterestLeg (pctxt, ((InterestLeg*)pnode->data)
         , OSUTF8("interestLeg"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode principalExchangeFeatures */

   if (pvalue->m.principalExchangeFeaturesPresent) {
      stat = XmlEnc_PrincipalExchangeFeatures (pctxt, &pvalue->
         principalExchangeFeatures
         , OSUTF8("principalExchangeFeatures"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode additionalPayment_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->additionalPayment_list.head;
   while (0 != pnode) {
      stat = XmlEnc_EquitySwapAdditionalPayment (pctxt, 
         ((EquitySwapAdditionalPayment*)pnode->data)
         , OSUTF8("additionalPayment"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode earlyTermination_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->earlyTermination_list.head;
   while (0 != pnode) {
      stat = XmlEnc_EquitySwapEarlyTerminationType (pctxt, 
         ((EquitySwapEarlyTerminationType*)pnode->data)
         , OSUTF8("earlyTermination"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AdjustableDate2_unadjustedDate                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AdjustableDate2_unadjustedDate (OSCTXT* pctxt,
   AdjustableDate2_unadjustedDate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_charstr (pctxt, pvalue->base, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_AdjustableDate2_unadjustedDate (OSCTXT* pctxt, 
   AdjustableDate2_unadjustedDate* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BusinessDayAdjustmentsReference                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BusinessDayAdjustmentsReference (OSCTXT* pctxt,
   BusinessDayAdjustmentsReference *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode href */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->href, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BusinessDayAdjustmentsReference (OSCTXT* pctxt, 
   BusinessDayAdjustmentsReference* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->href, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AdjustableDate2_choice                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AdjustableDate2_choice (OSCTXT* pctxt,
   AdjustableDate2_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_BusinessDayAdjustments (pctxt, pvalue->u.dateAdjustments, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_BusinessDayAdjustmentsReference (pctxt, pvalue->u.dateAdjustmentsReference, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_AdjustableDate2_choice (OSCTXT* pctxt, 
   AdjustableDate2_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode dateAdjustments */

         stat = XmlEnc_BusinessDayAdjustments (pctxt, pvalue->u.dateAdjustments
            , OSUTF8("dateAdjustments"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode dateAdjustmentsReference */

         stat = XmlEnc_BusinessDayAdjustmentsReference (pctxt, pvalue->
            u.dateAdjustmentsReference
            , OSUTF8("dateAdjustmentsReference"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AdjustableDate2                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AdjustableDate2 (OSCTXT* pctxt,
   AdjustableDate2 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode choice */

   if (pvalue->m.choicePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_AdjustableDate2_choice (pctxt, &pvalue->choice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode unadjustedDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_AdjustableDate2_unadjustedDate (pctxt, &pvalue->unadjustedDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_AdjustableDate2 (OSCTXT* pctxt, AdjustableDate2* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode unadjustedDate */

   stat = XmlEnc_AdjustableDate2_unadjustedDate (pctxt, &pvalue->unadjustedDate
      , OSUTF8("unadjustedDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode choice */

   if (pvalue->m.choicePresent) {
      stat = XmlEnc_AdjustableDate2_choice (pctxt, &pvalue->choice
         , OSUTF8(""), 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ScheduledTerminationDate                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ScheduledTerminationDate (OSCTXT* pctxt,
   ScheduledTerminationDate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AdjustableDate2 (pctxt, pvalue->u.adjustableDate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_Interval_derivations (pctxt, pvalue->u.relativeDate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   if (tagging == ASN1EXPL) {
      ll1 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll1);
      if (ll1 < 0) return LOG_RTERR (pctxt, ll1);
   }

   ll0 += ll1;

   return (ll0);
}

int XmlEnc_ScheduledTerminationDate (OSCTXT* pctxt, 
   ScheduledTerminationDate* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode adjustableDate */

         stat = XmlEnc_AdjustableDate2 (pctxt, pvalue->u.adjustableDate
            , OSUTF8("adjustableDate"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode relativeDate */

         stat = XmlEnc_Interval_derivations (pctxt, pvalue->u.relativeDate
            , OSUTF8("relativeDate"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EntityName                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EntityName (OSCTXT* pctxt,
   EntityName *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode entityNameScheme */

   if (pvalue->m.entityNameSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->entityNameScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EntityName (OSCTXT* pctxt, EntityName* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.entityNameSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" entityNameScheme=\""), 19);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->entityNameScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EntityId                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EntityId (OSCTXT* pctxt,
   EntityId *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode entityIdScheme */

   if (pvalue->m.entityIdSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->entityIdScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EntityId (OSCTXT* pctxt, EntityId* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.entityIdSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" entityIdScheme=\""), 17);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->entityIdScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LegalEntity_sequence                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_LegalEntity_sequence (OSCTXT* pctxt,
   LegalEntity_sequence *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode entityId_list */

   pnode2 = pvalue->entityId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_EntityId (pctxt, ((EntityId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode entityName */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_EntityName (pctxt, &pvalue->entityName, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_LegalEntity_sequence (OSCTXT* pctxt, LegalEntity_sequence* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode entityName */

   stat = XmlEnc_EntityName (pctxt, &pvalue->entityName
      , OSUTF8("entityName"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode entityId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->entityId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_EntityId (pctxt, ((EntityId*)pnode->data)
         , OSUTF8("entityId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LegalEntity_choice                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_LegalEntity_choice (OSCTXT* pctxt,
   LegalEntity_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_LegalEntity_sequence (pctxt, pvalue->u.sequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         if (!(pvalue->u.entityId_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "LegalEntity_choice.u.entityId_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.entityId_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         pnode2 = pvalue->u.entityId_list->tail;
         while (0 != pnode2) {
            ll = asn1E_EntityId (pctxt, ((EntityId*)pnode2->data), ASN1EXPL);
            if (ll < 0) return LOG_RTERR (pctxt, ll);
            ll2 += ll;

            pnode2 = pnode2->prev;
         }
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else { ll1 += ll; ll2 = 0; }
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_LegalEntity_choice (OSCTXT* pctxt, LegalEntity_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode sequence */

         stat = XmlEnc_LegalEntity_sequence (pctxt, pvalue->u.sequence
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode entityId_list */

         if (!(pvalue->u.entityId_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "LegalEntity_choice.u.entityId_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.entityId_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         { const OSUTF8CHAR* savedPrefix = nsPrefix;
         nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
            "http://www.fpml.org/2003/FpML-4-0"));

         { OSRTDListNode* pnode = pvalue->u.entityId_list->head;
         while (0 != pnode) {
            stat = XmlEnc_EntityId (pctxt, ((EntityId*)pnode->data)
               , OSUTF8("entityId"), nsPrefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            pnode = pnode->next;
         }}
         nsPrefix = savedPrefix;
         }

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LegalEntity                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_LegalEntity (OSCTXT* pctxt,
   LegalEntity *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_LegalEntity_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_LegalEntity (OSCTXT* pctxt, LegalEntity* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode choice */

   stat = XmlEnc_LegalEntity_choice (pctxt, &pvalue->choice, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReferenceObligation_choice                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ReferenceObligation_choice (OSCTXT* pctxt,
   ReferenceObligation_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_Bond (pctxt, pvalue->u.bond, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_ConvertibleBond (pctxt, pvalue->u.convertibleBond, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_ReferenceObligation_choice (OSCTXT* pctxt, 
   ReferenceObligation_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode bond */

         stat = XmlEnc_Bond (pctxt, pvalue->u.bond, OSUTF8("bond"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode convertibleBond */

         stat = XmlEnc_ConvertibleBond (pctxt, pvalue->u.convertibleBond
            , OSUTF8("convertibleBond"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LegalEntityReference                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_LegalEntityReference (OSCTXT* pctxt,
   LegalEntityReference *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode href */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->href, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_LegalEntityReference (OSCTXT* pctxt, LegalEntityReference* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->href, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReferenceObligation_choice_1                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ReferenceObligation_choice_1 (OSCTXT* pctxt,
   ReferenceObligation_choice_1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_LegalEntity (pctxt, pvalue->u.primaryObligor, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_LegalEntityReference (pctxt, pvalue->u.primaryObligorReference, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_ReferenceObligation_choice_1 (OSCTXT* pctxt, 
   ReferenceObligation_choice_1* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode primaryObligor */

         stat = XmlEnc_LegalEntity (pctxt, pvalue->u.primaryObligor
            , OSUTF8("primaryObligor"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode primaryObligorReference */

         stat = XmlEnc_LegalEntityReference (pctxt, pvalue->
            u.primaryObligorReference
            , OSUTF8("primaryObligorReference"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReferenceObligation_element                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ReferenceObligation_element (OSCTXT* pctxt,
   ReferenceObligation_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_LegalEntity (pctxt, pvalue->u.guarantor, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_LegalEntityReference (pctxt, pvalue->u.guarantorReference, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_ReferenceObligation_element (OSCTXT* pctxt, 
   ReferenceObligation_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode guarantor */

         stat = XmlEnc_LegalEntity (pctxt, pvalue->u.guarantor
            , OSUTF8("guarantor"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode guarantorReference */

         stat = XmlEnc_LegalEntityReference (pctxt, pvalue->
            u.guarantorReference, OSUTF8("guarantorReference"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReferenceObligation                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ReferenceObligation (OSCTXT* pctxt,
   ReferenceObligation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode choice_2_list */

   pnode2 = pvalue->choice_2_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ReferenceObligation_element (pctxt, ((ReferenceObligation_element*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode choice_1 */

   if (pvalue->m.choice_1Present) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ReferenceObligation_choice_1 (pctxt, &pvalue->choice_1, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_ReferenceObligation_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ReferenceObligation (OSCTXT* pctxt, ReferenceObligation* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode choice */

   stat = XmlEnc_ReferenceObligation_choice (pctxt, &pvalue->choice
      , OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode choice_1 */

   if (pvalue->m.choice_1Present) {
      stat = XmlEnc_ReferenceObligation_choice_1 (pctxt, &pvalue->choice_1
         , OSUTF8(""), 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode choice_2_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->choice_2_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ReferenceObligation_element (pctxt, 
         ((ReferenceObligation_element*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Empty                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Empty (OSCTXT* pctxt,
   Empty *pvalue, ASN1TagType tagging)
{
   int ll0 = 0;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Empty (OSCTXT* pctxt, Empty* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReferenceInformation_choice                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ReferenceInformation_choice (OSCTXT* pctxt,
   ReferenceInformation_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         if (!(pvalue->u.referenceObligation_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "ReferenceInformation_choice.u.referenceObligation_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.referenceObligation_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         pnode2 = pvalue->u.referenceObligation_list->tail;
         while (0 != pnode2) {
            ll = asn1E_ReferenceObligation (pctxt, ((ReferenceObligation*)pnode2->data), ASN1EXPL);
            if (ll < 0) return LOG_RTERR (pctxt, ll);
            ll2 += ll;

            pnode2 = pnode2->prev;
         }
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else { ll1 += ll; ll2 = 0; }
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_Empty (pctxt, pvalue->u.noReferenceObligation, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_Empty (pctxt, pvalue->u.unknownReferenceObligation, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_ReferenceInformation_choice (OSCTXT* pctxt, 
   ReferenceInformation_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode referenceObligation_list */

         if (!(pvalue->u.referenceObligation_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "ReferenceInformation_choice.u.referenceObligation_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.referenceObligation_list->
               count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         { const OSUTF8CHAR* savedPrefix = nsPrefix;
         nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
            "http://www.fpml.org/2003/FpML-4-0"));

         { OSRTDListNode* pnode = pvalue->u.referenceObligation_list->head;
         while (0 != pnode) {
            stat = XmlEnc_ReferenceObligation (pctxt, 
               ((ReferenceObligation*)pnode->data)
               , OSUTF8("referenceObligation"), nsPrefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            pnode = pnode->next;
         }}
         nsPrefix = savedPrefix;
         }

         break;

      case 2:
         /* encode noReferenceObligation */

         stat = XmlEnc_Empty (pctxt, pvalue->u.noReferenceObligation
            , OSUTF8("noReferenceObligation"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode unknownReferenceObligation */

         stat = XmlEnc_Empty (pctxt, pvalue->u.unknownReferenceObligation
            , OSUTF8("unknownReferenceObligation"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReferenceInformation                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ReferenceInformation (OSCTXT* pctxt,
   ReferenceInformation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode referencePrice */

   if (pvalue->m.referencePricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_real (pctxt, &pvalue->referencePrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode allGuarantees */

   if (pvalue->m.allGuaranteesPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_boolean (pctxt, &pvalue->allGuarantees, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_ReferenceInformation_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode referenceEntity */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_LegalEntity (pctxt, &pvalue->referenceEntity, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ReferenceInformation (OSCTXT* pctxt, ReferenceInformation* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode referenceEntity */

   stat = XmlEnc_LegalEntity (pctxt, &pvalue->referenceEntity
      , OSUTF8("referenceEntity"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode choice */

   stat = XmlEnc_ReferenceInformation_choice (pctxt, &pvalue->choice
      , OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode allGuarantees */

   if (pvalue->m.allGuaranteesPresent) {
      stat = rtXmlEncBool (pctxt, pvalue->allGuarantees
         , OSUTF8("allGuarantees"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode referencePrice */

   if (pvalue->m.referencePricePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->referencePrice
         , OSUTF8("referencePrice"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AdditionalTerm                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AdditionalTerm (OSCTXT* pctxt,
   AdditionalTerm *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode additionalTermScheme */

   if (pvalue->m.additionalTermSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->additionalTermScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_AdditionalTerm (OSCTXT* pctxt, AdditionalTerm* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.additionalTermSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" additionalTermScheme=\""), 23);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->additionalTermScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GeneralTerms                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_GeneralTerms (OSCTXT* pctxt,
   GeneralTerms *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode additionalTerm_list */

   pnode2 = pvalue->additionalTerm_list.tail;
   while (0 != pnode2) {
      ll = asn1E_AdditionalTerm (pctxt, ((AdditionalTerm*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode referenceInformation */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_ReferenceInformation (pctxt, &pvalue->referenceInformation, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode dateAdjustments */

   if (pvalue->m.dateAdjustmentsPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_BusinessDayAdjustments (pctxt, &pvalue->dateAdjustments, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode buyerPartyReference */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_PartyReference (pctxt, &pvalue->buyerPartyReference, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode sellerPartyReference */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_PartyReference (pctxt, &pvalue->sellerPartyReference, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode scheduledTerminationDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_ScheduledTerminationDate (pctxt, &pvalue->scheduledTerminationDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode effectiveDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_AdjustableDate2 (pctxt, &pvalue->effectiveDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_GeneralTerms (OSCTXT* pctxt, GeneralTerms* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode effectiveDate */

   stat = XmlEnc_AdjustableDate2 (pctxt, &pvalue->effectiveDate
      , OSUTF8("effectiveDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode scheduledTerminationDate */

   stat = XmlEnc_ScheduledTerminationDate (pctxt, &pvalue->
      scheduledTerminationDate, OSUTF8("scheduledTerminationDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode sellerPartyReference */

   stat = XmlEnc_PartyReference (pctxt, &pvalue->sellerPartyReference
      , OSUTF8("sellerPartyReference"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode buyerPartyReference */

   stat = XmlEnc_PartyReference (pctxt, &pvalue->buyerPartyReference
      , OSUTF8("buyerPartyReference"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dateAdjustments */

   if (pvalue->m.dateAdjustmentsPresent) {
      stat = XmlEnc_BusinessDayAdjustments (pctxt, &pvalue->dateAdjustments
         , OSUTF8("dateAdjustments"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode referenceInformation */

   stat = XmlEnc_ReferenceInformation (pctxt, &pvalue->referenceInformation
      , OSUTF8("referenceInformation"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode additionalTerm_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->additionalTerm_list.head;
   while (0 != pnode) {
      stat = XmlEnc_AdditionalTerm (pctxt, ((AdditionalTerm*)pnode->data)
         , OSUTF8("additionalTerm"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SinglePayment                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SinglePayment (OSCTXT* pctxt,
   SinglePayment *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode fixedAmount */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_Money_derivations (pctxt, &pvalue->fixedAmount, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode adjustedPaymentDate */

   if (pvalue->m.adjustedPaymentDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_charstr (pctxt, pvalue->adjustedPaymentDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode adjustablePaymentDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_charstr (pctxt, pvalue->adjustablePaymentDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SinglePayment (OSCTXT* pctxt, SinglePayment* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode adjustablePaymentDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
      adjustablePaymentDate, OSUTF8("adjustablePaymentDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode adjustedPaymentDate */

   if (pvalue->m.adjustedPaymentDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         adjustedPaymentDate, OSUTF8("adjustedPaymentDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fixedAmount */

   stat = XmlEnc_Money_derivations (pctxt, &pvalue->fixedAmount
      , OSUTF8("fixedAmount"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FixedAmountCalculation                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FixedAmountCalculation (OSCTXT* pctxt,
   FixedAmountCalculation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode dayCountFraction */

   if (pvalue->m.dayCountFractionPresent) {
      if(pvalue->dayCountFraction < 0 || pvalue->dayCountFraction > 7)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         asn1E_DayCountFractionEnum (pctxt, &pvalue->dayCountFraction, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode fixedRate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_real (pctxt, &pvalue->fixedRate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode calculationAmount */

   if (pvalue->m.calculationAmountPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Money_derivations (pctxt, &pvalue->calculationAmount, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FixedAmountCalculation (OSCTXT* pctxt, 
   FixedAmountCalculation* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode calculationAmount */

   if (pvalue->m.calculationAmountPresent) {
      stat = XmlEnc_Money_derivations (pctxt, &pvalue->calculationAmount
         , OSUTF8("calculationAmount"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fixedRate */

   stat = rtXmlEncDouble (pctxt, pvalue->fixedRate
      , OSUTF8("fixedRate"), nsPrefix, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dayCountFraction */

   if (pvalue->m.dayCountFractionPresent) {
      if(pvalue->dayCountFraction < 0 || pvalue->dayCountFraction > 7)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_DayCountFractionEnum (pctxt, pvalue->dayCountFraction
         , OSUTF8("dayCountFraction"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PeriodicPayment_choice                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PeriodicPayment_choice (OSCTXT* pctxt,
   PeriodicPayment_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_Money_derivations (pctxt, pvalue->u.fixedAmount, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_FixedAmountCalculation (pctxt, pvalue->u.fixedAmountCalculation, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_PeriodicPayment_choice (OSCTXT* pctxt, 
   PeriodicPayment_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode fixedAmount */

         stat = XmlEnc_Money_derivations (pctxt, pvalue->u.fixedAmount
            , OSUTF8("fixedAmount"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode fixedAmountCalculation */

         stat = XmlEnc_FixedAmountCalculation (pctxt, pvalue->
            u.fixedAmountCalculation
            , OSUTF8("fixedAmountCalculation"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AdjustedPaymentDates                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AdjustedPaymentDates (OSCTXT* pctxt,
   AdjustedPaymentDates *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode paymentAmount */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Money_derivations (pctxt, &pvalue->paymentAmount, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode adjustedPaymentDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_charstr (pctxt, pvalue->adjustedPaymentDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_AdjustedPaymentDates (OSCTXT* pctxt, AdjustedPaymentDates* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode adjustedPaymentDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
      adjustedPaymentDate, OSUTF8("adjustedPaymentDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode paymentAmount */

   stat = XmlEnc_Money_derivations (pctxt, &pvalue->paymentAmount
      , OSUTF8("paymentAmount"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PeriodicPayment                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PeriodicPayment (OSCTXT* pctxt,
   PeriodicPayment *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode adjustedPaymentDates_list */

   pnode2 = pvalue->adjustedPaymentDates_list.tail;
   while (0 != pnode2) {
      ll = asn1E_AdjustedPaymentDates (pctxt, ((AdjustedPaymentDates*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_PeriodicPayment_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode rollConvention */

   if(pvalue->rollConvention < 0 || pvalue->rollConvention > 43)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
      asn1E_RollConventionEnum (pctxt, &pvalue->rollConvention, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode lastRegularPaymentDate */

   if (pvalue->m.lastRegularPaymentDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_charstr (pctxt, pvalue->lastRegularPaymentDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode firstPaymentDate */

   if (pvalue->m.firstPaymentDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_charstr (pctxt, pvalue->firstPaymentDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode paymentFrequency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Interval_derivations (pctxt, &pvalue->paymentFrequency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PeriodicPayment (OSCTXT* pctxt, PeriodicPayment* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode paymentFrequency */

   stat = XmlEnc_Interval_derivations (pctxt, &pvalue->paymentFrequency
      , OSUTF8("paymentFrequency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode firstPaymentDate */

   if (pvalue->m.firstPaymentDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         firstPaymentDate, OSUTF8("firstPaymentDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode lastRegularPaymentDate */

   if (pvalue->m.lastRegularPaymentDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         lastRegularPaymentDate, OSUTF8("lastRegularPaymentDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode rollConvention */

   if(pvalue->rollConvention < 0 || pvalue->rollConvention > 43)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_RollConventionEnum (pctxt, pvalue->rollConvention
      , OSUTF8("rollConvention"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode choice */

   stat = XmlEnc_PeriodicPayment_choice (pctxt, &pvalue->choice
      , OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode adjustedPaymentDates_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->adjustedPaymentDates_list.head;
   while (0 != pnode) {
      stat = XmlEnc_AdjustedPaymentDates (pctxt, 
         ((AdjustedPaymentDates*)pnode->data)
         , OSUTF8("adjustedPaymentDates"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeeLeg                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FeeLeg (OSCTXT* pctxt,
   FeeLeg *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode periodicPayment */

   if (pvalue->m.periodicPaymentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_PeriodicPayment (pctxt, &pvalue->periodicPayment, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode singlePayment_list */

   pnode2 = pvalue->singlePayment_list.tail;
   while (0 != pnode2) {
      ll = asn1E_SinglePayment (pctxt, ((SinglePayment*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FeeLeg (OSCTXT* pctxt, FeeLeg* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode singlePayment_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->singlePayment_list.head;
   while (0 != pnode) {
      stat = XmlEnc_SinglePayment (pctxt, ((SinglePayment*)pnode->data)
         , OSUTF8("singlePayment"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode periodicPayment */

   if (pvalue->m.periodicPaymentPresent) {
      stat = XmlEnc_PeriodicPayment (pctxt, &pvalue->periodicPayment
         , OSUTF8("periodicPayment"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GracePeriodExtension                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_GracePeriodExtension (OSCTXT* pctxt,
   GracePeriodExtension *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_Offset_derivations (pctxt, pvalue, ASN1IMPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   if (tagging == ASN1EXPL) {
      ll = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
   }
   ll0 += ll;

   return (ll0);
}

int XmlEnc_GracePeriodExtension (OSCTXT* pctxt, GracePeriodExtension* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   stat = XmlEnc_Offset_derivations (pctxt, pvalue
      , OSUTF8("gracePeriod"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FailureToPay                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FailureToPay (OSCTXT* pctxt,
   FailureToPay *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode paymentRequirement */

   if (pvalue->m.paymentRequirementPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Money_derivations (pctxt, &pvalue->paymentRequirement, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode gracePeriodExtension */

   if (pvalue->m.gracePeriodExtensionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_GracePeriodExtension (pctxt, &pvalue->gracePeriodExtension, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FailureToPay (OSCTXT* pctxt, FailureToPay* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode gracePeriodExtension */

   if (pvalue->m.gracePeriodExtensionPresent) {
      stat = XmlEnc_GracePeriodExtension (pctxt, &pvalue->gracePeriodExtension
         , OSUTF8("gracePeriodExtension"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode paymentRequirement */

   if (pvalue->m.paymentRequirementPresent) {
      stat = XmlEnc_Money_derivations (pctxt, &pvalue->paymentRequirement
         , OSUTF8("paymentRequirement"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RestructuringType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RestructuringType (OSCTXT* pctxt,
   RestructuringType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode restructuringScheme */

   if (pvalue->m.restructuringSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->restructuringScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_RestructuringType (OSCTXT* pctxt, RestructuringType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.restructuringSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" restructuringScheme=\""), 22);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->restructuringScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Restructuring                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Restructuring (OSCTXT* pctxt,
   Restructuring *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode multipleCreditEventNotices */

   if (pvalue->m.multipleCreditEventNoticesPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Empty (pctxt, &pvalue->multipleCreditEventNotices, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode multipleHolderObligation */

   if (pvalue->m.multipleHolderObligationPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Empty (pctxt, &pvalue->multipleHolderObligation, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode restructuringType */

   if (pvalue->m.restructuringTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_RestructuringType (pctxt, &pvalue->restructuringType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Restructuring (OSCTXT* pctxt, Restructuring* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode restructuringType */

   if (pvalue->m.restructuringTypePresent) {
      stat = XmlEnc_RestructuringType (pctxt, &pvalue->restructuringType
         , OSUTF8("restructuringType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode multipleHolderObligation */

   if (pvalue->m.multipleHolderObligationPresent) {
      stat = XmlEnc_Empty (pctxt, &pvalue->multipleHolderObligation
         , OSUTF8("multipleHolderObligation"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode multipleCreditEventNotices */

   if (pvalue->m.multipleCreditEventNoticesPresent) {
      stat = XmlEnc_Empty (pctxt, &pvalue->multipleCreditEventNotices
         , OSUTF8("multipleCreditEventNotices"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotifyingParty                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_NotifyingParty (OSCTXT* pctxt,
   NotifyingParty *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode sellerPartyReference */

   if (pvalue->m.sellerPartyReferencePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_PartyReference (pctxt, &pvalue->sellerPartyReference, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode buyerPartyReference */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_PartyReference (pctxt, &pvalue->buyerPartyReference, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_NotifyingParty (OSCTXT* pctxt, NotifyingParty* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode buyerPartyReference */

   stat = XmlEnc_PartyReference (pctxt, &pvalue->buyerPartyReference
      , OSUTF8("buyerPartyReference"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode sellerPartyReference */

   if (pvalue->m.sellerPartyReferencePresent) {
      stat = XmlEnc_PartyReference (pctxt, &pvalue->sellerPartyReference
         , OSUTF8("sellerPartyReference"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PubliclyAvailableInformation                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PubliclyAvailableInformation (OSCTXT* pctxt,
   PubliclyAvailableInformation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode specifiedNumber */

   if (pvalue->m.specifiedNumberPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_unsigned (pctxt, &pvalue->specifiedNumber, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode publicSource_list */

   pnode2 = pvalue->publicSource_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode standardPublicSources */

   if (pvalue->m.standardPublicSourcesPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Empty (pctxt, &pvalue->standardPublicSources, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PubliclyAvailableInformation (OSCTXT* pctxt, 
   PubliclyAvailableInformation* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode standardPublicSources */

   if (pvalue->m.standardPublicSourcesPresent) {
      stat = XmlEnc_Empty (pctxt, &pvalue->standardPublicSources
         , OSUTF8("standardPublicSources"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode publicSource_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->publicSource_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("publicSource"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode specifiedNumber */

   if (pvalue->m.specifiedNumberPresent) {
      stat = rtXmlEncUInt (pctxt, pvalue->specifiedNumber
         , OSUTF8("specifiedNumber"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CreditEventNotice                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CreditEventNotice (OSCTXT* pctxt,
   CreditEventNotice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode publiclyAvailableInformation */

   if (pvalue->m.publiclyAvailableInformationPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_PubliclyAvailableInformation (pctxt, &pvalue->publiclyAvailableInformation, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode businessCenter */

   if (pvalue->m.businessCenterPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_BusinessCenter (pctxt, &pvalue->businessCenter, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode notifyingParty */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_NotifyingParty (pctxt, &pvalue->notifyingParty, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CreditEventNotice (OSCTXT* pctxt, CreditEventNotice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode notifyingParty */

   stat = XmlEnc_NotifyingParty (pctxt, &pvalue->notifyingParty
      , OSUTF8("notifyingParty"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode businessCenter */

   if (pvalue->m.businessCenterPresent) {
      stat = XmlEnc_BusinessCenter (pctxt, &pvalue->businessCenter
         , OSUTF8("businessCenter"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode publiclyAvailableInformation */

   if (pvalue->m.publiclyAvailableInformationPresent) {
      stat = XmlEnc_PubliclyAvailableInformation (pctxt, &pvalue->
         publiclyAvailableInformation
         , OSUTF8("publiclyAvailableInformation"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CreditEvents                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CreditEvents (OSCTXT* pctxt,
   CreditEvents *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode creditEventNotice */

   if (pvalue->m.creditEventNoticePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_CreditEventNotice (pctxt, &pvalue->creditEventNotice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode defaultRequirement */

   if (pvalue->m.defaultRequirementPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_Money_derivations (pctxt, &pvalue->defaultRequirement, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode restructuring */

   if (pvalue->m.restructuringPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_Restructuring (pctxt, &pvalue->restructuring, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode repudiationMoratorium */

   if (pvalue->m.repudiationMoratoriumPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Empty (pctxt, &pvalue->repudiationMoratorium, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode obligationAcceleration */

   if (pvalue->m.obligationAccelerationPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Empty (pctxt, &pvalue->obligationAcceleration, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode obligationDefault */

   if (pvalue->m.obligationDefaultPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Empty (pctxt, &pvalue->obligationDefault, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode failureToPay */

   if (pvalue->m.failureToPayPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_FailureToPay (pctxt, &pvalue->failureToPay, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bankruptcy */

   if (pvalue->m.bankruptcyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Empty (pctxt, &pvalue->bankruptcy, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CreditEvents (OSCTXT* pctxt, CreditEvents* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode bankruptcy */

   if (pvalue->m.bankruptcyPresent) {
      stat = XmlEnc_Empty (pctxt, &pvalue->bankruptcy
         , OSUTF8("bankruptcy"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode failureToPay */

   if (pvalue->m.failureToPayPresent) {
      stat = XmlEnc_FailureToPay (pctxt, &pvalue->failureToPay
         , OSUTF8("failureToPay"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode obligationDefault */

   if (pvalue->m.obligationDefaultPresent) {
      stat = XmlEnc_Empty (pctxt, &pvalue->obligationDefault
         , OSUTF8("obligationDefault"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode obligationAcceleration */

   if (pvalue->m.obligationAccelerationPresent) {
      stat = XmlEnc_Empty (pctxt, &pvalue->obligationAcceleration
         , OSUTF8("obligationAcceleration"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode repudiationMoratorium */

   if (pvalue->m.repudiationMoratoriumPresent) {
      stat = XmlEnc_Empty (pctxt, &pvalue->repudiationMoratorium
         , OSUTF8("repudiationMoratorium"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode restructuring */

   if (pvalue->m.restructuringPresent) {
      stat = XmlEnc_Restructuring (pctxt, &pvalue->restructuring
         , OSUTF8("restructuring"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode defaultRequirement */

   if (pvalue->m.defaultRequirementPresent) {
      stat = XmlEnc_Money_derivations (pctxt, &pvalue->defaultRequirement
         , OSUTF8("defaultRequirement"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode creditEventNotice */

   if (pvalue->m.creditEventNoticePresent) {
      stat = XmlEnc_CreditEventNotice (pctxt, &pvalue->creditEventNotice
         , OSUTF8("creditEventNotice"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ObligationCategoryEnum                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ObligationCategoryEnum (OSCTXT* pctxt,
   ObligationCategoryEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 5)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ObligationCategoryEnum (OSCTXT* pctxt, 
   ObligationCategoryEnum value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      ObligationCategoryEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SpecifiedCurrency                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SpecifiedCurrency (OSCTXT* pctxt,
   SpecifiedCurrency *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_Currency (pctxt, ((Currency*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SpecifiedCurrency (OSCTXT* pctxt, SpecifiedCurrency* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_Currency (pctxt, ((Currency*)pnode->data)
         , OSUTF8("currency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotDomesticCurrency                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_NotDomesticCurrency (OSCTXT* pctxt,
   NotDomesticCurrency *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_Currency (pctxt, pvalue, ASN1IMPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   if (tagging == ASN1EXPL) {
      ll = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
   }
   ll0 += ll;

   return (ll0);
}

int XmlEnc_NotDomesticCurrency (OSCTXT* pctxt, NotDomesticCurrency* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   stat = XmlEnc_Currency (pctxt, pvalue, OSUTF8("currency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Obligations                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Obligations (OSCTXT* pctxt,
   Obligations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode othReferenceEntityObligations */

   if (pvalue->m.othReferenceEntityObligationsPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|10,
         xe_utf8str (pctxt, pvalue->othReferenceEntityObligations, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode excluded */

   if (pvalue->m.excludedPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|9,
         xe_utf8str (pctxt, pvalue->excluded, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode notContingent */

   if (pvalue->m.notContingentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_Empty (pctxt, &pvalue->notContingent, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode notDomesticIssuance */

   if (pvalue->m.notDomesticIssuancePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_Empty (pctxt, &pvalue->notDomesticIssuance, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode listed */

   if (pvalue->m.listedPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_Empty (pctxt, &pvalue->listed, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode notDomesticLaw */

   if (pvalue->m.notDomesticLawPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_Empty (pctxt, &pvalue->notDomesticLaw, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode notDomesticCurrency */

   if (pvalue->m.notDomesticCurrencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_NotDomesticCurrency (pctxt, &pvalue->notDomesticCurrency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode notSovereignLender */

   if (pvalue->m.notSovereignLenderPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Empty (pctxt, &pvalue->notSovereignLender, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode specifiedCurrency */

   if (pvalue->m.specifiedCurrencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_SpecifiedCurrency (pctxt, &pvalue->specifiedCurrency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode notSubordinated */

   if (pvalue->m.notSubordinatedPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Empty (pctxt, &pvalue->notSubordinated, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode category */

   if(pvalue->category < 0 || pvalue->category > 5)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_ObligationCategoryEnum (pctxt, &pvalue->category, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Obligations (OSCTXT* pctxt, Obligations* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode category */

   if(pvalue->category < 0 || pvalue->category > 5)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_ObligationCategoryEnum (pctxt, pvalue->category
      , OSUTF8("category"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode notSubordinated */

   if (pvalue->m.notSubordinatedPresent) {
      stat = XmlEnc_Empty (pctxt, &pvalue->notSubordinated
         , OSUTF8("notSubordinated"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode specifiedCurrency */

   if (pvalue->m.specifiedCurrencyPresent) {
      stat = XmlEnc_SpecifiedCurrency (pctxt, &pvalue->specifiedCurrency
         , OSUTF8("specifiedCurrency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode notSovereignLender */

   if (pvalue->m.notSovereignLenderPresent) {
      stat = XmlEnc_Empty (pctxt, &pvalue->notSovereignLender
         , OSUTF8("notSovereignLender"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode notDomesticCurrency */

   if (pvalue->m.notDomesticCurrencyPresent) {
      stat = XmlEnc_NotDomesticCurrency (pctxt, &pvalue->notDomesticCurrency
         , OSUTF8("notDomesticCurrency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode notDomesticLaw */

   if (pvalue->m.notDomesticLawPresent) {
      stat = XmlEnc_Empty (pctxt, &pvalue->notDomesticLaw
         , OSUTF8("notDomesticLaw"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode listed */

   if (pvalue->m.listedPresent) {
      stat = XmlEnc_Empty (pctxt, &pvalue->listed
         , OSUTF8("listed"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode notDomesticIssuance */

   if (pvalue->m.notDomesticIssuancePresent) {
      stat = XmlEnc_Empty (pctxt, &pvalue->notDomesticIssuance
         , OSUTF8("notDomesticIssuance"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode notContingent */

   if (pvalue->m.notContingentPresent) {
      stat = XmlEnc_Empty (pctxt, &pvalue->notContingent
         , OSUTF8("notContingent"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode excluded */

   if (pvalue->m.excludedPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->excluded
         , OSUTF8("excluded"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode othReferenceEntityObligations */

   if (pvalue->m.othReferenceEntityObligationsPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->othReferenceEntityObligations
         , OSUTF8("othReferenceEntityObligations"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ProtectionTerms                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ProtectionTerms (OSCTXT* pctxt,
   ProtectionTerms *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode obligations */

   if (pvalue->m.obligationsPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Obligations (pctxt, &pvalue->obligations, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode creditEvents */

   if (pvalue->m.creditEventsPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_CreditEvents (pctxt, &pvalue->creditEvents, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode calculationAmount */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Money_derivations (pctxt, &pvalue->calculationAmount, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ProtectionTerms (OSCTXT* pctxt, ProtectionTerms* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode calculationAmount */

   stat = XmlEnc_Money_derivations (pctxt, &pvalue->calculationAmount
      , OSUTF8("calculationAmount"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode creditEvents */

   if (pvalue->m.creditEventsPresent) {
      stat = XmlEnc_CreditEvents (pctxt, &pvalue->creditEvents
         , OSUTF8("creditEvents"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode obligations */

   if (pvalue->m.obligationsPresent) {
      stat = XmlEnc_Obligations (pctxt, &pvalue->obligations
         , OSUTF8("obligations"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SingleValuationDate                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SingleValuationDate (OSCTXT* pctxt,
   SingleValuationDate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_unsigned (pctxt, pvalue, ASN1IMPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0, ll);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   if (tagging == ASN1EXPL) {
      ll = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
   }
   ll0 += ll;

   return (ll0);
}

int XmlEnc_SingleValuationDate (OSCTXT* pctxt, SingleValuationDate value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   stat = rtXmlEncUInt (pctxt, value, OSUTF8("businessDays"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultipleValuationDates                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MultipleValuationDates (OSCTXT* pctxt,
   MultipleValuationDates *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode numberValuationDates */

   if (pvalue->m.numberValuationDatesPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_unsigned (pctxt, &pvalue->numberValuationDates, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode businessDaysThereafter */

   if (pvalue->m.businessDaysThereafterPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_unsigned (pctxt, &pvalue->businessDaysThereafter, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode businessDays */

   if (pvalue->m.businessDaysPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_unsigned (pctxt, &pvalue->businessDays, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MultipleValuationDates (OSCTXT* pctxt, 
   MultipleValuationDates* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode businessDays */

   if (pvalue->m.businessDaysPresent) {
      stat = rtXmlEncUInt (pctxt, pvalue->businessDays
         , OSUTF8("businessDays"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode businessDaysThereafter */

   if (pvalue->m.businessDaysThereafterPresent) {
      stat = rtXmlEncUInt (pctxt, pvalue->businessDaysThereafter
         , OSUTF8("businessDaysThereafter"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode numberValuationDates */

   if (pvalue->m.numberValuationDatesPresent) {
      stat = rtXmlEncUInt (pctxt, pvalue->numberValuationDates
         , OSUTF8("numberValuationDates"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SingleValuationDate_derivations                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SingleValuationDate_derivations (OSCTXT* pctxt,
   SingleValuationDate_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_SingleValuationDate (pctxt, &pvalue->u.singleValuationDate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_MultipleValuationDates (pctxt, pvalue->u.multipleValuationDates, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_SingleValuationDate_derivations (OSCTXT* pctxt, 
   SingleValuationDate_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode singleValuationDate */

         stat = XmlEnc_SingleValuationDate (pctxt, pvalue->
            u.singleValuationDate, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode multipleValuationDates */

         stat = XmlEnc_MultipleValuationDates (pctxt, pvalue->
            u.multipleValuationDates, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ValuationDate                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ValuationDate (OSCTXT* pctxt,
   ValuationDate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_SingleValuationDate_derivations (pctxt, pvalue->u.singleValuationDate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_MultipleValuationDates (pctxt, pvalue->u.multipleValuationDates, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   if (tagging == ASN1EXPL) {
      ll1 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll1);
      if (ll1 < 0) return LOG_RTERR (pctxt, ll1);
   }

   ll0 += ll1;

   return (ll0);
}

int XmlEnc_ValuationDate (OSCTXT* pctxt, ValuationDate* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode singleValuationDate */

         stat = XmlEnc_SingleValuationDate_derivations (pctxt, pvalue->
            u.singleValuationDate, OSUTF8("singleValuationDate"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode multipleValuationDates */

         stat = XmlEnc_MultipleValuationDates (pctxt, pvalue->
            u.multipleValuationDates
            , OSUTF8("multipleValuationDates"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ValuationMethodEnum                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ValuationMethodEnum (OSCTXT* pctxt,
   ValuationMethodEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 7)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ValuationMethodEnum (OSCTXT* pctxt, ValuationMethodEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      ValuationMethodEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CashSettlementTerms                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CashSettlementTerms (OSCTXT* pctxt,
   CashSettlementTerms *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode valuationMethod */

   if (pvalue->m.valuationMethodPresent) {
      if(pvalue->valuationMethod < 0 || pvalue->valuationMethod > 7)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|10,
         asn1E_ValuationMethodEnum (pctxt, &pvalue->valuationMethod, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode accruedInterest */

   if (pvalue->m.accruedInterestPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|9,
         xe_boolean (pctxt, &pvalue->accruedInterest, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode cashSettlementAmount */

   if (pvalue->m.cashSettlementAmountPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_Money_derivations (pctxt, &pvalue->cashSettlementAmount, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode cashSettlementBusinessDays */

   if (pvalue->m.cashSettlementBusinessDaysPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
         xe_unsigned (pctxt, &pvalue->cashSettlementBusinessDays, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dealer_list */

   pnode2 = pvalue->dealer_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode minimumQuotationAmount */

   if (pvalue->m.minimumQuotationAmountPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_Money_derivations (pctxt, &pvalue->minimumQuotationAmount, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode quotationAmount */

   if (pvalue->m.quotationAmountPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Money_derivations (pctxt, &pvalue->quotationAmount, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode quotationMethod */

   if (pvalue->m.quotationMethodPresent) {
      if(pvalue->quotationMethod < 0 || pvalue->quotationMethod > 3)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         asn1E_QuotationRateTypeEnum (pctxt, &pvalue->quotationMethod, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_BusinessCenterTime (pctxt, &pvalue->valuationTime, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode valuationDate */

   if (pvalue->m.valuationDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ValuationDate (pctxt, &pvalue->valuationDate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode settlementCurrency */

   if (pvalue->m.settlementCurrencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Currency (pctxt, &pvalue->settlementCurrency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CashSettlementTerms (OSCTXT* pctxt, CashSettlementTerms* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode settlementCurrency */

   if (pvalue->m.settlementCurrencyPresent) {
      stat = XmlEnc_Currency (pctxt, &pvalue->settlementCurrency
         , OSUTF8("settlementCurrency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode valuationDate */

   if (pvalue->m.valuationDatePresent) {
      stat = XmlEnc_ValuationDate (pctxt, &pvalue->valuationDate
         , OSUTF8("valuationDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->valuationTime
         , OSUTF8("valuationTime"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quotationMethod */

   if (pvalue->m.quotationMethodPresent) {
      if(pvalue->quotationMethod < 0 || pvalue->quotationMethod > 3)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_QuotationRateTypeEnum (pctxt, pvalue->quotationMethod
         , OSUTF8("quotationMethod"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quotationAmount */

   if (pvalue->m.quotationAmountPresent) {
      stat = XmlEnc_Money_derivations (pctxt, &pvalue->quotationAmount
         , OSUTF8("quotationAmount"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode minimumQuotationAmount */

   if (pvalue->m.minimumQuotationAmountPresent) {
      stat = XmlEnc_Money_derivations (pctxt, &pvalue->minimumQuotationAmount
         , OSUTF8("minimumQuotationAmount"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode dealer_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->dealer_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("dealer"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode cashSettlementBusinessDays */

   if (pvalue->m.cashSettlementBusinessDaysPresent) {
      stat = rtXmlEncUInt (pctxt, pvalue->cashSettlementBusinessDays
         , OSUTF8("cashSettlementBusinessDays"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode cashSettlementAmount */

   if (pvalue->m.cashSettlementAmountPresent) {
      stat = XmlEnc_Money_derivations (pctxt, &pvalue->cashSettlementAmount
         , OSUTF8("cashSettlementAmount"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode accruedInterest */

   if (pvalue->m.accruedInterestPresent) {
      stat = rtXmlEncBool (pctxt, pvalue->accruedInterest
         , OSUTF8("accruedInterest"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode valuationMethod */

   if (pvalue->m.valuationMethodPresent) {
      if(pvalue->valuationMethod < 0 || pvalue->valuationMethod > 7)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_ValuationMethodEnum (pctxt, pvalue->valuationMethod
         , OSUTF8("valuationMethod"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PhysicalSettlementPeriod                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PhysicalSettlementPeriod (OSCTXT* pctxt,
   PhysicalSettlementPeriod *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_Empty (pctxt, pvalue->u.businessDaysNotSpecified, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
            xe_unsigned (pctxt, &pvalue->u.businessDays, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
            xe_unsigned (pctxt, &pvalue->u.maximumBusinessDays, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   if (tagging == ASN1EXPL) {
      ll1 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll1);
      if (ll1 < 0) return LOG_RTERR (pctxt, ll1);
   }

   ll0 += ll1;

   return (ll0);
}

int XmlEnc_PhysicalSettlementPeriod (OSCTXT* pctxt, 
   PhysicalSettlementPeriod* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode businessDaysNotSpecified */

         stat = XmlEnc_Empty (pctxt, pvalue->u.businessDaysNotSpecified
            , OSUTF8("businessDaysNotSpecified"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode businessDays */

         stat = rtXmlEncUInt (pctxt, pvalue->u.businessDays
            , OSUTF8("businessDays"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode maximumBusinessDays */

         stat = rtXmlEncUInt (pctxt, pvalue->u.maximumBusinessDays
            , OSUTF8("maximumBusinessDays"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PCDeliverableObligationCharac                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PCDeliverableObligationCharac (OSCTXT* pctxt,
   PCDeliverableObligationCharac *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_Empty (pctxt, pvalue, ASN1IMPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   if (tagging == ASN1EXPL) {
      ll = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
   }
   ll0 += ll;

   return (ll0);
}

int XmlEnc_PCDeliverableObligationCharac (OSCTXT* pctxt, 
   PCDeliverableObligationCharac* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   stat = XmlEnc_Empty (pctxt, pvalue
      , OSUTF8("partialCashSettlement"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LoanParticipation                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_LoanParticipation (OSCTXT* pctxt,
   LoanParticipation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode qualifyingParticipationSeller */

   if (pvalue->m.qualifyingParticipationSellerPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->qualifyingParticipationSeller, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode partialCashSettlement */

   if (pvalue->m.partialCashSettlementPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Empty (pctxt, &pvalue->partialCashSettlement, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_LoanParticipation (OSCTXT* pctxt, LoanParticipation* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode partialCashSettlement */

   if (pvalue->m.partialCashSettlementPresent) {
      stat = XmlEnc_Empty (pctxt, &pvalue->partialCashSettlement
         , OSUTF8("partialCashSettlement"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode qualifyingParticipationSeller */

   if (pvalue->m.qualifyingParticipationSellerPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->qualifyingParticipationSeller
         , OSUTF8("qualifyingParticipationSeller"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PCDeliverableObligationCharac_derivations                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PCDeliverableObligationCharac_derivations (OSCTXT* pctxt,
   PCDeliverableObligationCharac_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_PCDeliverableObligationCharac (pctxt, pvalue->u.pCDeliverableObligationCharac, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_LoanParticipation (pctxt, pvalue->u.loanParticipation, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_PCDeliverableObligationCharac_derivations (OSCTXT* pctxt, 
   PCDeliverableObligationCharac_derivations* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode pCDeliverableObligationCharac */

         stat = XmlEnc_PCDeliverableObligationCharac (pctxt, pvalue->
            u.pCDeliverableObligationCharac, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode loanParticipation */

         stat = XmlEnc_LoanParticipation (pctxt, pvalue->u.loanParticipation
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DeliverableObligations                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DeliverableObligations (OSCTXT* pctxt,
   DeliverableObligations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode othReferenceEntityObligations */

   if (pvalue->m.othReferenceEntityObligationsPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|19,
         xe_utf8str (pctxt, pvalue->othReferenceEntityObligations, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode excluded */

   if (pvalue->m.excludedPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|18,
         xe_utf8str (pctxt, pvalue->excluded, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode indirectLoanParticipation */

   if (pvalue->m.indirectLoanParticipationPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|17,
         asn1E_LoanParticipation (pctxt, &pvalue->indirectLoanParticipation, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode notBearer */

   if (pvalue->m.notBearerPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|16,
         asn1E_Empty (pctxt, &pvalue->notBearer, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode acceleratedOrMatured */

   if (pvalue->m.acceleratedOrMaturedPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|15,
         asn1E_Empty (pctxt, &pvalue->acceleratedOrMatured, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode maximumMaturity */

   if (pvalue->m.maximumMaturityPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|14,
         asn1E_Interval_derivations (pctxt, &pvalue->maximumMaturity, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode transferable */

   if (pvalue->m.transferablePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|13,
         asn1E_Empty (pctxt, &pvalue->transferable, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode directLoanParticipation */

   if (pvalue->m.directLoanParticipationPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|12,
         asn1E_LoanParticipation (pctxt, &pvalue->directLoanParticipation, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode consentRequiredLoan */

   if (pvalue->m.consentRequiredLoanPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|11,
         asn1E_PCDeliverableObligationCharac_derivations (pctxt, &pvalue->consentRequiredLoan, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode assignableLoan */

   if (pvalue->m.assignableLoanPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10,
         asn1E_PCDeliverableObligationCharac_derivations (pctxt, &pvalue->assignableLoan, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode notDomesticIssuance */

   if (pvalue->m.notDomesticIssuancePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9,
         asn1E_Empty (pctxt, &pvalue->notDomesticIssuance, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode notContingent */

   if (pvalue->m.notContingentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_Empty (pctxt, &pvalue->notContingent, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode listed */

   if (pvalue->m.listedPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_Empty (pctxt, &pvalue->listed, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode notDomesticLaw */

   if (pvalue->m.notDomesticLawPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_Empty (pctxt, &pvalue->notDomesticLaw, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode notDomesticCurrency */

   if (pvalue->m.notDomesticCurrencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_NotDomesticCurrency (pctxt, &pvalue->notDomesticCurrency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode notSovereignLender */

   if (pvalue->m.notSovereignLenderPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Empty (pctxt, &pvalue->notSovereignLender, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode specifiedCurrency */

   if (pvalue->m.specifiedCurrencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_SpecifiedCurrency (pctxt, &pvalue->specifiedCurrency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode notSubordinated */

   if (pvalue->m.notSubordinatedPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Empty (pctxt, &pvalue->notSubordinated, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode category */

   if(pvalue->category < 0 || pvalue->category > 5)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_ObligationCategoryEnum (pctxt, &pvalue->category, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode accruedInterest */

   if (pvalue->m.accruedInterestPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_boolean (pctxt, &pvalue->accruedInterest, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DeliverableObligations (OSCTXT* pctxt, 
   DeliverableObligations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode accruedInterest */

   if (pvalue->m.accruedInterestPresent) {
      stat = rtXmlEncBool (pctxt, pvalue->accruedInterest
         , OSUTF8("accruedInterest"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode category */

   if(pvalue->category < 0 || pvalue->category > 5)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_ObligationCategoryEnum (pctxt, pvalue->category
      , OSUTF8("category"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode notSubordinated */

   if (pvalue->m.notSubordinatedPresent) {
      stat = XmlEnc_Empty (pctxt, &pvalue->notSubordinated
         , OSUTF8("notSubordinated"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode specifiedCurrency */

   if (pvalue->m.specifiedCurrencyPresent) {
      stat = XmlEnc_SpecifiedCurrency (pctxt, &pvalue->specifiedCurrency
         , OSUTF8("specifiedCurrency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode notSovereignLender */

   if (pvalue->m.notSovereignLenderPresent) {
      stat = XmlEnc_Empty (pctxt, &pvalue->notSovereignLender
         , OSUTF8("notSovereignLender"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode notDomesticCurrency */

   if (pvalue->m.notDomesticCurrencyPresent) {
      stat = XmlEnc_NotDomesticCurrency (pctxt, &pvalue->notDomesticCurrency
         , OSUTF8("notDomesticCurrency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode notDomesticLaw */

   if (pvalue->m.notDomesticLawPresent) {
      stat = XmlEnc_Empty (pctxt, &pvalue->notDomesticLaw
         , OSUTF8("notDomesticLaw"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode listed */

   if (pvalue->m.listedPresent) {
      stat = XmlEnc_Empty (pctxt, &pvalue->listed
         , OSUTF8("listed"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode notContingent */

   if (pvalue->m.notContingentPresent) {
      stat = XmlEnc_Empty (pctxt, &pvalue->notContingent
         , OSUTF8("notContingent"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode notDomesticIssuance */

   if (pvalue->m.notDomesticIssuancePresent) {
      stat = XmlEnc_Empty (pctxt, &pvalue->notDomesticIssuance
         , OSUTF8("notDomesticIssuance"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode assignableLoan */

   if (pvalue->m.assignableLoanPresent) {
      stat = XmlEnc_PCDeliverableObligationCharac_derivations (pctxt, &pvalue->
         assignableLoan, OSUTF8("assignableLoan"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode consentRequiredLoan */

   if (pvalue->m.consentRequiredLoanPresent) {
      stat = XmlEnc_PCDeliverableObligationCharac_derivations (pctxt, &pvalue->
         consentRequiredLoan, OSUTF8("consentRequiredLoan"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode directLoanParticipation */

   if (pvalue->m.directLoanParticipationPresent) {
      stat = XmlEnc_LoanParticipation (pctxt, &pvalue->directLoanParticipation
         , OSUTF8("directLoanParticipation"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode transferable */

   if (pvalue->m.transferablePresent) {
      stat = XmlEnc_Empty (pctxt, &pvalue->transferable
         , OSUTF8("transferable"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode maximumMaturity */

   if (pvalue->m.maximumMaturityPresent) {
      stat = XmlEnc_Interval_derivations (pctxt, &pvalue->maximumMaturity
         , OSUTF8("maximumMaturity"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode acceleratedOrMatured */

   if (pvalue->m.acceleratedOrMaturedPresent) {
      stat = XmlEnc_Empty (pctxt, &pvalue->acceleratedOrMatured
         , OSUTF8("acceleratedOrMatured"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode notBearer */

   if (pvalue->m.notBearerPresent) {
      stat = XmlEnc_Empty (pctxt, &pvalue->notBearer
         , OSUTF8("notBearer"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode indirectLoanParticipation */

   if (pvalue->m.indirectLoanParticipationPresent) {
      stat = XmlEnc_LoanParticipation (pctxt, &pvalue->
         indirectLoanParticipation
         , OSUTF8("indirectLoanParticipation"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode excluded */

   if (pvalue->m.excludedPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->excluded
         , OSUTF8("excluded"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode othReferenceEntityObligations */

   if (pvalue->m.othReferenceEntityObligationsPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->othReferenceEntityObligations
         , OSUTF8("othReferenceEntityObligations"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PhysicalSettlementTerms                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PhysicalSettlementTerms (OSCTXT* pctxt,
   PhysicalSettlementTerms *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode escrow */

   if (pvalue->m.escrowPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_boolean (pctxt, &pvalue->escrow, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode deliverableObligations */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_DeliverableObligations (pctxt, &pvalue->deliverableObligations, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode physicalSettlementPeriod */

   if (pvalue->m.physicalSettlementPeriodPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_PhysicalSettlementPeriod (pctxt, &pvalue->physicalSettlementPeriod, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode settlementCurrency */

   if (pvalue->m.settlementCurrencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Currency (pctxt, &pvalue->settlementCurrency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PhysicalSettlementTerms (OSCTXT* pctxt, 
   PhysicalSettlementTerms* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode settlementCurrency */

   if (pvalue->m.settlementCurrencyPresent) {
      stat = XmlEnc_Currency (pctxt, &pvalue->settlementCurrency
         , OSUTF8("settlementCurrency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode physicalSettlementPeriod */

   if (pvalue->m.physicalSettlementPeriodPresent) {
      stat = XmlEnc_PhysicalSettlementPeriod (pctxt, &pvalue->
         physicalSettlementPeriod
         , OSUTF8("physicalSettlementPeriod"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode deliverableObligations */

   stat = XmlEnc_DeliverableObligations (pctxt, &pvalue->deliverableObligations
      , OSUTF8("deliverableObligations"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode escrow */

   if (pvalue->m.escrowPresent) {
      stat = rtXmlEncBool (pctxt, pvalue->escrow, OSUTF8("escrow"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CreditDefaultSwap_choice                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CreditDefaultSwap_choice (OSCTXT* pctxt,
   CreditDefaultSwap_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_CashSettlementTerms (pctxt, pvalue->u.cashSettlementTerms, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_PhysicalSettlementTerms (pctxt, pvalue->u.physicalSettlementTerms, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_CreditDefaultSwap_choice (OSCTXT* pctxt, 
   CreditDefaultSwap_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode cashSettlementTerms */

         stat = XmlEnc_CashSettlementTerms (pctxt, pvalue->
            u.cashSettlementTerms, OSUTF8("cashSettlementTerms"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode physicalSettlementTerms */

         stat = XmlEnc_PhysicalSettlementTerms (pctxt, pvalue->
            u.physicalSettlementTerms
            , OSUTF8("physicalSettlementTerms"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CreditDefaultSwap                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CreditDefaultSwap (OSCTXT* pctxt,
   CreditDefaultSwap *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode choice */

   if (pvalue->m.choicePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_CreditDefaultSwap_choice (pctxt, &pvalue->choice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode protectionTerms */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_ProtectionTerms (pctxt, &pvalue->protectionTerms, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode feeLeg */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_FeeLeg (pctxt, &pvalue->feeLeg, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode generalTerms */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_GeneralTerms (pctxt, &pvalue->generalTerms, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode productId_list */

   pnode2 = pvalue->productId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ProductId (pctxt, ((ProductId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ProductType (pctxt, &pvalue->productType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CreditDefaultSwap (OSCTXT* pctxt, CreditDefaultSwap* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      stat = XmlEnc_ProductType (pctxt, &pvalue->productType
         , OSUTF8("productType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode productId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->productId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ProductId (pctxt, ((ProductId*)pnode->data)
         , OSUTF8("productId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode generalTerms */

   stat = XmlEnc_GeneralTerms (pctxt, &pvalue->generalTerms
      , OSUTF8("generalTerms"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode feeLeg */

   stat = XmlEnc_FeeLeg (pctxt, &pvalue->feeLeg, OSUTF8("feeLeg"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protectionTerms */

   stat = XmlEnc_ProtectionTerms (pctxt, &pvalue->protectionTerms
      , OSUTF8("protectionTerms"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode choice */

   if (pvalue->m.choicePresent) {
      stat = XmlEnc_CreditDefaultSwap_choice (pctxt, &pvalue->choice
         , OSUTF8(""), 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Product_group                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Product_group (OSCTXT* pctxt,
   Product_group *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_Strategy (pctxt, pvalue->u.strategy, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_FxAverageRateOption (pctxt, pvalue->u.fxAverageRateOption, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_FxBarrierOption (pctxt, pvalue->u.fxBarrierOption, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 4:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
            asn1E_FxDigitalOption (pctxt, pvalue->u.fxDigitalOption, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 5:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
            asn1E_FxSimpleOption (pctxt, pvalue->u.fxSimpleOption, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 6:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
            asn1E_FxSingleLeg (pctxt, pvalue->u.fxSingleLeg, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 7:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
            asn1E_FxSwap (pctxt, pvalue->u.fxSwap, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 8:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
            asn1E_TermDeposit (pctxt, pvalue->u.termDeposit, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 9:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
            asn1E_BulletPayment (pctxt, pvalue->u.bulletPayment, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 10:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9,
            asn1E_CapFloor (pctxt, pvalue->u.capFloor, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 11:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10,
            asn1E_Fra (pctxt, pvalue->u.fra, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 12:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|11,
            asn1E_Swap (pctxt, pvalue->u.swap, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 13:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|12,
            asn1E_Swaption (pctxt, pvalue->u.swaption, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 14:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|13,
            asn1E_EquityOption (pctxt, pvalue->u.equityOption, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 15:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|14,
            asn1E_EquitySwap (pctxt, pvalue->u.equitySwap, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 16:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|15,
            asn1E_CreditDefaultSwap (pctxt, pvalue->u.creditDefaultSwap, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Product_group (OSCTXT* pctxt, Product_group* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode strategy */

         stat = XmlEnc_Strategy (pctxt, pvalue->u.strategy
            , OSUTF8("strategy"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode fxAverageRateOption */

         stat = XmlEnc_FxAverageRateOption (pctxt, pvalue->
            u.fxAverageRateOption, OSUTF8("fxAverageRateOption"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode fxBarrierOption */

         stat = XmlEnc_FxBarrierOption (pctxt, pvalue->u.fxBarrierOption
            , OSUTF8("fxBarrierOption"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 4:
         /* encode fxDigitalOption */

         stat = XmlEnc_FxDigitalOption (pctxt, pvalue->u.fxDigitalOption
            , OSUTF8("fxDigitalOption"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 5:
         /* encode fxSimpleOption */

         stat = XmlEnc_FxSimpleOption (pctxt, pvalue->u.fxSimpleOption
            , OSUTF8("fxSimpleOption"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 6:
         /* encode fxSingleLeg */

         stat = XmlEnc_FxSingleLeg (pctxt, pvalue->u.fxSingleLeg
            , OSUTF8("fxSingleLeg"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 7:
         /* encode fxSwap */

         stat = XmlEnc_FxSwap (pctxt, pvalue->u.fxSwap
            , OSUTF8("fxSwap"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 8:
         /* encode termDeposit */

         stat = XmlEnc_TermDeposit (pctxt, pvalue->u.termDeposit
            , OSUTF8("termDeposit"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 9:
         /* encode bulletPayment */

         stat = XmlEnc_BulletPayment (pctxt, pvalue->u.bulletPayment
            , OSUTF8("bulletPayment"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 10:
         /* encode capFloor */

         stat = XmlEnc_CapFloor (pctxt, pvalue->u.capFloor
            , OSUTF8("capFloor"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 11:
         /* encode fra */

         stat = XmlEnc_Fra (pctxt, pvalue->u.fra, OSUTF8("fra"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 12:
         /* encode swap */

         stat = XmlEnc_Swap (pctxt, pvalue->u.swap, OSUTF8("swap"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 13:
         /* encode swaption */

         stat = XmlEnc_Swaption (pctxt, pvalue->u.swaption
            , OSUTF8("swaption"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 14:
         /* encode equityOption */

         stat = XmlEnc_EquityOption (pctxt, pvalue->u.equityOption
            , OSUTF8("equityOption"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 15:
         /* encode equitySwap */

         stat = XmlEnc_EquitySwap (pctxt, pvalue->u.equitySwap
            , OSUTF8("equitySwap"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 16:
         /* encode creditDefaultSwap */

         stat = XmlEnc_CreditDefaultSwap (pctxt, pvalue->u.creditDefaultSwap
            , OSUTF8("creditDefaultSwap"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MasterAgreementType                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MasterAgreementType (OSCTXT* pctxt,
   MasterAgreementType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode masterAgreementTypeScheme */

   if (pvalue->m.masterAgreementTypeSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->masterAgreementTypeScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MasterAgreementType (OSCTXT* pctxt, MasterAgreementType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.masterAgreementTypeSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" masterAgreementTypeScheme=\""), 28);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->masterAgreementTypeScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MasterAgreement                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MasterAgreement (OSCTXT* pctxt,
   MasterAgreement *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode masterAgreementDate */

   if (pvalue->m.masterAgreementDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_charstr (pctxt, pvalue->masterAgreementDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode masterAgreementType */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_MasterAgreementType (pctxt, &pvalue->masterAgreementType, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MasterAgreement (OSCTXT* pctxt, MasterAgreement* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode masterAgreementType */

   stat = XmlEnc_MasterAgreementType (pctxt, &pvalue->masterAgreementType
      , OSUTF8("masterAgreementType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode masterAgreementDate */

   if (pvalue->m.masterAgreementDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         masterAgreementDate, OSUTF8("masterAgreementDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MasterConfirmationType                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MasterConfirmationType (OSCTXT* pctxt,
   MasterConfirmationType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode masterConfirmationTypeScheme */

   if (pvalue->m.masterConfirmationTypeSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->masterConfirmationTypeScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MasterConfirmationType (OSCTXT* pctxt, 
   MasterConfirmationType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.masterConfirmationTypeSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" masterConfirmationTypeScheme=\""), 31);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->masterConfirmationTypeScheme
         , 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MasterConfirmation                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MasterConfirmation (OSCTXT* pctxt,
   MasterConfirmation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode masterConfirmationAnnexDate */

   if (pvalue->m.masterConfirmationAnnexDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_charstr (pctxt, pvalue->masterConfirmationAnnexDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode masterConfirmationDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_charstr (pctxt, pvalue->masterConfirmationDate, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode masterConfirmationType */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_MasterConfirmationType (pctxt, &pvalue->masterConfirmationType, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MasterConfirmation (OSCTXT* pctxt, MasterConfirmation* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode masterConfirmationType */

   stat = XmlEnc_MasterConfirmationType (pctxt, &pvalue->masterConfirmationType
      , OSUTF8("masterConfirmationType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode masterConfirmationDate */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
      masterConfirmationDate, OSUTF8("masterConfirmationDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode masterConfirmationAnnexDate */

   if (pvalue->m.masterConfirmationAnnexDatePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         masterConfirmationAnnexDate
         , OSUTF8("masterConfirmationAnnexDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ContractualDefinitions                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ContractualDefinitions (OSCTXT* pctxt,
   ContractualDefinitions *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode contractualDefinitionsScheme */

   if (pvalue->m.contractualDefinitionsSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->contractualDefinitionsScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ContractualDefinitions (OSCTXT* pctxt, 
   ContractualDefinitions* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.contractualDefinitionsSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" contractualDefinitionsScheme=\""), 31);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->contractualDefinitionsScheme
         , 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ContractualSupplement                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ContractualSupplement (OSCTXT* pctxt,
   ContractualSupplement *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode contractualSupplementScheme */

   if (pvalue->m.contractualSupplementSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->contractualSupplementScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ContractualSupplement (OSCTXT* pctxt, 
   ContractualSupplement* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.contractualSupplementSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" contractualSupplementScheme=\""), 30);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->contractualSupplementScheme
         , 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Documentation                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Documentation (OSCTXT* pctxt,
   Documentation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode creditSupportDocument */

   if (pvalue->m.creditSupportDocumentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_utf8str (pctxt, pvalue->creditSupportDocument, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode contractualSupplement_list */

   pnode2 = pvalue->contractualSupplement_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ContractualSupplement (pctxt, ((ContractualSupplement*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode contractualDefinitions_list */

   pnode2 = pvalue->contractualDefinitions_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ContractualDefinitions (pctxt, ((ContractualDefinitions*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode masterConfirmation */

   if (pvalue->m.masterConfirmationPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_MasterConfirmation (pctxt, &pvalue->masterConfirmation, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode masterAgreement */

   if (pvalue->m.masterAgreementPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_MasterAgreement (pctxt, &pvalue->masterAgreement, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Documentation (OSCTXT* pctxt, Documentation* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode masterAgreement */

   if (pvalue->m.masterAgreementPresent) {
      stat = XmlEnc_MasterAgreement (pctxt, &pvalue->masterAgreement
         , OSUTF8("masterAgreement"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode masterConfirmation */

   if (pvalue->m.masterConfirmationPresent) {
      stat = XmlEnc_MasterConfirmation (pctxt, &pvalue->masterConfirmation
         , OSUTF8("masterConfirmation"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode contractualDefinitions_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->contractualDefinitions_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ContractualDefinitions (pctxt, 
         ((ContractualDefinitions*)pnode->data)
         , OSUTF8("contractualDefinitions"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode contractualSupplement_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->contractualSupplement_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ContractualSupplement (pctxt, 
         ((ContractualSupplement*)pnode->data)
         , OSUTF8("contractualSupplement"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode creditSupportDocument */

   if (pvalue->m.creditSupportDocumentPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->creditSupportDocument
         , OSUTF8("creditSupportDocument"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GoverningLaw                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_GoverningLaw (OSCTXT* pctxt,
   GoverningLaw *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode governingLawScheme */

   if (pvalue->m.governingLawSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->governingLawScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_GoverningLaw (OSCTXT* pctxt, GoverningLaw* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.governingLawSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" governingLawScheme=\""), 21);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->governingLawScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Trade                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Trade (OSCTXT* pctxt,
   Trade *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode governingLaw */

   if (pvalue->m.governingLawPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_GoverningLaw (pctxt, &pvalue->governingLaw, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode documentation */

   if (pvalue->m.documentationPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_Documentation (pctxt, &pvalue->documentation, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode calculationAgentBusinessCenter */

   if (pvalue->m.calculationAgentBusinessCenterPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_BusinessCenter (pctxt, &pvalue->calculationAgentBusinessCenter, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode calculationAgent */

   if (pvalue->m.calculationAgentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_CalculationAgent (pctxt, &pvalue->calculationAgent, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode brokerPartyReference_list */

   pnode2 = pvalue->brokerPartyReference_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PartyReference (pctxt, ((PartyReference*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode otherPartyPayment_list */

   pnode2 = pvalue->otherPartyPayment_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Payment (pctxt, ((Payment*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode product */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_Product_group (pctxt, &pvalue->product, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode tradeHeader */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_TradeHeader (pctxt, &pvalue->tradeHeader, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Trade (OSCTXT* pctxt, Trade* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode tradeHeader */

   stat = XmlEnc_TradeHeader (pctxt, &pvalue->tradeHeader
      , OSUTF8("tradeHeader"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode product */

   stat = XmlEnc_Product_group (pctxt, &pvalue->product
      , OSUTF8(""), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode otherPartyPayment_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->otherPartyPayment_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Payment (pctxt, ((Payment*)pnode->data)
         , OSUTF8("otherPartyPayment"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode brokerPartyReference_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->brokerPartyReference_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PartyReference (pctxt, ((PartyReference*)pnode->data)
         , OSUTF8("brokerPartyReference"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode calculationAgent */

   if (pvalue->m.calculationAgentPresent) {
      stat = XmlEnc_CalculationAgent (pctxt, &pvalue->calculationAgent
         , OSUTF8("calculationAgent"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode calculationAgentBusinessCenter */

   if (pvalue->m.calculationAgentBusinessCenterPresent) {
      stat = XmlEnc_BusinessCenter (pctxt, &pvalue->
         calculationAgentBusinessCenter
         , OSUTF8("calculationAgentBusinessCenter"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode documentation */

   if (pvalue->m.documentationPresent) {
      stat = XmlEnc_Documentation (pctxt, &pvalue->documentation
         , OSUTF8("documentation"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode governingLaw */

   if (pvalue->m.governingLawPresent) {
      stat = XmlEnc_GoverningLaw (pctxt, &pvalue->governingLaw
         , OSUTF8("governingLaw"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PortfolioName                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PortfolioName (OSCTXT* pctxt,
   PortfolioName *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode portfolioNameScheme */

   if (pvalue->m.portfolioNameSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->portfolioNameScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PortfolioName (OSCTXT* pctxt, PortfolioName* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.portfolioNameSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" portfolioNameScheme=\""), 22);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->portfolioNameScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PartyPortfolioName                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PartyPortfolioName (OSCTXT* pctxt,
   PartyPortfolioName *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode portfolioName_list */

   if (!(pvalue->portfolioName_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "PartyPortfolioName.portfolioName_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->portfolioName_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->portfolioName_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PortfolioName (pctxt, ((PortfolioName*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode partyReference */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_PartyReference (pctxt, &pvalue->partyReference, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PartyPortfolioName (OSCTXT* pctxt, PartyPortfolioName* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode partyReference */

   stat = XmlEnc_PartyReference (pctxt, &pvalue->partyReference
      , OSUTF8("partyReference"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode portfolioName_list */

   if (!(pvalue->portfolioName_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "PartyPortfolioName.portfolioName_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->portfolioName_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->portfolioName_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PortfolioName (pctxt, ((PortfolioName*)pnode->data)
         , OSUTF8("portfolioName"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Portfolio                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Portfolio (OSCTXT* pctxt,
   Portfolio *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode portfolio_list */

   pnode2 = pvalue->portfolio_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Portfolio (pctxt, (Portfolio*)((Portfolio*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode tradeId_list */

   pnode2 = pvalue->tradeId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TradeId (pctxt, ((TradeId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode partyPortfolioName */

   if (pvalue->m.partyPortfolioNamePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_PartyPortfolioName (pctxt, &pvalue->partyPortfolioName, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Portfolio (OSCTXT* pctxt, Portfolio* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode partyPortfolioName */

   if (pvalue->m.partyPortfolioNamePresent) {
      stat = XmlEnc_PartyPortfolioName (pctxt, &pvalue->partyPortfolioName
         , OSUTF8("partyPortfolioName"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode tradeId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->tradeId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TradeId (pctxt, ((TradeId*)pnode->data)
         , OSUTF8("tradeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode portfolio_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->portfolio_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Portfolio (pctxt, ((Portfolio*)pnode->data)
         , OSUTF8("portfolio"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PartyId                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PartyId (OSCTXT* pctxt,
   PartyId *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode partyIdScheme */

   if (pvalue->m.partyIdSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->partyIdScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PartyId (OSCTXT* pctxt, PartyId* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.partyIdSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" partyIdScheme=\""), 16);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->partyIdScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Party                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Party (OSCTXT* pctxt,
   Party *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode partyName */

   if (pvalue->m.partyNamePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->partyName, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode partyId */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_PartyId (pctxt, &pvalue->partyId, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Party (OSCTXT* pctxt, Party* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode partyId */

   stat = XmlEnc_PartyId (pctxt, &pvalue->partyId
      , OSUTF8("partyId"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode partyName */

   if (pvalue->m.partyNamePresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->partyName
         , OSUTF8("partyName"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataDocument                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DataDocument (OSCTXT* pctxt,
   DataDocument *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode party_list */

   pnode2 = pvalue->party_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Party (pctxt, ((Party*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode portfolio_list */

   pnode2 = pvalue->portfolio_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Portfolio (pctxt, ((Portfolio*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode trade_list */

   pnode2 = pvalue->trade_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Trade (pctxt, ((Trade*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode validation_model */

   if (pvalue->m.validation_modelPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Validation_model (pctxt, &pvalue->validation_model, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_DataDocument_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DataDocument (OSCTXT* pctxt, DataDocument* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_DataDocument_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode validation_model */

   if (pvalue->m.validation_modelPresent) {
      stat = XmlEnc_Validation_model (pctxt, &pvalue->validation_model
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode trade_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->trade_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Trade (pctxt, ((Trade*)pnode->data)
         , OSUTF8("trade"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode portfolio_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->portfolio_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Portfolio (pctxt, ((Portfolio*)pnode->data)
         , OSUTF8("portfolio"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode party_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->party_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Party (pctxt, ((Party*)pnode->data)
         , OSUTF8("party"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotificationMessage_version                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_NotificationMessage_version (OSCTXT* pctxt,
   NotificationMessage_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_NotificationMessage_version (OSCTXT* pctxt, 
   NotificationMessage_version value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      NotificationMessage_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConversationId                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ConversationId (OSCTXT* pctxt,
   ConversationId *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode conversationIdScheme */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->conversationIdScheme, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ConversationId (OSCTXT* pctxt, ConversationId* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" conversationIdScheme=\""), 23);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->conversationIdScheme, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MessageId                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MessageId (OSCTXT* pctxt,
   MessageId *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode messageIdScheme */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->messageIdScheme, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MessageId (OSCTXT* pctxt, MessageId* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" messageIdScheme=\""), 18);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->messageIdScheme, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotificationMessageHeader                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_NotificationMessageHeader (OSCTXT* pctxt,
   NotificationMessageHeader *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode signature_list */

   pnode2 = pvalue->signature_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Signature (pctxt, ((Signature*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode expiryTimestamp */

   if (pvalue->m.expiryTimestampPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
         xe_charstr (pctxt, pvalue->expiryTimestamp, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode creationTimestamp */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
      xe_charstr (pctxt, pvalue->creationTimestamp, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode copyTo_list */

   pnode2 = pvalue->copyTo_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PartyId (pctxt, ((PartyId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode sendTo_list */

   pnode2 = pvalue->sendTo_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PartyId (pctxt, ((PartyId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode sentBy */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_PartyId (pctxt, &pvalue->sentBy, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode inReplyTo */

   if (pvalue->m.inReplyToPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_MessageId (pctxt, &pvalue->inReplyTo, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode messageId */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_MessageId (pctxt, &pvalue->messageId, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode conversationId */

   if (pvalue->m.conversationIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ConversationId (pctxt, &pvalue->conversationId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_NotificationMessageHeader (OSCTXT* pctxt, 
   NotificationMessageHeader* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode conversationId */

   if (pvalue->m.conversationIdPresent) {
      stat = XmlEnc_ConversationId (pctxt, &pvalue->conversationId
         , OSUTF8("conversationId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode messageId */

   stat = XmlEnc_MessageId (pctxt, &pvalue->messageId
      , OSUTF8("messageId"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode inReplyTo */

   if (pvalue->m.inReplyToPresent) {
      stat = XmlEnc_MessageId (pctxt, &pvalue->inReplyTo
         , OSUTF8("inReplyTo"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode sentBy */

   stat = XmlEnc_PartyId (pctxt, &pvalue->sentBy, OSUTF8("sentBy"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode sendTo_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->sendTo_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PartyId (pctxt, ((PartyId*)pnode->data)
         , OSUTF8("sendTo"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode copyTo_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->copyTo_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PartyId (pctxt, ((PartyId*)pnode->data)
         , OSUTF8("copyTo"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode creationTimestamp */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->creationTimestamp
      , OSUTF8("creationTimestamp"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode expiryTimestamp */

   if (pvalue->m.expiryTimestampPresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->expiryTimestamp
         , OSUTF8("expiryTimestamp"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode signature_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->signature_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Signature (pctxt, ((Signature*)pnode->data)
         , OSUTF8("Signature"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotificationMessage                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_NotificationMessage (OSCTXT* pctxt,
   NotificationMessage *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode validation_model */

   if (pvalue->m.validation_modelPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Validation_model (pctxt, &pvalue->validation_model, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode header */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_NotificationMessageHeader (pctxt, &pvalue->header, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_NotificationMessage_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_NotificationMessage (OSCTXT* pctxt, NotificationMessage* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_NotificationMessage_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode header */

   stat = XmlEnc_NotificationMessageHeader (pctxt, &pvalue->header
      , OSUTF8("header"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode validation_model */

   if (pvalue->m.validation_modelPresent) {
      stat = XmlEnc_Validation_model (pctxt, &pvalue->validation_model
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MessageRejected_version                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MessageRejected_version (OSCTXT* pctxt,
   MessageRejected_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_MessageRejected_version (OSCTXT* pctxt, 
   MessageRejected_version value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      MessageRejected_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reason_location                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Reason_location (OSCTXT* pctxt,
   Reason_location *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode locationType */

   if (pvalue->m.locationTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->locationType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Reason_location (OSCTXT* pctxt, Reason_location* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.locationTypePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" locationType=\""), 15);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->locationType, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reason_validationRuleId                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Reason_validationRuleId (OSCTXT* pctxt,
   Reason_validationRuleId *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode validationScheme */

   if (pvalue->m.validationSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->validationScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Reason_validationRuleId (OSCTXT* pctxt, 
   Reason_validationRuleId* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.validationSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" validationScheme=\""), 19);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->validationScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reason_additionalData                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Reason_additionalData (OSCTXT* pctxt,
   Reason_additionalData *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode additionalDataType */

   if (pvalue->m.additionalDataTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->additionalDataType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Reason_additionalData (OSCTXT* pctxt, 
   Reason_additionalData* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.additionalDataTypePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" additionalDataType=\""), 21);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->additionalDataType, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reason                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Reason (OSCTXT* pctxt,
   Reason *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode additionalData_list */

   pnode2 = pvalue->additionalData_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Reason_additionalData (pctxt, ((Reason_additionalData*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode validationRuleId */

   if (pvalue->m.validationRuleIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Reason_validationRuleId (pctxt, &pvalue->validationRuleId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode description */

   if (pvalue->m.descriptionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->description, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode location */

   if (pvalue->m.locationPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Reason_location (pctxt, &pvalue->location, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode reasonCode */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->reasonCode, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Reason (OSCTXT* pctxt, Reason* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode reasonCode */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->reasonCode
      , OSUTF8("reasonCode"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode location */

   if (pvalue->m.locationPresent) {
      stat = XmlEnc_Reason_location (pctxt, &pvalue->location
         , OSUTF8("location"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode description */

   if (pvalue->m.descriptionPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->description
         , OSUTF8("description"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode validationRuleId */

   if (pvalue->m.validationRuleIdPresent) {
      stat = XmlEnc_Reason_validationRuleId (pctxt, &pvalue->validationRuleId
         , OSUTF8("validationRuleId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode additionalData_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->additionalData_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Reason_additionalData (pctxt, 
         ((Reason_additionalData*)pnode->data)
         , OSUTF8("additionalData"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MessageRejected                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MessageRejected (OSCTXT* pctxt,
   MessageRejected *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode additionalData */

   if (pvalue->m.additionalDataPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->additionalData, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode reason_list */

   if (!(pvalue->reason_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "MessageRejected.reason_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->reason_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->reason_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Reason (pctxt, ((Reason*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_MessageRejected_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MessageRejected (OSCTXT* pctxt, MessageRejected* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_MessageRejected_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode reason_list */

   if (!(pvalue->reason_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "MessageRejected.reason_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->reason_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->reason_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Reason (pctxt, ((Reason*)pnode->data)
         , OSUTF8("reason"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode additionalData */

   if (pvalue->m.additionalDataPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->additionalData
         , OSUTF8("additionalData"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeAffirmation_version                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeAffirmation_version (OSCTXT* pctxt,
   TradeAffirmation_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_TradeAffirmation_version (OSCTXT* pctxt, 
   TradeAffirmation_version value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      TradeAffirmation_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeAffirmation                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeAffirmation (OSCTXT* pctxt,
   TradeAffirmation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode party_list */

   if (!(pvalue->party_list.count >= 2U)) {
      rtxErrAddStrParm (pctxt, "TradeAffirmation.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->party_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Party (pctxt, ((Party*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode trade */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Trade (pctxt, &pvalue->trade, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_TradeAffirmation_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TradeAffirmation (OSCTXT* pctxt, TradeAffirmation* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TradeAffirmation_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode trade */

   stat = XmlEnc_Trade (pctxt, &pvalue->trade, OSUTF8("trade"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode party_list */

   if (!(pvalue->party_list.count >= 2U)) {
      rtxErrAddStrParm (pctxt, "TradeAffirmation.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->party_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Party (pctxt, ((Party*)pnode->data)
         , OSUTF8("party"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeAlleged_version                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeAlleged_version (OSCTXT* pctxt,
   TradeAlleged_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_TradeAlleged_version (OSCTXT* pctxt, TradeAlleged_version value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      TradeAlleged_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeIdentifier                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeIdentifier (OSCTXT* pctxt,
   TradeIdentifier *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode tradeId_list */

   if (!(pvalue->tradeId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TradeIdentifier.tradeId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->tradeId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->tradeId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TradeId (pctxt, ((TradeId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode partyReference */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_PartyReference (pctxt, &pvalue->partyReference, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TradeIdentifier (OSCTXT* pctxt, TradeIdentifier* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode partyReference */

   stat = XmlEnc_PartyReference (pctxt, &pvalue->partyReference
      , OSUTF8("partyReference"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode tradeId_list */

   if (!(pvalue->tradeId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TradeIdentifier.tradeId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->tradeId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->tradeId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TradeId (pctxt, ((TradeId*)pnode->data)
         , OSUTF8("tradeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeIdentifier_derivations                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeIdentifier_derivations (OSCTXT* pctxt,
   TradeIdentifier_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_TradeIdentifier (pctxt, pvalue->u.tradeIdentifier, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_PartyTradeIdentifier (pctxt, pvalue->u.partyTradeIdentifier, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_TradeIdentifier_derivations (OSCTXT* pctxt, 
   TradeIdentifier_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode tradeIdentifier */

         stat = XmlEnc_TradeIdentifier (pctxt, pvalue->u.tradeIdentifier
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode partyTradeIdentifier */

         stat = XmlEnc_PartyTradeIdentifier (pctxt, pvalue->
            u.partyTradeIdentifier, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeAlleged                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeAlleged (OSCTXT* pctxt,
   TradeAlleged *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode party_list */

   if (!(pvalue->party_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TradeAlleged.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->party_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Party (pctxt, ((Party*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode bestFitTradeId_list */

   pnode2 = pvalue->bestFitTradeId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TradeIdentifier_derivations (pctxt, ((TradeIdentifier_derivations*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode tradeIdentifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_TradeAlleged_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TradeAlleged (OSCTXT* pctxt, TradeAlleged* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TradeAlleged_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode tradeIdentifier */

   stat = XmlEnc_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier
      , OSUTF8("tradeIdentifier"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode bestFitTradeId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->bestFitTradeId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TradeIdentifier_derivations (pctxt, 
         ((TradeIdentifier_derivations*)pnode->data)
         , OSUTF8("bestFitTradeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode party_list */

   if (!(pvalue->party_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TradeAlleged.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->party_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Party (pctxt, ((Party*)pnode->data)
         , OSUTF8("party"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeConfirmed_version                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeConfirmed_version (OSCTXT* pctxt,
   TradeConfirmed_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_TradeConfirmed_version (OSCTXT* pctxt, 
   TradeConfirmed_version value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      TradeConfirmed_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeConfirmed                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeConfirmed (OSCTXT* pctxt,
   TradeConfirmed *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode party_list */

   if (!(pvalue->party_list.count >= 2U)) {
      rtxErrAddStrParm (pctxt, "TradeConfirmed.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->party_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Party (pctxt, ((Party*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode trade */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Trade (pctxt, &pvalue->trade, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_TradeConfirmed_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TradeConfirmed (OSCTXT* pctxt, TradeConfirmed* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TradeConfirmed_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode trade */

   stat = XmlEnc_Trade (pctxt, &pvalue->trade, OSUTF8("trade"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode party_list */

   if (!(pvalue->party_list.count >= 2U)) {
      rtxErrAddStrParm (pctxt, "TradeConfirmed.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->party_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Party (pctxt, ((Party*)pnode->data)
         , OSUTF8("party"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeMatched_version                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeMatched_version (OSCTXT* pctxt,
   TradeMatched_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_TradeMatched_version (OSCTXT* pctxt, TradeMatched_version value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      TradeMatched_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DifferenceTypeEnum                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DifferenceTypeEnum (OSCTXT* pctxt,
   DifferenceTypeEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 3)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_DifferenceTypeEnum (OSCTXT* pctxt, DifferenceTypeEnum value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      DifferenceTypeEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DifferenceSeverityEnum                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DifferenceSeverityEnum (OSCTXT* pctxt,
   DifferenceSeverityEnum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_DifferenceSeverityEnum (OSCTXT* pctxt, 
   DifferenceSeverityEnum value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      DifferenceSeverityEnum_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeDifference                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeDifference (OSCTXT* pctxt,
   TradeDifference *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode message */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|9,
      xe_utf8str (pctxt, pvalue->message, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode extraElement_list */

   pnode2 = pvalue->extraElement_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode missingElement_list */

   pnode2 = pvalue->missingElement_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode otherValue */

   if (pvalue->m.otherValuePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
         xe_utf8str (pctxt, pvalue->otherValue, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode otherPath */

   if (pvalue->m.otherPathPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         xe_utf8str (pctxt, pvalue->otherPath, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode baseValue */

   if (pvalue->m.baseValuePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_utf8str (pctxt, pvalue->baseValue, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode basePath */

   if (pvalue->m.basePathPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_utf8str (pctxt, pvalue->basePath, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode element */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_utf8str (pctxt, pvalue->element, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode differenceSeverity */

   if(pvalue->differenceSeverity < 0 || pvalue->differenceSeverity > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_DifferenceSeverityEnum (pctxt, &pvalue->differenceSeverity, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode differenceType */

   if(pvalue->differenceType < 0 || pvalue->differenceType > 3)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_DifferenceTypeEnum (pctxt, &pvalue->differenceType, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TradeDifference (OSCTXT* pctxt, TradeDifference* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode differenceType */

   if(pvalue->differenceType < 0 || pvalue->differenceType > 3)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_DifferenceTypeEnum (pctxt, pvalue->differenceType
      , OSUTF8("differenceType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode differenceSeverity */

   if(pvalue->differenceSeverity < 0 || pvalue->differenceSeverity > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_DifferenceSeverityEnum (pctxt, pvalue->differenceSeverity
      , OSUTF8("differenceSeverity"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode element */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->element
      , OSUTF8("element"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode basePath */

   if (pvalue->m.basePathPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->basePath
         , OSUTF8("basePath"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode baseValue */

   if (pvalue->m.baseValuePresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->baseValue
         , OSUTF8("baseValue"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode otherPath */

   if (pvalue->m.otherPathPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->otherPath
         , OSUTF8("otherPath"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode otherValue */

   if (pvalue->m.otherValuePresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->otherValue
         , OSUTF8("otherValue"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode missingElement_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->missingElement_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("missingElement"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode extraElement_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->extraElement_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("extraElement"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode message */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->message
      , OSUTF8("message"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeMatched                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeMatched (OSCTXT* pctxt,
   TradeMatched *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode party_list */

   if (!(pvalue->party_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TradeMatched.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->party_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Party (pctxt, ((Party*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode differences_list */

   pnode2 = pvalue->differences_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TradeDifference (pctxt, ((TradeDifference*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode tradeIdentifier_list */

   if (!(pvalue->tradeIdentifier_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TradeMatched.tradeIdentifier_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->tradeIdentifier_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->tradeIdentifier_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TradeIdentifier_derivations (pctxt, ((TradeIdentifier_derivations*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_TradeMatched_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TradeMatched (OSCTXT* pctxt, TradeMatched* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TradeMatched_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode tradeIdentifier_list */

   if (!(pvalue->tradeIdentifier_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TradeMatched.tradeIdentifier_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->tradeIdentifier_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->tradeIdentifier_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TradeIdentifier_derivations (pctxt, 
         ((TradeIdentifier_derivations*)pnode->data)
         , OSUTF8("tradeIdentifier"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode differences_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->differences_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TradeDifference (pctxt, ((TradeDifference*)pnode->data)
         , OSUTF8("differences"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode party_list */

   if (!(pvalue->party_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TradeMatched.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->party_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Party (pctxt, ((Party*)pnode->data)
         , OSUTF8("party"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeMismatched_version                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeMismatched_version (OSCTXT* pctxt,
   TradeMismatched_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_TradeMismatched_version (OSCTXT* pctxt, 
   TradeMismatched_version value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      TradeMismatched_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BestFitTrade                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BestFitTrade (OSCTXT* pctxt,
   BestFitTrade *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode differences_list */

   pnode2 = pvalue->differences_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TradeDifference (pctxt, ((TradeDifference*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode tradeIdentifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BestFitTrade (OSCTXT* pctxt, BestFitTrade* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode tradeIdentifier */

   stat = XmlEnc_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier
      , OSUTF8("tradeIdentifier"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode differences_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->differences_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TradeDifference (pctxt, ((TradeDifference*)pnode->data)
         , OSUTF8("differences"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeMismatched                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeMismatched (OSCTXT* pctxt,
   TradeMismatched *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode party_list */

   if (!(pvalue->party_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TradeMismatched.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->party_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Party (pctxt, ((Party*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode bestFitTrade_list */

   pnode2 = pvalue->bestFitTrade_list.tail;
   while (0 != pnode2) {
      ll = asn1E_BestFitTrade (pctxt, ((BestFitTrade*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode tradeIdentifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_TradeMismatched_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TradeMismatched (OSCTXT* pctxt, TradeMismatched* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TradeMismatched_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode tradeIdentifier */

   stat = XmlEnc_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier
      , OSUTF8("tradeIdentifier"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode bestFitTrade_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->bestFitTrade_list.head;
   while (0 != pnode) {
      stat = XmlEnc_BestFitTrade (pctxt, ((BestFitTrade*)pnode->data)
         , OSUTF8("bestFitTrade"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode party_list */

   if (!(pvalue->party_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TradeMismatched.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->party_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Party (pctxt, ((Party*)pnode->data)
         , OSUTF8("party"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeUnmatched_version                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeUnmatched_version (OSCTXT* pctxt,
   TradeUnmatched_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_TradeUnmatched_version (OSCTXT* pctxt, 
   TradeUnmatched_version value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      TradeUnmatched_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeUnmatched                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeUnmatched (OSCTXT* pctxt,
   TradeUnmatched *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode party_list */

   if (!(pvalue->party_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TradeUnmatched.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->party_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Party (pctxt, ((Party*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode bestFitTradeId_list */

   pnode2 = pvalue->bestFitTradeId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TradeIdentifier_derivations (pctxt, ((TradeIdentifier_derivations*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode tradeIdentifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_TradeUnmatched_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TradeUnmatched (OSCTXT* pctxt, TradeUnmatched* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TradeUnmatched_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode tradeIdentifier */

   stat = XmlEnc_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier
      , OSUTF8("tradeIdentifier"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode bestFitTradeId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->bestFitTradeId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TradeIdentifier_derivations (pctxt, 
         ((TradeIdentifier_derivations*)pnode->data)
         , OSUTF8("bestFitTradeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode party_list */

   if (!(pvalue->party_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TradeUnmatched.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->party_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Party (pctxt, ((Party*)pnode->data)
         , OSUTF8("party"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeCreated_version                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeCreated_version (OSCTXT* pctxt,
   TradeCreated_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_TradeCreated_version (OSCTXT* pctxt, TradeCreated_version value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      TradeCreated_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeCreated                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeCreated (OSCTXT* pctxt,
   TradeCreated *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode party_list */

   if (!(pvalue->party_list.count >= 2U)) {
      rtxErrAddStrParm (pctxt, "TradeCreated.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->party_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Party (pctxt, ((Party*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode trade */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Trade (pctxt, &pvalue->trade, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_TradeCreated_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TradeCreated (OSCTXT* pctxt, TradeCreated* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TradeCreated_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode trade */

   stat = XmlEnc_Trade (pctxt, &pvalue->trade, OSUTF8("trade"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode party_list */

   if (!(pvalue->party_list.count >= 2U)) {
      rtxErrAddStrParm (pctxt, "TradeCreated.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->party_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Party (pctxt, ((Party*)pnode->data)
         , OSUTF8("party"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeAmended_version                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeAmended_version (OSCTXT* pctxt,
   TradeAmended_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_TradeAmended_version (OSCTXT* pctxt, TradeAmended_version value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      TradeAmended_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeAmended                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeAmended (OSCTXT* pctxt,
   TradeAmended *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode party_list */

   if (!(pvalue->party_list.count >= 2U)) {
      rtxErrAddStrParm (pctxt, "TradeAmended.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->party_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Party (pctxt, ((Party*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode trade */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Trade (pctxt, &pvalue->trade, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_TradeAmended_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TradeAmended (OSCTXT* pctxt, TradeAmended* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TradeAmended_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode trade */

   stat = XmlEnc_Trade (pctxt, &pvalue->trade, OSUTF8("trade"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode party_list */

   if (!(pvalue->party_list.count >= 2U)) {
      rtxErrAddStrParm (pctxt, "TradeAmended.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->party_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Party (pctxt, ((Party*)pnode->data)
         , OSUTF8("party"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeCancelled_version                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeCancelled_version (OSCTXT* pctxt,
   TradeCancelled_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_TradeCancelled_version (OSCTXT* pctxt, 
   TradeCancelled_version value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      TradeCancelled_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeCancelled                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeCancelled (OSCTXT* pctxt,
   TradeCancelled *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode party_list */

   if (!(pvalue->party_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TradeCancelled.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->party_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Party (pctxt, ((Party*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode tradeIdentifier_list */

   if (!(pvalue->tradeIdentifier_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TradeCancelled.tradeIdentifier_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->tradeIdentifier_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->tradeIdentifier_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TradeIdentifier_derivations (pctxt, ((TradeIdentifier_derivations*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_TradeCancelled_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TradeCancelled (OSCTXT* pctxt, TradeCancelled* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TradeCancelled_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode tradeIdentifier_list */

   if (!(pvalue->tradeIdentifier_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TradeCancelled.tradeIdentifier_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->tradeIdentifier_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->tradeIdentifier_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TradeIdentifier_derivations (pctxt, 
         ((TradeIdentifier_derivations*)pnode->data)
         , OSUTF8("tradeIdentifier"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode party_list */

   if (!(pvalue->party_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TradeCancelled.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->party_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Party (pctxt, ((Party*)pnode->data)
         , OSUTF8("party"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotificationMessage_derivations                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_NotificationMessage_derivations (OSCTXT* pctxt,
   NotificationMessage_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_NotificationMessage (pctxt, pvalue->u.notificationMessage, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_MessageRejected (pctxt, pvalue->u.messageRejected, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_TradeAffirmation (pctxt, pvalue->u.tradeAffirmation, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 4:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
            asn1E_TradeAlleged (pctxt, pvalue->u.tradeAlleged, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 5:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
            asn1E_TradeConfirmed (pctxt, pvalue->u.tradeConfirmed, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 6:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
            asn1E_TradeMatched (pctxt, pvalue->u.tradeMatched, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 7:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
            asn1E_TradeMismatched (pctxt, pvalue->u.tradeMismatched, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 8:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
            asn1E_TradeUnmatched (pctxt, pvalue->u.tradeUnmatched, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 9:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
            asn1E_TradeCreated (pctxt, pvalue->u.tradeCreated, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 10:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9,
            asn1E_TradeAmended (pctxt, pvalue->u.tradeAmended, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 11:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10,
            asn1E_TradeCancelled (pctxt, pvalue->u.tradeCancelled, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_NotificationMessage_derivations (OSCTXT* pctxt, 
   NotificationMessage_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode notificationMessage */

         stat = XmlEnc_NotificationMessage (pctxt, pvalue->
            u.notificationMessage, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode messageRejected */

         stat = XmlEnc_MessageRejected (pctxt, pvalue->u.messageRejected
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode tradeAffirmation */

         stat = XmlEnc_TradeAffirmation (pctxt, pvalue->u.tradeAffirmation
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 4:
         /* encode tradeAlleged */

         stat = XmlEnc_TradeAlleged (pctxt, pvalue->u.tradeAlleged
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 5:
         /* encode tradeConfirmed */

         stat = XmlEnc_TradeConfirmed (pctxt, pvalue->u.tradeConfirmed
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 6:
         /* encode tradeMatched */

         stat = XmlEnc_TradeMatched (pctxt, pvalue->u.tradeMatched
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 7:
         /* encode tradeMismatched */

         stat = XmlEnc_TradeMismatched (pctxt, pvalue->u.tradeMismatched
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 8:
         /* encode tradeUnmatched */

         stat = XmlEnc_TradeUnmatched (pctxt, pvalue->u.tradeUnmatched
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 9:
         /* encode tradeCreated */

         stat = XmlEnc_TradeCreated (pctxt, pvalue->u.tradeCreated
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 10:
         /* encode tradeAmended */

         stat = XmlEnc_TradeAmended (pctxt, pvalue->u.tradeAmended
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 11:
         /* encode tradeCancelled */

         stat = XmlEnc_TradeCancelled (pctxt, pvalue->u.tradeCancelled
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ModifyTradeConfirmation_version                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ModifyTradeConfirmation_version (OSCTXT* pctxt,
   ModifyTradeConfirmation_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ModifyTradeConfirmation_version (OSCTXT* pctxt, 
   ModifyTradeConfirmation_version value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      ModifyTradeConfirmation_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ModifyTradeConfirmation                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ModifyTradeConfirmation (OSCTXT* pctxt,
   ModifyTradeConfirmation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode party_list */

   if (!(pvalue->party_list.count >= 2U)) {
      rtxErrAddStrParm (pctxt, "ModifyTradeConfirmation.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->party_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Party (pctxt, ((Party*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode trade */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Trade (pctxt, &pvalue->trade, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_ModifyTradeConfirmation_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ModifyTradeConfirmation (OSCTXT* pctxt, 
   ModifyTradeConfirmation* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_ModifyTradeConfirmation_version (pctxt, pvalue->version
      , 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode trade */

   stat = XmlEnc_Trade (pctxt, &pvalue->trade, OSUTF8("trade"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode party_list */

   if (!(pvalue->party_list.count >= 2U)) {
      rtxErrAddStrParm (pctxt, "ModifyTradeConfirmation.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->party_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Party (pctxt, ((Party*)pnode->data)
         , OSUTF8("party"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ModifyTradeMatch_version                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ModifyTradeMatch_version (OSCTXT* pctxt,
   ModifyTradeMatch_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ModifyTradeMatch_version (OSCTXT* pctxt, 
   ModifyTradeMatch_version value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      ModifyTradeMatch_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ModifyTradeMatch                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ModifyTradeMatch (OSCTXT* pctxt,
   ModifyTradeMatch *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode party_list */

   if (!(pvalue->party_list.count >= 2U)) {
      rtxErrAddStrParm (pctxt, "ModifyTradeMatch.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->party_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Party (pctxt, ((Party*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode trade */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Trade (pctxt, &pvalue->trade, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_ModifyTradeMatch_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ModifyTradeMatch (OSCTXT* pctxt, ModifyTradeMatch* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_ModifyTradeMatch_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode trade */

   stat = XmlEnc_Trade (pctxt, &pvalue->trade, OSUTF8("trade"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode party_list */

   if (!(pvalue->party_list.count >= 2U)) {
      rtxErrAddStrParm (pctxt, "ModifyTradeMatch.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->party_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Party (pctxt, ((Party*)pnode->data)
         , OSUTF8("party"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestTradeConfirmation_version                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RequestTradeConfirmation_version (OSCTXT* pctxt,
   RequestTradeConfirmation_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_RequestTradeConfirmation_version (OSCTXT* pctxt, 
   RequestTradeConfirmation_version value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      RequestTradeConfirmation_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestTradeConfirmation                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RequestTradeConfirmation (OSCTXT* pctxt,
   RequestTradeConfirmation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode party_list */

   if (!(pvalue->party_list.count >= 2U)) {
      rtxErrAddStrParm (pctxt, "RequestTradeConfirmation.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->party_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Party (pctxt, ((Party*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode trade */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Trade (pctxt, &pvalue->trade, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_RequestTradeConfirmation_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_RequestTradeConfirmation (OSCTXT* pctxt, 
   RequestTradeConfirmation* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_RequestTradeConfirmation_version (pctxt, pvalue->version
      , 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode trade */

   stat = XmlEnc_Trade (pctxt, &pvalue->trade, OSUTF8("trade"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode party_list */

   if (!(pvalue->party_list.count >= 2U)) {
      rtxErrAddStrParm (pctxt, "RequestTradeConfirmation.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->party_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Party (pctxt, ((Party*)pnode->data)
         , OSUTF8("party"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestTradeMatch_version                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RequestTradeMatch_version (OSCTXT* pctxt,
   RequestTradeMatch_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_RequestTradeMatch_version (OSCTXT* pctxt, 
   RequestTradeMatch_version value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      RequestTradeMatch_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestTradeMatch                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RequestTradeMatch (OSCTXT* pctxt,
   RequestTradeMatch *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode party_list */

   if (!(pvalue->party_list.count >= 2U)) {
      rtxErrAddStrParm (pctxt, "RequestTradeMatch.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->party_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Party (pctxt, ((Party*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode trade */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Trade (pctxt, &pvalue->trade, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_RequestTradeMatch_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_RequestTradeMatch (OSCTXT* pctxt, RequestTradeMatch* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_RequestTradeMatch_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode trade */

   stat = XmlEnc_Trade (pctxt, &pvalue->trade, OSUTF8("trade"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode party_list */

   if (!(pvalue->party_list.count >= 2U)) {
      rtxErrAddStrParm (pctxt, "RequestTradeMatch.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->party_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Party (pctxt, ((Party*)pnode->data)
         , OSUTF8("party"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestTradeStatus_version                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RequestTradeStatus_version (OSCTXT* pctxt,
   RequestTradeStatus_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_RequestTradeStatus_version (OSCTXT* pctxt, 
   RequestTradeStatus_version value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      RequestTradeStatus_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestTradeStatus                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RequestTradeStatus (OSCTXT* pctxt,
   RequestTradeStatus *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode party_list */

   if (!(pvalue->party_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "RequestTradeStatus.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->party_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Party (pctxt, ((Party*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode tradeIdentifier_list */

   if (!(pvalue->tradeIdentifier_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "RequestTradeStatus.tradeIdentifier_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->tradeIdentifier_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->tradeIdentifier_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TradeIdentifier_derivations (pctxt, ((TradeIdentifier_derivations*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_RequestTradeStatus_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_RequestTradeStatus (OSCTXT* pctxt, RequestTradeStatus* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_RequestTradeStatus_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode tradeIdentifier_list */

   if (!(pvalue->tradeIdentifier_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "RequestTradeStatus.tradeIdentifier_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->tradeIdentifier_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->tradeIdentifier_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TradeIdentifier_derivations (pctxt, 
         ((TradeIdentifier_derivations*)pnode->data)
         , OSUTF8("tradeIdentifier"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode party_list */

   if (!(pvalue->party_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "RequestTradeStatus.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->party_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Party (pctxt, ((Party*)pnode->data)
         , OSUTF8("party"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CancelTradeMatch_version                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CancelTradeMatch_version (OSCTXT* pctxt,
   CancelTradeMatch_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_CancelTradeMatch_version (OSCTXT* pctxt, 
   CancelTradeMatch_version value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      CancelTradeMatch_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CancelTradeMatch                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CancelTradeMatch (OSCTXT* pctxt,
   CancelTradeMatch *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode party */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_Party (pctxt, &pvalue->party, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode partyTradeIdentifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_PartyTradeIdentifier (pctxt, &pvalue->partyTradeIdentifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_CancelTradeMatch_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CancelTradeMatch (OSCTXT* pctxt, CancelTradeMatch* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_CancelTradeMatch_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode partyTradeIdentifier */

   stat = XmlEnc_PartyTradeIdentifier (pctxt, &pvalue->partyTradeIdentifier
      , OSUTF8("partyTradeIdentifier"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode party */

   stat = XmlEnc_Party (pctxt, &pvalue->party, OSUTF8("party"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CancelTradeConfirmation_version                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CancelTradeConfirmation_version (OSCTXT* pctxt,
   CancelTradeConfirmation_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_CancelTradeConfirmation_version (OSCTXT* pctxt, 
   CancelTradeConfirmation_version value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      CancelTradeConfirmation_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CancelTradeConfirmation                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CancelTradeConfirmation (OSCTXT* pctxt,
   CancelTradeConfirmation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode party */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_Party (pctxt, &pvalue->party, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode partyTradeIdentifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_PartyTradeIdentifier (pctxt, &pvalue->partyTradeIdentifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_CancelTradeConfirmation_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CancelTradeConfirmation (OSCTXT* pctxt, 
   CancelTradeConfirmation* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_CancelTradeConfirmation_version (pctxt, pvalue->version
      , 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode partyTradeIdentifier */

   stat = XmlEnc_PartyTradeIdentifier (pctxt, &pvalue->partyTradeIdentifier
      , OSUTF8("partyTradeIdentifier"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode party */

   stat = XmlEnc_Party (pctxt, &pvalue->party, OSUTF8("party"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConfirmTrade_version                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ConfirmTrade_version (OSCTXT* pctxt,
   ConfirmTrade_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ConfirmTrade_version (OSCTXT* pctxt, ConfirmTrade_version value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      ConfirmTrade_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConfirmTrade                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ConfirmTrade (OSCTXT* pctxt,
   ConfirmTrade *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode party */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_Party (pctxt, &pvalue->party, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode partyTradeIdentifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_PartyTradeIdentifier (pctxt, &pvalue->partyTradeIdentifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_ConfirmTrade_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ConfirmTrade (OSCTXT* pctxt, ConfirmTrade* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_ConfirmTrade_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode partyTradeIdentifier */

   stat = XmlEnc_PartyTradeIdentifier (pctxt, &pvalue->partyTradeIdentifier
      , OSUTF8("partyTradeIdentifier"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode party */

   stat = XmlEnc_Party (pctxt, &pvalue->party, OSUTF8("party"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestQuote_version                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RequestQuote_version (OSCTXT* pctxt,
   RequestQuote_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_RequestQuote_version (OSCTXT* pctxt, RequestQuote_version value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      RequestQuote_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuotableProduct_1                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuotableProduct_1 (OSCTXT* pctxt,
   QuotableProduct_1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode productId_list */

   pnode2 = pvalue->productId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ProductId (pctxt, ((ProductId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ProductType (pctxt, &pvalue->productType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuotableProduct_1 (OSCTXT* pctxt, QuotableProduct_1* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      stat = XmlEnc_ProductType (pctxt, &pvalue->productType
         , OSUTF8("productType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode productId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->productId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ProductId (pctxt, ((ProductId*)pnode->data)
         , OSUTF8("productId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuotableProduct_derivations                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuotableProduct_derivations (OSCTXT* pctxt,
   QuotableProduct_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_QuotableProduct_1 (pctxt, pvalue->u.quotableProduct, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_QuotableFXLeg (pctxt, pvalue->u.quotableFXLeg, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_QuotableProduct_derivations (OSCTXT* pctxt, 
   QuotableProduct_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode quotableProduct */

         stat = XmlEnc_QuotableProduct_1 (pctxt, pvalue->u.quotableProduct
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode quotableFXLeg */

         stat = XmlEnc_QuotableFXLeg (pctxt, pvalue->u.quotableFXLeg
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuotableProduct                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuotableProduct (OSCTXT* pctxt,
   QuotableProduct *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_QuotableProduct_derivations (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_QuotableProduct (OSCTXT* pctxt, QuotableProduct* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_QuotableProduct_derivations (pctxt, pvalue
      , elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuotableProduct_group                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuotableProduct_group (OSCTXT* pctxt,
   QuotableProduct_group *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_QuotableProduct (pctxt, pvalue->u.quotableProduct, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_QuotableFxSingleLeg (pctxt, pvalue->u.quotableFxSingleLeg, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_QuotableProduct_group (OSCTXT* pctxt, 
   QuotableProduct_group* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode quotableProduct */

         stat = XmlEnc_QuotableProduct (pctxt, pvalue->u.quotableProduct
            , OSUTF8("quotableProduct"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode quotableFxSingleLeg */

         stat = XmlEnc_QuotableFxSingleLeg (pctxt, pvalue->
            u.quotableFxSingleLeg, OSUTF8("quotableFxSingleLeg"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestQuote                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RequestQuote (OSCTXT* pctxt,
   RequestQuote *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode party_list */

   pnode2 = pvalue->party_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Party (pctxt, ((Party*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode quotableProduct_list */

   if (!(pvalue->quotableProduct_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "RequestQuote.quotableProduct_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->quotableProduct_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->quotableProduct_list.tail;
   while (0 != pnode2) {
      ll = asn1E_QuotableProduct_group (pctxt, ((QuotableProduct_group*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_RequestQuote_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_RequestQuote (OSCTXT* pctxt, RequestQuote* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_RequestQuote_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode quotableProduct_list */

   if (!(pvalue->quotableProduct_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "RequestQuote.quotableProduct_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->quotableProduct_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->quotableProduct_list.head;
   while (0 != pnode) {
      stat = XmlEnc_QuotableProduct_group (pctxt, 
         ((QuotableProduct_group*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode party_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->party_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Party (pctxt, ((Party*)pnode->data)
         , OSUTF8("party"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestMessage_derivations                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RequestMessage_derivations (OSCTXT* pctxt,
   RequestMessage_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_ModifyTradeConfirmation (pctxt, pvalue->u.modifyTradeConfirmation, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_ModifyTradeMatch (pctxt, pvalue->u.modifyTradeMatch, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_RequestTradeConfirmation (pctxt, pvalue->u.requestTradeConfirmation, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 4:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
            asn1E_RequestTradeMatch (pctxt, pvalue->u.requestTradeMatch, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 5:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
            asn1E_RequestTradeStatus (pctxt, pvalue->u.requestTradeStatus, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 6:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
            asn1E_CancelTradeMatch (pctxt, pvalue->u.cancelTradeMatch, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 7:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
            asn1E_CancelTradeConfirmation (pctxt, pvalue->u.cancelTradeConfirmation, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 8:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
            asn1E_ConfirmTrade (pctxt, pvalue->u.confirmTrade, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 9:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
            asn1E_RequestQuote (pctxt, pvalue->u.requestQuote, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_RequestMessage_derivations (OSCTXT* pctxt, 
   RequestMessage_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode modifyTradeConfirmation */

         stat = XmlEnc_ModifyTradeConfirmation (pctxt, pvalue->
            u.modifyTradeConfirmation, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode modifyTradeMatch */

         stat = XmlEnc_ModifyTradeMatch (pctxt, pvalue->u.modifyTradeMatch
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode requestTradeConfirmation */

         stat = XmlEnc_RequestTradeConfirmation (pctxt, pvalue->
            u.requestTradeConfirmation, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 4:
         /* encode requestTradeMatch */

         stat = XmlEnc_RequestTradeMatch (pctxt, pvalue->u.requestTradeMatch
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 5:
         /* encode requestTradeStatus */

         stat = XmlEnc_RequestTradeStatus (pctxt, pvalue->u.requestTradeStatus
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 6:
         /* encode cancelTradeMatch */

         stat = XmlEnc_CancelTradeMatch (pctxt, pvalue->u.cancelTradeMatch
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 7:
         /* encode cancelTradeConfirmation */

         stat = XmlEnc_CancelTradeConfirmation (pctxt, pvalue->
            u.cancelTradeConfirmation, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 8:
         /* encode confirmTrade */

         stat = XmlEnc_ConfirmTrade (pctxt, pvalue->u.confirmTrade
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 9:
         /* encode requestQuote */

         stat = XmlEnc_RequestQuote (pctxt, pvalue->u.requestQuote
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResponseMessage_version                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ResponseMessage_version (OSCTXT* pctxt,
   ResponseMessage_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ResponseMessage_version (OSCTXT* pctxt, 
   ResponseMessage_version value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      ResponseMessage_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResponseMessageHeader                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ResponseMessageHeader (OSCTXT* pctxt,
   ResponseMessageHeader *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode signature_list */

   pnode2 = pvalue->signature_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Signature (pctxt, ((Signature*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode expiryTimestamp */

   if (pvalue->m.expiryTimestampPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
         xe_charstr (pctxt, pvalue->expiryTimestamp, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode creationTimestamp */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
      xe_charstr (pctxt, pvalue->creationTimestamp, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode copyTo_list */

   pnode2 = pvalue->copyTo_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PartyId (pctxt, ((PartyId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode sendTo_list */

   pnode2 = pvalue->sendTo_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PartyId (pctxt, ((PartyId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode sentBy */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_PartyId (pctxt, &pvalue->sentBy, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode inReplyTo */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_MessageId (pctxt, &pvalue->inReplyTo, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode messageId */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_MessageId (pctxt, &pvalue->messageId, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode conversationId */

   if (pvalue->m.conversationIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ConversationId (pctxt, &pvalue->conversationId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ResponseMessageHeader (OSCTXT* pctxt, 
   ResponseMessageHeader* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode conversationId */

   if (pvalue->m.conversationIdPresent) {
      stat = XmlEnc_ConversationId (pctxt, &pvalue->conversationId
         , OSUTF8("conversationId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode messageId */

   stat = XmlEnc_MessageId (pctxt, &pvalue->messageId
      , OSUTF8("messageId"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode inReplyTo */

   stat = XmlEnc_MessageId (pctxt, &pvalue->inReplyTo
      , OSUTF8("inReplyTo"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode sentBy */

   stat = XmlEnc_PartyId (pctxt, &pvalue->sentBy, OSUTF8("sentBy"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode sendTo_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->sendTo_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PartyId (pctxt, ((PartyId*)pnode->data)
         , OSUTF8("sendTo"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode copyTo_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->copyTo_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PartyId (pctxt, ((PartyId*)pnode->data)
         , OSUTF8("copyTo"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode creationTimestamp */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->creationTimestamp
      , OSUTF8("creationTimestamp"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode expiryTimestamp */

   if (pvalue->m.expiryTimestampPresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->expiryTimestamp
         , OSUTF8("expiryTimestamp"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode signature_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->signature_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Signature (pctxt, ((Signature*)pnode->data)
         , OSUTF8("Signature"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResponseMessage                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ResponseMessage (OSCTXT* pctxt,
   ResponseMessage *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode validation_model */

   if (pvalue->m.validation_modelPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Validation_model (pctxt, &pvalue->validation_model, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode header */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_ResponseMessageHeader (pctxt, &pvalue->header, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_ResponseMessage_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ResponseMessage (OSCTXT* pctxt, ResponseMessage* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_ResponseMessage_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode header */

   stat = XmlEnc_ResponseMessageHeader (pctxt, &pvalue->header
      , OSUTF8("header"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode validation_model */

   if (pvalue->m.validation_modelPresent) {
      stat = XmlEnc_Validation_model (pctxt, &pvalue->validation_model
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeAffirmed_version                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeAffirmed_version (OSCTXT* pctxt,
   TradeAffirmed_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_TradeAffirmed_version (OSCTXT* pctxt, TradeAffirmed_version value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      TradeAffirmed_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeAffirmed                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeAffirmed (OSCTXT* pctxt,
   TradeAffirmed *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode party_list */

   if (!(pvalue->party_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TradeAffirmed.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->party_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Party (pctxt, ((Party*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode tradeIdentifier_list */

   if (!(pvalue->tradeIdentifier_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TradeAffirmed.tradeIdentifier_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->tradeIdentifier_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->tradeIdentifier_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TradeIdentifier_derivations (pctxt, ((TradeIdentifier_derivations*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_TradeAffirmed_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TradeAffirmed (OSCTXT* pctxt, TradeAffirmed* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TradeAffirmed_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode tradeIdentifier_list */

   if (!(pvalue->tradeIdentifier_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TradeAffirmed.tradeIdentifier_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->tradeIdentifier_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->tradeIdentifier_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TradeIdentifier_derivations (pctxt, 
         ((TradeIdentifier_derivations*)pnode->data)
         , OSUTF8("tradeIdentifier"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode party_list */

   if (!(pvalue->party_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TradeAffirmed.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->party_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Party (pctxt, ((Party*)pnode->data)
         , OSUTF8("party"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeAlreadyMatched_version                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeAlreadyMatched_version (OSCTXT* pctxt,
   TradeAlreadyMatched_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_TradeAlreadyMatched_version (OSCTXT* pctxt, 
   TradeAlreadyMatched_version value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      TradeAlreadyMatched_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeAlreadyMatched                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeAlreadyMatched (OSCTXT* pctxt,
   TradeAlreadyMatched *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode party */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_Party (pctxt, &pvalue->party, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode tradeIdentifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_TradeAlreadyMatched_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TradeAlreadyMatched (OSCTXT* pctxt, TradeAlreadyMatched* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TradeAlreadyMatched_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode tradeIdentifier */

   stat = XmlEnc_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier
      , OSUTF8("tradeIdentifier"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode party */

   stat = XmlEnc_Party (pctxt, &pvalue->party, OSUTF8("party"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeAlreadySubmitted_version                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeAlreadySubmitted_version (OSCTXT* pctxt,
   TradeAlreadySubmitted_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_TradeAlreadySubmitted_version (OSCTXT* pctxt, 
   TradeAlreadySubmitted_version value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      TradeAlreadySubmitted_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeAlreadySubmitted                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeAlreadySubmitted (OSCTXT* pctxt,
   TradeAlreadySubmitted *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode party */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_Party (pctxt, &pvalue->party, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode tradeIdentifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_TradeAlreadySubmitted_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TradeAlreadySubmitted (OSCTXT* pctxt, 
   TradeAlreadySubmitted* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TradeAlreadySubmitted_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode tradeIdentifier */

   stat = XmlEnc_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier
      , OSUTF8("tradeIdentifier"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode party */

   stat = XmlEnc_Party (pctxt, &pvalue->party, OSUTF8("party"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeNotFound_version                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeNotFound_version (OSCTXT* pctxt,
   TradeNotFound_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_TradeNotFound_version (OSCTXT* pctxt, TradeNotFound_version value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      TradeNotFound_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeNotFound                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeNotFound (OSCTXT* pctxt,
   TradeNotFound *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode party */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_Party (pctxt, &pvalue->party, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode tradeIdentifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_TradeNotFound_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TradeNotFound (OSCTXT* pctxt, TradeNotFound* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TradeNotFound_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode tradeIdentifier */

   stat = XmlEnc_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier
      , OSUTF8("tradeIdentifier"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode party */

   stat = XmlEnc_Party (pctxt, &pvalue->party, OSUTF8("party"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeStatus_version                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeStatus_version (OSCTXT* pctxt,
   TradeStatus_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_TradeStatus_version (OSCTXT* pctxt, TradeStatus_version value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      TradeStatus_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeStatusValue                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeStatusValue (OSCTXT* pctxt,
   TradeStatusValue *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode tradeStatusScheme */

   if (pvalue->m.tradeStatusSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->tradeStatusScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TradeStatusValue (OSCTXT* pctxt, TradeStatusValue* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.tradeStatusSchemePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" tradeStatusScheme=\""), 20);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->tradeStatusScheme, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeStatusItem                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeStatusItem (OSCTXT* pctxt,
   TradeStatusItem *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode tradeStatusValue */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_TradeStatusValue (pctxt, &pvalue->tradeStatusValue, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode tradeIdentifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TradeStatusItem (OSCTXT* pctxt, TradeStatusItem* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode tradeIdentifier */

   stat = XmlEnc_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier
      , OSUTF8("tradeIdentifier"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode tradeStatusValue */

   stat = XmlEnc_TradeStatusValue (pctxt, &pvalue->tradeStatusValue
      , OSUTF8("tradeStatusValue"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeStatus                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeStatus (OSCTXT* pctxt,
   TradeStatus *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode party_list */

   if (!(pvalue->party_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TradeStatus.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->party_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Party (pctxt, ((Party*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode tradeStatusItem_list */

   if (!(pvalue->tradeStatusItem_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TradeStatus.tradeStatusItem_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->tradeStatusItem_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->tradeStatusItem_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TradeStatusItem (pctxt, ((TradeStatusItem*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_TradeStatus_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TradeStatus (OSCTXT* pctxt, TradeStatus* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TradeStatus_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode tradeStatusItem_list */

   if (!(pvalue->tradeStatusItem_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TradeStatus.tradeStatusItem_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->tradeStatusItem_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->tradeStatusItem_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TradeStatusItem (pctxt, ((TradeStatusItem*)pnode->data)
         , OSUTF8("tradeStatusItem"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode party_list */

   if (!(pvalue->party_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TradeStatus.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->party_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Party (pctxt, ((Party*)pnode->data)
         , OSUTF8("party"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConfirmationCancelled_version                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ConfirmationCancelled_version (OSCTXT* pctxt,
   ConfirmationCancelled_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ConfirmationCancelled_version (OSCTXT* pctxt, 
   ConfirmationCancelled_version value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      ConfirmationCancelled_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConfirmationCancelled                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ConfirmationCancelled (OSCTXT* pctxt,
   ConfirmationCancelled *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode party */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_Party (pctxt, &pvalue->party, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode tradeIdentifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_ConfirmationCancelled_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ConfirmationCancelled (OSCTXT* pctxt, 
   ConfirmationCancelled* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_ConfirmationCancelled_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode tradeIdentifier */

   stat = XmlEnc_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier
      , OSUTF8("tradeIdentifier"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode party */

   stat = XmlEnc_Party (pctxt, &pvalue->party, OSUTF8("party"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestQuoteResponse_version                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RequestQuoteResponse_version (OSCTXT* pctxt,
   RequestQuoteResponse_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_RequestQuoteResponse_version (OSCTXT* pctxt, 
   RequestQuoteResponse_version value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      RequestQuoteResponse_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestQuoteResponse                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RequestQuoteResponse (OSCTXT* pctxt,
   RequestQuoteResponse *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode party_list */

   if (!(pvalue->party_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "RequestQuoteResponse.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->party_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Party (pctxt, ((Party*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode product_list */

   if (!(pvalue->product_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "RequestQuoteResponse.product_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->product_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->product_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Product_group (pctxt, ((Product_group*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_RequestQuoteResponse_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_RequestQuoteResponse (OSCTXT* pctxt, RequestQuoteResponse* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_RequestQuoteResponse_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode product_list */

   if (!(pvalue->product_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "RequestQuoteResponse.product_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->product_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->product_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Product_group (pctxt, ((Product_group*)pnode->data)
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode party_list */

   if (!(pvalue->party_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "RequestQuoteResponse.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->party_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Party (pctxt, ((Party*)pnode->data)
         , OSUTF8("party"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AcceptQuote_version                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AcceptQuote_version (OSCTXT* pctxt,
   AcceptQuote_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_AcceptQuote_version (OSCTXT* pctxt, AcceptQuote_version value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      AcceptQuote_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AcceptQuote                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AcceptQuote (OSCTXT* pctxt,
   AcceptQuote *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode party_list */

   if (!(pvalue->party_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "AcceptQuote.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->party_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Party (pctxt, ((Party*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode trade_list */

   if (!(pvalue->trade_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "AcceptQuote.trade_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->trade_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->trade_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Trade (pctxt, ((Trade*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_AcceptQuote_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_AcceptQuote (OSCTXT* pctxt, AcceptQuote* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_AcceptQuote_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode trade_list */

   if (!(pvalue->trade_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "AcceptQuote.trade_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->trade_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->trade_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Trade (pctxt, ((Trade*)pnode->data)
         , OSUTF8("trade"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode party_list */

   if (!(pvalue->party_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "AcceptQuote.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->party_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Party (pctxt, ((Party*)pnode->data)
         , OSUTF8("party"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuoteAcceptanceConfirmed_version                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuoteAcceptanceConfirmed_version (OSCTXT* pctxt,
   QuoteAcceptanceConfirmed_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_QuoteAcceptanceConfirmed_version (OSCTXT* pctxt, 
   QuoteAcceptanceConfirmed_version value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      QuoteAcceptanceConfirmed_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuoteAcceptanceConfirmed                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuoteAcceptanceConfirmed (OSCTXT* pctxt,
   QuoteAcceptanceConfirmed *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode party_list */

   if (!(pvalue->party_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "QuoteAcceptanceConfirmed.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->party_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Party (pctxt, ((Party*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode trade_list */

   if (!(pvalue->trade_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "QuoteAcceptanceConfirmed.trade_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->trade_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->trade_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Trade (pctxt, ((Trade*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_QuoteAcceptanceConfirmed_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuoteAcceptanceConfirmed (OSCTXT* pctxt, 
   QuoteAcceptanceConfirmed* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_QuoteAcceptanceConfirmed_version (pctxt, pvalue->version
      , 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode trade_list */

   if (!(pvalue->trade_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "QuoteAcceptanceConfirmed.trade_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->trade_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->trade_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Trade (pctxt, ((Trade*)pnode->data)
         , OSUTF8("trade"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode party_list */

   if (!(pvalue->party_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "QuoteAcceptanceConfirmed.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->party_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Party (pctxt, ((Party*)pnode->data)
         , OSUTF8("party"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuoteUpdated_version                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuoteUpdated_version (OSCTXT* pctxt,
   QuoteUpdated_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_QuoteUpdated_version (OSCTXT* pctxt, QuoteUpdated_version value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      QuoteUpdated_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuoteUpdated                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuoteUpdated (OSCTXT* pctxt,
   QuoteUpdated *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode party_list */

   if (!(pvalue->party_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "QuoteUpdated.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->party_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Party (pctxt, ((Party*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode quotableProduct_list */

   if (!(pvalue->quotableProduct_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "QuoteUpdated.quotableProduct_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->quotableProduct_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->quotableProduct_list.tail;
   while (0 != pnode2) {
      ll = asn1E_QuotableProduct_group (pctxt, ((QuotableProduct_group*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_QuoteUpdated_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuoteUpdated (OSCTXT* pctxt, QuoteUpdated* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_QuoteUpdated_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode quotableProduct_list */

   if (!(pvalue->quotableProduct_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "QuoteUpdated.quotableProduct_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->quotableProduct_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->quotableProduct_list.head;
   while (0 != pnode) {
      stat = XmlEnc_QuotableProduct_group (pctxt, 
         ((QuotableProduct_group*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode party_list */

   if (!(pvalue->party_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "QuoteUpdated.party_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->party_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->party_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Party (pctxt, ((Party*)pnode->data)
         , OSUTF8("party"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuoteAlreadyExpired_version                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuoteAlreadyExpired_version (OSCTXT* pctxt,
   QuoteAlreadyExpired_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_QuoteAlreadyExpired_version (OSCTXT* pctxt, 
   QuoteAlreadyExpired_version value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      QuoteAlreadyExpired_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuoteAlreadyExpired                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuoteAlreadyExpired (OSCTXT* pctxt,
   QuoteAlreadyExpired *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_QuoteAlreadyExpired_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuoteAlreadyExpired (OSCTXT* pctxt, QuoteAlreadyExpired* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_QuoteAlreadyExpired_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResponseMessage_derivations                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ResponseMessage_derivations (OSCTXT* pctxt,
   ResponseMessage_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_ResponseMessage (pctxt, pvalue->u.responseMessage, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_TradeAffirmed (pctxt, pvalue->u.tradeAffirmed, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_TradeAlreadyMatched (pctxt, pvalue->u.tradeAlreadyMatched, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 4:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
            asn1E_TradeAlreadySubmitted (pctxt, pvalue->u.tradeAlreadySubmitted, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 5:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
            asn1E_TradeNotFound (pctxt, pvalue->u.tradeNotFound, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 6:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
            asn1E_TradeStatus (pctxt, pvalue->u.tradeStatus, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 7:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
            asn1E_ConfirmationCancelled (pctxt, pvalue->u.confirmationCancelled, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 8:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
            asn1E_RequestQuoteResponse (pctxt, pvalue->u.requestQuoteResponse, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 9:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
            asn1E_AcceptQuote (pctxt, pvalue->u.acceptQuote, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 10:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9,
            asn1E_QuoteAcceptanceConfirmed (pctxt, pvalue->u.quoteAcceptanceConfirmed, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 11:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10,
            asn1E_QuoteUpdated (pctxt, pvalue->u.quoteUpdated, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 12:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|11,
            asn1E_QuoteAlreadyExpired (pctxt, pvalue->u.quoteAlreadyExpired, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_ResponseMessage_derivations (OSCTXT* pctxt, 
   ResponseMessage_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode responseMessage */

         stat = XmlEnc_ResponseMessage (pctxt, pvalue->u.responseMessage
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode tradeAffirmed */

         stat = XmlEnc_TradeAffirmed (pctxt, pvalue->u.tradeAffirmed
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode tradeAlreadyMatched */

         stat = XmlEnc_TradeAlreadyMatched (pctxt, pvalue->
            u.tradeAlreadyMatched, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 4:
         /* encode tradeAlreadySubmitted */

         stat = XmlEnc_TradeAlreadySubmitted (pctxt, pvalue->
            u.tradeAlreadySubmitted, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 5:
         /* encode tradeNotFound */

         stat = XmlEnc_TradeNotFound (pctxt, pvalue->u.tradeNotFound
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 6:
         /* encode tradeStatus */

         stat = XmlEnc_TradeStatus (pctxt, pvalue->u.tradeStatus
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 7:
         /* encode confirmationCancelled */

         stat = XmlEnc_ConfirmationCancelled (pctxt, pvalue->
            u.confirmationCancelled, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 8:
         /* encode requestQuoteResponse */

         stat = XmlEnc_RequestQuoteResponse (pctxt, pvalue->
            u.requestQuoteResponse, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 9:
         /* encode acceptQuote */

         stat = XmlEnc_AcceptQuote (pctxt, pvalue->u.acceptQuote
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 10:
         /* encode quoteAcceptanceConfirmed */

         stat = XmlEnc_QuoteAcceptanceConfirmed (pctxt, pvalue->
            u.quoteAcceptanceConfirmed, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 11:
         /* encode quoteUpdated */

         stat = XmlEnc_QuoteUpdated (pctxt, pvalue->u.quoteUpdated
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 12:
         /* encode quoteAlreadyExpired */

         stat = XmlEnc_QuoteAlreadyExpired (pctxt, pvalue->
            u.quoteAlreadyExpired, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Message_derivations                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Message_derivations (OSCTXT* pctxt,
   Message_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_NotificationMessage_derivations (pctxt, pvalue->u.notificationMessage, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_RequestMessage_derivations (pctxt, pvalue->u.requestMessage, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_ResponseMessage_derivations (pctxt, pvalue->u.responseMessage, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Message_derivations (OSCTXT* pctxt, Message_derivations* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode notificationMessage */

         stat = XmlEnc_NotificationMessage_derivations (pctxt, pvalue->
            u.notificationMessage, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode requestMessage */

         stat = XmlEnc_RequestMessage_derivations (pctxt, pvalue->
            u.requestMessage, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode responseMessage */

         stat = XmlEnc_ResponseMessage_derivations (pctxt, pvalue->
            u.responseMessage, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Document_derivations                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Document_derivations (OSCTXT* pctxt,
   Document_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_DataDocument (pctxt, pvalue->u.dataDocument, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_Message_derivations (pctxt, pvalue->u.message, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Document_derivations (OSCTXT* pctxt, Document_derivations* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode dataDocument */

         stat = XmlEnc_DataDocument (pctxt, pvalue->u.dataDocument
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode message */

         stat = XmlEnc_Message_derivations (pctxt, pvalue->u.message
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FpML                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FpML (OSCTXT* pctxt,
   FpML *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_Document_derivations (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_FpML (OSCTXT* pctxt, FpML* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_Document_derivations (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Exercise_1                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Exercise_1 (OSCTXT* pctxt,
   Exercise_1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Exercise_1 (OSCTXT* pctxt, Exercise_1* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Exercise                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Exercise (OSCTXT* pctxt,
   Exercise *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_Exercise_1 (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Exercise (OSCTXT* pctxt, Exercise* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_Exercise_1 (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Product_1                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Product_1 (OSCTXT* pctxt,
   Product_1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode productId_list */

   pnode2 = pvalue->productId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ProductId (pctxt, ((ProductId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ProductType (pctxt, &pvalue->productType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Product_1 (OSCTXT* pctxt, Product_1* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      stat = XmlEnc_ProductType (pctxt, &pvalue->productType
         , OSUTF8("productType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode productId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->productId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ProductId (pctxt, ((ProductId*)pnode->data)
         , OSUTF8("productId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Product                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Product (OSCTXT* pctxt,
   Product *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_Product_1 (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Product (OSCTXT* pctxt, Product* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_Product_1 (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnderlyingAsset                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_UnderlyingAsset (OSCTXT* pctxt,
   UnderlyingAsset *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_UnderlyingAsset_1 (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_UnderlyingAsset (OSCTXT* pctxt, UnderlyingAsset* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_UnderlyingAsset_1 (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LinkId                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_LinkId (OSCTXT* pctxt,
   LinkId pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_utf8str (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_LinkId (OSCTXT* pctxt, LinkId value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt, value, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SettlementTerms_1                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SettlementTerms_1 (OSCTXT* pctxt,
   SettlementTerms_1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_Currency (pctxt, pvalue, ASN1IMPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   if (tagging == ASN1EXPL) {
      ll = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
   }
   ll0 += ll;

   return (ll0);
}

int XmlEnc_SettlementTerms_1 (OSCTXT* pctxt, SettlementTerms_1* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   stat = XmlEnc_Currency (pctxt, pvalue
      , OSUTF8("settlementCurrency"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ValidationRuleId                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ValidationRuleId (OSCTXT* pctxt,
   ValidationRuleId pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_utf8str (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ValidationRuleId (OSCTXT* pctxt, ValidationRuleId value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt, value, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Document_version                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Document_version (OSCTXT* pctxt,
   Document_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Document_version (OSCTXT* pctxt, Document_version value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      Document_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Message_version                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Message_version (OSCTXT* pctxt,
   Message_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Message_version (OSCTXT* pctxt, Message_version value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      Message_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestMessage_version                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RequestMessage_version (OSCTXT* pctxt,
   RequestMessage_version *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_RequestMessage_version (OSCTXT* pctxt, 
   RequestMessage_version value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      RequestMessage_version_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TradeReference                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TradeReference (OSCTXT* pctxt,
   TradeReference *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode href */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->href, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TradeReference (OSCTXT* pctxt, TradeReference* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" href=\""), 7);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->href, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Document                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Document (OSCTXT* pctxt,
   Document *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_Document_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Document (OSCTXT* pctxt, Document* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_Document_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SharedAmericanExercise                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SharedAmericanExercise (OSCTXT* pctxt,
   SharedAmericanExercise *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode latestExerciseTime */

   if (pvalue->m.latestExerciseTimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_BusinessCenterTime (pctxt, &pvalue->latestExerciseTime, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode expirationDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_AdjustableOrRelativeDate (pctxt, &pvalue->expirationDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode commencementDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_AdjustableOrRelativeDate (pctxt, &pvalue->commencementDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SharedAmericanExercise (OSCTXT* pctxt, 
   SharedAmericanExercise* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode commencementDate */

   stat = XmlEnc_AdjustableOrRelativeDate (pctxt, &pvalue->commencementDate
      , OSUTF8("commencementDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode expirationDate */

   stat = XmlEnc_AdjustableOrRelativeDate (pctxt, &pvalue->expirationDate
      , OSUTF8("expirationDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode latestExerciseTime */

   if (pvalue->m.latestExerciseTimePresent) {
      stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->latestExerciseTime
         , OSUTF8("latestExerciseTime"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_initialPrice_sequence_fxConversion    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_initialPrice_sequence_fxConversion (OSCTXT* pctxt,
   EquitySwapValuation_initialPrice_sequence_fxConversion *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         if (!(pvalue->u.fxRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "EquitySwapValuation_initialPrice_sequence_fxConversion.u.fxRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         pnode2 = pvalue->u.fxRate_list->tail;
         while (0 != pnode2) {
            ll = asn1E_FxRate_derivations (pctxt, ((FxRate_derivations*)pnode2->data), ASN1EXPL);
            if (ll < 0) return LOG_RTERR (pctxt, ll);
            ll2 += ll;

            pnode2 = pnode2->prev;
         }
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else { ll1 += ll; ll2 = 0; }
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquitySwapValuation_initialPrice_sequence_fxConversion 
   (OSCTXT* pctxt, 
   EquitySwapValuation_initialPrice_sequence_fxConversion* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode fxRate_list */

         if (!(pvalue->u.fxRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "EquitySwapValuation_initialPrice_sequence_fxConversion.u.fxRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         { const OSUTF8CHAR* savedPrefix = nsPrefix;
         nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
            "http://www.fpml.org/2003/FpML-4-0"));

         { OSRTDListNode* pnode = pvalue->u.fxRate_list->head;
         while (0 != pnode) {
            stat = XmlEnc_FxRate_derivations (pctxt, 
               ((FxRate_derivations*)pnode->data)
               , OSUTF8("fxRate"), nsPrefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            pnode = pnode->next;
         }}
         nsPrefix = savedPrefix;
         }

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_initialPrice_sequence                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_initialPrice_sequence (OSCTXT* pctxt,
   EquitySwapValuation_initialPrice_sequence *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode fxConversion */

   if (pvalue->m.fxConversionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_EquitySwapValuation_initialPrice_sequence_fxConversion (pctxt, &pvalue->fxConversion, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode accruedInterestPrice */

   if (pvalue->m.accruedInterestPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_real (pctxt, &pvalue->accruedInterestPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode netPrice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_ActualPrice (pctxt, &pvalue->netPrice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode grossPrice */

   if (pvalue->m.grossPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ActualPrice (pctxt, &pvalue->grossPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquitySwapValuation_initialPrice_sequence (OSCTXT* pctxt, 
   EquitySwapValuation_initialPrice_sequence* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode grossPrice */

   if (pvalue->m.grossPricePresent) {
      stat = XmlEnc_ActualPrice (pctxt, &pvalue->grossPrice
         , OSUTF8("grossPrice"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode netPrice */

   stat = XmlEnc_ActualPrice (pctxt, &pvalue->netPrice
      , OSUTF8("netPrice"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode accruedInterestPrice */

   if (pvalue->m.accruedInterestPricePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->accruedInterestPrice
         , OSUTF8("accruedInterestPrice"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fxConversion */

   if (pvalue->m.fxConversionPresent) {
      stat = XmlEnc_EquitySwapValuation_initialPrice_sequence_fxConversion (pctxt
         , &pvalue->fxConversion, OSUTF8("fxConversion"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_initialPrice_choice                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_initialPrice_choice (OSCTXT* pctxt,
   EquitySwapValuation_initialPrice_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            xe_utf8str (pctxt, pvalue->u.determinationMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_EquitySwapValuation_initialPrice_sequence (pctxt, pvalue->u.sequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquitySwapValuation_initialPrice_choice (OSCTXT* pctxt, 
   EquitySwapValuation_initialPrice_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode determinationMethod */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.determinationMethod
            , OSUTF8("determinationMethod"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode sequence */

         stat = XmlEnc_EquitySwapValuation_initialPrice_sequence (pctxt, pvalue
            ->u.sequence, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_initialPrice_equityValuationDate      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_initialPrice_equityValuationDate (OSCTXT* pctxt,
   EquitySwapValuation_initialPrice_equityValuationDate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AdjustableDate (pctxt, pvalue->u.adjustableDate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_RelativeDateSequence (pctxt, pvalue->u.relativeDateSequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquitySwapValuation_initialPrice_equityValuationDate 
   (OSCTXT* pctxt, 
   EquitySwapValuation_initialPrice_equityValuationDate* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode adjustableDate */

         stat = XmlEnc_AdjustableDate (pctxt, pvalue->u.adjustableDate
            , OSUTF8("adjustableDate"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode relativeDateSequence */

         stat = XmlEnc_RelativeDateSequence (pctxt, pvalue->
            u.relativeDateSequence, OSUTF8("relativeDateSequence"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_initialPrice                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_initialPrice (OSCTXT* pctxt,
   EquitySwapValuation_initialPrice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode equityValuationDate */

   if (pvalue->m.equityValuationDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_EquitySwapValuation_initialPrice_equityValuationDate (pctxt, &pvalue->equityValuationDate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_BusinessCenterTime (pctxt, &pvalue->valuationTime, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode valuationTimeType */

   if (pvalue->m.valuationTimeTypePresent) {
      if(pvalue->valuationTimeType < 0 || pvalue->valuationTimeType > 4)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         asn1E_TimeTypeEnum (pctxt, &pvalue->valuationTimeType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_EquitySwapValuation_initialPrice_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode commission */

   if (pvalue->m.commissionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Commission (pctxt, &pvalue->commission, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquitySwapValuation_initialPrice (OSCTXT* pctxt, 
   EquitySwapValuation_initialPrice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode commission */

   if (pvalue->m.commissionPresent) {
      stat = XmlEnc_Commission (pctxt, &pvalue->commission
         , OSUTF8("commission"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode choice */

   stat = XmlEnc_EquitySwapValuation_initialPrice_choice (pctxt, &pvalue->
      choice, OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode valuationTimeType */

   if (pvalue->m.valuationTimeTypePresent) {
      if(pvalue->valuationTimeType < 0 || pvalue->valuationTimeType > 4)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_TimeTypeEnum (pctxt, pvalue->valuationTimeType
         , OSUTF8("valuationTimeType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->valuationTime
         , OSUTF8("valuationTime"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode equityValuationDate */

   if (pvalue->m.equityValuationDatePresent) {
      stat = XmlEnc_EquitySwapValuation_initialPrice_equityValuationDate (pctxt
         , &pvalue->equityValuationDate
         , OSUTF8("equityValuationDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_valuationPriceInterim_sequence_fxCon  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_valuationPriceInterim_sequence_fxConversion (OSCTXT* pctxt,
   EquitySwapValuation_valuationPriceInterim_sequence_fxConversion *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         if (!(pvalue->u.fxRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "EquitySwapValuation_valuationPriceInterim_sequence_fxConversion.u.fxRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         pnode2 = pvalue->u.fxRate_list->tail;
         while (0 != pnode2) {
            ll = asn1E_FxRate_derivations (pctxt, ((FxRate_derivations*)pnode2->data), ASN1EXPL);
            if (ll < 0) return LOG_RTERR (pctxt, ll);
            ll2 += ll;

            pnode2 = pnode2->prev;
         }
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else { ll1 += ll; ll2 = 0; }
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquitySwapValuation_valuationPriceInterim_sequence_fxConversion 
   (OSCTXT* pctxt, 
   EquitySwapValuation_valuationPriceInterim_sequence_fxConversion* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode fxRate_list */

         if (!(pvalue->u.fxRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "EquitySwapValuation_valuationPriceInterim_sequence_fxConversion.u.fxRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         { const OSUTF8CHAR* savedPrefix = nsPrefix;
         nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
            "http://www.fpml.org/2003/FpML-4-0"));

         { OSRTDListNode* pnode = pvalue->u.fxRate_list->head;
         while (0 != pnode) {
            stat = XmlEnc_FxRate_derivations (pctxt, 
               ((FxRate_derivations*)pnode->data)
               , OSUTF8("fxRate"), nsPrefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            pnode = pnode->next;
         }}
         nsPrefix = savedPrefix;
         }

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_valuationPriceInterim_sequence        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_valuationPriceInterim_sequence (OSCTXT* pctxt,
   EquitySwapValuation_valuationPriceInterim_sequence *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode fxConversion */

   if (pvalue->m.fxConversionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_EquitySwapValuation_valuationPriceInterim_sequence_fxConversion (pctxt, &pvalue->fxConversion, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode accruedInterestPrice */

   if (pvalue->m.accruedInterestPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_real (pctxt, &pvalue->accruedInterestPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode netPrice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_ActualPrice (pctxt, &pvalue->netPrice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode grossPrice */

   if (pvalue->m.grossPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ActualPrice (pctxt, &pvalue->grossPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquitySwapValuation_valuationPriceInterim_sequence (OSCTXT* pctxt, 
   EquitySwapValuation_valuationPriceInterim_sequence* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode grossPrice */

   if (pvalue->m.grossPricePresent) {
      stat = XmlEnc_ActualPrice (pctxt, &pvalue->grossPrice
         , OSUTF8("grossPrice"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode netPrice */

   stat = XmlEnc_ActualPrice (pctxt, &pvalue->netPrice
      , OSUTF8("netPrice"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode accruedInterestPrice */

   if (pvalue->m.accruedInterestPricePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->accruedInterestPrice
         , OSUTF8("accruedInterestPrice"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fxConversion */

   if (pvalue->m.fxConversionPresent) {
      stat = XmlEnc_EquitySwapValuation_valuationPriceInterim_sequence_fxConversion (pctxt
         , &pvalue->fxConversion, OSUTF8("fxConversion"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_valuationPriceInterim_choice          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_valuationPriceInterim_choice (OSCTXT* pctxt,
   EquitySwapValuation_valuationPriceInterim_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            xe_utf8str (pctxt, pvalue->u.determinationMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_EquitySwapValuation_valuationPriceInterim_sequence (pctxt, pvalue->u.sequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquitySwapValuation_valuationPriceInterim_choice (OSCTXT* pctxt, 
   EquitySwapValuation_valuationPriceInterim_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode determinationMethod */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.determinationMethod
            , OSUTF8("determinationMethod"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode sequence */

         stat = XmlEnc_EquitySwapValuation_valuationPriceInterim_sequence (pctxt
            , pvalue->u.sequence, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_valuationPriceInterim                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_valuationPriceInterim (OSCTXT* pctxt,
   EquitySwapValuation_valuationPriceInterim *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode equityValuationDates */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_AdjustableRelativeOrPeriodicDates (pctxt, &pvalue->equityValuationDates, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_BusinessCenterTime (pctxt, &pvalue->valuationTime, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode valuationTimeType */

   if(pvalue->valuationTimeType < 0 || pvalue->valuationTimeType > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      asn1E_TimeTypeEnum (pctxt, &pvalue->valuationTimeType, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_EquitySwapValuation_valuationPriceInterim_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode commission */

   if (pvalue->m.commissionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Commission (pctxt, &pvalue->commission, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquitySwapValuation_valuationPriceInterim (OSCTXT* pctxt, 
   EquitySwapValuation_valuationPriceInterim* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode commission */

   if (pvalue->m.commissionPresent) {
      stat = XmlEnc_Commission (pctxt, &pvalue->commission
         , OSUTF8("commission"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode choice */

   stat = XmlEnc_EquitySwapValuation_valuationPriceInterim_choice (pctxt, &
      pvalue->choice, OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode valuationTimeType */

   if(pvalue->valuationTimeType < 0 || pvalue->valuationTimeType > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TimeTypeEnum (pctxt, pvalue->valuationTimeType
      , OSUTF8("valuationTimeType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->valuationTime
         , OSUTF8("valuationTime"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode equityValuationDates */

   stat = XmlEnc_AdjustableRelativeOrPeriodicDates (pctxt, &pvalue->
      equityValuationDates, OSUTF8("equityValuationDates"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_valuationPriceFinal_sequence_fxConve  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_valuationPriceFinal_sequence_fxConversion (OSCTXT* pctxt,
   EquitySwapValuation_valuationPriceFinal_sequence_fxConversion *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         if (!(pvalue->u.fxRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "EquitySwapValuation_valuationPriceFinal_sequence_fxConversion.u.fxRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         pnode2 = pvalue->u.fxRate_list->tail;
         while (0 != pnode2) {
            ll = asn1E_FxRate_derivations (pctxt, ((FxRate_derivations*)pnode2->data), ASN1EXPL);
            if (ll < 0) return LOG_RTERR (pctxt, ll);
            ll2 += ll;

            pnode2 = pnode2->prev;
         }
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else { ll1 += ll; ll2 = 0; }
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquitySwapValuation_valuationPriceFinal_sequence_fxConversion 
   (OSCTXT* pctxt, 
   EquitySwapValuation_valuationPriceFinal_sequence_fxConversion* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode fxRate_list */

         if (!(pvalue->u.fxRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "EquitySwapValuation_valuationPriceFinal_sequence_fxConversion.u.fxRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         { const OSUTF8CHAR* savedPrefix = nsPrefix;
         nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
            "http://www.fpml.org/2003/FpML-4-0"));

         { OSRTDListNode* pnode = pvalue->u.fxRate_list->head;
         while (0 != pnode) {
            stat = XmlEnc_FxRate_derivations (pctxt, 
               ((FxRate_derivations*)pnode->data)
               , OSUTF8("fxRate"), nsPrefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            pnode = pnode->next;
         }}
         nsPrefix = savedPrefix;
         }

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_valuationPriceFinal_sequence          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_valuationPriceFinal_sequence (OSCTXT* pctxt,
   EquitySwapValuation_valuationPriceFinal_sequence *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode fxConversion */

   if (pvalue->m.fxConversionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_EquitySwapValuation_valuationPriceFinal_sequence_fxConversion (pctxt, &pvalue->fxConversion, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode accruedInterestPrice */

   if (pvalue->m.accruedInterestPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_real (pctxt, &pvalue->accruedInterestPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode netPrice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_ActualPrice (pctxt, &pvalue->netPrice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode grossPrice */

   if (pvalue->m.grossPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ActualPrice (pctxt, &pvalue->grossPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquitySwapValuation_valuationPriceFinal_sequence (OSCTXT* pctxt, 
   EquitySwapValuation_valuationPriceFinal_sequence* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode grossPrice */

   if (pvalue->m.grossPricePresent) {
      stat = XmlEnc_ActualPrice (pctxt, &pvalue->grossPrice
         , OSUTF8("grossPrice"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode netPrice */

   stat = XmlEnc_ActualPrice (pctxt, &pvalue->netPrice
      , OSUTF8("netPrice"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode accruedInterestPrice */

   if (pvalue->m.accruedInterestPricePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->accruedInterestPrice
         , OSUTF8("accruedInterestPrice"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fxConversion */

   if (pvalue->m.fxConversionPresent) {
      stat = XmlEnc_EquitySwapValuation_valuationPriceFinal_sequence_fxConversion (pctxt
         , &pvalue->fxConversion, OSUTF8("fxConversion"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_valuationPriceFinal_choice            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_valuationPriceFinal_choice (OSCTXT* pctxt,
   EquitySwapValuation_valuationPriceFinal_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            xe_utf8str (pctxt, pvalue->u.determinationMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_EquitySwapValuation_valuationPriceFinal_sequence (pctxt, pvalue->u.sequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquitySwapValuation_valuationPriceFinal_choice (OSCTXT* pctxt, 
   EquitySwapValuation_valuationPriceFinal_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode determinationMethod */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.determinationMethod
            , OSUTF8("determinationMethod"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode sequence */

         stat = XmlEnc_EquitySwapValuation_valuationPriceFinal_sequence (pctxt
            , pvalue->u.sequence, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_valuationPriceFinal_equityValuationD  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_valuationPriceFinal_equityValuationDate (OSCTXT* pctxt,
   EquitySwapValuation_valuationPriceFinal_equityValuationDate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AdjustableDate (pctxt, pvalue->u.adjustableDate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_RelativeDateSequence (pctxt, pvalue->u.relativeDateSequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquitySwapValuation_valuationPriceFinal_equityValuationDate 
   (OSCTXT* pctxt, 
   EquitySwapValuation_valuationPriceFinal_equityValuationDate* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode adjustableDate */

         stat = XmlEnc_AdjustableDate (pctxt, pvalue->u.adjustableDate
            , OSUTF8("adjustableDate"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode relativeDateSequence */

         stat = XmlEnc_RelativeDateSequence (pctxt, pvalue->
            u.relativeDateSequence, OSUTF8("relativeDateSequence"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_valuationPriceFinal                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_valuationPriceFinal (OSCTXT* pctxt,
   EquitySwapValuation_valuationPriceFinal *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode equityValuationDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_EquitySwapValuation_valuationPriceFinal_equityValuationDate (pctxt, &pvalue->equityValuationDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_BusinessCenterTime (pctxt, &pvalue->valuationTime, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode valuationTimeType */

   if (pvalue->m.valuationTimeTypePresent) {
      if(pvalue->valuationTimeType < 0 || pvalue->valuationTimeType > 4)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         asn1E_TimeTypeEnum (pctxt, &pvalue->valuationTimeType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_EquitySwapValuation_valuationPriceFinal_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode commission */

   if (pvalue->m.commissionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Commission (pctxt, &pvalue->commission, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquitySwapValuation_valuationPriceFinal (OSCTXT* pctxt, 
   EquitySwapValuation_valuationPriceFinal* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode commission */

   if (pvalue->m.commissionPresent) {
      stat = XmlEnc_Commission (pctxt, &pvalue->commission
         , OSUTF8("commission"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode choice */

   stat = XmlEnc_EquitySwapValuation_valuationPriceFinal_choice (pctxt, &pvalue
      ->choice, OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode valuationTimeType */

   if (pvalue->m.valuationTimeTypePresent) {
      if(pvalue->valuationTimeType < 0 || pvalue->valuationTimeType > 4)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_TimeTypeEnum (pctxt, pvalue->valuationTimeType
         , OSUTF8("valuationTimeType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->valuationTime
         , OSUTF8("valuationTime"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode equityValuationDate */

   stat = XmlEnc_EquitySwapValuation_valuationPriceFinal_equityValuationDate (pctxt
      , &pvalue->equityValuationDate
      , OSUTF8("equityValuationDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation (OSCTXT* pctxt,
   EquitySwapValuation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode equityPaymentDates */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_EquityPaymentDates (pctxt, &pvalue->equityPaymentDates, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode valuationPriceFinal */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_EquitySwapValuation_valuationPriceFinal (pctxt, &pvalue->valuationPriceFinal, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode valuationPriceInterim */

   if (pvalue->m.valuationPriceInterimPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_EquitySwapValuation_valuationPriceInterim (pctxt, &pvalue->valuationPriceInterim, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode equityNotionalReset */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_boolean (pctxt, &pvalue->equityNotionalReset, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode initialPrice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_EquitySwapValuation_initialPrice (pctxt, &pvalue->initialPrice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquitySwapValuation (OSCTXT* pctxt, EquitySwapValuation* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode initialPrice */

   stat = XmlEnc_EquitySwapValuation_initialPrice (pctxt, &pvalue->initialPrice
      , OSUTF8("initialPrice"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode equityNotionalReset */

   stat = rtXmlEncBool (pctxt, pvalue->equityNotionalReset
      , OSUTF8("equityNotionalReset"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode valuationPriceInterim */

   if (pvalue->m.valuationPriceInterimPresent) {
      stat = XmlEnc_EquitySwapValuation_valuationPriceInterim (pctxt, &pvalue->
         valuationPriceInterim, OSUTF8("valuationPriceInterim"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode valuationPriceFinal */

   stat = XmlEnc_EquitySwapValuation_valuationPriceFinal (pctxt, &pvalue->
      valuationPriceFinal, OSUTF8("valuationPriceFinal"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode equityPaymentDates */

   stat = XmlEnc_EquityPaymentDates (pctxt, &pvalue->equityPaymentDates
      , OSUTF8("equityPaymentDates"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterestAccrualsMethod                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_InterestAccrualsMethod (OSCTXT* pctxt,
   InterestAccrualsMethod *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_FloatingRateCalculation (pctxt, pvalue->u.floatingRateCalculation, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
            xe_real (pctxt, &pvalue->u.fixedRate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   if (tagging == ASN1EXPL) {
      ll1 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll1);
      if (ll1 < 0) return LOG_RTERR (pctxt, ll1);
   }

   ll0 += ll1;

   return (ll0);
}

int XmlEnc_InterestAccrualsMethod (OSCTXT* pctxt, 
   InterestAccrualsMethod* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode floatingRateCalculation */

         stat = XmlEnc_FloatingRateCalculation (pctxt, pvalue->
            u.floatingRateCalculation
            , OSUTF8("floatingRateCalculation"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode fixedRate */

         stat = rtXmlEncDouble (pctxt, pvalue->u.fixedRate
            , OSUTF8("fixedRate"), nsPrefix, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MessageHeader                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MessageHeader (OSCTXT* pctxt,
   MessageHeader *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode signature_list */

   pnode2 = pvalue->signature_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Signature (pctxt, ((Signature*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode expiryTimestamp */

   if (pvalue->m.expiryTimestampPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
         xe_charstr (pctxt, pvalue->expiryTimestamp, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode creationTimestamp */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
      xe_charstr (pctxt, pvalue->creationTimestamp, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode copyTo_list */

   pnode2 = pvalue->copyTo_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PartyId (pctxt, ((PartyId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode sendTo_list */

   pnode2 = pvalue->sendTo_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PartyId (pctxt, ((PartyId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode sentBy */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_PartyId (pctxt, &pvalue->sentBy, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode inReplyTo */

   if (pvalue->m.inReplyToPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_MessageId (pctxt, &pvalue->inReplyTo, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode messageId */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_MessageId (pctxt, &pvalue->messageId, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode conversationId */

   if (pvalue->m.conversationIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ConversationId (pctxt, &pvalue->conversationId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MessageHeader (OSCTXT* pctxt, MessageHeader* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode conversationId */

   if (pvalue->m.conversationIdPresent) {
      stat = XmlEnc_ConversationId (pctxt, &pvalue->conversationId
         , OSUTF8("conversationId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode messageId */

   stat = XmlEnc_MessageId (pctxt, &pvalue->messageId
      , OSUTF8("messageId"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode inReplyTo */

   if (pvalue->m.inReplyToPresent) {
      stat = XmlEnc_MessageId (pctxt, &pvalue->inReplyTo
         , OSUTF8("inReplyTo"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode sentBy */

   stat = XmlEnc_PartyId (pctxt, &pvalue->sentBy, OSUTF8("sentBy"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode sendTo_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->sendTo_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PartyId (pctxt, ((PartyId*)pnode->data)
         , OSUTF8("sendTo"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode copyTo_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->copyTo_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PartyId (pctxt, ((PartyId*)pnode->data)
         , OSUTF8("copyTo"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode creationTimestamp */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->creationTimestamp
      , OSUTF8("creationTimestamp"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode expiryTimestamp */

   if (pvalue->m.expiryTimestampPresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->expiryTimestamp
         , OSUTF8("expiryTimestamp"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode signature_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->signature_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Signature (pctxt, ((Signature*)pnode->data)
         , OSUTF8("Signature"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Equity_1                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Equity_1 (OSCTXT* pctxt,
   Equity_1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_ClearanceSystem (pctxt, &pvalue->clearanceSystem, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode relatedExchangeId_list */

   pnode2 = pvalue->relatedExchangeId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ExchangeId (pctxt, ((ExchangeId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode exchangeId_list */

   pnode2 = pvalue->exchangeId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ExchangeId (pctxt, ((ExchangeId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode currency */

   if (pvalue->m.currencyPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Currency (pctxt, &pvalue->currency, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Equity_1.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->instrumentId_list.tail;
   while (0 != pnode2) {
      ll = asn1E_InstrumentId (pctxt, ((InstrumentId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode description */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->description, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Equity_1 (OSCTXT* pctxt, Equity_1* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode description */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->description
      , OSUTF8("description"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode instrumentId_list */

   if (!(pvalue->instrumentId_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Equity_1.instrumentId_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->instrumentId_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->instrumentId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_InstrumentId (pctxt, ((InstrumentId*)pnode->data)
         , OSUTF8("instrumentId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode currency */

   if (pvalue->m.currencyPresent) {
      stat = XmlEnc_Currency (pctxt, &pvalue->currency
         , OSUTF8("currency"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode exchangeId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->exchangeId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ExchangeId (pctxt, ((ExchangeId*)pnode->data)
         , OSUTF8("exchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode relatedExchangeId_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->relatedExchangeId_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ExchangeId (pctxt, ((ExchangeId*)pnode->data)
         , OSUTF8("relatedExchangeId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode clearanceSystem */

   if (pvalue->m.clearanceSystemPresent) {
      stat = XmlEnc_ClearanceSystem (pctxt, &pvalue->clearanceSystem
         , OSUTF8("clearanceSystem"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestMessageHeader                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RequestMessageHeader (OSCTXT* pctxt,
   RequestMessageHeader *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode signature_list */

   pnode2 = pvalue->signature_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Signature (pctxt, ((Signature*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode expiryTimestamp */

   if (pvalue->m.expiryTimestampPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
         xe_charstr (pctxt, pvalue->expiryTimestamp, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode creationTimestamp */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
      xe_charstr (pctxt, pvalue->creationTimestamp, ASN1IMPL, TM_UNIV|TM_PRIM|26));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode copyTo_list */

   pnode2 = pvalue->copyTo_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PartyId (pctxt, ((PartyId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode sendTo_list */

   pnode2 = pvalue->sendTo_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PartyId (pctxt, ((PartyId*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode sentBy */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_PartyId (pctxt, &pvalue->sentBy, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode messageId */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_MessageId (pctxt, &pvalue->messageId, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode conversationId */

   if (pvalue->m.conversationIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ConversationId (pctxt, &pvalue->conversationId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_RequestMessageHeader (OSCTXT* pctxt, RequestMessageHeader* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode conversationId */

   if (pvalue->m.conversationIdPresent) {
      stat = XmlEnc_ConversationId (pctxt, &pvalue->conversationId
         , OSUTF8("conversationId"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode messageId */

   stat = XmlEnc_MessageId (pctxt, &pvalue->messageId
      , OSUTF8("messageId"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode sentBy */

   stat = XmlEnc_PartyId (pctxt, &pvalue->sentBy, OSUTF8("sentBy"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode sendTo_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->sendTo_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PartyId (pctxt, ((PartyId*)pnode->data)
         , OSUTF8("sendTo"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode copyTo_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->copyTo_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PartyId (pctxt, ((PartyId*)pnode->data)
         , OSUTF8("copyTo"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode creationTimestamp */

   stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->creationTimestamp
      , OSUTF8("creationTimestamp"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode expiryTimestamp */

   if (pvalue->m.expiryTimestampPresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->expiryTimestamp
         , OSUTF8("expiryTimestamp"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode signature_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   { OSRTDListNode* pnode = pvalue->signature_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Signature (pctxt, ((Signature*)pnode->data)
         , OSUTF8("Signature"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MessageHeader_derivations                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MessageHeader_derivations (OSCTXT* pctxt,
   MessageHeader_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_MessageHeader (pctxt, pvalue->u.messageHeader, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_NotificationMessageHeader (pctxt, pvalue->u.notificationMessageHeader, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_RequestMessageHeader (pctxt, pvalue->u.requestMessageHeader, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 4:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
            asn1E_ResponseMessageHeader (pctxt, pvalue->u.responseMessageHeader, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_MessageHeader_derivations (OSCTXT* pctxt, 
   MessageHeader_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode messageHeader */

         stat = XmlEnc_MessageHeader (pctxt, pvalue->u.messageHeader
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode notificationMessageHeader */

         stat = XmlEnc_NotificationMessageHeader (pctxt, pvalue->
            u.notificationMessageHeader, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode requestMessageHeader */

         stat = XmlEnc_RequestMessageHeader (pctxt, pvalue->
            u.requestMessageHeader, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 4:
         /* encode responseMessageHeader */

         stat = XmlEnc_ResponseMessageHeader (pctxt, pvalue->
            u.responseMessageHeader, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Message                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Message (OSCTXT* pctxt,
   Message *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode validation_model */

   if (pvalue->m.validation_modelPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Validation_model (pctxt, &pvalue->validation_model, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode header */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_MessageHeader_derivations (pctxt, &pvalue->header, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_Message_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Message (OSCTXT* pctxt, Message* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_Message_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode header */

   stat = XmlEnc_MessageHeader_derivations (pctxt, &pvalue->header
      , OSUTF8("header"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode validation_model */

   if (pvalue->m.validation_modelPresent) {
      stat = XmlEnc_Validation_model (pctxt, &pvalue->validation_model
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestMessage                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RequestMessage (OSCTXT* pctxt,
   RequestMessage *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode validation_model */

   if (pvalue->m.validation_modelPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Validation_model (pctxt, &pvalue->validation_model, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode header */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_RequestMessageHeader (pctxt, &pvalue->header, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode version */

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_RequestMessage_version (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_RequestMessage (OSCTXT* pctxt, RequestMessage* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

   if(pvalue->version < 0 || pvalue->version > 0)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_RequestMessage_version (pctxt, pvalue->version, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode header */

   stat = XmlEnc_RequestMessageHeader (pctxt, &pvalue->header
      , OSUTF8("header"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode validation_model */

   if (pvalue->m.validation_modelPresent) {
      stat = XmlEnc_Validation_model (pctxt, &pvalue->validation_model
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Product_derivations                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Product_derivations (OSCTXT* pctxt,
   Product_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_Product_1 (pctxt, pvalue->u.product, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_Strategy (pctxt, pvalue->u.strategy, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_FXAverageRateOption (pctxt, pvalue->u.fXAverageRateOption, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 4:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
            asn1E_FXOptionLeg_derivations (pctxt, pvalue->u.fXOptionLeg, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 5:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
            asn1E_FXDigitalOption (pctxt, pvalue->u.fXDigitalOption, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 6:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
            asn1E_FXLeg (pctxt, pvalue->u.fXLeg, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 7:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
            asn1E_FXSwap (pctxt, pvalue->u.fXSwap, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 8:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
            asn1E_TermDeposit (pctxt, pvalue->u.termDeposit, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 9:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
            asn1E_BulletPayment (pctxt, pvalue->u.bulletPayment, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 10:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9,
            asn1E_CapFloor (pctxt, pvalue->u.capFloor, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 11:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10,
            asn1E_Fra (pctxt, pvalue->u.fra, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 12:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|11,
            asn1E_Swap (pctxt, pvalue->u.swap, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 13:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|12,
            asn1E_Swaption (pctxt, pvalue->u.swaption, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 14:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|13,
            asn1E_EquityOption (pctxt, pvalue->u.equityOption, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 15:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|14,
            asn1E_EquitySwap (pctxt, pvalue->u.equitySwap, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 16:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|15,
            asn1E_CreditDefaultSwap (pctxt, pvalue->u.creditDefaultSwap, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Product_derivations (OSCTXT* pctxt, Product_derivations* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode product */

         stat = XmlEnc_Product_1 (pctxt, pvalue->u.product, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode strategy */

         stat = XmlEnc_Strategy (pctxt, pvalue->u.strategy, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode fXAverageRateOption */

         stat = XmlEnc_FXAverageRateOption (pctxt, pvalue->
            u.fXAverageRateOption, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 4:
         /* encode fXOptionLeg */

         stat = XmlEnc_FXOptionLeg_derivations (pctxt, pvalue->u.fXOptionLeg
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 5:
         /* encode fXDigitalOption */

         stat = XmlEnc_FXDigitalOption (pctxt, pvalue->u.fXDigitalOption
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 6:
         /* encode fXLeg */

         stat = XmlEnc_FXLeg (pctxt, pvalue->u.fXLeg, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 7:
         /* encode fXSwap */

         stat = XmlEnc_FXSwap (pctxt, pvalue->u.fXSwap, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 8:
         /* encode termDeposit */

         stat = XmlEnc_TermDeposit (pctxt, pvalue->u.termDeposit
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 9:
         /* encode bulletPayment */

         stat = XmlEnc_BulletPayment (pctxt, pvalue->u.bulletPayment
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 10:
         /* encode capFloor */

         stat = XmlEnc_CapFloor (pctxt, pvalue->u.capFloor, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 11:
         /* encode fra */

         stat = XmlEnc_Fra (pctxt, pvalue->u.fra, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 12:
         /* encode swap */

         stat = XmlEnc_Swap (pctxt, pvalue->u.swap, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 13:
         /* encode swaption */

         stat = XmlEnc_Swaption (pctxt, pvalue->u.swaption, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 14:
         /* encode equityOption */

         stat = XmlEnc_EquityOption (pctxt, pvalue->u.equityOption
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 15:
         /* encode equitySwap */

         stat = XmlEnc_EquitySwap (pctxt, pvalue->u.equitySwap, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 16:
         /* encode creditDefaultSwap */

         stat = XmlEnc_CreditDefaultSwap (pctxt, pvalue->u.creditDefaultSwap
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SharedAmericanExercise_derivations                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SharedAmericanExercise_derivations (OSCTXT* pctxt,
   SharedAmericanExercise_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_SharedAmericanExercise (pctxt, pvalue->u.sharedAmericanExercise, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_EquityAmericanExercise (pctxt, pvalue->u.equityAmericanExercise, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_SharedAmericanExercise_derivations (OSCTXT* pctxt, 
   SharedAmericanExercise_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode sharedAmericanExercise */

         stat = XmlEnc_SharedAmericanExercise (pctxt, pvalue->
            u.sharedAmericanExercise, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode equityAmericanExercise */

         stat = XmlEnc_EquityAmericanExercise (pctxt, pvalue->
            u.equityAmericanExercise, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Exercise_derivations                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Exercise_derivations (OSCTXT* pctxt,
   Exercise_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_Exercise_1 (pctxt, pvalue->u.exercise, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_AmericanExercise (pctxt, pvalue->u.americanExercise, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_BermudaExercise (pctxt, pvalue->u.bermudaExercise, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 4:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
            asn1E_EuropeanExercise (pctxt, pvalue->u.europeanExercise, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 5:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
            asn1E_EquityEuropeanExercise (pctxt, pvalue->u.equityEuropeanExercise, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 6:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
            asn1E_SharedAmericanExercise_derivations (pctxt, pvalue->u.sharedAmericanExercise, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Exercise_derivations (OSCTXT* pctxt, Exercise_derivations* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode exercise */

         stat = XmlEnc_Exercise_1 (pctxt, pvalue->u.exercise, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode americanExercise */

         stat = XmlEnc_AmericanExercise (pctxt, pvalue->u.americanExercise
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode bermudaExercise */

         stat = XmlEnc_BermudaExercise (pctxt, pvalue->u.bermudaExercise
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 4:
         /* encode europeanExercise */

         stat = XmlEnc_EuropeanExercise (pctxt, pvalue->u.europeanExercise
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 5:
         /* encode equityEuropeanExercise */

         stat = XmlEnc_EquityEuropeanExercise (pctxt, pvalue->
            u.equityEuropeanExercise, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 6:
         /* encode sharedAmericanExercise */

         stat = XmlEnc_SharedAmericanExercise_derivations (pctxt, pvalue->
            u.sharedAmericanExercise, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_derivations_equityLeg_valuation_init  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_sequence_fxConversion (OSCTXT* pctxt,
   EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_sequence_fxConversion *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         if (!(pvalue->u.fxRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_sequence_fxConversion.u.fxRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         pnode2 = pvalue->u.fxRate_list->tail;
         while (0 != pnode2) {
            ll = asn1E_FxRate_derivations (pctxt, ((FxRate_derivations*)pnode2->data), ASN1EXPL);
            if (ll < 0) return LOG_RTERR (pctxt, ll);
            ll2 += ll;

            pnode2 = pnode2->prev;
         }
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else { ll1 += ll; ll2 = 0; }
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_sequence_fxConversion 
   (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_sequence_fxConversion* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode fxRate_list */

         if (!(pvalue->u.fxRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_sequence_fxConversion.u.fxRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         { const OSUTF8CHAR* savedPrefix = nsPrefix;
         nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
            "http://www.fpml.org/2003/FpML-4-0"));

         { OSRTDListNode* pnode = pvalue->u.fxRate_list->head;
         while (0 != pnode) {
            stat = XmlEnc_FxRate_derivations (pctxt, 
               ((FxRate_derivations*)pnode->data)
               , OSUTF8("fxRate"), nsPrefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            pnode = pnode->next;
         }}
         nsPrefix = savedPrefix;
         }

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_derivations_equityLeg_valuation_init  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_sequence (OSCTXT* pctxt,
   EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_sequence *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode fxConversion */

   if (pvalue->m.fxConversionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_sequence_fxConversion (pctxt, &pvalue->fxConversion, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode accruedInterestPrice */

   if (pvalue->m.accruedInterestPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_real (pctxt, &pvalue->accruedInterestPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode netPrice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_ActualPrice (pctxt, &pvalue->netPrice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode grossPrice */

   if (pvalue->m.grossPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ActualPrice (pctxt, &pvalue->grossPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_sequence 
   (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_sequence* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode grossPrice */

   if (pvalue->m.grossPricePresent) {
      stat = XmlEnc_ActualPrice (pctxt, &pvalue->grossPrice
         , OSUTF8("grossPrice"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode netPrice */

   stat = XmlEnc_ActualPrice (pctxt, &pvalue->netPrice
      , OSUTF8("netPrice"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode accruedInterestPrice */

   if (pvalue->m.accruedInterestPricePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->accruedInterestPrice
         , OSUTF8("accruedInterestPrice"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fxConversion */

   if (pvalue->m.fxConversionPresent) {
      stat = XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_sequence_fxConversion (pctxt
         , &pvalue->fxConversion, OSUTF8("fxConversion"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_derivations_equityLeg_valuation_init  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_choice (OSCTXT* pctxt,
   EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            xe_utf8str (pctxt, pvalue->u.determinationMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_sequence (pctxt, pvalue->u.sequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_choice 
   (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode determinationMethod */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.determinationMethod
            , OSUTF8("determinationMethod"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode sequence */

         stat = XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_sequence (pctxt
            , pvalue->u.sequence, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_derivations_equityLeg_valuation_init  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_equityValuationDate (OSCTXT* pctxt,
   EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_equityValuationDate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AdjustableDate (pctxt, pvalue->u.adjustableDate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_RelativeDateSequence (pctxt, pvalue->u.relativeDateSequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_equityValuationDate 
   (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_equityValuationDate* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode adjustableDate */

         stat = XmlEnc_AdjustableDate (pctxt, pvalue->u.adjustableDate
            , OSUTF8("adjustableDate"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode relativeDateSequence */

         stat = XmlEnc_RelativeDateSequence (pctxt, pvalue->
            u.relativeDateSequence, OSUTF8("relativeDateSequence"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_derivations_equityLeg_valuation_init  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice (OSCTXT* pctxt,
   EquitySwapValuation_derivations_equityLeg_valuation_initialPrice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode equityValuationDate */

   if (pvalue->m.equityValuationDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_equityValuationDate (pctxt, &pvalue->equityValuationDate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_BusinessCenterTime (pctxt, &pvalue->valuationTime, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode valuationTimeType */

   if (pvalue->m.valuationTimeTypePresent) {
      if(pvalue->valuationTimeType < 0 || pvalue->valuationTimeType > 4)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         asn1E_TimeTypeEnum (pctxt, &pvalue->valuationTimeType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode commission */

   if (pvalue->m.commissionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Commission (pctxt, &pvalue->commission, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice 
   (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_initialPrice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode commission */

   if (pvalue->m.commissionPresent) {
      stat = XmlEnc_Commission (pctxt, &pvalue->commission
         , OSUTF8("commission"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode choice */

   stat = XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_choice (pctxt
      , &pvalue->choice, OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode valuationTimeType */

   if (pvalue->m.valuationTimeTypePresent) {
      if(pvalue->valuationTimeType < 0 || pvalue->valuationTimeType > 4)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_TimeTypeEnum (pctxt, pvalue->valuationTimeType
         , OSUTF8("valuationTimeType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->valuationTime
         , OSUTF8("valuationTime"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode equityValuationDate */

   if (pvalue->m.equityValuationDatePresent) {
      stat = XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_equityValuationDate (pctxt
         , &pvalue->equityValuationDate
         , OSUTF8("equityValuationDate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_derivations_equityLeg_valuation_valu  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_sequence_fxConversion (OSCTXT* pctxt,
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_sequence_fxConversion *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         if (!(pvalue->u.fxRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_sequence_fxConversion.u.fxRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         pnode2 = pvalue->u.fxRate_list->tail;
         while (0 != pnode2) {
            ll = asn1E_FxRate_derivations (pctxt, ((FxRate_derivations*)pnode2->data), ASN1EXPL);
            if (ll < 0) return LOG_RTERR (pctxt, ll);
            ll2 += ll;

            pnode2 = pnode2->prev;
         }
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else { ll1 += ll; ll2 = 0; }
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_sequence_fxConversion 
   (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_sequence_fxConversion* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode fxRate_list */

         if (!(pvalue->u.fxRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_sequence_fxConversion.u.fxRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         { const OSUTF8CHAR* savedPrefix = nsPrefix;
         nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
            "http://www.fpml.org/2003/FpML-4-0"));

         { OSRTDListNode* pnode = pvalue->u.fxRate_list->head;
         while (0 != pnode) {
            stat = XmlEnc_FxRate_derivations (pctxt, 
               ((FxRate_derivations*)pnode->data)
               , OSUTF8("fxRate"), nsPrefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            pnode = pnode->next;
         }}
         nsPrefix = savedPrefix;
         }

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_derivations_equityLeg_valuation_valu  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_sequence (OSCTXT* pctxt,
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_sequence *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode fxConversion */

   if (pvalue->m.fxConversionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_sequence_fxConversion (pctxt, &pvalue->fxConversion, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode accruedInterestPrice */

   if (pvalue->m.accruedInterestPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_real (pctxt, &pvalue->accruedInterestPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode netPrice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_ActualPrice (pctxt, &pvalue->netPrice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode grossPrice */

   if (pvalue->m.grossPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ActualPrice (pctxt, &pvalue->grossPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_sequence 
   (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_sequence* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode grossPrice */

   if (pvalue->m.grossPricePresent) {
      stat = XmlEnc_ActualPrice (pctxt, &pvalue->grossPrice
         , OSUTF8("grossPrice"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode netPrice */

   stat = XmlEnc_ActualPrice (pctxt, &pvalue->netPrice
      , OSUTF8("netPrice"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode accruedInterestPrice */

   if (pvalue->m.accruedInterestPricePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->accruedInterestPrice
         , OSUTF8("accruedInterestPrice"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fxConversion */

   if (pvalue->m.fxConversionPresent) {
      stat = XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_sequence_fxConversion (pctxt
         , &pvalue->fxConversion, OSUTF8("fxConversion"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_derivations_equityLeg_valuation_valu  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_choice (OSCTXT* pctxt,
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            xe_utf8str (pctxt, pvalue->u.determinationMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_sequence (pctxt, pvalue->u.sequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_choice 
   (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode determinationMethod */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.determinationMethod
            , OSUTF8("determinationMethod"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode sequence */

         stat = XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_sequence (pctxt
            , pvalue->u.sequence, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_derivations_equityLeg_valuation_valu  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim (OSCTXT* pctxt,
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode equityValuationDates */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_AdjustableRelativeOrPeriodicDates (pctxt, &pvalue->equityValuationDates, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_BusinessCenterTime (pctxt, &pvalue->valuationTime, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode valuationTimeType */

   if(pvalue->valuationTimeType < 0 || pvalue->valuationTimeType > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      asn1E_TimeTypeEnum (pctxt, &pvalue->valuationTimeType, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode commission */

   if (pvalue->m.commissionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Commission (pctxt, &pvalue->commission, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim 
   (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode commission */

   if (pvalue->m.commissionPresent) {
      stat = XmlEnc_Commission (pctxt, &pvalue->commission
         , OSUTF8("commission"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode choice */

   stat = XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_choice (pctxt
      , &pvalue->choice, OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode valuationTimeType */

   if(pvalue->valuationTimeType < 0 || pvalue->valuationTimeType > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TimeTypeEnum (pctxt, pvalue->valuationTimeType
      , OSUTF8("valuationTimeType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->valuationTime
         , OSUTF8("valuationTime"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode equityValuationDates */

   stat = XmlEnc_AdjustableRelativeOrPeriodicDates (pctxt, &pvalue->
      equityValuationDates, OSUTF8("equityValuationDates"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_derivations_equityLeg_valuation_valu  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_sequence_fxConversion (OSCTXT* pctxt,
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_sequence_fxConversion *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         if (!(pvalue->u.fxRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_sequence_fxConversion.u.fxRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         pnode2 = pvalue->u.fxRate_list->tail;
         while (0 != pnode2) {
            ll = asn1E_FxRate_derivations (pctxt, ((FxRate_derivations*)pnode2->data), ASN1EXPL);
            if (ll < 0) return LOG_RTERR (pctxt, ll);
            ll2 += ll;

            pnode2 = pnode2->prev;
         }
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else { ll1 += ll; ll2 = 0; }
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_sequence_fxConversion 
   (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_sequence_fxConversion* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode fxRate_list */

         if (!(pvalue->u.fxRate_list->count >= 1U)) {
            rtxErrAddStrParm (pctxt, "EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_sequence_fxConversion.u.fxRate_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.fxRate_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         { const OSUTF8CHAR* savedPrefix = nsPrefix;
         nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
            "http://www.fpml.org/2003/FpML-4-0"));

         { OSRTDListNode* pnode = pvalue->u.fxRate_list->head;
         while (0 != pnode) {
            stat = XmlEnc_FxRate_derivations (pctxt, 
               ((FxRate_derivations*)pnode->data)
               , OSUTF8("fxRate"), nsPrefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            pnode = pnode->next;
         }}
         nsPrefix = savedPrefix;
         }

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_derivations_equityLeg_valuation_valu  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_sequence (OSCTXT* pctxt,
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_sequence *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode fxConversion */

   if (pvalue->m.fxConversionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_sequence_fxConversion (pctxt, &pvalue->fxConversion, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode accruedInterestPrice */

   if (pvalue->m.accruedInterestPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_real (pctxt, &pvalue->accruedInterestPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode netPrice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_ActualPrice (pctxt, &pvalue->netPrice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode grossPrice */

   if (pvalue->m.grossPricePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ActualPrice (pctxt, &pvalue->grossPrice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_sequence 
   (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_sequence* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode grossPrice */

   if (pvalue->m.grossPricePresent) {
      stat = XmlEnc_ActualPrice (pctxt, &pvalue->grossPrice
         , OSUTF8("grossPrice"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode netPrice */

   stat = XmlEnc_ActualPrice (pctxt, &pvalue->netPrice
      , OSUTF8("netPrice"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode accruedInterestPrice */

   if (pvalue->m.accruedInterestPricePresent) {
      stat = rtXmlEncDouble (pctxt, pvalue->accruedInterestPrice
         , OSUTF8("accruedInterestPrice"), nsPrefix, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fxConversion */

   if (pvalue->m.fxConversionPresent) {
      stat = XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_sequence_fxConversion (pctxt
         , &pvalue->fxConversion, OSUTF8("fxConversion"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_derivations_equityLeg_valuation_valu  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_choice (OSCTXT* pctxt,
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            xe_utf8str (pctxt, pvalue->u.determinationMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_sequence (pctxt, pvalue->u.sequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_choice 
   (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode determinationMethod */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.determinationMethod
            , OSUTF8("determinationMethod"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode amountRelativeTo */

         stat = XmlEnc_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo
            , OSUTF8("amountRelativeTo"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode sequence */

         stat = XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_sequence (pctxt
            , pvalue->u.sequence, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_derivations_equityLeg_valuation_valu  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_equityValuationDate (OSCTXT* pctxt,
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_equityValuationDate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_AdjustableDate (pctxt, pvalue->u.adjustableDate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_RelativeDateSequence (pctxt, pvalue->u.relativeDateSequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_equityValuationDate 
   (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_equityValuationDate* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode adjustableDate */

         stat = XmlEnc_AdjustableDate (pctxt, pvalue->u.adjustableDate
            , OSUTF8("adjustableDate"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode relativeDateSequence */

         stat = XmlEnc_RelativeDateSequence (pctxt, pvalue->
            u.relativeDateSequence, OSUTF8("relativeDateSequence"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_derivations_equityLeg_valuation_valu  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal (OSCTXT* pctxt,
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode equityValuationDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_equityValuationDate (pctxt, &pvalue->equityValuationDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_BusinessCenterTime (pctxt, &pvalue->valuationTime, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode valuationTimeType */

   if (pvalue->m.valuationTimeTypePresent) {
      if(pvalue->valuationTimeType < 0 || pvalue->valuationTimeType > 4)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         asn1E_TimeTypeEnum (pctxt, &pvalue->valuationTimeType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode commission */

   if (pvalue->m.commissionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Commission (pctxt, &pvalue->commission, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal 
   (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode commission */

   if (pvalue->m.commissionPresent) {
      stat = XmlEnc_Commission (pctxt, &pvalue->commission
         , OSUTF8("commission"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode choice */

   stat = XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_choice (pctxt
      , &pvalue->choice, OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode valuationTimeType */

   if (pvalue->m.valuationTimeTypePresent) {
      if(pvalue->valuationTimeType < 0 || pvalue->valuationTimeType > 4)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_TimeTypeEnum (pctxt, pvalue->valuationTimeType
         , OSUTF8("valuationTimeType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode valuationTime */

   if (pvalue->m.valuationTimePresent) {
      stat = XmlEnc_BusinessCenterTime (pctxt, &pvalue->valuationTime
         , OSUTF8("valuationTime"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode equityValuationDate */

   stat = XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_equityValuationDate (pctxt
      , &pvalue->equityValuationDate
      , OSUTF8("equityValuationDate"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_derivations_equityLeg_valuation       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_derivations_equityLeg_valuation (OSCTXT* pctxt,
   EquitySwapValuation_derivations_equityLeg_valuation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode equityPaymentDates */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_EquityPaymentDates (pctxt, &pvalue->equityPaymentDates, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode valuationPriceFinal */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal (pctxt, &pvalue->valuationPriceFinal, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode valuationPriceInterim */

   if (pvalue->m.valuationPriceInterimPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim (pctxt, &pvalue->valuationPriceInterim, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode equityNotionalReset */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_boolean (pctxt, &pvalue->equityNotionalReset, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode initialPrice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice (pctxt, &pvalue->initialPrice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode initialPrice */

   stat = XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice (pctxt
      , &pvalue->initialPrice, OSUTF8("initialPrice"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode equityNotionalReset */

   stat = rtXmlEncBool (pctxt, pvalue->equityNotionalReset
      , OSUTF8("equityNotionalReset"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode valuationPriceInterim */

   if (pvalue->m.valuationPriceInterimPresent) {
      stat = XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim (pctxt
         , &pvalue->valuationPriceInterim
         , OSUTF8("valuationPriceInterim"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode valuationPriceFinal */

   stat = XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal (pctxt
      , &pvalue->valuationPriceFinal
      , OSUTF8("valuationPriceFinal"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode equityPaymentDates */

   stat = XmlEnc_EquityPaymentDates (pctxt, &pvalue->equityPaymentDates
      , OSUTF8("equityPaymentDates"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EquitySwapValuation_derivations                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EquitySwapValuation_derivations (OSCTXT* pctxt,
   EquitySwapValuation_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_EquitySwapValuation (pctxt, pvalue->u.equitySwapValuation, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_EquitySwapValuation_derivations_equityLeg_valuation (pctxt, pvalue->u.equityLeg_valuation, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_EquitySwapValuation_derivations (OSCTXT* pctxt, 
   EquitySwapValuation_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode equitySwapValuation */

         stat = XmlEnc_EquitySwapValuation (pctxt, pvalue->
            u.equitySwapValuation, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode equityLeg_valuation */

         stat = XmlEnc_EquitySwapValuation_derivations_equityLeg_valuation (pctxt
            , pvalue->u.equityLeg_valuation, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterestAccrualsMethod_derivations_dividendConditions_in  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_InterestAccrualsMethod_derivations_dividendConditions_interestAccrualsMethod_choice (OSCTXT* pctxt,
   InterestAccrualsMethod_derivations_dividendConditions_interestAccrualsMethod_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_FloatingRateCalculation (pctxt, pvalue->u.floatingRateCalculation, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
            xe_real (pctxt, &pvalue->u.fixedRate, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_InterestAccrualsMethod_derivations_dividendConditions_interestAccrualsMethod_choice 
   (OSCTXT* pctxt, 
   InterestAccrualsMethod_derivations_dividendConditions_interestAccrualsMethod_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode floatingRateCalculation */

         stat = XmlEnc_FloatingRateCalculation (pctxt, pvalue->
            u.floatingRateCalculation
            , OSUTF8("floatingRateCalculation"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode fixedRate */

         stat = rtXmlEncDouble (pctxt, pvalue->u.fixedRate
            , OSUTF8("fixedRate"), nsPrefix, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterestAccrualsMethod_derivations_dividendConditions_in  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_InterestAccrualsMethod_derivations_dividendConditions_interestAccrualsMethod (OSCTXT* pctxt,
   InterestAccrualsMethod_derivations_dividendConditions_interestAccrualsMethod *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode compoundingMethod */

   if(pvalue->compoundingMethod < 0 || pvalue->compoundingMethod > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_CompoundingMethodEnum (pctxt, &pvalue->compoundingMethod, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_InterestAccrualsMethod_derivations_dividendConditions_interestAccrualsMethod_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_InterestAccrualsMethod_derivations_dividendConditions_interestAccrualsMethod 
   (OSCTXT* pctxt, 
   InterestAccrualsMethod_derivations_dividendConditions_interestAccrualsMethod* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   /* encode choice */

   stat = XmlEnc_InterestAccrualsMethod_derivations_dividendConditions_interestAccrualsMethod_choice (pctxt
      , &pvalue->choice, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode compoundingMethod */

   if(pvalue->compoundingMethod < 0 || pvalue->compoundingMethod > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_CompoundingMethodEnum (pctxt, pvalue->compoundingMethod
      , OSUTF8("compoundingMethod"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InterestAccrualsMethod_derivations                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_InterestAccrualsMethod_derivations (OSCTXT* pctxt,
   InterestAccrualsMethod_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_InterestAccrualsMethod (pctxt, pvalue->u.interestAccrualsMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_InterestAccrualsMethod_derivations_dividendConditions_interestAccrualsMethod (pctxt, pvalue->u.dividendConditions_interestAccrualsMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_InterestAccrualsMethod_derivations (OSCTXT* pctxt, 
   InterestAccrualsMethod_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode interestAccrualsMethod */

         stat = XmlEnc_InterestAccrualsMethod (pctxt, pvalue->
            u.interestAccrualsMethod, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode dividendConditions_interestAccrualsMethod */

         stat = XmlEnc_InterestAccrualsMethod_derivations_dividendConditions_interestAccrualsMethod (pctxt
            , pvalue->u.dividendConditions_interestAccrualsMethod
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SettlementTerms_derivations                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SettlementTerms_derivations (OSCTXT* pctxt,
   SettlementTerms_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_SettlementTerms_1 (pctxt, pvalue->u.settlementTerms, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_CashSettlementTerms (pctxt, pvalue->u.cashSettlementTerms, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_PhysicalSettlementTerms (pctxt, pvalue->u.physicalSettlementTerms, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_SettlementTerms_derivations (OSCTXT* pctxt, 
   SettlementTerms_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.fpml.org/2003/FpML-4-0"));

   switch (pvalue->t)
   {
      case 1:
         /* encode settlementTerms */

         stat = XmlEnc_SettlementTerms_1 (pctxt, pvalue->u.settlementTerms
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode cashSettlementTerms */

         stat = XmlEnc_CashSettlementTerms (pctxt, pvalue->
            u.cashSettlementTerms, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode physicalSettlementTerms */

         stat = XmlEnc_PhysicalSettlementTerms (pctxt, pvalue->
            u.physicalSettlementTerms, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

int XmlEnc_FpML_PDU (OSCTXT* pctxt, FpML* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   rtXmlNSSetNamespace (pctxt, OSUTF8("dsig"), 
      OSUTF8("http://www.w3.org/2000/09/xmldsig#"), FALSE);

   rtXmlNSSetNamespace (pctxt, 0, OSUTF8("http://www.fpml.org/2003/FpML-4-0"), 
      FALSE);

   nsPrefix = rtXmlNSGetPrefix (pctxt, 
      OSUTF8("http://www.fpml.org/2003/FpML-4-0"));

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("FpML"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_FpML (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("FpML"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_Exercise_PDU (OSCTXT* pctxt, Exercise* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   rtXmlNSSetNamespace (pctxt, OSUTF8("dsig"), 
      OSUTF8("http://www.w3.org/2000/09/xmldsig#"), FALSE);

   rtXmlNSSetNamespace (pctxt, 0, OSUTF8("http://www.fpml.org/2003/FpML-4-0"), 
      FALSE);

   nsPrefix = rtXmlNSGetPrefix (pctxt, 
      OSUTF8("http://www.fpml.org/2003/FpML-4-0"));

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("exercise"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_Exercise (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("exercise"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_Product_PDU (OSCTXT* pctxt, Product* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   rtXmlNSSetNamespace (pctxt, OSUTF8("dsig"), 
      OSUTF8("http://www.w3.org/2000/09/xmldsig#"), FALSE);

   rtXmlNSSetNamespace (pctxt, 0, OSUTF8("http://www.fpml.org/2003/FpML-4-0"), 
      FALSE);

   nsPrefix = rtXmlNSGetPrefix (pctxt, 
      OSUTF8("http://www.fpml.org/2003/FpML-4-0"));

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("product"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_Product (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("product"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_UnderlyingAsset_PDU (OSCTXT* pctxt, UnderlyingAsset* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   rtXmlNSSetNamespace (pctxt, OSUTF8("dsig"), 
      OSUTF8("http://www.w3.org/2000/09/xmldsig#"), FALSE);

   rtXmlNSSetNamespace (pctxt, 0, OSUTF8("http://www.fpml.org/2003/FpML-4-0"), 
      FALSE);

   nsPrefix = rtXmlNSGetPrefix (pctxt, 
      OSUTF8("http://www.fpml.org/2003/FpML-4-0"));

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("underlyingAsset"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_UnderlyingAsset (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("underlyingAsset"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_LinkId_PDU (OSCTXT* pctxt, LinkId value)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   rtXmlNSSetNamespace (pctxt, OSUTF8("dsig"), 
      OSUTF8("http://www.w3.org/2000/09/xmldsig#"), FALSE);

   rtXmlNSSetNamespace (pctxt, 0, OSUTF8("http://www.fpml.org/2003/FpML-4-0"), 
      FALSE);

   nsPrefix = rtXmlNSGetPrefix (pctxt, 
      OSUTF8("http://www.fpml.org/2003/FpML-4-0"));

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("linkId"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_LinkId (pctxt, value, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("linkId"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_ValidationRuleId_PDU (OSCTXT* pctxt, ValidationRuleId value)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   rtXmlNSSetNamespace (pctxt, OSUTF8("dsig"), 
      OSUTF8("http://www.w3.org/2000/09/xmldsig#"), FALSE);

   rtXmlNSSetNamespace (pctxt, 0, OSUTF8("http://www.fpml.org/2003/FpML-4-0"), 
      FALSE);

   nsPrefix = rtXmlNSGetPrefix (pctxt, 
      OSUTF8("http://www.fpml.org/2003/FpML-4-0"));

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("validationRuleId"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_ValidationRuleId (pctxt, value, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("validationRuleId"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_TradeReference_PDU (OSCTXT* pctxt, TradeReference* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   rtXmlNSSetNamespace (pctxt, OSUTF8("dsig"), 
      OSUTF8("http://www.w3.org/2000/09/xmldsig#"), FALSE);

   rtXmlNSSetNamespace (pctxt, 0, OSUTF8("http://www.fpml.org/2003/FpML-4-0"), 
      FALSE);

   nsPrefix = rtXmlNSGetPrefix (pctxt, 
      OSUTF8("http://www.fpml.org/2003/FpML-4-0"));

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("tradeReference"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_TradeReference (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("tradeReference"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_Document_PDU (OSCTXT* pctxt, Document* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   rtXmlNSSetNamespace (pctxt, OSUTF8("dsig"), 
      OSUTF8("http://www.w3.org/2000/09/xmldsig#"), FALSE);

   rtXmlNSSetNamespace (pctxt, 0, OSUTF8("http://www.fpml.org/2003/FpML-4-0"), 
      FALSE);

   nsPrefix = rtXmlNSGetPrefix (pctxt, 
      OSUTF8("http://www.fpml.org/2003/FpML-4-0"));

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("document"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_Document (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("document"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_Equity_1_PDU (OSCTXT* pctxt, Equity_1* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   rtXmlNSSetNamespace (pctxt, OSUTF8("dsig"), 
      OSUTF8("http://www.w3.org/2000/09/xmldsig#"), FALSE);

   rtXmlNSSetNamespace (pctxt, 0, OSUTF8("http://www.fpml.org/2003/FpML-4-0"), 
      FALSE);

   nsPrefix = rtXmlNSGetPrefix (pctxt, 
      OSUTF8("http://www.fpml.org/2003/FpML-4-0"));

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("equity-1"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_Equity_1 (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("equity-1"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_Message_PDU (OSCTXT* pctxt, Message* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   rtXmlNSSetNamespace (pctxt, OSUTF8("dsig"), 
      OSUTF8("http://www.w3.org/2000/09/xmldsig#"), FALSE);

   rtXmlNSSetNamespace (pctxt, 0, OSUTF8("http://www.fpml.org/2003/FpML-4-0"), 
      FALSE);

   nsPrefix = rtXmlNSGetPrefix (pctxt, 
      OSUTF8("http://www.fpml.org/2003/FpML-4-0"));

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("message"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_Message (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("message"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_RequestMessage_PDU (OSCTXT* pctxt, RequestMessage* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   rtXmlNSSetNamespace (pctxt, OSUTF8("dsig"), 
      OSUTF8("http://www.w3.org/2000/09/xmldsig#"), FALSE);

   rtXmlNSSetNamespace (pctxt, 0, OSUTF8("http://www.fpml.org/2003/FpML-4-0"), 
      FALSE);

   nsPrefix = rtXmlNSGetPrefix (pctxt, 
      OSUTF8("http://www.fpml.org/2003/FpML-4-0"));

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("requestMessage"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_RequestMessage (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("requestMessage"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
