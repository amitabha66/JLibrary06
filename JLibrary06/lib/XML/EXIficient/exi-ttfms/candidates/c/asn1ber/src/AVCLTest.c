/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "AVCL.h"
#include "libxml/parser.h"
#include "rtxmlsrc/osrtxml.h"
#include "rtxsrc/rtxCommon.h"

int DOMTest_MetaDataType (OSCTXT* pctxt, MetaDataType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("content"))) {
            pvalue->m.contentPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->content = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->content = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("name"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->name = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->name = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_PriorityElementType (OSCTXT* pctxt, PriorityElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("value"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->value = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_NonNegativeIntegerElementType (OSCTXT* pctxt, 
   NonNegativeIntegerElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("value"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->value = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_AcknowledgeElementType (OSCTXT* pctxt, 
   AcknowledgeElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("value"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               AcknowledgeType_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->value);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_AvclMessageHeadType (OSCTXT* pctxt, AvclMessageHeadType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("meta"))) {
            { MetaDataType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, MetaDataType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MetaDataType (pdata2);
            DOMTest_MetaDataType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->meta_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Priority"))) {
            pvalue->m.priorityPresent = 1;
            DOMTest_PriorityElementType (pctxt, &pvalue->priority, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Sender"))) {
            DOMTest_NonNegativeIntegerElementType (pctxt, &pvalue->sender, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Recipient"))) {
            { NonNegativeIntegerElementType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, NonNegativeIntegerElementType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NonNegativeIntegerElementType (pdata2);
            DOMTest_NonNegativeIntegerElementType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->recipient_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Acknowledge"))) {
            pvalue->m.acknowledgePresent = 1;
            DOMTest_AcknowledgeElementType (pctxt, &pvalue->acknowledge, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_LatitudeLongitudeElementType (OSCTXT* pctxt, 
   LatitudeLongitudeElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("latitude"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->latitude);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("longitude"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->longitude);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_GeoOriginElementType (OSCTXT* pctxt, GeoOriginElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("latitude"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->latitude);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("longitude"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->longitude);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("radiusOfInterest"))) {
            pvalue->m.radiusOfInterestPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->radiusOfInterest);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_LatitudeLongitudeElementType_derivations (OSCTXT* pctxt, 
   LatitudeLongitudeElementType_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("LatitudeLongitudeElementType");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("LatitudeLongitudeElementType")))
   {
      pvalue->t = 1;
      pvalue->u.latitudeLongitudeElementType
          = rtxMemAllocType (pctxt, LatitudeLongitudeElementType);

      if (pvalue->u.latitudeLongitudeElementType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_LatitudeLongitudeElementType (pvalue->u.latitudeLongitudeElementType);
      DOMTest_LatitudeLongitudeElementType (pctxt, pvalue->u.latitudeLongitudeElementType, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("GeoOriginElementType")))
   {
      pvalue->t = 2;
      pvalue->u.geoOriginElementType
          = rtxMemAllocType (pctxt, GeoOriginElementType);

      if (pvalue->u.geoOriginElementType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_GeoOriginElementType (pvalue->u.geoOriginElementType);
      DOMTest_GeoOriginElementType (pctxt, pvalue->u.geoOriginElementType, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_XyElementType (OSCTXT* pctxt, XyElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("x"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->x);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("y"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->y);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_PointListElements (OSCTXT* pctxt, PointListElements* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LatitudeLongitude"))) {
            pvalue->t = 1;
            pvalue->u.latitudeLongitude_list
                = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.latitudeLongitude_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.latitudeLongitude_list);
            {
            LatitudeLongitudeElementType_derivations* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LatitudeLongitude"))) {
                     pdata2
                         = rtxMemAllocType (pctxt, LatitudeLongitudeElementType_derivations);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_LatitudeLongitudeElementType_derivations (pdata2);
                     DOMTest_LatitudeLongitudeElementType_derivations (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.latitudeLongitude_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("XYPosition"))) {
            pvalue->t = 2;
            pvalue->u.xYPosition_list = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.xYPosition_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.xYPosition_list);
            {
            XyElementType* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("XYPosition"))) {
                     pdata2 = rtxMemAllocType (pctxt, XyElementType);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_XyElementType (pdata2);
                     DOMTest_XyElementType (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.xYPosition_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_WaypointListType (OSCTXT* pctxt, WaypointListType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LatitudeLongitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("XYPosition"))) {
            DOMTest_PointListElements (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_HorizontalPositionElements (OSCTXT* pctxt, 
   HorizontalPositionElements* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LatitudeLongitude"))) {
            pvalue->t = 1;
            pvalue->u.latitudeLongitude
                = rtxMemAllocType (pctxt, LatitudeLongitudeElementType_derivations);

            if (pvalue->u.latitudeLongitude == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_LatitudeLongitudeElementType_derivations (pvalue->u.latitudeLongitude);
            DOMTest_LatitudeLongitudeElementType_derivations (pctxt, pvalue->u.latitudeLongitude, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("XYPosition"))) {
            pvalue->t = 2;
            pvalue->u.xYPosition = rtxMemAllocType (pctxt, XyElementType);

            if (pvalue->u.xYPosition == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_XyElementType (pvalue->u.xYPosition);
            DOMTest_XyElementType (pctxt, pvalue->u.xYPosition, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RelativeXYPosition"))) {
            pvalue->t = 3;
            pvalue->u.relativeXYPosition
                = rtxMemAllocType (pctxt, XyElementType);

            if (pvalue->u.relativeXYPosition == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_XyElementType (pvalue->u.relativeXYPosition);
            DOMTest_XyElementType (pctxt, pvalue->u.relativeXYPosition, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_HorizontalPositionElementType (OSCTXT* pctxt, 
   HorizontalPositionElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LatitudeLongitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("XYPosition")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RelativeXYPosition"))) {
            DOMTest_HorizontalPositionElements (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_ParallelTrackType (OSCTXT* pctxt, ParallelTrackType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("firstTurn"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               TurnDirectionType_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->firstTurn);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("orientation"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->orientation);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("trackCount"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->trackCount = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("trackLength"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->trackLength);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("trackSpacing"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->trackSpacing);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("StartPoint"))) {
            DOMTest_HorizontalPositionElementType (pctxt, &pvalue->startPoint, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_SectorPatternType (OSCTXT* pctxt, SectorPatternType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("firstTurn"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               TurnDirectionType_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->firstTurn);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("orientation"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->orientation);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("radius"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->radius);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("sectorCount"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->sectorCount = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("sectorSize"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->sectorSize);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("StartPoint"))) {
            DOMTest_HorizontalPositionElementType (pctxt, &pvalue->startPoint, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_ExpandingSquareType (OSCTXT* pctxt, ExpandingSquareType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("orientation"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->orientation);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("trackCount"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->trackCount = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("trackSpacing"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->trackSpacing);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("turnDirection"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               TurnDirectionType_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->turnDirection);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("StartPoint"))) {
            DOMTest_HorizontalPositionElementType (pctxt, &pvalue->startPoint, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_CompositeWaypointElements (OSCTXT* pctxt, 
   CompositeWaypointElements* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("WaypointList"))) {
            pvalue->t = 1;
            pvalue->u.waypointList
                = rtxMemAllocType (pctxt, WaypointListType);

            if (pvalue->u.waypointList == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_WaypointListType (pvalue->u.waypointList);
            DOMTest_WaypointListType (pctxt, pvalue->u.waypointList, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ParallelTrack"))) {
            pvalue->t = 2;
            pvalue->u.parallelTrack
                = rtxMemAllocType (pctxt, ParallelTrackType);

            if (pvalue->u.parallelTrack == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ParallelTrackType (pvalue->u.parallelTrack);
            DOMTest_ParallelTrackType (pctxt, pvalue->u.parallelTrack, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SectorPattern"))) {
            pvalue->t = 3;
            pvalue->u.sectorPattern
                = rtxMemAllocType (pctxt, SectorPatternType);

            if (pvalue->u.sectorPattern == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SectorPatternType (pvalue->u.sectorPattern);
            DOMTest_SectorPatternType (pctxt, pvalue->u.sectorPattern, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ExpandingSquare"))) {
            pvalue->t = 4;
            pvalue->u.expandingSquare
                = rtxMemAllocType (pctxt, ExpandingSquareType);

            if (pvalue->u.expandingSquare == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ExpandingSquareType (pvalue->u.expandingSquare);
            DOMTest_ExpandingSquareType (pctxt, pvalue->u.expandingSquare, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_PositiveScalarElementType (OSCTXT* pctxt, 
   PositiveScalarElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("value"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->value);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_SpeedElementType (OSCTXT* pctxt, SpeedElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("speedOverGround"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->speedOverGround);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("value"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->value);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_PositiveScalarElementType_derivations (OSCTXT* pctxt, 
   PositiveScalarElementType_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("PositiveScalarElementType");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("PositiveScalarElementType")))
   {
      pvalue->t = 1;
      pvalue->u.positiveScalarElementType
          = rtxMemAllocType (pctxt, PositiveScalarElementType);

      if (pvalue->u.positiveScalarElementType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType (pvalue->u.positiveScalarElementType);
      DOMTest_PositiveScalarElementType (pctxt, pvalue->u.positiveScalarElementType, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("SpeedElementType")))
   {
      pvalue->t = 2;
      pvalue->u.speedElementType = rtxMemAllocType (pctxt, SpeedElementType);

      if (pvalue->u.speedElementType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SpeedElementType (pvalue->u.speedElementType);
      DOMTest_SpeedElementType (pctxt, pvalue->u.speedElementType, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_DepthTypeElements (OSCTXT* pctxt, DepthTypeElements* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Depth"))) {
            pvalue->t = 1;
            pvalue->u.depth
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.depth == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.depth);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.depth, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Altitude"))) {
            pvalue->t = 2;
            pvalue->u.altitude
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.altitude == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.altitude);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.altitude, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_TrackModeElementType (OSCTXT* pctxt, TrackModeElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("value"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               TrackModeType_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->value);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_SignedPercentElementType (OSCTXT* pctxt, 
   SignedPercentElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("value"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->value);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_SetPropellerCommandType_choice (OSCTXT* pctxt, 
   SetPropellerCommandType_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PortPropeller"))) {
            pvalue->t = 1;
            pvalue->u.portPropeller
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.portPropeller == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.portPropeller);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.portPropeller, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("StarboardPropeller"))) {
            pvalue->t = 2;
            pvalue->u.starboardPropeller
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.starboardPropeller == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.starboardPropeller);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.starboardPropeller, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("CenterlinePropeller"))) {
            pvalue->t = 3;
            pvalue->u.centerlinePropeller
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.centerlinePropeller == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.centerlinePropeller);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.centerlinePropeller, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AllPropellers"))) {
            pvalue->t = 4;
            pvalue->u.allPropellers
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.allPropellers == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.allPropellers);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.allPropellers, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_SetPropellerCommandType (OSCTXT* pctxt, 
   SetPropellerCommandType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PortPropeller")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("StarboardPropeller")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("CenterlinePropeller")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AllPropellers"))) {
            DOMTest_SetPropellerCommandType_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_UuvSpeedElements (OSCTXT* pctxt, UuvSpeedElements* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPower"))) {
            pvalue->t = 1;
            pvalue->u.setPower
                = rtxMemAllocType (pctxt, SetPropellerCommandType);

            if (pvalue->u.setPower == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SetPropellerCommandType (pvalue->u.setPower);
            DOMTest_SetPropellerCommandType (pctxt, pvalue->u.setPower, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeKnots"))) {
            pvalue->t = 2;
            pvalue->u.makeKnots = rtxMemAllocType (pctxt, SpeedElementType);

            if (pvalue->u.makeKnots == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SpeedElementType (pvalue->u.makeKnots);
            DOMTest_SpeedElementType (pctxt, pvalue->u.makeKnots, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeSpeed"))) {
            pvalue->t = 3;
            pvalue->u.makeSpeed = rtxMemAllocType (pctxt, SpeedElementType);

            if (pvalue->u.makeSpeed == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SpeedElementType (pvalue->u.makeSpeed);
            DOMTest_SpeedElementType (pctxt, pvalue->u.makeSpeed, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_PositiveIntegerElementType (OSCTXT* pctxt, 
   PositiveIntegerElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("value"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->value = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_UuvCompositeWaypointCommandType (OSCTXT* pctxt, 
   UuvCompositeWaypointCommandType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("WaypointList")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ParallelTrack")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SectorPattern")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ExpandingSquare"))) {
            DOMTest_CompositeWaypointElements (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Depth")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Altitude"))) {
            DOMTest_DepthTypeElements (pctxt, &pvalue->choice_1, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("HomingMode"))) {
            pvalue->m.homingModePresent = 1;
            DOMTest_TrackModeElementType (pctxt, &pvalue->homingMode, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPower")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeKnots")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeSpeed"))) {
            pvalue->m.choice_2Present = 1;
            DOMTest_UuvSpeedElements (pctxt, &pvalue->choice_2, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("GpsFixes"))) {
            pvalue->m.gpsFixesPresent = 1;
            DOMTest_PositiveIntegerElementType (pctxt, &pvalue->gpsFixes, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Standoff"))) {
            pvalue->m.standoffPresent = 1;
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->standoff, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TimeOut"))) {
            pvalue->m.timeOutPresent = 1;
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->timeOut, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_StringElementType (OSCTXT* pctxt, StringElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("value"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->value = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->value = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_FollowBeaconCommandType (OSCTXT* pctxt, 
   FollowBeaconCommandType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Beacon"))) {
            pvalue->m.beaconPresent = 1;
            DOMTest_StringElementType (pctxt, &pvalue->beacon, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TimeOut"))) {
            pvalue->m.timeOutPresent = 1;
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->timeOut, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_GpsFixCommandType (OSCTXT* pctxt, GpsFixCommandType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeOut"))) {
            pvalue->m.timeOutPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeOut);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("value"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->value);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_NoValueElementType (OSCTXT* pctxt, NoValueElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_HeadingElementType (OSCTXT* pctxt, HeadingElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("value"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->value);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_BooleanElementType (OSCTXT* pctxt, BooleanElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("value"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->value);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_BooleanElementType_derivations (OSCTXT* pctxt, 
   BooleanElementType_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("BooleanElementType");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("BooleanElementType")))
   {
      pvalue->t = 1;
      pvalue->u.booleanElementType
          = rtxMemAllocType (pctxt, BooleanElementType);

      if (pvalue->u.booleanElementType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BooleanElementType (pvalue->u.booleanElementType);
      DOMTest_BooleanElementType (pctxt, pvalue->u.booleanElementType, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("GpsFixCommandType")))
   {
      pvalue->t = 2;
      pvalue->u.gpsFixCommandType
          = rtxMemAllocType (pctxt, GpsFixCommandType);

      if (pvalue->u.gpsFixCommandType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_GpsFixCommandType (pvalue->u.gpsFixCommandType);
      DOMTest_GpsFixCommandType (pctxt, pvalue->u.gpsFixCommandType, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_HoverCommandType (OSCTXT* pctxt, HoverCommandType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LatitudeLongitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("XYPosition")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RelativeXYPosition"))) {
            pvalue->m.choicePresent = 1;
            DOMTest_HorizontalPositionElements (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Depth")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Altitude"))) {
            pvalue->m.choice_1Present = 1;
            DOMTest_DepthTypeElements (pctxt, &pvalue->choice_1, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Heading"))) {
            pvalue->m.headingPresent = 1;
            DOMTest_HeadingElementType (pctxt, &pvalue->heading, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ObtainGps"))) {
            pvalue->m.obtainGpsPresent = 1;
            DOMTest_BooleanElementType_derivations (pctxt, &pvalue->obtainGps, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Standoff"))) {
            pvalue->m.standoffPresent = 1;
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->standoff, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TimeOut"))) {
            pvalue->m.timeOutPresent = 1;
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->timeOut, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_UuvLoiterCommandType (OSCTXT* pctxt, UuvLoiterCommandType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LatitudeLongitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("XYPosition")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RelativeXYPosition"))) {
            pvalue->m.choicePresent = 1;
            DOMTest_HorizontalPositionElements (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Depth")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Altitude"))) {
            pvalue->m.choice_1Present = 1;
            DOMTest_DepthTypeElements (pctxt, &pvalue->choice_1, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPower")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeKnots")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeSpeed"))) {
            pvalue->m.choice_2Present = 1;
            DOMTest_UuvSpeedElements (pctxt, &pvalue->choice_2, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LoiterDepth"))) {
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->loiterDepth, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TimeOut"))) {
            pvalue->m.timeOutPresent = 1;
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->timeOut, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_ExitModeElements (OSCTXT* pctxt, ExitModeElements* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("NormalExit"))) {
            pvalue->t = 1;
            pvalue->u.normalExit
                = rtxMemAllocType (pctxt, NoValueElementType);

            if (pvalue->u.normalExit == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NoValueElementType (pvalue->u.normalExit);
            DOMTest_NoValueElementType (pctxt, pvalue->u.normalExit, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionAbort"))) {
            pvalue->t = 2;
            pvalue->u.missionAbort
                = rtxMemAllocType (pctxt, NoValueElementType);

            if (pvalue->u.missionAbort == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NoValueElementType (pvalue->u.missionAbort);
            DOMTest_NoValueElementType (pctxt, pvalue->u.missionAbort, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SystemAbort"))) {
            pvalue->t = 3;
            pvalue->u.systemAbort
                = rtxMemAllocType (pctxt, NoValueElementType);

            if (pvalue->u.systemAbort == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NoValueElementType (pvalue->u.systemAbort);
            DOMTest_NoValueElementType (pctxt, pvalue->u.systemAbort, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RecallAbort"))) {
            pvalue->t = 4;
            pvalue->u.recallAbort
                = rtxMemAllocType (pctxt, NoValueElementType);

            if (pvalue->u.recallAbort == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NoValueElementType (pvalue->u.recallAbort);
            DOMTest_NoValueElementType (pctxt, pvalue->u.recallAbort, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_QuitCommandType (OSCTXT* pctxt, QuitCommandType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("NormalExit")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionAbort")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SystemAbort")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RecallAbort"))) {
            pvalue->m.choicePresent = 1;
            DOMTest_ExitModeElements (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_ScalarElementType (OSCTXT* pctxt, ScalarElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("value"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->value);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_RecoverCommandType (OSCTXT* pctxt, RecoverCommandType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Range"))) {
            DOMTest_ScalarElementType (pctxt, &pvalue->range, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Heading"))) {
            DOMTest_HeadingElementType (pctxt, &pvalue->heading, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TimeOut"))) {
            pvalue->m.timeOutPresent = 1;
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->timeOut, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_SendMessageCommandType_choice (OSCTXT* pctxt, 
   SendMessageCommandType_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AVCLMessage"))) {
            pvalue->t = 1;
            pvalue->u.aVCLMessage = rtxMemAllocType (pctxt, AvclMessageType);

            if (pvalue->u.aVCLMessage == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AvclMessageType ((AvclMessageType*)pvalue->u.aVCLMessage);
            DOMTest_AvclMessageType (pctxt, (AvclMessageType*)pvalue->u.aVCLMessage, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_SendMessageCommandType (OSCTXT* pctxt, 
   SendMessageCommandType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AVCLMessage"))) {
            DOMTest_SendMessageCommandType_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_SetPlanesCommandType_choice (OSCTXT* pctxt, 
   SetPlanesCommandType_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("BowPlanes"))) {
            pvalue->t = 1;
            pvalue->u.bowPlanes
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.bowPlanes == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.bowPlanes);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.bowPlanes, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SternPlanes"))) {
            pvalue->t = 2;
            pvalue->u.sternPlanes
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.sternPlanes == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.sternPlanes);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.sternPlanes, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AllPlanes"))) {
            pvalue->t = 3;
            pvalue->u.allPlanes
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.allPlanes == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.allPlanes);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.allPlanes, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_SetPlanesCommandType (OSCTXT* pctxt, SetPlanesCommandType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("BowPlanes")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SternPlanes")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AllPlanes"))) {
            DOMTest_SetPlanesCommandType_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_AbsoluteHorizontalPositionElements (OSCTXT* pctxt, 
   AbsoluteHorizontalPositionElements* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LatitudeLongitude"))) {
            pvalue->t = 1;
            pvalue->u.latitudeLongitude
                = rtxMemAllocType (pctxt, LatitudeLongitudeElementType_derivations);

            if (pvalue->u.latitudeLongitude == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_LatitudeLongitudeElementType_derivations (pvalue->u.latitudeLongitude);
            DOMTest_LatitudeLongitudeElementType_derivations (pctxt, pvalue->u.latitudeLongitude, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("XYPosition"))) {
            pvalue->t = 2;
            pvalue->u.xYPosition = rtxMemAllocType (pctxt, XyElementType);

            if (pvalue->u.xYPosition == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_XyElementType (pvalue->u.xYPosition);
            DOMTest_XyElementType (pctxt, pvalue->u.xYPosition, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_UuvPositionCommandType (OSCTXT* pctxt, 
   UuvPositionCommandType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LatitudeLongitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("XYPosition"))) {
            DOMTest_AbsoluteHorizontalPositionElements (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Depth"))) {
            pvalue->m.depthPresent = 1;
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->depth, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_SetSonarCommandType_choice (OSCTXT* pctxt, 
   SetSonarCommandType_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Manual"))) {
            pvalue->t = 1;
            pvalue->u.manual = rtxMemAllocType (pctxt, NoValueElementType);

            if (pvalue->u.manual == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NoValueElementType (pvalue->u.manual);
            DOMTest_NoValueElementType (pctxt, pvalue->u.manual, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Scan"))) {
            pvalue->t = 2;
            pvalue->u.scan = rtxMemAllocType (pctxt, NoValueElementType);

            if (pvalue->u.scan == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NoValueElementType (pvalue->u.scan);
            DOMTest_NoValueElementType (pctxt, pvalue->u.scan, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Track"))) {
            pvalue->t = 3;
            pvalue->u.track = rtxMemAllocType (pctxt, NoValueElementType);

            if (pvalue->u.track == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NoValueElementType (pvalue->u.track);
            DOMTest_NoValueElementType (pctxt, pvalue->u.track, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_BearingTypeElements (OSCTXT* pctxt, BearingTypeElements* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Relative"))) {
            pvalue->t = 1;
            pvalue->u.relative = rtxMemAllocType (pctxt, NoValueElementType);

            if (pvalue->u.relative == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NoValueElementType (pvalue->u.relative);
            DOMTest_NoValueElementType (pctxt, pvalue->u.relative, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("True"))) {
            pvalue->t = 2;
            pvalue->u.true_ = rtxMemAllocType (pctxt, NoValueElementType);

            if (pvalue->u.true_ == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NoValueElementType (pvalue->u.true_);
            DOMTest_NoValueElementType (pctxt, pvalue->u.true_, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Magnetic"))) {
            pvalue->t = 3;
            pvalue->u.magnetic = rtxMemAllocType (pctxt, NoValueElementType);

            if (pvalue->u.magnetic == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NoValueElementType (pvalue->u.magnetic);
            DOMTest_NoValueElementType (pctxt, pvalue->u.magnetic, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_SetSonarCommandType (OSCTXT* pctxt, SetSonarCommandType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Model"))) {
            DOMTest_StringElementType (pctxt, &pvalue->model, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Manual")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Scan")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Track"))) {
            DOMTest_SetSonarCommandType_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Bearing"))) {
            pvalue->m.bearingPresent = 1;
            DOMTest_ScalarElementType (pctxt, &pvalue->bearing, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Elevation"))) {
            pvalue->m.elevationPresent = 1;
            DOMTest_ScalarElementType (pctxt, &pvalue->elevation, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Relative")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("True")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Magnetic"))) {
            pvalue->m.choice_1Present = 1;
            DOMTest_BearingTypeElements (pctxt, &pvalue->choice_1, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_SetThrusterCommandType_choice (OSCTXT* pctxt, 
   SetThrusterCommandType_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("BowLateralThruster"))) {
            pvalue->t = 1;
            pvalue->u.bowLateralThruster
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.bowLateralThruster == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.bowLateralThruster);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.bowLateralThruster, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SternLateralThruster"))) {
            pvalue->t = 2;
            pvalue->u.sternLateralThruster
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.sternLateralThruster == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.sternLateralThruster);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.sternLateralThruster, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LateralThrusters"))) {
            pvalue->t = 3;
            pvalue->u.lateralThrusters
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.lateralThrusters == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.lateralThrusters);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.lateralThrusters, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("BowVerticalThruster"))) {
            pvalue->t = 4;
            pvalue->u.bowVerticalThruster
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.bowVerticalThruster == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.bowVerticalThruster);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.bowVerticalThruster, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SternVerticalThruster"))) {
            pvalue->t = 5;
            pvalue->u.sternVerticalThruster
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.sternVerticalThruster == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.sternVerticalThruster);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.sternVerticalThruster, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("VerticalThrusters"))) {
            pvalue->t = 6;
            pvalue->u.verticalThrusters
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.verticalThrusters == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.verticalThrusters);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.verticalThrusters, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_SetThrusterCommandType (OSCTXT* pctxt, 
   SetThrusterCommandType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("BowLateralThruster")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SternLateralThruster")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LateralThrusters")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("BowVerticalThruster")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SternVerticalThruster")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("VerticalThrusters"))) {
            DOMTest_SetThrusterCommandType_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_TakeStationCommandType_choice (OSCTXT* pctxt, 
   TakeStationCommandType_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TargetSonarScan"))) {
            pvalue->t = 1;
            pvalue->u.targetSonarScan
                = rtxMemAllocType (pctxt, NoValueElementType);

            if (pvalue->u.targetSonarScan == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NoValueElementType (pvalue->u.targetSonarScan);
            DOMTest_NoValueElementType (pctxt, pvalue->u.targetSonarScan, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TargetEdgeSonarScan"))) {
            pvalue->t = 2;
            pvalue->u.targetEdgeSonarScan
                = rtxMemAllocType (pctxt, NoValueElementType);

            if (pvalue->u.targetEdgeSonarScan == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NoValueElementType (pvalue->u.targetEdgeSonarScan);
            DOMTest_NoValueElementType (pctxt, pvalue->u.targetEdgeSonarScan, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_TargetElementType (OSCTXT* pctxt, TargetElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("bearing"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->bearing);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("elevation"))) {
            pvalue->m.elevationPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->elevation);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("range"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->range);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_TakeStationCommandType (OSCTXT* pctxt, 
   TakeStationCommandType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TargetSonarScan")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TargetEdgeSonarScan"))) {
            DOMTest_TakeStationCommandType_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TargetLocation"))) {
            pvalue->m.targetLocationPresent = 1;
            DOMTest_TargetElementType (pctxt, &pvalue->targetLocation, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("CommandedStation"))) {
            DOMTest_TargetElementType (pctxt, &pvalue->commandedStation, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Heading"))) {
            pvalue->m.headingPresent = 1;
            DOMTest_HeadingElementType (pctxt, &pvalue->heading, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TimeOut"))) {
            pvalue->m.timeOutPresent = 1;
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->timeOut, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_UuvWaypointCommandType (OSCTXT* pctxt, 
   UuvWaypointCommandType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LatitudeLongitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("XYPosition")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RelativeXYPosition"))) {
            DOMTest_HorizontalPositionElements (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Depth")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Altitude"))) {
            pvalue->m.choice_1Present = 1;
            DOMTest_DepthTypeElements (pctxt, &pvalue->choice_1, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("HomingMode"))) {
            pvalue->m.homingModePresent = 1;
            DOMTest_TrackModeElementType (pctxt, &pvalue->homingMode, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPower")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeKnots")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeSpeed"))) {
            pvalue->m.choice_2Present = 1;
            DOMTest_UuvSpeedElements (pctxt, &pvalue->choice_2, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ObtainGps"))) {
            pvalue->m.obtainGpsPresent = 1;
            DOMTest_BooleanElementType_derivations (pctxt, &pvalue->obtainGps, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Standoff"))) {
            pvalue->m.standoffPresent = 1;
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->standoff, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TimeOut"))) {
            pvalue->m.timeOutPresent = 1;
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->timeOut, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_UuvScriptCommandsType_element (OSCTXT* pctxt, 
   UuvScriptCommandsType_element* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("CompositeWaypoint"))) {
            pvalue->t = 1;
            pvalue->u.compositeWaypoint
                = rtxMemAllocType (pctxt, UuvCompositeWaypointCommandType);

            if (pvalue->u.compositeWaypoint == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UuvCompositeWaypointCommandType (pvalue->u.compositeWaypoint);
            DOMTest_UuvCompositeWaypointCommandType (pctxt, pvalue->u.compositeWaypoint, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("FollowBeacon"))) {
            pvalue->t = 2;
            pvalue->u.followBeacon
                = rtxMemAllocType (pctxt, FollowBeaconCommandType);

            if (pvalue->u.followBeacon == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FollowBeaconCommandType (pvalue->u.followBeacon);
            DOMTest_FollowBeaconCommandType (pctxt, pvalue->u.followBeacon, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("GpsFix"))) {
            pvalue->t = 3;
            pvalue->u.gpsFix = rtxMemAllocType (pctxt, GpsFixCommandType);

            if (pvalue->u.gpsFix == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_GpsFixCommandType (pvalue->u.gpsFix);
            DOMTest_GpsFixCommandType (pctxt, pvalue->u.gpsFix, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Help"))) {
            pvalue->t = 4;
            pvalue->u.help = rtxMemAllocType (pctxt, NoValueElementType);

            if (pvalue->u.help == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NoValueElementType (pvalue->u.help);
            DOMTest_NoValueElementType (pctxt, pvalue->u.help, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Hover"))) {
            pvalue->t = 5;
            pvalue->u.hover = rtxMemAllocType (pctxt, HoverCommandType);

            if (pvalue->u.hover == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_HoverCommandType (pvalue->u.hover);
            DOMTest_HoverCommandType (pctxt, pvalue->u.hover, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Loiter"))) {
            pvalue->t = 6;
            pvalue->u.loiter = rtxMemAllocType (pctxt, UuvLoiterCommandType);

            if (pvalue->u.loiter == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UuvLoiterCommandType (pvalue->u.loiter);
            DOMTest_UuvLoiterCommandType (pctxt, pvalue->u.loiter, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeAltitude"))) {
            pvalue->t = 7;
            pvalue->u.makeAltitude
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.makeAltitude == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeAltitude);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.makeAltitude, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeDepth"))) {
            pvalue->t = 8;
            pvalue->u.makeDepth
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.makeDepth == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeDepth);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.makeDepth, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeHeading"))) {
            pvalue->t = 9;
            pvalue->u.makeHeading
                = rtxMemAllocType (pctxt, HeadingElementType);

            if (pvalue->u.makeHeading == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_HeadingElementType (pvalue->u.makeHeading);
            DOMTest_HeadingElementType (pctxt, pvalue->u.makeHeading, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeKnots"))) {
            pvalue->t = 10;
            pvalue->u.makeKnots = rtxMemAllocType (pctxt, SpeedElementType);

            if (pvalue->u.makeKnots == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SpeedElementType (pvalue->u.makeKnots);
            DOMTest_SpeedElementType (pctxt, pvalue->u.makeKnots, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeSpeed"))) {
            pvalue->t = 11;
            pvalue->u.makeSpeed = rtxMemAllocType (pctxt, SpeedElementType);

            if (pvalue->u.makeSpeed == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SpeedElementType (pvalue->u.makeSpeed);
            DOMTest_SpeedElementType (pctxt, pvalue->u.makeSpeed, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MetaCommand"))) {
            pvalue->t = 12;
            pvalue->u.metaCommand = rtxMemAllocType (pctxt, MetaDataType);

            if (pvalue->u.metaCommand == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MetaDataType (pvalue->u.metaCommand);
            DOMTest_MetaDataType (pctxt, pvalue->u.metaCommand, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScript"))) {
            pvalue->t = 13;
            pvalue->u.missionScript
                = rtxMemAllocType (pctxt, StringElementType);

            if (pvalue->u.missionScript == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StringElementType (pvalue->u.missionScript);
            DOMTest_StringElementType (pctxt, pvalue->u.missionScript, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScriptInline"))) {
            pvalue->t = 14;
            pvalue->u.missionScriptInline
                = rtxMemAllocType (pctxt, StringElementType);

            if (pvalue->u.missionScriptInline == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StringElementType (pvalue->u.missionScriptInline);
            DOMTest_StringElementType (pctxt, pvalue->u.missionScriptInline, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MoveLateral"))) {
            pvalue->t = 15;
            pvalue->u.moveLateral
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.moveLateral == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.moveLateral);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.moveLateral, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MoveRotate"))) {
            pvalue->t = 16;
            pvalue->u.moveRotate
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.moveRotate == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.moveRotate);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.moveRotate, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Quit"))) {
            pvalue->t = 17;
            pvalue->u.quit = rtxMemAllocType (pctxt, QuitCommandType);

            if (pvalue->u.quit == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_QuitCommandType (pvalue->u.quit);
            DOMTest_QuitCommandType (pctxt, pvalue->u.quit, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Realtime"))) {
            pvalue->t = 18;
            pvalue->u.realtime
                = rtxMemAllocType (pctxt, BooleanElementType_derivations);

            if (pvalue->u.realtime == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BooleanElementType_derivations (pvalue->u.realtime);
            DOMTest_BooleanElementType_derivations (pctxt, pvalue->u.realtime, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Recover"))) {
            pvalue->t = 19;
            pvalue->u.recover = rtxMemAllocType (pctxt, RecoverCommandType);

            if (pvalue->u.recover == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RecoverCommandType (pvalue->u.recover);
            DOMTest_RecoverCommandType (pctxt, pvalue->u.recover, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SendMessage"))) {
            pvalue->t = 20;
            pvalue->u.sendMessage
                = rtxMemAllocType (pctxt, SendMessageCommandType);

            if (pvalue->u.sendMessage == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SendMessageCommandType (pvalue->u.sendMessage);
            DOMTest_SendMessageCommandType (pctxt, pvalue->u.sendMessage, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPlanes"))) {
            pvalue->t = 21;
            pvalue->u.setPlanes
                = rtxMemAllocType (pctxt, SetPlanesCommandType);

            if (pvalue->u.setPlanes == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SetPlanesCommandType (pvalue->u.setPlanes);
            DOMTest_SetPlanesCommandType (pctxt, pvalue->u.setPlanes, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPosition"))) {
            pvalue->t = 22;
            pvalue->u.setPosition
                = rtxMemAllocType (pctxt, UuvPositionCommandType);

            if (pvalue->u.setPosition == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UuvPositionCommandType (pvalue->u.setPosition);
            DOMTest_UuvPositionCommandType (pctxt, pvalue->u.setPosition, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPower"))) {
            pvalue->t = 23;
            pvalue->u.setPower
                = rtxMemAllocType (pctxt, SetPropellerCommandType);

            if (pvalue->u.setPower == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SetPropellerCommandType (pvalue->u.setPower);
            DOMTest_SetPropellerCommandType (pctxt, pvalue->u.setPower, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetRudder"))) {
            pvalue->t = 24;
            pvalue->u.setRudder
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.setRudder == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.setRudder);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.setRudder, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetSonar"))) {
            pvalue->t = 25;
            pvalue->u.setSonar = rtxMemAllocType (pctxt, SetSonarCommandType);

            if (pvalue->u.setSonar == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SetSonarCommandType (pvalue->u.setSonar);
            DOMTest_SetSonarCommandType (pctxt, pvalue->u.setSonar, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetStandoff"))) {
            pvalue->t = 26;
            pvalue->u.setStandoff
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.setStandoff == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.setStandoff);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.setStandoff, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetThruster"))) {
            pvalue->t = 27;
            pvalue->u.setThruster
                = rtxMemAllocType (pctxt, SetThrusterCommandType);

            if (pvalue->u.setThruster == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SetThrusterCommandType (pvalue->u.setThruster);
            DOMTest_SetThrusterCommandType (pctxt, pvalue->u.setThruster, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTime"))) {
            pvalue->t = 28;
            pvalue->u.setTime = rtxMemAllocType (pctxt, ScalarElementType);

            if (pvalue->u.setTime == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ScalarElementType (pvalue->u.setTime);
            DOMTest_ScalarElementType (pctxt, pvalue->u.setTime, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTimeStep"))) {
            pvalue->t = 29;
            pvalue->u.setTimeStep
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.setTimeStep == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.setTimeStep);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.setTimeStep, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TakeStation"))) {
            pvalue->t = 30;
            pvalue->u.takeStation
                = rtxMemAllocType (pctxt, TakeStationCommandType);

            if (pvalue->u.takeStation == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TakeStationCommandType (pvalue->u.takeStation);
            DOMTest_TakeStationCommandType (pctxt, pvalue->u.takeStation, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Thrusters"))) {
            pvalue->t = 31;
            pvalue->u.thrusters
                = rtxMemAllocType (pctxt, BooleanElementType_derivations);

            if (pvalue->u.thrusters == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BooleanElementType_derivations (pvalue->u.thrusters);
            DOMTest_BooleanElementType_derivations (pctxt, pvalue->u.thrusters, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Trace"))) {
            pvalue->t = 32;
            pvalue->u.trace
                = rtxMemAllocType (pctxt, BooleanElementType_derivations);

            if (pvalue->u.trace == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BooleanElementType_derivations (pvalue->u.trace);
            DOMTest_BooleanElementType_derivations (pctxt, pvalue->u.trace, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Wait"))) {
            pvalue->t = 33;
            pvalue->u.wait
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.wait == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.wait);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.wait, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("WaitUntilTime"))) {
            pvalue->t = 34;
            pvalue->u.waitUntilTime
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.waitUntilTime == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.waitUntilTime);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.waitUntilTime, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Waypoint"))) {
            pvalue->t = 35;
            pvalue->u.waypoint
                = rtxMemAllocType (pctxt, UuvWaypointCommandType);

            if (pvalue->u.waypoint == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UuvWaypointCommandType (pvalue->u.waypoint);
            DOMTest_UuvWaypointCommandType (pctxt, pvalue->u.waypoint, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_UuvScriptCommandsType (OSCTXT* pctxt, 
   UuvScriptCommandsType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("CompositeWaypoint")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("FollowBeacon")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("GpsFix")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Help")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Hover")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Loiter")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeAltitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeDepth")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeHeading")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeKnots")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeSpeed")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MetaCommand")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScript")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScriptInline")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MoveLateral")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MoveRotate")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Quit")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Realtime")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Recover")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SendMessage")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPlanes")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPosition")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPower")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetRudder")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetSonar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetStandoff")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetThruster")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTime")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTimeStep")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TakeStation")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Thrusters")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Trace")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Wait")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("WaitUntilTime")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Waypoint"))) {
            { UuvScriptCommandsType_element* pdata2;
            pdata2 = rtxMemAllocType (pctxt, UuvScriptCommandsType_element);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UuvScriptCommandsType_element (pdata2);
            DOMTest_UuvScriptCommandsType_element (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_SpeedTypeElements (OSCTXT* pctxt, SpeedTypeElements* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Speed"))) {
            pvalue->t = 1;
            pvalue->u.speed
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.speed == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.speed);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.speed, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Knots"))) {
            pvalue->t = 2;
            pvalue->u.knots
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.knots == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.knots);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.knots, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_UsvCompositeWaypointCommandType (OSCTXT* pctxt, 
   UsvCompositeWaypointCommandType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("WaypointList")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ParallelTrack")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SectorPattern")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ExpandingSquare"))) {
            DOMTest_CompositeWaypointElements (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("HomingMode"))) {
            pvalue->m.homingModePresent = 1;
            DOMTest_TrackModeElementType (pctxt, &pvalue->homingMode, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Speed")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Knots"))) {
            pvalue->m.choice_1Present = 1;
            DOMTest_SpeedTypeElements (pctxt, &pvalue->choice_1, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Standoff"))) {
            pvalue->m.standoffPresent = 1;
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->standoff, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TimeOut"))) {
            pvalue->m.timeOutPresent = 1;
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->timeOut, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_UsvLoiterCommandType (OSCTXT* pctxt, UsvLoiterCommandType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LatitudeLongitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("XYPosition")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RelativeXYPosition"))) {
            pvalue->m.choicePresent = 1;
            DOMTest_HorizontalPositionElements (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Speed")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Knots"))) {
            pvalue->m.choice_1Present = 1;
            DOMTest_SpeedTypeElements (pctxt, &pvalue->choice_1, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TimeOut"))) {
            pvalue->m.timeOutPresent = 1;
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->timeOut, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_UsvPositionCommandType (OSCTXT* pctxt, 
   UsvPositionCommandType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LatitudeLongitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("XYPosition"))) {
            DOMTest_AbsoluteHorizontalPositionElements (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_UsvWaypointCommandType (OSCTXT* pctxt, 
   UsvWaypointCommandType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LatitudeLongitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("XYPosition")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RelativeXYPosition"))) {
            DOMTest_HorizontalPositionElements (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("HomingMode"))) {
            pvalue->m.homingModePresent = 1;
            DOMTest_TrackModeElementType (pctxt, &pvalue->homingMode, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Speed")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Knots"))) {
            pvalue->m.choice_1Present = 1;
            DOMTest_SpeedTypeElements (pctxt, &pvalue->choice_1, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Standoff"))) {
            pvalue->m.standoffPresent = 1;
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->standoff, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TimeOut"))) {
            pvalue->m.timeOutPresent = 1;
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->timeOut, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_UsvScriptCommandsType_element (OSCTXT* pctxt, 
   UsvScriptCommandsType_element* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("CompositeWaypoint"))) {
            pvalue->t = 1;
            pvalue->u.compositeWaypoint
                = rtxMemAllocType (pctxt, UsvCompositeWaypointCommandType);

            if (pvalue->u.compositeWaypoint == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UsvCompositeWaypointCommandType (pvalue->u.compositeWaypoint);
            DOMTest_UsvCompositeWaypointCommandType (pctxt, pvalue->u.compositeWaypoint, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("FollowBeacon"))) {
            pvalue->t = 2;
            pvalue->u.followBeacon
                = rtxMemAllocType (pctxt, FollowBeaconCommandType);

            if (pvalue->u.followBeacon == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FollowBeaconCommandType (pvalue->u.followBeacon);
            DOMTest_FollowBeaconCommandType (pctxt, pvalue->u.followBeacon, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Help"))) {
            pvalue->t = 3;
            pvalue->u.help = rtxMemAllocType (pctxt, NoValueElementType);

            if (pvalue->u.help == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NoValueElementType (pvalue->u.help);
            DOMTest_NoValueElementType (pctxt, pvalue->u.help, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Loiter"))) {
            pvalue->t = 4;
            pvalue->u.loiter = rtxMemAllocType (pctxt, UsvLoiterCommandType);

            if (pvalue->u.loiter == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UsvLoiterCommandType (pvalue->u.loiter);
            DOMTest_UsvLoiterCommandType (pctxt, pvalue->u.loiter, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeHeading"))) {
            pvalue->t = 5;
            pvalue->u.makeHeading
                = rtxMemAllocType (pctxt, HeadingElementType);

            if (pvalue->u.makeHeading == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_HeadingElementType (pvalue->u.makeHeading);
            DOMTest_HeadingElementType (pctxt, pvalue->u.makeHeading, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeKnots"))) {
            pvalue->t = 6;
            pvalue->u.makeKnots = rtxMemAllocType (pctxt, SpeedElementType);

            if (pvalue->u.makeKnots == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SpeedElementType (pvalue->u.makeKnots);
            DOMTest_SpeedElementType (pctxt, pvalue->u.makeKnots, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeSpeed"))) {
            pvalue->t = 7;
            pvalue->u.makeSpeed = rtxMemAllocType (pctxt, SpeedElementType);

            if (pvalue->u.makeSpeed == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SpeedElementType (pvalue->u.makeSpeed);
            DOMTest_SpeedElementType (pctxt, pvalue->u.makeSpeed, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MetaCommand"))) {
            pvalue->t = 8;
            pvalue->u.metaCommand = rtxMemAllocType (pctxt, MetaDataType);

            if (pvalue->u.metaCommand == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MetaDataType (pvalue->u.metaCommand);
            DOMTest_MetaDataType (pctxt, pvalue->u.metaCommand, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScript"))) {
            pvalue->t = 9;
            pvalue->u.missionScript
                = rtxMemAllocType (pctxt, StringElementType);

            if (pvalue->u.missionScript == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StringElementType (pvalue->u.missionScript);
            DOMTest_StringElementType (pctxt, pvalue->u.missionScript, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScriptInline"))) {
            pvalue->t = 10;
            pvalue->u.missionScriptInline
                = rtxMemAllocType (pctxt, StringElementType);

            if (pvalue->u.missionScriptInline == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StringElementType (pvalue->u.missionScriptInline);
            DOMTest_StringElementType (pctxt, pvalue->u.missionScriptInline, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Quit"))) {
            pvalue->t = 11;
            pvalue->u.quit = rtxMemAllocType (pctxt, QuitCommandType);

            if (pvalue->u.quit == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_QuitCommandType (pvalue->u.quit);
            DOMTest_QuitCommandType (pctxt, pvalue->u.quit, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Realtime"))) {
            pvalue->t = 12;
            pvalue->u.realtime
                = rtxMemAllocType (pctxt, BooleanElementType_derivations);

            if (pvalue->u.realtime == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BooleanElementType_derivations (pvalue->u.realtime);
            DOMTest_BooleanElementType_derivations (pctxt, pvalue->u.realtime, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SendMessage"))) {
            pvalue->t = 13;
            pvalue->u.sendMessage
                = rtxMemAllocType (pctxt, SendMessageCommandType);

            if (pvalue->u.sendMessage == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SendMessageCommandType (pvalue->u.sendMessage);
            DOMTest_SendMessageCommandType (pctxt, pvalue->u.sendMessage, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPosition"))) {
            pvalue->t = 14;
            pvalue->u.setPosition
                = rtxMemAllocType (pctxt, UsvPositionCommandType);

            if (pvalue->u.setPosition == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UsvPositionCommandType (pvalue->u.setPosition);
            DOMTest_UsvPositionCommandType (pctxt, pvalue->u.setPosition, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPower"))) {
            pvalue->t = 15;
            pvalue->u.setPower
                = rtxMemAllocType (pctxt, SetPropellerCommandType);

            if (pvalue->u.setPower == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SetPropellerCommandType (pvalue->u.setPower);
            DOMTest_SetPropellerCommandType (pctxt, pvalue->u.setPower, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetRudder"))) {
            pvalue->t = 16;
            pvalue->u.setRudder
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.setRudder == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.setRudder);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.setRudder, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetStandoff"))) {
            pvalue->t = 17;
            pvalue->u.setStandoff
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.setStandoff == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.setStandoff);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.setStandoff, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTime"))) {
            pvalue->t = 18;
            pvalue->u.setTime = rtxMemAllocType (pctxt, ScalarElementType);

            if (pvalue->u.setTime == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ScalarElementType (pvalue->u.setTime);
            DOMTest_ScalarElementType (pctxt, pvalue->u.setTime, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTimeStep"))) {
            pvalue->t = 19;
            pvalue->u.setTimeStep
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.setTimeStep == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.setTimeStep);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.setTimeStep, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Trace"))) {
            pvalue->t = 20;
            pvalue->u.trace
                = rtxMemAllocType (pctxt, BooleanElementType_derivations);

            if (pvalue->u.trace == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BooleanElementType_derivations (pvalue->u.trace);
            DOMTest_BooleanElementType_derivations (pctxt, pvalue->u.trace, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Wait"))) {
            pvalue->t = 21;
            pvalue->u.wait
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.wait == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.wait);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.wait, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("WaitUntilTime"))) {
            pvalue->t = 22;
            pvalue->u.waitUntilTime
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.waitUntilTime == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.waitUntilTime);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.waitUntilTime, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Waypoint"))) {
            pvalue->t = 23;
            pvalue->u.waypoint
                = rtxMemAllocType (pctxt, UsvWaypointCommandType);

            if (pvalue->u.waypoint == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UsvWaypointCommandType (pvalue->u.waypoint);
            DOMTest_UsvWaypointCommandType (pctxt, pvalue->u.waypoint, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_UsvScriptCommandsType (OSCTXT* pctxt, 
   UsvScriptCommandsType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("CompositeWaypoint")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("FollowBeacon")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Help")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Loiter")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeHeading")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeKnots")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeSpeed")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MetaCommand")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScript")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScriptInline")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Quit")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Realtime")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SendMessage")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPosition")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPower")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetRudder")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetStandoff")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTime")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTimeStep")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Trace")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Wait")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("WaitUntilTime")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Waypoint"))) {
            { UsvScriptCommandsType_element* pdata2;
            pdata2 = rtxMemAllocType (pctxt, UsvScriptCommandsType_element);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UsvScriptCommandsType_element (pdata2);
            DOMTest_UsvScriptCommandsType_element (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_UgvCompositeWaypointCommandType (OSCTXT* pctxt, 
   UgvCompositeWaypointCommandType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("WaypointList")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ParallelTrack")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SectorPattern")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ExpandingSquare"))) {
            DOMTest_CompositeWaypointElements (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("HomingMode"))) {
            pvalue->m.homingModePresent = 1;
            DOMTest_TrackModeElementType (pctxt, &pvalue->homingMode, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Speed")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Knots"))) {
            pvalue->m.choice_1Present = 1;
            DOMTest_SpeedTypeElements (pctxt, &pvalue->choice_1, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Standoff"))) {
            pvalue->m.standoffPresent = 1;
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->standoff, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TimeOut"))) {
            pvalue->m.timeOutPresent = 1;
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->timeOut, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_UgvLoiterCommandType (OSCTXT* pctxt, UgvLoiterCommandType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LatitudeLongitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("XYPosition")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RelativeXYPosition"))) {
            pvalue->m.choicePresent = 1;
            DOMTest_HorizontalPositionElements (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Speed")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Knots"))) {
            pvalue->m.choice_1Present = 1;
            DOMTest_SpeedTypeElements (pctxt, &pvalue->choice_1, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TimeOut"))) {
            pvalue->m.timeOutPresent = 1;
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->timeOut, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_UgvPositionCommandType (OSCTXT* pctxt, 
   UgvPositionCommandType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LatitudeLongitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("XYPosition"))) {
            DOMTest_AbsoluteHorizontalPositionElements (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_UgvWaypointCommandType (OSCTXT* pctxt, 
   UgvWaypointCommandType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LatitudeLongitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("XYPosition")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RelativeXYPosition"))) {
            DOMTest_HorizontalPositionElements (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Speed")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Knots"))) {
            pvalue->m.choice_1Present = 1;
            DOMTest_SpeedTypeElements (pctxt, &pvalue->choice_1, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("HomingMode"))) {
            pvalue->m.homingModePresent = 1;
            DOMTest_TrackModeElementType (pctxt, &pvalue->homingMode, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Standoff"))) {
            pvalue->m.standoffPresent = 1;
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->standoff, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TimeOut"))) {
            pvalue->m.timeOutPresent = 1;
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->timeOut, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_UgvScriptCommandsType_element (OSCTXT* pctxt, 
   UgvScriptCommandsType_element* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("CompositeWaypoint"))) {
            pvalue->t = 1;
            pvalue->u.compositeWaypoint
                = rtxMemAllocType (pctxt, UgvCompositeWaypointCommandType);

            if (pvalue->u.compositeWaypoint == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UgvCompositeWaypointCommandType (pvalue->u.compositeWaypoint);
            DOMTest_UgvCompositeWaypointCommandType (pctxt, pvalue->u.compositeWaypoint, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("FollowBeacon"))) {
            pvalue->t = 2;
            pvalue->u.followBeacon
                = rtxMemAllocType (pctxt, FollowBeaconCommandType);

            if (pvalue->u.followBeacon == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FollowBeaconCommandType (pvalue->u.followBeacon);
            DOMTest_FollowBeaconCommandType (pctxt, pvalue->u.followBeacon, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Help"))) {
            pvalue->t = 3;
            pvalue->u.help = rtxMemAllocType (pctxt, NoValueElementType);

            if (pvalue->u.help == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NoValueElementType (pvalue->u.help);
            DOMTest_NoValueElementType (pctxt, pvalue->u.help, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Loiter"))) {
            pvalue->t = 4;
            pvalue->u.loiter = rtxMemAllocType (pctxt, UgvLoiterCommandType);

            if (pvalue->u.loiter == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UgvLoiterCommandType (pvalue->u.loiter);
            DOMTest_UgvLoiterCommandType (pctxt, pvalue->u.loiter, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeHeading"))) {
            pvalue->t = 5;
            pvalue->u.makeHeading
                = rtxMemAllocType (pctxt, HeadingElementType);

            if (pvalue->u.makeHeading == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_HeadingElementType (pvalue->u.makeHeading);
            DOMTest_HeadingElementType (pctxt, pvalue->u.makeHeading, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeKnots"))) {
            pvalue->t = 6;
            pvalue->u.makeKnots
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.makeKnots == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeKnots);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.makeKnots, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeSpeed"))) {
            pvalue->t = 7;
            pvalue->u.makeSpeed
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.makeSpeed == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeSpeed);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.makeSpeed, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MetaCommand"))) {
            pvalue->t = 8;
            pvalue->u.metaCommand = rtxMemAllocType (pctxt, MetaDataType);

            if (pvalue->u.metaCommand == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MetaDataType (pvalue->u.metaCommand);
            DOMTest_MetaDataType (pctxt, pvalue->u.metaCommand, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScript"))) {
            pvalue->t = 9;
            pvalue->u.missionScript
                = rtxMemAllocType (pctxt, StringElementType);

            if (pvalue->u.missionScript == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StringElementType (pvalue->u.missionScript);
            DOMTest_StringElementType (pctxt, pvalue->u.missionScript, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScriptInline"))) {
            pvalue->t = 10;
            pvalue->u.missionScriptInline
                = rtxMemAllocType (pctxt, StringElementType);

            if (pvalue->u.missionScriptInline == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StringElementType (pvalue->u.missionScriptInline);
            DOMTest_StringElementType (pctxt, pvalue->u.missionScriptInline, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Quit"))) {
            pvalue->t = 11;
            pvalue->u.quit = rtxMemAllocType (pctxt, QuitCommandType);

            if (pvalue->u.quit == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_QuitCommandType (pvalue->u.quit);
            DOMTest_QuitCommandType (pctxt, pvalue->u.quit, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Realtime"))) {
            pvalue->t = 12;
            pvalue->u.realtime
                = rtxMemAllocType (pctxt, BooleanElementType_derivations);

            if (pvalue->u.realtime == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BooleanElementType_derivations (pvalue->u.realtime);
            DOMTest_BooleanElementType_derivations (pctxt, pvalue->u.realtime, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SendMessage"))) {
            pvalue->t = 13;
            pvalue->u.sendMessage
                = rtxMemAllocType (pctxt, SendMessageCommandType);

            if (pvalue->u.sendMessage == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SendMessageCommandType (pvalue->u.sendMessage);
            DOMTest_SendMessageCommandType (pctxt, pvalue->u.sendMessage, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPosition"))) {
            pvalue->t = 14;
            pvalue->u.setPosition
                = rtxMemAllocType (pctxt, UgvPositionCommandType);

            if (pvalue->u.setPosition == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UgvPositionCommandType (pvalue->u.setPosition);
            DOMTest_UgvPositionCommandType (pctxt, pvalue->u.setPosition, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetStandoff"))) {
            pvalue->t = 15;
            pvalue->u.setStandoff
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.setStandoff == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.setStandoff);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.setStandoff, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTime"))) {
            pvalue->t = 16;
            pvalue->u.setTime = rtxMemAllocType (pctxt, ScalarElementType);

            if (pvalue->u.setTime == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ScalarElementType (pvalue->u.setTime);
            DOMTest_ScalarElementType (pctxt, pvalue->u.setTime, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTimeStep"))) {
            pvalue->t = 17;
            pvalue->u.setTimeStep
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.setTimeStep == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.setTimeStep);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.setTimeStep, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Trace"))) {
            pvalue->t = 18;
            pvalue->u.trace
                = rtxMemAllocType (pctxt, BooleanElementType_derivations);

            if (pvalue->u.trace == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BooleanElementType_derivations (pvalue->u.trace);
            DOMTest_BooleanElementType_derivations (pctxt, pvalue->u.trace, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Wait"))) {
            pvalue->t = 19;
            pvalue->u.wait
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.wait == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.wait);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.wait, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("WaitUntilTime"))) {
            pvalue->t = 20;
            pvalue->u.waitUntilTime
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.waitUntilTime == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.waitUntilTime);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.waitUntilTime, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Waypoint"))) {
            pvalue->t = 21;
            pvalue->u.waypoint
                = rtxMemAllocType (pctxt, UgvWaypointCommandType);

            if (pvalue->u.waypoint == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UgvWaypointCommandType (pvalue->u.waypoint);
            DOMTest_UgvWaypointCommandType (pctxt, pvalue->u.waypoint, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_UgvScriptCommandsType (OSCTXT* pctxt, 
   UgvScriptCommandsType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("CompositeWaypoint")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("FollowBeacon")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Help")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Loiter")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeHeading")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeKnots")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeSpeed")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MetaCommand")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScript")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScriptInline")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Quit")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Realtime")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SendMessage")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPosition")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetStandoff")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTime")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTimeStep")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Trace")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Wait")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("WaitUntilTime")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Waypoint"))) {
            { UgvScriptCommandsType_element* pdata2;
            pdata2 = rtxMemAllocType (pctxt, UgvScriptCommandsType_element);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UgvScriptCommandsType_element (pdata2);
            DOMTest_UgvScriptCommandsType_element (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_AltitudeTypeElements (OSCTXT* pctxt, AltitudeTypeElements* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AGLAltitude"))) {
            pvalue->t = 1;
            pvalue->u.aGLAltitude
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.aGLAltitude == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.aGLAltitude);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.aGLAltitude, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MSLAltitude"))) {
            pvalue->t = 2;
            pvalue->u.mSLAltitude
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.mSLAltitude == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.mSLAltitude);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.mSLAltitude, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_UavCompositeWaypointCommandType (OSCTXT* pctxt, 
   UavCompositeWaypointCommandType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("WaypointList")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ParallelTrack")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SectorPattern")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ExpandingSquare"))) {
            DOMTest_CompositeWaypointElements (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AGLAltitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MSLAltitude"))) {
            DOMTest_AltitudeTypeElements (pctxt, &pvalue->choice_1, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("HomingMode"))) {
            pvalue->m.homingModePresent = 1;
            DOMTest_TrackModeElementType (pctxt, &pvalue->homingMode, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Speed")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Knots"))) {
            pvalue->m.choice_2Present = 1;
            DOMTest_SpeedTypeElements (pctxt, &pvalue->choice_2, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Standoff"))) {
            pvalue->m.standoffPresent = 1;
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->standoff, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TimeOut"))) {
            pvalue->m.timeOutPresent = 1;
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->timeOut, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_UavLoiterCommandType (OSCTXT* pctxt, UavLoiterCommandType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LatitudeLongitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("XYPosition")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RelativeXYPosition"))) {
            pvalue->m.choicePresent = 1;
            DOMTest_HorizontalPositionElements (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Speed")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Knots"))) {
            pvalue->m.choice_1Present = 1;
            DOMTest_SpeedTypeElements (pctxt, &pvalue->choice_1, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AGLAltitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MSLAltitude"))) {
            pvalue->m.choice_2Present = 1;
            DOMTest_AltitudeTypeElements (pctxt, &pvalue->choice_2, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LoiterAltitude"))) {
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->loiterAltitude, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TimeOut"))) {
            pvalue->m.timeOutPresent = 1;
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->timeOut, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_UavPositionCommandType (OSCTXT* pctxt, 
   UavPositionCommandType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LatitudeLongitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("XYPosition"))) {
            DOMTest_AbsoluteHorizontalPositionElements (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MSLAltitude"))) {
            pvalue->m.mSLAltitudePresent = 1;
            DOMTest_ScalarElementType (pctxt, &pvalue->mSLAltitude, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_PercentElementType (OSCTXT* pctxt, PercentElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("value"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->value);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_UavWaypointCommandType (OSCTXT* pctxt, 
   UavWaypointCommandType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LatitudeLongitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("XYPosition")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RelativeXYPosition"))) {
            DOMTest_HorizontalPositionElements (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AGLAltitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MSLAltitude"))) {
            pvalue->m.choice_1Present = 1;
            DOMTest_AltitudeTypeElements (pctxt, &pvalue->choice_1, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("HomingMode"))) {
            pvalue->m.homingModePresent = 1;
            DOMTest_TrackModeElementType (pctxt, &pvalue->homingMode, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Speed")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Knots"))) {
            pvalue->m.choice_2Present = 1;
            DOMTest_SpeedTypeElements (pctxt, &pvalue->choice_2, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Standoff"))) {
            pvalue->m.standoffPresent = 1;
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->standoff, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TimeOut"))) {
            pvalue->m.timeOutPresent = 1;
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->timeOut, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_UavScriptCommandsType_element (OSCTXT* pctxt, 
   UavScriptCommandsType_element* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("CompositeWaypoint"))) {
            pvalue->t = 1;
            pvalue->u.compositeWaypoint
                = rtxMemAllocType (pctxt, UavCompositeWaypointCommandType);

            if (pvalue->u.compositeWaypoint == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UavCompositeWaypointCommandType (pvalue->u.compositeWaypoint);
            DOMTest_UavCompositeWaypointCommandType (pctxt, pvalue->u.compositeWaypoint, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("FollowBeacon"))) {
            pvalue->t = 2;
            pvalue->u.followBeacon
                = rtxMemAllocType (pctxt, FollowBeaconCommandType);

            if (pvalue->u.followBeacon == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FollowBeaconCommandType (pvalue->u.followBeacon);
            DOMTest_FollowBeaconCommandType (pctxt, pvalue->u.followBeacon, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Help"))) {
            pvalue->t = 3;
            pvalue->u.help = rtxMemAllocType (pctxt, NoValueElementType);

            if (pvalue->u.help == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NoValueElementType (pvalue->u.help);
            DOMTest_NoValueElementType (pctxt, pvalue->u.help, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Loiter"))) {
            pvalue->t = 4;
            pvalue->u.loiter = rtxMemAllocType (pctxt, UavLoiterCommandType);

            if (pvalue->u.loiter == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UavLoiterCommandType (pvalue->u.loiter);
            DOMTest_UavLoiterCommandType (pctxt, pvalue->u.loiter, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeAltitudeAGL"))) {
            pvalue->t = 5;
            pvalue->u.makeAltitudeAGL
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.makeAltitudeAGL == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeAltitudeAGL);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.makeAltitudeAGL, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeAltitudeMSL"))) {
            pvalue->t = 6;
            pvalue->u.makeAltitudeMSL
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.makeAltitudeMSL == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeAltitudeMSL);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.makeAltitudeMSL, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeClimbRate"))) {
            pvalue->t = 7;
            pvalue->u.makeClimbRate
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.makeClimbRate == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.makeClimbRate);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.makeClimbRate, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeHeading"))) {
            pvalue->t = 8;
            pvalue->u.makeHeading
                = rtxMemAllocType (pctxt, HeadingElementType);

            if (pvalue->u.makeHeading == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_HeadingElementType (pvalue->u.makeHeading);
            DOMTest_HeadingElementType (pctxt, pvalue->u.makeHeading, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeKnots"))) {
            pvalue->t = 9;
            pvalue->u.makeKnots = rtxMemAllocType (pctxt, SpeedElementType);

            if (pvalue->u.makeKnots == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SpeedElementType (pvalue->u.makeKnots);
            DOMTest_SpeedElementType (pctxt, pvalue->u.makeKnots, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeSpeed"))) {
            pvalue->t = 10;
            pvalue->u.makeSpeed = rtxMemAllocType (pctxt, SpeedElementType);

            if (pvalue->u.makeSpeed == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SpeedElementType (pvalue->u.makeSpeed);
            DOMTest_SpeedElementType (pctxt, pvalue->u.makeSpeed, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeTurnRate"))) {
            pvalue->t = 11;
            pvalue->u.makeTurnRate
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.makeTurnRate == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.makeTurnRate);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.makeTurnRate, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MetaCommand"))) {
            pvalue->t = 12;
            pvalue->u.metaCommand = rtxMemAllocType (pctxt, MetaDataType);

            if (pvalue->u.metaCommand == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MetaDataType (pvalue->u.metaCommand);
            DOMTest_MetaDataType (pctxt, pvalue->u.metaCommand, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScript"))) {
            pvalue->t = 13;
            pvalue->u.missionScript
                = rtxMemAllocType (pctxt, StringElementType);

            if (pvalue->u.missionScript == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StringElementType (pvalue->u.missionScript);
            DOMTest_StringElementType (pctxt, pvalue->u.missionScript, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScriptInline"))) {
            pvalue->t = 14;
            pvalue->u.missionScriptInline
                = rtxMemAllocType (pctxt, StringElementType);

            if (pvalue->u.missionScriptInline == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StringElementType (pvalue->u.missionScriptInline);
            DOMTest_StringElementType (pctxt, pvalue->u.missionScriptInline, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Quit"))) {
            pvalue->t = 15;
            pvalue->u.quit = rtxMemAllocType (pctxt, QuitCommandType);

            if (pvalue->u.quit == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_QuitCommandType (pvalue->u.quit);
            DOMTest_QuitCommandType (pctxt, pvalue->u.quit, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Realtime"))) {
            pvalue->t = 16;
            pvalue->u.realtime
                = rtxMemAllocType (pctxt, BooleanElementType_derivations);

            if (pvalue->u.realtime == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BooleanElementType_derivations (pvalue->u.realtime);
            DOMTest_BooleanElementType_derivations (pctxt, pvalue->u.realtime, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SendMessage"))) {
            pvalue->t = 17;
            pvalue->u.sendMessage
                = rtxMemAllocType (pctxt, SendMessageCommandType);

            if (pvalue->u.sendMessage == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SendMessageCommandType (pvalue->u.sendMessage);
            DOMTest_SendMessageCommandType (pctxt, pvalue->u.sendMessage, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetAileron"))) {
            pvalue->t = 18;
            pvalue->u.setAileron
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.setAileron == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.setAileron);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.setAileron, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetElevator"))) {
            pvalue->t = 19;
            pvalue->u.setElevator
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.setElevator == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.setElevator);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.setElevator, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPosition"))) {
            pvalue->t = 20;
            pvalue->u.setPosition
                = rtxMemAllocType (pctxt, UavPositionCommandType);

            if (pvalue->u.setPosition == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UavPositionCommandType (pvalue->u.setPosition);
            DOMTest_UavPositionCommandType (pctxt, pvalue->u.setPosition, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPower"))) {
            pvalue->t = 21;
            pvalue->u.setPower = rtxMemAllocType (pctxt, PercentElementType);

            if (pvalue->u.setPower == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PercentElementType (pvalue->u.setPower);
            DOMTest_PercentElementType (pctxt, pvalue->u.setPower, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetRudder"))) {
            pvalue->t = 22;
            pvalue->u.setRudder
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.setRudder == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.setRudder);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.setRudder, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetStandoff"))) {
            pvalue->t = 23;
            pvalue->u.setStandoff
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.setStandoff == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.setStandoff);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.setStandoff, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTime"))) {
            pvalue->t = 24;
            pvalue->u.setTime = rtxMemAllocType (pctxt, ScalarElementType);

            if (pvalue->u.setTime == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ScalarElementType (pvalue->u.setTime);
            DOMTest_ScalarElementType (pctxt, pvalue->u.setTime, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTimeStep"))) {
            pvalue->t = 25;
            pvalue->u.setTimeStep
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.setTimeStep == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.setTimeStep);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.setTimeStep, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Trace"))) {
            pvalue->t = 26;
            pvalue->u.trace
                = rtxMemAllocType (pctxt, BooleanElementType_derivations);

            if (pvalue->u.trace == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BooleanElementType_derivations (pvalue->u.trace);
            DOMTest_BooleanElementType_derivations (pctxt, pvalue->u.trace, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Wait"))) {
            pvalue->t = 27;
            pvalue->u.wait
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.wait == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.wait);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.wait, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("WaitUntilTime"))) {
            pvalue->t = 28;
            pvalue->u.waitUntilTime
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.waitUntilTime == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.waitUntilTime);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.waitUntilTime, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Waypoint"))) {
            pvalue->t = 29;
            pvalue->u.waypoint
                = rtxMemAllocType (pctxt, UavWaypointCommandType);

            if (pvalue->u.waypoint == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UavWaypointCommandType (pvalue->u.waypoint);
            DOMTest_UavWaypointCommandType (pctxt, pvalue->u.waypoint, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_UavScriptCommandsType (OSCTXT* pctxt, 
   UavScriptCommandsType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("CompositeWaypoint")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("FollowBeacon")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Help")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Loiter")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeAltitudeAGL")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeAltitudeMSL")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeClimbRate")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeHeading")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeKnots")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeSpeed")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeTurnRate")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MetaCommand")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScript")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScriptInline")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Quit")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Realtime")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SendMessage")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetAileron")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetElevator")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPosition")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPower")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetRudder")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetStandoff")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTime")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTimeStep")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Trace")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Wait")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("WaitUntilTime")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Waypoint"))) {
            { UavScriptCommandsType_element* pdata2;
            pdata2 = rtxMemAllocType (pctxt, UavScriptCommandsType_element);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UavScriptCommandsType_element (pdata2);
            DOMTest_UavScriptCommandsType_element (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_AbsoluteHorizontalPositionElementType (OSCTXT* pctxt, 
   AbsoluteHorizontalPositionElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LatitudeLongitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("XYPosition"))) {
            DOMTest_AbsoluteHorizontalPositionElements (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_ActionObjectElementType (OSCTXT* pctxt, 
   ActionObjectElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("name"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->name = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->name = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_AttackElementType (OSCTXT* pctxt, AttackElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("disableOnly"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->disableOnly);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("singleTarget"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->singleTarget);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("weaponStatus"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               WeaponStatusType_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->weaponStatus);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Target"))) {
            { ActionObjectElementType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ActionObjectElementType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ActionObjectElementType (pdata2);
            DOMTest_ActionObjectElementType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->target_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_ContaminantElementType (OSCTXT* pctxt, 
   ContaminantElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               ContaminantType_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->type);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_DecontaminateElementType (OSCTXT* pctxt, 
   DecontaminateElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Contaminant"))) {
            { ContaminantElementType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ContaminantElementType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ContaminantElementType (pdata2);
            DOMTest_ContaminantElementType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->contaminant_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_DemolishElementType (OSCTXT* pctxt, DemolishElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("permanentDisable"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->permanentDisable);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("singleTarget"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->singleTarget);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Target"))) {
            { ActionObjectElementType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ActionObjectElementType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ActionObjectElementType (pdata2);
            DOMTest_ActionObjectElementType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->target_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_IlluminatorElementType (OSCTXT* pctxt, 
   IlluminatorElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               IlluminatorType_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->type);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("IlluminatorCharacteristic"))) {
            { StringElementType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, StringElementType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StringElementType (pdata2);
            DOMTest_StringElementType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->illuminatorCharacteristic_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_IlluminateElementType (OSCTXT* pctxt, 
   IlluminateElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Illuminator"))) {
            DOMTest_IlluminatorElementType (pctxt, &pvalue->illuminator, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_FrequencyRangeElementType (OSCTXT* pctxt, 
   FrequencyRangeElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("maxFrequency"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->maxFrequency);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("minFrequency"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->minFrequency);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_JamElementType (OSCTXT* pctxt, JamElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("FrequencyRange"))) {
            { FrequencyRangeElementType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, FrequencyRangeElementType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FrequencyRangeElementType (pdata2);
            DOMTest_FrequencyRangeElementType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->frequencyRange_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_MarkerElementType (OSCTXT* pctxt, MarkerElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               MarkerType_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->type);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MarkerCharacteristic"))) {
            { StringElementType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, StringElementType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StringElementType (pdata2);
            DOMTest_StringElementType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->markerCharacteristic_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_MarkElementType (OSCTXT* pctxt, MarkElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Marker"))) {
            DOMTest_MarkerElementType (pctxt, &pvalue->marker, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Target"))) {
            { ActionObjectElementType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ActionObjectElementType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ActionObjectElementType (pdata2);
            DOMTest_ActionObjectElementType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->target_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_MonitorTransmissionsElementType (OSCTXT* pctxt, 
   MonitorTransmissionsElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("FrequencyRange"))) {
            { FrequencyRangeElementType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, FrequencyRangeElementType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FrequencyRangeElementType (pdata2);
            DOMTest_FrequencyRangeElementType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->frequencyRange_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_PatrolElementType (OSCTXT* pctxt, PatrolElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Qualifier"))) {
            { StringElementType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, StringElementType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StringElementType (pdata2);
            DOMTest_StringElementType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->qualifier_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_RendezvousElementType (OSCTXT* pctxt, 
   RendezvousElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("targetVehicleID"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->targetVehicleID = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->targetVehicleID = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Qualifier"))) {
            { StringElementType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, StringElementType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StringElementType (pdata2);
            DOMTest_StringElementType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->qualifier_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_SampleEnvironmentElementType (OSCTXT* pctxt, 
   SampleEnvironmentElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Contaminant"))) {
            { ContaminantElementType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ContaminantElementType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ContaminantElementType (pdata2);
            DOMTest_ContaminantElementType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->contaminant_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_SearchElementType (OSCTXT* pctxt, SearchElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("datumType"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               DatumTypeType_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->datumType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("requiredPD"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->requiredPD);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("singleTarget"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->singleTarget);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SearchTarget"))) {
            { ActionObjectElementType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ActionObjectElementType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ActionObjectElementType (pdata2);
            DOMTest_ActionObjectElementType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->searchTarget_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_GoalElements (OSCTXT* pctxt, GoalElements* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Attack"))) {
            pvalue->t = 1;
            pvalue->u.attack = rtxMemAllocType (pctxt, AttackElementType);

            if (pvalue->u.attack == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AttackElementType (pvalue->u.attack);
            DOMTest_AttackElementType (pctxt, pvalue->u.attack, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Decontaminate"))) {
            pvalue->t = 2;
            pvalue->u.decontaminate
                = rtxMemAllocType (pctxt, DecontaminateElementType);

            if (pvalue->u.decontaminate == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_DecontaminateElementType (pvalue->u.decontaminate);
            DOMTest_DecontaminateElementType (pctxt, pvalue->u.decontaminate, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Demolish"))) {
            pvalue->t = 3;
            pvalue->u.demolish = rtxMemAllocType (pctxt, DemolishElementType);

            if (pvalue->u.demolish == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_DemolishElementType (pvalue->u.demolish);
            DOMTest_DemolishElementType (pctxt, pvalue->u.demolish, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("IlluminateArea"))) {
            pvalue->t = 4;
            pvalue->u.illuminateArea
                = rtxMemAllocType (pctxt, IlluminateElementType);

            if (pvalue->u.illuminateArea == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_IlluminateElementType (pvalue->u.illuminateArea);
            DOMTest_IlluminateElementType (pctxt, pvalue->u.illuminateArea, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Jam"))) {
            pvalue->t = 5;
            pvalue->u.jam = rtxMemAllocType (pctxt, JamElementType);

            if (pvalue->u.jam == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_JamElementType (pvalue->u.jam);
            DOMTest_JamElementType (pctxt, pvalue->u.jam, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MarkTarget"))) {
            pvalue->t = 6;
            pvalue->u.markTarget = rtxMemAllocType (pctxt, MarkElementType);

            if (pvalue->u.markTarget == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MarkElementType (pvalue->u.markTarget);
            DOMTest_MarkElementType (pctxt, pvalue->u.markTarget, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MonitorTransmissions"))) {
            pvalue->t = 7;
            pvalue->u.monitorTransmissions
                = rtxMemAllocType (pctxt, MonitorTransmissionsElementType);

            if (pvalue->u.monitorTransmissions == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MonitorTransmissionsElementType (pvalue->u.monitorTransmissions);
            DOMTest_MonitorTransmissionsElementType (pctxt, pvalue->u.monitorTransmissions, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Patrol"))) {
            pvalue->t = 8;
            pvalue->u.patrol = rtxMemAllocType (pctxt, PatrolElementType);

            if (pvalue->u.patrol == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PatrolElementType (pvalue->u.patrol);
            DOMTest_PatrolElementType (pctxt, pvalue->u.patrol, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Rendezvous"))) {
            pvalue->t = 9;
            pvalue->u.rendezvous
                = rtxMemAllocType (pctxt, RendezvousElementType);

            if (pvalue->u.rendezvous == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RendezvousElementType (pvalue->u.rendezvous);
            DOMTest_RendezvousElementType (pctxt, pvalue->u.rendezvous, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Reposition"))) {
            pvalue->t = 10;
            pvalue->u.reposition
                = rtxMemAllocType (pctxt, NoValueElementType);

            if (pvalue->u.reposition == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NoValueElementType (pvalue->u.reposition);
            DOMTest_NoValueElementType (pctxt, pvalue->u.reposition, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SampleEnvironment"))) {
            pvalue->t = 11;
            pvalue->u.sampleEnvironment
                = rtxMemAllocType (pctxt, SampleEnvironmentElementType);

            if (pvalue->u.sampleEnvironment == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SampleEnvironmentElementType (pvalue->u.sampleEnvironment);
            DOMTest_SampleEnvironmentElementType (pctxt, pvalue->u.sampleEnvironment, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Search"))) {
            pvalue->t = 12;
            pvalue->u.search = rtxMemAllocType (pctxt, SearchElementType);

            if (pvalue->u.search == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SearchElementType (pvalue->u.search);
            DOMTest_SearchElementType (pctxt, pvalue->u.search, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_CircleElementType (OSCTXT* pctxt, CircleElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Center"))) {
            DOMTest_AbsoluteHorizontalPositionElementType (pctxt, &pvalue->center, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Radius"))) {
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->radius, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_AreaOrientationElementType (OSCTXT* pctxt, 
   AreaOrientationElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("value"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->value);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_RectangleElementType (OSCTXT* pctxt, RectangleElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("NorthwestCorner"))) {
            DOMTest_AbsoluteHorizontalPositionElementType (pctxt, &pvalue->northwestCorner, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Width"))) {
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->width, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Height"))) {
            DOMTest_PositiveScalarElementType_derivations (pctxt, &pvalue->height, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Orientation"))) {
            pvalue->m.orientationPresent = 1;
            DOMTest_AreaOrientationElementType (pctxt, &pvalue->orientation, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_PolygonElementType (OSCTXT* pctxt, PolygonElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LatitudeLongitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("XYPosition"))) {
            DOMTest_PointListElements (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_LimitingLineElementType (OSCTXT* pctxt, 
   LimitingLineElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LatitudeLongitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("XYPosition"))) {
            DOMTest_PointListElements (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_AreaElements (OSCTXT* pctxt, AreaElements* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Point"))) {
            pvalue->t = 1;
            pvalue->u.point
                = rtxMemAllocType (pctxt, AbsoluteHorizontalPositionElementType);

            if (pvalue->u.point == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AbsoluteHorizontalPositionElementType (pvalue->u.point);
            DOMTest_AbsoluteHorizontalPositionElementType (pctxt, pvalue->u.point, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Circle"))) {
            pvalue->t = 2;
            pvalue->u.circle = rtxMemAllocType (pctxt, CircleElementType);

            if (pvalue->u.circle == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CircleElementType (pvalue->u.circle);
            DOMTest_CircleElementType (pctxt, pvalue->u.circle, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Rectangle"))) {
            pvalue->t = 3;
            pvalue->u.rectangle
                = rtxMemAllocType (pctxt, RectangleElementType);

            if (pvalue->u.rectangle == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RectangleElementType (pvalue->u.rectangle);
            DOMTest_RectangleElementType (pctxt, pvalue->u.rectangle, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Polygon"))) {
            pvalue->t = 4;
            pvalue->u.polygon = rtxMemAllocType (pctxt, PolygonElementType);

            if (pvalue->u.polygon == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PolygonElementType (pvalue->u.polygon);
            DOMTest_PolygonElementType (pctxt, pvalue->u.polygon, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LimitingLine"))) {
            pvalue->t = 5;
            pvalue->u.limitingLine
                = rtxMemAllocType (pctxt, LimitingLineElementType);

            if (pvalue->u.limitingLine == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_LimitingLineElementType (pvalue->u.limitingLine);
            DOMTest_LimitingLineElementType (pctxt, pvalue->u.limitingLine, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_NumericalBlockElementType (OSCTXT* pctxt, 
   NumericalBlockElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("maximum"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->maximum);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("minimum"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->minimum);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_DepthBlockElements (OSCTXT* pctxt, DepthBlockElements* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("DepthBlock"))) {
            pvalue->t = 1;
            pvalue->u.depthBlock
                = rtxMemAllocType (pctxt, NumericalBlockElementType);

            if (pvalue->u.depthBlock == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NumericalBlockElementType (pvalue->u.depthBlock);
            DOMTest_NumericalBlockElementType (pctxt, pvalue->u.depthBlock, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AltitudeBlock"))) {
            pvalue->t = 2;
            pvalue->u.altitudeBlock
                = rtxMemAllocType (pctxt, NumericalBlockElementType);

            if (pvalue->u.altitudeBlock == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NumericalBlockElementType (pvalue->u.altitudeBlock);
            DOMTest_NumericalBlockElementType (pctxt, pvalue->u.altitudeBlock, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("DepthAltitudeBlock"))) {
            pvalue->t = 3;
            pvalue->u.depthAltitudeBlock
                = rtxMemAllocType (pctxt, NumericalBlockElementType);

            if (pvalue->u.depthAltitudeBlock == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NumericalBlockElementType (pvalue->u.depthAltitudeBlock);
            DOMTest_NumericalBlockElementType (pctxt, pvalue->u.depthAltitudeBlock, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_AltitudeBlockElements (OSCTXT* pctxt, 
   AltitudeBlockElements* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AGLAltitudeBlock"))) {
            pvalue->t = 1;
            pvalue->u.aGLAltitudeBlock
                = rtxMemAllocType (pctxt, NumericalBlockElementType);

            if (pvalue->u.aGLAltitudeBlock == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NumericalBlockElementType (pvalue->u.aGLAltitudeBlock);
            DOMTest_NumericalBlockElementType (pctxt, pvalue->u.aGLAltitudeBlock, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MSLAltitudeBlock"))) {
            pvalue->t = 2;
            pvalue->u.mSLAltitudeBlock
                = rtxMemAllocType (pctxt, NumericalBlockElementType);

            if (pvalue->u.mSLAltitudeBlock == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NumericalBlockElementType (pvalue->u.mSLAltitudeBlock);
            DOMTest_NumericalBlockElementType (pctxt, pvalue->u.mSLAltitudeBlock, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AGLMSLAltitudeBlock"))) {
            pvalue->t = 3;
            pvalue->u.aGLMSLAltitudeBlock
                = rtxMemAllocType (pctxt, NumericalBlockElementType);

            if (pvalue->u.aGLMSLAltitudeBlock == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NumericalBlockElementType (pvalue->u.aGLMSLAltitudeBlock);
            DOMTest_NumericalBlockElementType (pctxt, pvalue->u.aGLMSLAltitudeBlock, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_VerticalBlockElements (OSCTXT* pctxt, 
   VerticalBlockElements* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Depth")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Altitude"))) {
            pvalue->t = 1;
            pvalue->u.choice = rtxMemAllocType (pctxt, DepthTypeElements);

            if (pvalue->u.choice == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_DepthTypeElements (pvalue->u.choice);
            DOMTest_DepthTypeElements (pctxt, pvalue->u.choice, pXmlNode, FALSE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AGLAltitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MSLAltitude"))) {
            pvalue->t = 2;
            pvalue->u.choice_1
                = rtxMemAllocType (pctxt, AltitudeTypeElements);

            if (pvalue->u.choice_1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AltitudeTypeElements (pvalue->u.choice_1);
            DOMTest_AltitudeTypeElements (pctxt, pvalue->u.choice_1, pXmlNode, FALSE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("DepthBlock")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AltitudeBlock")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("DepthAltitudeBlock"))) {
            pvalue->t = 3;
            pvalue->u.choice_2 = rtxMemAllocType (pctxt, DepthBlockElements);

            if (pvalue->u.choice_2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_DepthBlockElements (pvalue->u.choice_2);
            DOMTest_DepthBlockElements (pctxt, pvalue->u.choice_2, pXmlNode, FALSE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AGLAltitudeBlock")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MSLAltitudeBlock")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AGLMSLAltitudeBlock"))) {
            pvalue->t = 4;
            pvalue->u.choice_3
                = rtxMemAllocType (pctxt, AltitudeBlockElements);

            if (pvalue->u.choice_3 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AltitudeBlockElements (pvalue->u.choice_3);
            DOMTest_AltitudeBlockElements (pctxt, pvalue->u.choice_3, pXmlNode, FALSE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_AreaElementType (OSCTXT* pctxt, AreaElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Point")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Circle")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Rectangle")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Polygon")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LimitingLine"))) {
            pvalue->m.choicePresent = 1;
            DOMTest_AreaElements (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Depth")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Altitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AGLAltitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MSLAltitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("DepthBlock")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AltitudeBlock")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("DepthAltitudeBlock")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AGLAltitudeBlock")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MSLAltitudeBlock")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AGLMSLAltitudeBlock"))) {
            pvalue->m.choice_1Present = 1;
            DOMTest_VerticalBlockElements (pctxt, &pvalue->choice_1, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_AbsoluteTimingElementType (OSCTXT* pctxt, 
   AbsoluteTimingElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("start"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->start);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("stop"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->stop);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_TimingTypeElements (OSCTXT* pctxt, TimingTypeElements* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Duration"))) {
            pvalue->t = 1;
            pvalue->u.duration
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.duration == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.duration);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.duration, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Timing"))) {
            pvalue->t = 2;
            pvalue->u.timing
                = rtxMemAllocType (pctxt, AbsoluteTimingElementType);

            if (pvalue->u.timing == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AbsoluteTimingElementType (pvalue->u.timing);
            DOMTest_AbsoluteTimingElementType (pctxt, pvalue->u.timing, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_ReportingCriteriaElementType (OSCTXT* pctxt, 
   ReportingCriteriaElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("periodicity"))) {
            pvalue->m.periodicityPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->periodicity);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("value"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               ReportingCriteriaType_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->value);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_AgendaGoalElementType (OSCTXT* pctxt, 
   AgendaGoalElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("alert"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->alert);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("nextOnFail"))) {
            pvalue->m.nextOnFailPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->nextOnFail = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->nextOnFail = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("nextOnSucceed"))) {
            pvalue->m.nextOnSucceedPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->nextOnSucceed = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->nextOnSucceed = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Attack")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Decontaminate")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Demolish")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("IlluminateArea")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Jam")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MarkTarget")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MonitorTransmissions")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Patrol")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Rendezvous")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Reposition")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SampleEnvironment")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Search"))) {
            DOMTest_GoalElements (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("OperatingArea"))) {
            DOMTest_AreaElementType (pctxt, &pvalue->operatingArea, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Duration")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Timing"))) {
            DOMTest_TimingTypeElements (pctxt, &pvalue->choice_1, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ReportingCriteria"))) {
            { ReportingCriteriaElementType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ReportingCriteriaElementType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ReportingCriteriaElementType (pdata2);
            DOMTest_ReportingCriteriaElementType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->reportingCriteria_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_AgendaGoalListType (OSCTXT* pctxt, AgendaGoalListType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Goal"))) {
            { AgendaGoalElementType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, AgendaGoalElementType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AgendaGoalElementType (pdata2);
            DOMTest_AgendaGoalElementType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->goal_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_RouteElementType (OSCTXT* pctxt, RouteElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LatitudeLongitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("XYPosition"))) {
            pvalue->m.choicePresent = 1;
            DOMTest_PointListElements (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Depth")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Altitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AGLAltitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MSLAltitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("DepthBlock")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AltitudeBlock")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("DepthAltitudeBlock")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AGLAltitudeBlock")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MSLAltitudeBlock")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AGLMSLAltitudeBlock"))) {
            pvalue->m.choice_1Present = 1;
            DOMTest_VerticalBlockElements (pctxt, &pvalue->choice_1, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_AgendaConstraintListType (OSCTXT* pctxt, 
   AgendaConstraintListType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("IngressRouting"))) {
            pvalue->m.ingressRoutingPresent = 1;
            DOMTest_RouteElementType (pctxt, &pvalue->ingressRouting, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AvoidArea"))) {
            { AreaElementType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, AreaElementType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AreaElementType (pdata2);
            DOMTest_AreaElementType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->avoidArea_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("EgressRouting"))) {
            pvalue->m.egressRoutingPresent = 1;
            DOMTest_RouteElementType (pctxt, &pvalue->egressRouting, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_AgendaMissionElementType (OSCTXT* pctxt, 
   AgendaMissionElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("LaunchPosition"))) {
            pvalue->m.launchPositionPresent = 1;
            DOMTest_AbsoluteHorizontalPositionElementType (pctxt, &pvalue->launchPosition, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RecoveryPosition"))) {
            pvalue->m.recoveryPositionPresent = 1;
            DOMTest_AbsoluteHorizontalPositionElementType (pctxt, &pvalue->recoveryPosition, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("GoalList"))) {
            DOMTest_AgendaGoalListType (pctxt, &pvalue->goalList, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ConstraintList"))) {
            pvalue->m.constraintListPresent = 1;
            DOMTest_AgendaConstraintListType (pctxt, &pvalue->constraintList, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_MissionSpecification (OSCTXT* pctxt, MissionSpecification* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UUVCommandScript"))) {
            pvalue->t = 1;
            pvalue->u.uUVCommandScript
                = rtxMemAllocType (pctxt, UuvScriptCommandsType);

            if (pvalue->u.uUVCommandScript == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UuvScriptCommandsType (pvalue->u.uUVCommandScript);
            DOMTest_UuvScriptCommandsType (pctxt, pvalue->u.uUVCommandScript, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("USVCommandScript"))) {
            pvalue->t = 2;
            pvalue->u.uSVCommandScript
                = rtxMemAllocType (pctxt, UsvScriptCommandsType);

            if (pvalue->u.uSVCommandScript == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UsvScriptCommandsType (pvalue->u.uSVCommandScript);
            DOMTest_UsvScriptCommandsType (pctxt, pvalue->u.uSVCommandScript, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UGVCommandScript"))) {
            pvalue->t = 3;
            pvalue->u.uGVCommandScript
                = rtxMemAllocType (pctxt, UgvScriptCommandsType);

            if (pvalue->u.uGVCommandScript == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UgvScriptCommandsType (pvalue->u.uGVCommandScript);
            DOMTest_UgvScriptCommandsType (pctxt, pvalue->u.uGVCommandScript, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UAVCommandScript"))) {
            pvalue->t = 4;
            pvalue->u.uAVCommandScript
                = rtxMemAllocType (pctxt, UavScriptCommandsType);

            if (pvalue->u.uAVCommandScript == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UavScriptCommandsType (pvalue->u.uAVCommandScript);
            DOMTest_UavScriptCommandsType (pctxt, pvalue->u.uAVCommandScript, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AgendaMission"))) {
            pvalue->t = 5;
            pvalue->u.agendaMission
                = rtxMemAllocType (pctxt, AgendaMissionElementType);

            if (pvalue->u.agendaMission == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AgendaMissionElementType (pvalue->u.agendaMission);
            DOMTest_AgendaMissionElementType (pctxt, pvalue->u.agendaMission, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_InformationRequestElementType (OSCTXT* pctxt, 
   InformationRequestElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("informationType"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               InformationRequestType_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->informationType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_VehicleGroupCompositionElementType (OSCTXT* pctxt, 
   VehicleGroupCompositionElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("request"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               VehicleGroupCompositionType_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->request);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_DimensionsElementType (OSCTXT* pctxt, 
   DimensionsElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("height"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->height);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("length"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->length);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mass"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->mass);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("width"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->width);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_UuvOperatingCharacteristicsElementType (OSCTXT* pctxt, 
   UuvOperatingCharacteristicsElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("cruiseSpeed"))) {
            pvalue->m.cruiseSpeedPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->cruiseSpeed);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("endurance"))) {
            pvalue->m.endurancePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->endurance);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("maxDepth"))) {
            pvalue->m.maxDepthPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->maxDepth);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("maxPitchRate"))) {
            pvalue->m.maxPitchRatePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->maxPitchRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("maxSpeed"))) {
            pvalue->m.maxSpeedPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->maxSpeed);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("maxYawRate"))) {
            pvalue->m.maxYawRatePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->maxYawRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("turnRadius"))) {
            pvalue->m.turnRadiusPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->turnRadius);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_DegreesOfControlElementType (OSCTXT* pctxt, 
   DegreesOfControlElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("lateral"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->lateral);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("longitudinal"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->longitudinal);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("pitch"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->pitch);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("roll"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->roll);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("vertical"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->vertical);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("yaw"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->yaw);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_UuvCapabilityElementType (OSCTXT* pctxt, 
   UuvCapabilityElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("value"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               UuvCapabilityType_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->value);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_UuvCharacteristicsElementType (OSCTXT* pctxt, 
   UuvCharacteristicsElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Dimensions"))) {
            pvalue->m.dimensionsPresent = 1;
            DOMTest_DimensionsElementType (pctxt, &pvalue->dimensions, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("OperatingCharacteristics"))) {
            pvalue->m.operatingCharacteristicsPresent = 1;
            DOMTest_UuvOperatingCharacteristicsElementType (pctxt, &pvalue->operatingCharacteristics, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("DegreesOfControl"))) {
            pvalue->m.degreesOfControlPresent = 1;
            DOMTest_DegreesOfControlElementType (pctxt, &pvalue->degreesOfControl, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Capability"))) {
            { UuvCapabilityElementType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, UuvCapabilityElementType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UuvCapabilityElementType (pdata2);
            DOMTest_UuvCapabilityElementType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->capability_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_UgvOperatingCharacteristicsElementType (OSCTXT* pctxt, 
   UgvOperatingCharacteristicsElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("cruiseSpeed"))) {
            pvalue->m.cruiseSpeedPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->cruiseSpeed);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("endurance"))) {
            pvalue->m.endurancePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->endurance);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("maxSpeed"))) {
            pvalue->m.maxSpeedPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->maxSpeed);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("maxYawRate"))) {
            pvalue->m.maxYawRatePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->maxYawRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("staticPitchover"))) {
            pvalue->m.staticPitchoverPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->staticPitchover);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("staticRollover"))) {
            pvalue->m.staticRolloverPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->staticRollover);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("trackWidth"))) {
            pvalue->m.trackWidthPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->trackWidth);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("turnRadius"))) {
            pvalue->m.turnRadiusPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->turnRadius);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("wheelBase"))) {
            pvalue->m.wheelBasePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->wheelBase);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_UgvCapabilityElementType (OSCTXT* pctxt, 
   UgvCapabilityElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("value"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               UgvCapabilityType_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->value);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_UgvCharacteristicsElementType (OSCTXT* pctxt, 
   UgvCharacteristicsElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Dimensions"))) {
            pvalue->m.dimensionsPresent = 1;
            DOMTest_DimensionsElementType (pctxt, &pvalue->dimensions, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("OperatingCharacteristics"))) {
            pvalue->m.operatingCharacteristicsPresent = 1;
            DOMTest_UgvOperatingCharacteristicsElementType (pctxt, &pvalue->operatingCharacteristics, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("DegreesOfControl"))) {
            pvalue->m.degreesOfControlPresent = 1;
            DOMTest_DegreesOfControlElementType (pctxt, &pvalue->degreesOfControl, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Capability"))) {
            { UgvCapabilityElementType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, UgvCapabilityElementType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UgvCapabilityElementType (pdata2);
            DOMTest_UgvCapabilityElementType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->capability_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_UsvOperatingCharacteristicsElementType (OSCTXT* pctxt, 
   UsvOperatingCharacteristicsElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("cruiseSpeed"))) {
            pvalue->m.cruiseSpeedPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->cruiseSpeed);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("endurance"))) {
            pvalue->m.endurancePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->endurance);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("maxSpeed"))) {
            pvalue->m.maxSpeedPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->maxSpeed);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("maxYawRate"))) {
            pvalue->m.maxYawRatePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->maxYawRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("turnRadius"))) {
            pvalue->m.turnRadiusPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->turnRadius);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_UsvCapabilityElementType (OSCTXT* pctxt, 
   UsvCapabilityElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("value"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               UsvCapabilityType_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->value);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_UsvCharacteristicsElementType (OSCTXT* pctxt, 
   UsvCharacteristicsElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Dimensions"))) {
            pvalue->m.dimensionsPresent = 1;
            DOMTest_DimensionsElementType (pctxt, &pvalue->dimensions, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("OperatingCharacteristics"))) {
            pvalue->m.operatingCharacteristicsPresent = 1;
            DOMTest_UsvOperatingCharacteristicsElementType (pctxt, &pvalue->operatingCharacteristics, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("DegreesOfControl"))) {
            pvalue->m.degreesOfControlPresent = 1;
            DOMTest_DegreesOfControlElementType (pctxt, &pvalue->degreesOfControl, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Capability"))) {
            { UsvCapabilityElementType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, UsvCapabilityElementType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UsvCapabilityElementType (pdata2);
            DOMTest_UsvCapabilityElementType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->capability_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_UavOperatingCharacteristicsElementType (OSCTXT* pctxt, 
   UavOperatingCharacteristicsElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("cruiseSpeed"))) {
            pvalue->m.cruiseSpeedPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->cruiseSpeed);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("endurance"))) {
            pvalue->m.endurancePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->endurance);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("maxAltitude"))) {
            pvalue->m.maxAltitudePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->maxAltitude);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("maxPitchRate"))) {
            pvalue->m.maxPitchRatePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->maxPitchRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("maxRollRate"))) {
            pvalue->m.maxRollRatePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->maxRollRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("maxSpeed"))) {
            pvalue->m.maxSpeedPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->maxSpeed);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("maxYawRate"))) {
            pvalue->m.maxYawRatePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->maxYawRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_UavCapabilityElementType (OSCTXT* pctxt, 
   UavCapabilityElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("value"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               UavCapabilityType_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->value);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_UavCharacteristicsElementType (OSCTXT* pctxt, 
   UavCharacteristicsElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Dimensions"))) {
            pvalue->m.dimensionsPresent = 1;
            DOMTest_DimensionsElementType (pctxt, &pvalue->dimensions, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("OperatingCharacteristics"))) {
            pvalue->m.operatingCharacteristicsPresent = 1;
            DOMTest_UavOperatingCharacteristicsElementType (pctxt, &pvalue->operatingCharacteristics, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("DegreesOfControl"))) {
            pvalue->m.degreesOfControlPresent = 1;
            DOMTest_DegreesOfControlElementType (pctxt, &pvalue->degreesOfControl, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Capability"))) {
            { UavCapabilityElementType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, UavCapabilityElementType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UavCapabilityElementType (pdata2);
            DOMTest_UavCapabilityElementType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->capability_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_VehicleCharacteristicsGroup (OSCTXT* pctxt, 
   VehicleCharacteristicsGroup* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UUVCharacteristics"))) {
            pvalue->t = 1;
            pvalue->u.uUVCharacteristics
                = rtxMemAllocType (pctxt, UuvCharacteristicsElementType);

            if (pvalue->u.uUVCharacteristics == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UuvCharacteristicsElementType (pvalue->u.uUVCharacteristics);
            DOMTest_UuvCharacteristicsElementType (pctxt, pvalue->u.uUVCharacteristics, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UGVCharacteristics"))) {
            pvalue->t = 2;
            pvalue->u.uGVCharacteristics
                = rtxMemAllocType (pctxt, UgvCharacteristicsElementType);

            if (pvalue->u.uGVCharacteristics == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UgvCharacteristicsElementType (pvalue->u.uGVCharacteristics);
            DOMTest_UgvCharacteristicsElementType (pctxt, pvalue->u.uGVCharacteristics, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("USVCharacteristics"))) {
            pvalue->t = 3;
            pvalue->u.uSVCharacteristics
                = rtxMemAllocType (pctxt, UsvCharacteristicsElementType);

            if (pvalue->u.uSVCharacteristics == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UsvCharacteristicsElementType (pvalue->u.uSVCharacteristics);
            DOMTest_UsvCharacteristicsElementType (pctxt, pvalue->u.uSVCharacteristics, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UAVCharacteristics"))) {
            pvalue->t = 4;
            pvalue->u.uAVCharacteristics
                = rtxMemAllocType (pctxt, UavCharacteristicsElementType);

            if (pvalue->u.uAVCharacteristics == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UavCharacteristicsElementType (pvalue->u.uAVCharacteristics);
            DOMTest_UavCharacteristicsElementType (pctxt, pvalue->u.uAVCharacteristics, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_UuvVerticalPositionElementType (OSCTXT* pctxt, 
   UuvVerticalPositionElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("altitude"))) {
            pvalue->m.altitudePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->altitude);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("depth"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->depth);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_OrientationElementType (OSCTXT* pctxt, 
   OrientationElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("phi"))) {
            pvalue->m.phiPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->phi);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("psi"))) {
            pvalue->m.psiPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->psi);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("theta"))) {
            pvalue->m.thetaPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->theta);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_WorldCoordinateVelocityElementType (OSCTXT* pctxt, 
   WorldCoordinateVelocityElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("phiDot"))) {
            pvalue->m.phiDotPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->phiDot);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("psiDot"))) {
            pvalue->m.psiDotPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->psiDot);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("thetaDot"))) {
            pvalue->m.thetaDotPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->thetaDot);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("xDot"))) {
            pvalue->m.xDotPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->xDot);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("yDot"))) {
            pvalue->m.yDotPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->yDot);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("zDot"))) {
            pvalue->m.zDotPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->zDot);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_BodyCoordinateVelocityElementType (OSCTXT* pctxt, 
   BodyCoordinateVelocityElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("p"))) {
            pvalue->m.pPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->p);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("q"))) {
            pvalue->m.qPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->q);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("r"))) {
            pvalue->m.rPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->r);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("u"))) {
            pvalue->m.uPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->u);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("v"))) {
            pvalue->m.vPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->v);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("w"))) {
            pvalue->m.wPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->w);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_DopplerVelocityElementType (OSCTXT* pctxt, 
   DopplerVelocityElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("speedOverGroundU"))) {
            pvalue->m.speedOverGroundUPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->speedOverGroundU);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("speedOverGroundV"))) {
            pvalue->m.speedOverGroundVPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->speedOverGroundV);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("speedThroughMediumU"))) {
            pvalue->m.speedThroughMediumUPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->speedThroughMediumU);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("speedThroughMediumV"))) {
            pvalue->m.speedThroughMediumVPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->speedThroughMediumV);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_UuvTelemetryElementType (OSCTXT* pctxt, 
   UuvTelemetryElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   pvalue->_order.n = 0;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("GeographicPosition"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 0;
            pvalue->m.geographicPositionPresent = 1;
            DOMTest_AbsoluteHorizontalPositionElementType (pctxt, &pvalue->geographicPosition, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("VerticalPosition"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 1;
            pvalue->m.verticalPositionPresent = 1;
            DOMTest_UuvVerticalPositionElementType (pctxt, &pvalue->verticalPosition, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Orientation"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 2;
            pvalue->m.orientationPresent = 1;
            DOMTest_OrientationElementType (pctxt, &pvalue->orientation, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("WorldCoordinateVelocity"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 3;
            pvalue->m.worldCoordinateVelocityPresent = 1;
            DOMTest_WorldCoordinateVelocityElementType (pctxt, &pvalue->worldCoordinateVelocity, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("BodyCoordinateVelocity"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 4;
            pvalue->m.bodyCoordinateVelocityPresent = 1;
            DOMTest_BodyCoordinateVelocityElementType (pctxt, &pvalue->bodyCoordinateVelocity, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("DopplerVelocity"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 5;
            pvalue->m.dopplerVelocityPresent = 1;
            DOMTest_DopplerVelocityElementType (pctxt, &pvalue->dopplerVelocity, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RemainingPower"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 6;
            pvalue->m.remainingPowerPresent = 1;
            DOMTest_PercentElementType (pctxt, &pvalue->remainingPower, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_UsvTelemetryElementType (OSCTXT* pctxt, 
   UsvTelemetryElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   pvalue->_order.n = 0;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("GeographicPosition"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 0;
            pvalue->m.geographicPositionPresent = 1;
            DOMTest_AbsoluteHorizontalPositionElementType (pctxt, &pvalue->geographicPosition, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Orientation"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 1;
            pvalue->m.orientationPresent = 1;
            DOMTest_OrientationElementType (pctxt, &pvalue->orientation, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("WorldCoordinateVelocity"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 2;
            pvalue->m.worldCoordinateVelocityPresent = 1;
            DOMTest_WorldCoordinateVelocityElementType (pctxt, &pvalue->worldCoordinateVelocity, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("BodyCoordinateVelocity"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 3;
            pvalue->m.bodyCoordinateVelocityPresent = 1;
            DOMTest_BodyCoordinateVelocityElementType (pctxt, &pvalue->bodyCoordinateVelocity, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("DopplerVelocity"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 4;
            pvalue->m.dopplerVelocityPresent = 1;
            DOMTest_DopplerVelocityElementType (pctxt, &pvalue->dopplerVelocity, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RemainingPower"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 5;
            pvalue->m.remainingPowerPresent = 1;
            DOMTest_PercentElementType (pctxt, &pvalue->remainingPower, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_UgvVerticalPositionElementType (OSCTXT* pctxt, 
   UgvVerticalPositionElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("altitudeMSL"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->altitudeMSL);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_UgvTelemetryElementType (OSCTXT* pctxt, 
   UgvTelemetryElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   pvalue->_order.n = 0;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("GeographicPosition"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 0;
            pvalue->m.geographicPositionPresent = 1;
            DOMTest_AbsoluteHorizontalPositionElementType (pctxt, &pvalue->geographicPosition, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Altitude"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 1;
            pvalue->m.altitudePresent = 1;
            DOMTest_UgvVerticalPositionElementType (pctxt, &pvalue->altitude, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Orientation"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 2;
            pvalue->m.orientationPresent = 1;
            DOMTest_OrientationElementType (pctxt, &pvalue->orientation, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("WorldCoordinateVelocity"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 3;
            pvalue->m.worldCoordinateVelocityPresent = 1;
            DOMTest_WorldCoordinateVelocityElementType (pctxt, &pvalue->worldCoordinateVelocity, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("BodyCoordinateVelocity"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 4;
            pvalue->m.bodyCoordinateVelocityPresent = 1;
            DOMTest_BodyCoordinateVelocityElementType (pctxt, &pvalue->bodyCoordinateVelocity, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("DopplerVelocity"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 5;
            pvalue->m.dopplerVelocityPresent = 1;
            DOMTest_DopplerVelocityElementType (pctxt, &pvalue->dopplerVelocity, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RemainingPower"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 6;
            pvalue->m.remainingPowerPresent = 1;
            DOMTest_PercentElementType (pctxt, &pvalue->remainingPower, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_UavVerticalPositionElementType (OSCTXT* pctxt, 
   UavVerticalPositionElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("altitudeAGL"))) {
            pvalue->m.altitudeAGLPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->altitudeAGL);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("altitudeMSL"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->altitudeMSL);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_UavTelemetryElementType (OSCTXT* pctxt, 
   UavTelemetryElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   pvalue->_order.n = 0;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("GeographicPosition"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 0;
            pvalue->m.geographicPositionPresent = 1;
            DOMTest_AbsoluteHorizontalPositionElementType (pctxt, &pvalue->geographicPosition, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("VerticalPosition"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 1;
            pvalue->m.verticalPositionPresent = 1;
            DOMTest_UavVerticalPositionElementType (pctxt, &pvalue->verticalPosition, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Orientation"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 2;
            pvalue->m.orientationPresent = 1;
            DOMTest_OrientationElementType (pctxt, &pvalue->orientation, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("WorldCoordinateVelocity"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 3;
            pvalue->m.worldCoordinateVelocityPresent = 1;
            DOMTest_WorldCoordinateVelocityElementType (pctxt, &pvalue->worldCoordinateVelocity, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("BodyCoordinateVelocity"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 4;
            pvalue->m.bodyCoordinateVelocityPresent = 1;
            DOMTest_BodyCoordinateVelocityElementType (pctxt, &pvalue->bodyCoordinateVelocity, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("DopplerVelocity"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 5;
            pvalue->m.dopplerVelocityPresent = 1;
            DOMTest_DopplerVelocityElementType (pctxt, &pvalue->dopplerVelocity, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RemainingPower"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 6;
            pvalue->m.remainingPowerPresent = 1;
            DOMTest_PercentElementType (pctxt, &pvalue->remainingPower, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_DiscreteTimeResultsElementType_choice (OSCTXT* pctxt, 
   DiscreteTimeResultsElementType_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UUVTelemetry"))) {
            pvalue->t = 1;
            pvalue->u.uUVTelemetry
                = rtxMemAllocType (pctxt, UuvTelemetryElementType);

            if (pvalue->u.uUVTelemetry == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UuvTelemetryElementType (pvalue->u.uUVTelemetry);
            DOMTest_UuvTelemetryElementType (pctxt, pvalue->u.uUVTelemetry, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("USVTelemetry"))) {
            pvalue->t = 2;
            pvalue->u.uSVTelemetry
                = rtxMemAllocType (pctxt, UsvTelemetryElementType);

            if (pvalue->u.uSVTelemetry == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UsvTelemetryElementType (pvalue->u.uSVTelemetry);
            DOMTest_UsvTelemetryElementType (pctxt, pvalue->u.uSVTelemetry, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UGVTelemetry"))) {
            pvalue->t = 3;
            pvalue->u.uGVTelemetry
                = rtxMemAllocType (pctxt, UgvTelemetryElementType);

            if (pvalue->u.uGVTelemetry == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UgvTelemetryElementType (pvalue->u.uGVTelemetry);
            DOMTest_UgvTelemetryElementType (pctxt, pvalue->u.uGVTelemetry, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UAVTelemetry"))) {
            pvalue->t = 4;
            pvalue->u.uAVTelemetry
                = rtxMemAllocType (pctxt, UavTelemetryElementType);

            if (pvalue->u.uAVTelemetry == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UavTelemetryElementType (pvalue->u.uAVTelemetry);
            DOMTest_UavTelemetryElementType (pctxt, pvalue->u.uAVTelemetry, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_UuvPropellersOrderElementType (OSCTXT* pctxt, 
   UuvPropellersOrderElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("all"))) {
            pvalue->m.allPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->all);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("centerline"))) {
            pvalue->m.centerlinePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->centerline);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("port"))) {
            pvalue->m.portPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->port);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("starboard"))) {
            pvalue->m.starboardPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->starboard);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_UuvPlanesOrderElementType (OSCTXT* pctxt, 
   UuvPlanesOrderElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("bow"))) {
            pvalue->m.bowPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->bow);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("stern"))) {
            pvalue->m.sternPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->stern);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_UuvBodyThrustersOrderElementType (OSCTXT* pctxt, 
   UuvBodyThrustersOrderElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("bowLateral"))) {
            pvalue->m.bowLateralPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->bowLateral);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("bowVertical"))) {
            pvalue->m.bowVerticalPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->bowVertical);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("sternLateral"))) {
            pvalue->m.sternLateralPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->sternLateral);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("sternVertical"))) {
            pvalue->m.sternVerticalPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->sternVertical);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_UuvControlOrdersElementType (OSCTXT* pctxt, 
   UuvControlOrdersElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   pvalue->_order.n = 0;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Propellers"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 0;
            pvalue->m.propellersPresent = 1;
            DOMTest_UuvPropellersOrderElementType (pctxt, &pvalue->propellers, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Rudder"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 1;
            pvalue->m.rudderPresent = 1;
            DOMTest_ScalarElementType (pctxt, &pvalue->rudder, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Planes"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 2;
            pvalue->m.planesPresent = 1;
            DOMTest_UuvPlanesOrderElementType (pctxt, &pvalue->planes, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("BodyThrusters"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 3;
            pvalue->m.bodyThrustersPresent = 1;
            DOMTest_UuvBodyThrustersOrderElementType (pctxt, &pvalue->bodyThrusters, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_UsvPropellersOrderElementType (OSCTXT* pctxt, 
   UsvPropellersOrderElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("all"))) {
            pvalue->m.allPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->all);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("centerline"))) {
            pvalue->m.centerlinePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->centerline);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("port"))) {
            pvalue->m.portPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->port);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("starboard"))) {
            pvalue->m.starboardPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->starboard);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_UsvControlOrdersElementType (OSCTXT* pctxt, 
   UsvControlOrdersElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   pvalue->_order.n = 0;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Propellers"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 0;
            pvalue->m.propellersPresent = 1;
            DOMTest_UsvPropellersOrderElementType (pctxt, &pvalue->propellers, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Rudder"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 1;
            pvalue->m.rudderPresent = 1;
            DOMTest_SignedPercentElementType (pctxt, &pvalue->rudder, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_UgvControlOrdersElementType (OSCTXT* pctxt, 
   UgvControlOrdersElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   pvalue->_order.n = 0;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PlaceHolder"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 0;
            pvalue->m.placeHolderPresent = 1;
            DOMTest_NoValueElementType (pctxt, &pvalue->placeHolder, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_UavEnginesOrdersElementType (OSCTXT* pctxt, 
   UavEnginesOrdersElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("engine1"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->engine1);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("engine2"))) {
            pvalue->m.engine2Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->engine2);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_UavStabilatorOrderElementType (OSCTXT* pctxt, 
   UavStabilatorOrderElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("port"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->port);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("starboard"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->starboard);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_FixedWingUAVControlOrders (OSCTXT* pctxt, 
   FixedWingUAVControlOrders* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Engines"))) {
            pvalue->m.enginesPresent = 1;
            DOMTest_UavEnginesOrdersElementType (pctxt, &pvalue->engines, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Aileron"))) {
            pvalue->m.aileronPresent = 1;
            DOMTest_SignedPercentElementType (pctxt, &pvalue->aileron, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Rudder"))) {
            pvalue->m.rudderPresent = 1;
            DOMTest_SignedPercentElementType (pctxt, &pvalue->rudder, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Elevator"))) {
            pvalue->m.elevatorPresent = 1;
            DOMTest_UavStabilatorOrderElementType (pctxt, &pvalue->elevator, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_UavCyclicOrderElementType (OSCTXT* pctxt, 
   UavCyclicOrderElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("foreAft"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->foreAft);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("lateral"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->lateral);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_RotaryWingUAVControlOrders (OSCTXT* pctxt, 
   RotaryWingUAVControlOrders* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Collective"))) {
            pvalue->m.collectivePresent = 1;
            DOMTest_SignedPercentElementType (pctxt, &pvalue->collective, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Cyclic"))) {
            pvalue->m.cyclicPresent = 1;
            DOMTest_UavCyclicOrderElementType (pctxt, &pvalue->cyclic, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Pedals"))) {
            pvalue->m.pedalsPresent = 1;
            DOMTest_SignedPercentElementType (pctxt, &pvalue->pedals, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_UavControlOrdersElementType_choice (OSCTXT* pctxt, 
   UavControlOrdersElementType_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Engines")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Aileron")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Rudder")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Elevator"))) {
            pvalue->t = 1;
            pvalue->u.fixedWingUAVControlOrders
                = rtxMemAllocType (pctxt, FixedWingUAVControlOrders);

            if (pvalue->u.fixedWingUAVControlOrders == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FixedWingUAVControlOrders (pvalue->u.fixedWingUAVControlOrders);
            DOMTest_FixedWingUAVControlOrders (pctxt, pvalue->u.fixedWingUAVControlOrders, pXmlNode, FALSE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Collective")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Cyclic")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Pedals"))) {
            pvalue->t = 2;
            pvalue->u.rotaryWingUAVControlOrders
                = rtxMemAllocType (pctxt, RotaryWingUAVControlOrders);

            if (pvalue->u.rotaryWingUAVControlOrders == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RotaryWingUAVControlOrders (pvalue->u.rotaryWingUAVControlOrders);
            DOMTest_RotaryWingUAVControlOrders (pctxt, pvalue->u.rotaryWingUAVControlOrders, pXmlNode, FALSE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_UavControlOrdersElementType (OSCTXT* pctxt, 
   UavControlOrdersElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Engines")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Aileron")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Rudder")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Elevator")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Collective")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Cyclic")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Pedals"))) {
            DOMTest_UavControlOrdersElementType_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_DiscreteTimeResultsElementType_choice_1 (OSCTXT* pctxt, 
   DiscreteTimeResultsElementType_choice_1* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UUVControlOrder"))) {
            pvalue->t = 1;
            pvalue->u.uUVControlOrder
                = rtxMemAllocType (pctxt, UuvControlOrdersElementType);

            if (pvalue->u.uUVControlOrder == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UuvControlOrdersElementType (pvalue->u.uUVControlOrder);
            DOMTest_UuvControlOrdersElementType (pctxt, pvalue->u.uUVControlOrder, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("USVControlOrder"))) {
            pvalue->t = 2;
            pvalue->u.uSVControlOrder
                = rtxMemAllocType (pctxt, UsvControlOrdersElementType);

            if (pvalue->u.uSVControlOrder == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UsvControlOrdersElementType (pvalue->u.uSVControlOrder);
            DOMTest_UsvControlOrdersElementType (pctxt, pvalue->u.uSVControlOrder, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UGVControlOrder"))) {
            pvalue->t = 3;
            pvalue->u.uGVControlOrder
                = rtxMemAllocType (pctxt, UgvControlOrdersElementType);

            if (pvalue->u.uGVControlOrder == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UgvControlOrdersElementType (pvalue->u.uGVControlOrder);
            DOMTest_UgvControlOrdersElementType (pctxt, pvalue->u.uGVControlOrder, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UAVControlOrder"))) {
            pvalue->t = 4;
            pvalue->u.uAVControlOrder
                = rtxMemAllocType (pctxt, UavControlOrdersElementType);

            if (pvalue->u.uAVControlOrder == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UavControlOrdersElementType (pvalue->u.uAVControlOrder);
            DOMTest_UavControlOrdersElementType (pctxt, pvalue->u.uAVControlOrder, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_SensorElements_activeSonar (OSCTXT* pctxt, 
   SensorElements_activeSonar* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("bearing"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->bearing);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("elevation"))) {
            pvalue->m.elevationPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->elevation);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("model"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->model = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->model = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("range"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->range);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("strength"))) {
            pvalue->m.strengthPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->strength);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_SensorElements_imagingSonar (OSCTXT* pctxt, 
   SensorElements_imagingSonar* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("model"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->model = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->model = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_SensorElements_blazedArraySonar (OSCTXT* pctxt, 
   SensorElements_blazedArraySonar* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("model"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->model = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->model = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_SensorElements_syntheticApertureSonar (OSCTXT* pctxt, 
   SensorElements_syntheticApertureSonar* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("model"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->model = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->model = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_SensorElements_passiveSonar (OSCTXT* pctxt, 
   SensorElements_passiveSonar* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("bearing"))) {
            pvalue->m.bearingPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->bearing);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("frequency"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->frequency);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("model"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->model = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->model = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("strength"))) {
            pvalue->m.strengthPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->strength);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_SensorElements_radar (OSCTXT* pctxt, SensorElements_radar* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("altitude"))) {
            pvalue->m.altitudePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->altitude);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("bearing"))) {
            pvalue->m.bearingPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->bearing);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("elevation"))) {
            pvalue->m.elevationPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->elevation);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("heading"))) {
            pvalue->m.headingPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->heading);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode1"))) {
            pvalue->m.mode1Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode1 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode2"))) {
            pvalue->m.mode2Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode2 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode3"))) {
            pvalue->m.mode3Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode3 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode4"))) {
            pvalue->m.mode4Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->mode4);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("modeC"))) {
            pvalue->m.modeCPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->modeC = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("model"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->model = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->model = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("range"))) {
            pvalue->m.rangePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->range);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("velocity"))) {
            pvalue->m.velocityPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->velocity);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_SensorElements_dopplerRadar (OSCTXT* pctxt, 
   SensorElements_dopplerRadar* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("altitude"))) {
            pvalue->m.altitudePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->altitude);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("bearing"))) {
            pvalue->m.bearingPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->bearing);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("elevation"))) {
            pvalue->m.elevationPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->elevation);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("heading"))) {
            pvalue->m.headingPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->heading);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode1"))) {
            pvalue->m.mode1Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode1 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode2"))) {
            pvalue->m.mode2Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode2 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode3"))) {
            pvalue->m.mode3Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode3 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode4"))) {
            pvalue->m.mode4Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->mode4);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("modeC"))) {
            pvalue->m.modeCPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->modeC = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("model"))) {
            pvalue->m.modelPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->model = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->model = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("range"))) {
            pvalue->m.rangePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->range);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("velocity"))) {
            pvalue->m.velocityPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->velocity);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_SensorElements_syntheticApertureRadar (OSCTXT* pctxt, 
   SensorElements_syntheticApertureRadar* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("altitude"))) {
            pvalue->m.altitudePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->altitude);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("bearing"))) {
            pvalue->m.bearingPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->bearing);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("elevation"))) {
            pvalue->m.elevationPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->elevation);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("heading"))) {
            pvalue->m.headingPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->heading);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode1"))) {
            pvalue->m.mode1Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode1 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode2"))) {
            pvalue->m.mode2Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode2 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode3"))) {
            pvalue->m.mode3Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode3 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode4"))) {
            pvalue->m.mode4Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->mode4);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("modeC"))) {
            pvalue->m.modeCPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->modeC = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("model"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->model = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->model = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("range"))) {
            pvalue->m.rangePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->range);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("velocity"))) {
            pvalue->m.velocityPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->velocity);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_SensorElements_trackWhileScanRadar_track (OSCTXT* pctxt, 
   SensorElements_trackWhileScanRadar_track* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("altitude"))) {
            pvalue->m.altitudePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->altitude);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("bearing"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->bearing);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("heading"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->heading);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode1"))) {
            pvalue->m.mode1Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode1 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode2"))) {
            pvalue->m.mode2Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode2 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode3"))) {
            pvalue->m.mode3Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode3 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode4"))) {
            pvalue->m.mode4Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->mode4);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("modeC"))) {
            pvalue->m.modeCPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->modeC = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("range"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->range);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("trackID"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->trackID = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->trackID = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("velocity"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->velocity);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_SensorElements_trackWhileScanRadar (OSCTXT* pctxt, 
   SensorElements_trackWhileScanRadar* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("model"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->model = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->model = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Track"))) {
            { SensorElements_trackWhileScanRadar_track* pdata2;
            pdata2
                = rtxMemAllocType (pctxt, SensorElements_trackWhileScanRadar_track);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SensorElements_trackWhileScanRadar_track (pdata2);
            DOMTest_SensorElements_trackWhileScanRadar_track (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->track_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_SensorElements_earlyWarningRadar (OSCTXT* pctxt, 
   SensorElements_earlyWarningRadar* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("altitude"))) {
            pvalue->m.altitudePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->altitude);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("bearing"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->bearing);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("heading"))) {
            pvalue->m.headingPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->heading);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode1"))) {
            pvalue->m.mode1Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode1 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode2"))) {
            pvalue->m.mode2Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode2 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode3"))) {
            pvalue->m.mode3Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode3 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode4"))) {
            pvalue->m.mode4Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->mode4);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("modeC"))) {
            pvalue->m.modeCPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->modeC = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("model"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->model = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->model = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("range"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->range);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("velocity"))) {
            pvalue->m.velocityPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->velocity);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_SensorElements_acquisitionRadar (OSCTXT* pctxt, 
   SensorElements_acquisitionRadar* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("altitude"))) {
            pvalue->m.altitudePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->altitude);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("bearing"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->bearing);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("heading"))) {
            pvalue->m.headingPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->heading);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode1"))) {
            pvalue->m.mode1Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode1 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode2"))) {
            pvalue->m.mode2Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode2 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode3"))) {
            pvalue->m.mode3Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode3 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode4"))) {
            pvalue->m.mode4Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->mode4);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("modeC"))) {
            pvalue->m.modeCPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->modeC = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("model"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->model = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->model = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("range"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->range);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("velocity"))) {
            pvalue->m.velocityPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->velocity);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_SensorElements_trackingRadar (OSCTXT* pctxt, 
   SensorElements_trackingRadar* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("altitude"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->altitude);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("bearing"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->bearing);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("heading"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->heading);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode1"))) {
            pvalue->m.mode1Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode1 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode2"))) {
            pvalue->m.mode2Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode2 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode3"))) {
            pvalue->m.mode3Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode3 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode4"))) {
            pvalue->m.mode4Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->mode4);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("modeC"))) {
            pvalue->m.modeCPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->modeC = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("model"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->model = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->model = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("range"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->range);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("velocity"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->velocity);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_SensorElements_fireControlRadar (OSCTXT* pctxt, 
   SensorElements_fireControlRadar* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("altitude"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->altitude);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("bearing"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->bearing);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("heading"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->heading);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode1"))) {
            pvalue->m.mode1Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode1 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode2"))) {
            pvalue->m.mode2Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode2 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode3"))) {
            pvalue->m.mode3Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode3 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode4"))) {
            pvalue->m.mode4Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->mode4);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("modeC"))) {
            pvalue->m.modeCPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->modeC = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("model"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->model = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->model = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("range"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->range);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("velocity"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->velocity);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_SensorElements_surfaceSearchRadar (OSCTXT* pctxt, 
   SensorElements_surfaceSearchRadar* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("bearing"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->bearing);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("heading"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->heading);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode1"))) {
            pvalue->m.mode1Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode1 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode2"))) {
            pvalue->m.mode2Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode2 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode3"))) {
            pvalue->m.mode3Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mode3 = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mode4"))) {
            pvalue->m.mode4Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->mode4);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("modeC"))) {
            pvalue->m.modeCPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->modeC = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("model"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->model = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->model = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("range"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->range);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("velocity"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->velocity);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_SensorElements_eSM (OSCTXT* pctxt, SensorElements_eSM* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("bearing"))) {
            pvalue->m.bearingPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->bearing);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("frequency"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->frequency);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("model"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->model = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->model = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("strength"))) {
            pvalue->m.strengthPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->strength);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_SensorElements_passiveSoundDetection (OSCTXT* pctxt, 
   SensorElements_passiveSoundDetection* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("bearing"))) {
            pvalue->m.bearingPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->bearing);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("frequency"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->frequency);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("model"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->model = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->model = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("strength"))) {
            pvalue->m.strengthPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->strength);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_SensorElements_chemicalBiologicalRadiologicalDetection (OSCTXT* pctxt, 
   SensorElements_chemicalBiologicalRadiologicalDetection* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("magnitude"))) {
            pvalue->m.magnitudePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->magnitude);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("model"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->model = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->model = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("substance"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->substance = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->substance = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_SensorElements_video (OSCTXT* pctxt, SensorElements_video* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("model"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->model = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->model = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_SensorElements_fLIR (OSCTXT* pctxt, SensorElements_fLIR* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("model"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->model = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->model = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_SensorElements_motionSensor (OSCTXT* pctxt, 
   SensorElements_motionSensor* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("model"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->model = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->model = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_SensorElements (OSCTXT* pctxt, SensorElements* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ActiveSonar"))) {
            pvalue->t = 1;
            pvalue->u.activeSonar
                = rtxMemAllocType (pctxt, SensorElements_activeSonar);

            if (pvalue->u.activeSonar == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SensorElements_activeSonar (pvalue->u.activeSonar);
            DOMTest_SensorElements_activeSonar (pctxt, pvalue->u.activeSonar, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ImagingSonar"))) {
            pvalue->t = 2;
            pvalue->u.imagingSonar
                = rtxMemAllocType (pctxt, SensorElements_imagingSonar);

            if (pvalue->u.imagingSonar == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SensorElements_imagingSonar (pvalue->u.imagingSonar);
            DOMTest_SensorElements_imagingSonar (pctxt, pvalue->u.imagingSonar, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("BlazedArraySonar"))) {
            pvalue->t = 3;
            pvalue->u.blazedArraySonar
                = rtxMemAllocType (pctxt, SensorElements_blazedArraySonar);

            if (pvalue->u.blazedArraySonar == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SensorElements_blazedArraySonar (pvalue->u.blazedArraySonar);
            DOMTest_SensorElements_blazedArraySonar (pctxt, pvalue->u.blazedArraySonar, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SyntheticApertureSonar"))) {
            pvalue->t = 4;
            pvalue->u.syntheticApertureSonar
                = rtxMemAllocType (pctxt, SensorElements_syntheticApertureSonar);

            if (pvalue->u.syntheticApertureSonar == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SensorElements_syntheticApertureSonar (pvalue->u.syntheticApertureSonar);
            DOMTest_SensorElements_syntheticApertureSonar (pctxt, pvalue->u.syntheticApertureSonar, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PassiveSonar"))) {
            pvalue->t = 5;
            pvalue->u.passiveSonar
                = rtxMemAllocType (pctxt, SensorElements_passiveSonar);

            if (pvalue->u.passiveSonar == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SensorElements_passiveSonar (pvalue->u.passiveSonar);
            DOMTest_SensorElements_passiveSonar (pctxt, pvalue->u.passiveSonar, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Radar"))) {
            pvalue->t = 6;
            pvalue->u.radar = rtxMemAllocType (pctxt, SensorElements_radar);

            if (pvalue->u.radar == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SensorElements_radar (pvalue->u.radar);
            DOMTest_SensorElements_radar (pctxt, pvalue->u.radar, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("DopplerRadar"))) {
            pvalue->t = 7;
            pvalue->u.dopplerRadar
                = rtxMemAllocType (pctxt, SensorElements_dopplerRadar);

            if (pvalue->u.dopplerRadar == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SensorElements_dopplerRadar (pvalue->u.dopplerRadar);
            DOMTest_SensorElements_dopplerRadar (pctxt, pvalue->u.dopplerRadar, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SyntheticApertureRadar"))) {
            pvalue->t = 8;
            pvalue->u.syntheticApertureRadar
                = rtxMemAllocType (pctxt, SensorElements_syntheticApertureRadar);

            if (pvalue->u.syntheticApertureRadar == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SensorElements_syntheticApertureRadar (pvalue->u.syntheticApertureRadar);
            DOMTest_SensorElements_syntheticApertureRadar (pctxt, pvalue->u.syntheticApertureRadar, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TrackWhileScanRadar"))) {
            pvalue->t = 9;
            pvalue->u.trackWhileScanRadar
                = rtxMemAllocType (pctxt, SensorElements_trackWhileScanRadar);

            if (pvalue->u.trackWhileScanRadar == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SensorElements_trackWhileScanRadar (pvalue->u.trackWhileScanRadar);
            DOMTest_SensorElements_trackWhileScanRadar (pctxt, pvalue->u.trackWhileScanRadar, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("EarlyWarningRadar"))) {
            pvalue->t = 10;
            pvalue->u.earlyWarningRadar
                = rtxMemAllocType (pctxt, SensorElements_earlyWarningRadar);

            if (pvalue->u.earlyWarningRadar == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SensorElements_earlyWarningRadar (pvalue->u.earlyWarningRadar);
            DOMTest_SensorElements_earlyWarningRadar (pctxt, pvalue->u.earlyWarningRadar, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AcquisitionRadar"))) {
            pvalue->t = 11;
            pvalue->u.acquisitionRadar
                = rtxMemAllocType (pctxt, SensorElements_acquisitionRadar);

            if (pvalue->u.acquisitionRadar == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SensorElements_acquisitionRadar (pvalue->u.acquisitionRadar);
            DOMTest_SensorElements_acquisitionRadar (pctxt, pvalue->u.acquisitionRadar, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TrackingRadar"))) {
            pvalue->t = 12;
            pvalue->u.trackingRadar
                = rtxMemAllocType (pctxt, SensorElements_trackingRadar);

            if (pvalue->u.trackingRadar == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SensorElements_trackingRadar (pvalue->u.trackingRadar);
            DOMTest_SensorElements_trackingRadar (pctxt, pvalue->u.trackingRadar, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("FireControlRadar"))) {
            pvalue->t = 13;
            pvalue->u.fireControlRadar
                = rtxMemAllocType (pctxt, SensorElements_fireControlRadar);

            if (pvalue->u.fireControlRadar == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SensorElements_fireControlRadar (pvalue->u.fireControlRadar);
            DOMTest_SensorElements_fireControlRadar (pctxt, pvalue->u.fireControlRadar, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SurfaceSearchRadar"))) {
            pvalue->t = 14;
            pvalue->u.surfaceSearchRadar
                = rtxMemAllocType (pctxt, SensorElements_surfaceSearchRadar);

            if (pvalue->u.surfaceSearchRadar == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SensorElements_surfaceSearchRadar (pvalue->u.surfaceSearchRadar);
            DOMTest_SensorElements_surfaceSearchRadar (pctxt, pvalue->u.surfaceSearchRadar, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ESM"))) {
            pvalue->t = 15;
            pvalue->u.eSM = rtxMemAllocType (pctxt, SensorElements_eSM);

            if (pvalue->u.eSM == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SensorElements_eSM (pvalue->u.eSM);
            DOMTest_SensorElements_eSM (pctxt, pvalue->u.eSM, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PassiveSoundDetection"))) {
            pvalue->t = 16;
            pvalue->u.passiveSoundDetection
                = rtxMemAllocType (pctxt, SensorElements_passiveSoundDetection);

            if (pvalue->u.passiveSoundDetection == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SensorElements_passiveSoundDetection (pvalue->u.passiveSoundDetection);
            DOMTest_SensorElements_passiveSoundDetection (pctxt, pvalue->u.passiveSoundDetection, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ChemicalBiologicalRadiologicalDetection"))) {
            pvalue->t = 17;
            pvalue->u.chemicalBiologicalRadiologicalDetection
                = rtxMemAllocType (pctxt, SensorElements_chemicalBiologicalRadiologicalDetection);

            if (pvalue->u.chemicalBiologicalRadiologicalDetection == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SensorElements_chemicalBiologicalRadiologicalDetection (pvalue->u.chemicalBiologicalRadiologicalDetection);
            DOMTest_SensorElements_chemicalBiologicalRadiologicalDetection (pctxt, pvalue->u.chemicalBiologicalRadiologicalDetection, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Video"))) {
            pvalue->t = 18;
            pvalue->u.video = rtxMemAllocType (pctxt, SensorElements_video);

            if (pvalue->u.video == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SensorElements_video (pvalue->u.video);
            DOMTest_SensorElements_video (pctxt, pvalue->u.video, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("FLIR"))) {
            pvalue->t = 19;
            pvalue->u.fLIR = rtxMemAllocType (pctxt, SensorElements_fLIR);

            if (pvalue->u.fLIR == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SensorElements_fLIR (pvalue->u.fLIR);
            DOMTest_SensorElements_fLIR (pctxt, pvalue->u.fLIR, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MotionSensor"))) {
            pvalue->t = 20;
            pvalue->u.motionSensor
                = rtxMemAllocType (pctxt, SensorElements_motionSensor);

            if (pvalue->u.motionSensor == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SensorElements_motionSensor (pvalue->u.motionSensor);
            DOMTest_SensorElements_motionSensor (pctxt, pvalue->u.motionSensor, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_SensorElementType (OSCTXT* pctxt, SensorElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ActiveSonar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ImagingSonar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("BlazedArraySonar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SyntheticApertureSonar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PassiveSonar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Radar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("DopplerRadar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SyntheticApertureRadar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TrackWhileScanRadar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("EarlyWarningRadar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AcquisitionRadar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TrackingRadar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("FireControlRadar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SurfaceSearchRadar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ESM")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PassiveSoundDetection")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ChemicalBiologicalRadiologicalDetection")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Video")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("FLIR")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MotionSensor"))) {
            { SensorElements* pdata2;
            pdata2 = rtxMemAllocType (pctxt, SensorElements);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SensorElements (pdata2);
            DOMTest_SensorElements (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_WeaponElementType (OSCTXT* pctxt, WeaponElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_DiscreteTimeResultsElementType (OSCTXT* pctxt, 
   DiscreteTimeResultsElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UUVTelemetry")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("USVTelemetry")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UGVTelemetry")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UAVTelemetry"))) {
            pvalue->m.choicePresent = 1;
            DOMTest_DiscreteTimeResultsElementType_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UUVControlOrder")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("USVControlOrder")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UGVControlOrder")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UAVControlOrder"))) {
            pvalue->m.choice_1Present = 1;
            DOMTest_DiscreteTimeResultsElementType_choice_1 (pctxt, &pvalue->choice_1, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Sensor"))) {
            pvalue->m.sensorPresent = 1;
            DOMTest_SensorElementType (pctxt, &pvalue->sensor, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Weapon"))) {
            pvalue->m.weaponPresent = 1;
            DOMTest_WeaponElementType (pctxt, &pvalue->weapon, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_UuvLoggableEventType_element (OSCTXT* pctxt, 
   UuvLoggableEventType_element* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("CompositeWaypoint"))) {
            pvalue->t = 1;
            pvalue->u.compositeWaypoint
                = rtxMemAllocType (pctxt, UuvCompositeWaypointCommandType);

            if (pvalue->u.compositeWaypoint == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UuvCompositeWaypointCommandType (pvalue->u.compositeWaypoint);
            DOMTest_UuvCompositeWaypointCommandType (pctxt, pvalue->u.compositeWaypoint, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("FollowBeacon"))) {
            pvalue->t = 2;
            pvalue->u.followBeacon
                = rtxMemAllocType (pctxt, FollowBeaconCommandType);

            if (pvalue->u.followBeacon == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FollowBeaconCommandType (pvalue->u.followBeacon);
            DOMTest_FollowBeaconCommandType (pctxt, pvalue->u.followBeacon, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("GpsFix"))) {
            pvalue->t = 3;
            pvalue->u.gpsFix = rtxMemAllocType (pctxt, GpsFixCommandType);

            if (pvalue->u.gpsFix == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_GpsFixCommandType (pvalue->u.gpsFix);
            DOMTest_GpsFixCommandType (pctxt, pvalue->u.gpsFix, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Help"))) {
            pvalue->t = 4;
            pvalue->u.help = rtxMemAllocType (pctxt, NoValueElementType);

            if (pvalue->u.help == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NoValueElementType (pvalue->u.help);
            DOMTest_NoValueElementType (pctxt, pvalue->u.help, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Hover"))) {
            pvalue->t = 5;
            pvalue->u.hover = rtxMemAllocType (pctxt, HoverCommandType);

            if (pvalue->u.hover == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_HoverCommandType (pvalue->u.hover);
            DOMTest_HoverCommandType (pctxt, pvalue->u.hover, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Loiter"))) {
            pvalue->t = 6;
            pvalue->u.loiter = rtxMemAllocType (pctxt, UuvLoiterCommandType);

            if (pvalue->u.loiter == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UuvLoiterCommandType (pvalue->u.loiter);
            DOMTest_UuvLoiterCommandType (pctxt, pvalue->u.loiter, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeAltitude"))) {
            pvalue->t = 7;
            pvalue->u.makeAltitude
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.makeAltitude == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeAltitude);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.makeAltitude, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeDepth"))) {
            pvalue->t = 8;
            pvalue->u.makeDepth
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.makeDepth == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeDepth);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.makeDepth, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeHeading"))) {
            pvalue->t = 9;
            pvalue->u.makeHeading
                = rtxMemAllocType (pctxt, HeadingElementType);

            if (pvalue->u.makeHeading == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_HeadingElementType (pvalue->u.makeHeading);
            DOMTest_HeadingElementType (pctxt, pvalue->u.makeHeading, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeKnots"))) {
            pvalue->t = 10;
            pvalue->u.makeKnots = rtxMemAllocType (pctxt, SpeedElementType);

            if (pvalue->u.makeKnots == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SpeedElementType (pvalue->u.makeKnots);
            DOMTest_SpeedElementType (pctxt, pvalue->u.makeKnots, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeSpeed"))) {
            pvalue->t = 11;
            pvalue->u.makeSpeed = rtxMemAllocType (pctxt, SpeedElementType);

            if (pvalue->u.makeSpeed == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SpeedElementType (pvalue->u.makeSpeed);
            DOMTest_SpeedElementType (pctxt, pvalue->u.makeSpeed, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MetaCommand"))) {
            pvalue->t = 12;
            pvalue->u.metaCommand = rtxMemAllocType (pctxt, MetaDataType);

            if (pvalue->u.metaCommand == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MetaDataType (pvalue->u.metaCommand);
            DOMTest_MetaDataType (pctxt, pvalue->u.metaCommand, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScript"))) {
            pvalue->t = 13;
            pvalue->u.missionScript
                = rtxMemAllocType (pctxt, StringElementType);

            if (pvalue->u.missionScript == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StringElementType (pvalue->u.missionScript);
            DOMTest_StringElementType (pctxt, pvalue->u.missionScript, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScriptInline"))) {
            pvalue->t = 14;
            pvalue->u.missionScriptInline
                = rtxMemAllocType (pctxt, StringElementType);

            if (pvalue->u.missionScriptInline == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StringElementType (pvalue->u.missionScriptInline);
            DOMTest_StringElementType (pctxt, pvalue->u.missionScriptInline, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MoveLateral"))) {
            pvalue->t = 15;
            pvalue->u.moveLateral
                = rtxMemAllocType (pctxt, ScalarElementType);

            if (pvalue->u.moveLateral == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ScalarElementType (pvalue->u.moveLateral);
            DOMTest_ScalarElementType (pctxt, pvalue->u.moveLateral, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MoveRotate"))) {
            pvalue->t = 16;
            pvalue->u.moveRotate = rtxMemAllocType (pctxt, ScalarElementType);

            if (pvalue->u.moveRotate == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ScalarElementType (pvalue->u.moveRotate);
            DOMTest_ScalarElementType (pctxt, pvalue->u.moveRotate, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Quit"))) {
            pvalue->t = 17;
            pvalue->u.quit = rtxMemAllocType (pctxt, QuitCommandType);

            if (pvalue->u.quit == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_QuitCommandType (pvalue->u.quit);
            DOMTest_QuitCommandType (pctxt, pvalue->u.quit, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Realtime"))) {
            pvalue->t = 18;
            pvalue->u.realtime
                = rtxMemAllocType (pctxt, BooleanElementType_derivations);

            if (pvalue->u.realtime == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BooleanElementType_derivations (pvalue->u.realtime);
            DOMTest_BooleanElementType_derivations (pctxt, pvalue->u.realtime, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Recover"))) {
            pvalue->t = 19;
            pvalue->u.recover = rtxMemAllocType (pctxt, RecoverCommandType);

            if (pvalue->u.recover == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RecoverCommandType (pvalue->u.recover);
            DOMTest_RecoverCommandType (pctxt, pvalue->u.recover, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SendMessage"))) {
            pvalue->t = 20;
            pvalue->u.sendMessage
                = rtxMemAllocType (pctxt, SendMessageCommandType);

            if (pvalue->u.sendMessage == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SendMessageCommandType (pvalue->u.sendMessage);
            DOMTest_SendMessageCommandType (pctxt, pvalue->u.sendMessage, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPlanes"))) {
            pvalue->t = 21;
            pvalue->u.setPlanes
                = rtxMemAllocType (pctxt, SetPlanesCommandType);

            if (pvalue->u.setPlanes == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SetPlanesCommandType (pvalue->u.setPlanes);
            DOMTest_SetPlanesCommandType (pctxt, pvalue->u.setPlanes, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPosition"))) {
            pvalue->t = 22;
            pvalue->u.setPosition
                = rtxMemAllocType (pctxt, UuvPositionCommandType);

            if (pvalue->u.setPosition == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UuvPositionCommandType (pvalue->u.setPosition);
            DOMTest_UuvPositionCommandType (pctxt, pvalue->u.setPosition, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPower"))) {
            pvalue->t = 23;
            pvalue->u.setPower
                = rtxMemAllocType (pctxt, SetPropellerCommandType);

            if (pvalue->u.setPower == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SetPropellerCommandType (pvalue->u.setPower);
            DOMTest_SetPropellerCommandType (pctxt, pvalue->u.setPower, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetRudder"))) {
            pvalue->t = 24;
            pvalue->u.setRudder
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.setRudder == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.setRudder);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.setRudder, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetSonar"))) {
            pvalue->t = 25;
            pvalue->u.setSonar = rtxMemAllocType (pctxt, SetSonarCommandType);

            if (pvalue->u.setSonar == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SetSonarCommandType (pvalue->u.setSonar);
            DOMTest_SetSonarCommandType (pctxt, pvalue->u.setSonar, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetStandoff"))) {
            pvalue->t = 26;
            pvalue->u.setStandoff
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.setStandoff == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.setStandoff);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.setStandoff, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetThruster"))) {
            pvalue->t = 27;
            pvalue->u.setThruster
                = rtxMemAllocType (pctxt, SetThrusterCommandType);

            if (pvalue->u.setThruster == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SetThrusterCommandType (pvalue->u.setThruster);
            DOMTest_SetThrusterCommandType (pctxt, pvalue->u.setThruster, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTime"))) {
            pvalue->t = 28;
            pvalue->u.setTime = rtxMemAllocType (pctxt, ScalarElementType);

            if (pvalue->u.setTime == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ScalarElementType (pvalue->u.setTime);
            DOMTest_ScalarElementType (pctxt, pvalue->u.setTime, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTimeStep"))) {
            pvalue->t = 29;
            pvalue->u.setTimeStep
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.setTimeStep == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.setTimeStep);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.setTimeStep, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TakeStation"))) {
            pvalue->t = 30;
            pvalue->u.takeStation
                = rtxMemAllocType (pctxt, TakeStationCommandType);

            if (pvalue->u.takeStation == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TakeStationCommandType (pvalue->u.takeStation);
            DOMTest_TakeStationCommandType (pctxt, pvalue->u.takeStation, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Thrusters"))) {
            pvalue->t = 31;
            pvalue->u.thrusters
                = rtxMemAllocType (pctxt, BooleanElementType_derivations);

            if (pvalue->u.thrusters == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BooleanElementType_derivations (pvalue->u.thrusters);
            DOMTest_BooleanElementType_derivations (pctxt, pvalue->u.thrusters, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Trace"))) {
            pvalue->t = 32;
            pvalue->u.trace
                = rtxMemAllocType (pctxt, BooleanElementType_derivations);

            if (pvalue->u.trace == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BooleanElementType_derivations (pvalue->u.trace);
            DOMTest_BooleanElementType_derivations (pctxt, pvalue->u.trace, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Wait"))) {
            pvalue->t = 33;
            pvalue->u.wait
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.wait == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.wait);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.wait, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("WaitUntilTime"))) {
            pvalue->t = 34;
            pvalue->u.waitUntilTime
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.waitUntilTime == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.waitUntilTime);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.waitUntilTime, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Waypoint"))) {
            pvalue->t = 35;
            pvalue->u.waypoint
                = rtxMemAllocType (pctxt, UuvWaypointCommandType);

            if (pvalue->u.waypoint == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UuvWaypointCommandType (pvalue->u.waypoint);
            DOMTest_UuvWaypointCommandType (pctxt, pvalue->u.waypoint, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AVCLMessage"))) {
            pvalue->t = 36;
            pvalue->u.aVCLMessage = rtxMemAllocType (pctxt, AvclMessageType);

            if (pvalue->u.aVCLMessage == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AvclMessageType ((AvclMessageType*)pvalue->u.aVCLMessage);
            DOMTest_AvclMessageType (pctxt, (AvclMessageType*)pvalue->u.aVCLMessage, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_UuvLoggableEventType (OSCTXT* pctxt, UuvLoggableEventType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("CompositeWaypoint")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("FollowBeacon")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("GpsFix")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Help")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Hover")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Loiter")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeAltitude")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeDepth")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeHeading")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeKnots")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeSpeed")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MetaCommand")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScript")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScriptInline")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MoveLateral")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MoveRotate")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Quit")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Realtime")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Recover")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SendMessage")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPlanes")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPosition")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPower")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetRudder")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetSonar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetStandoff")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetThruster")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTime")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTimeStep")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TakeStation")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Thrusters")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Trace")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Wait")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("WaitUntilTime")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Waypoint")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AVCLMessage"))) {
            { UuvLoggableEventType_element* pdata2;
            pdata2 = rtxMemAllocType (pctxt, UuvLoggableEventType_element);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UuvLoggableEventType_element (pdata2);
            DOMTest_UuvLoggableEventType_element (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_UgvLoggableEventType_element (OSCTXT* pctxt, 
   UgvLoggableEventType_element* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("CompositeWaypoint"))) {
            pvalue->t = 1;
            pvalue->u.compositeWaypoint
                = rtxMemAllocType (pctxt, UgvCompositeWaypointCommandType);

            if (pvalue->u.compositeWaypoint == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UgvCompositeWaypointCommandType (pvalue->u.compositeWaypoint);
            DOMTest_UgvCompositeWaypointCommandType (pctxt, pvalue->u.compositeWaypoint, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Help"))) {
            pvalue->t = 2;
            pvalue->u.help = rtxMemAllocType (pctxt, NoValueElementType);

            if (pvalue->u.help == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NoValueElementType (pvalue->u.help);
            DOMTest_NoValueElementType (pctxt, pvalue->u.help, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Loiter"))) {
            pvalue->t = 3;
            pvalue->u.loiter = rtxMemAllocType (pctxt, UgvLoiterCommandType);

            if (pvalue->u.loiter == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UgvLoiterCommandType (pvalue->u.loiter);
            DOMTest_UgvLoiterCommandType (pctxt, pvalue->u.loiter, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeHeading"))) {
            pvalue->t = 4;
            pvalue->u.makeHeading
                = rtxMemAllocType (pctxt, HeadingElementType);

            if (pvalue->u.makeHeading == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_HeadingElementType (pvalue->u.makeHeading);
            DOMTest_HeadingElementType (pctxt, pvalue->u.makeHeading, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeSpeed"))) {
            pvalue->t = 5;
            pvalue->u.makeSpeed
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.makeSpeed == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeSpeed);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.makeSpeed, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MetaCommand"))) {
            pvalue->t = 6;
            pvalue->u.metaCommand = rtxMemAllocType (pctxt, MetaDataType);

            if (pvalue->u.metaCommand == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MetaDataType (pvalue->u.metaCommand);
            DOMTest_MetaDataType (pctxt, pvalue->u.metaCommand, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScript"))) {
            pvalue->t = 7;
            pvalue->u.missionScript
                = rtxMemAllocType (pctxt, StringElementType);

            if (pvalue->u.missionScript == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StringElementType (pvalue->u.missionScript);
            DOMTest_StringElementType (pctxt, pvalue->u.missionScript, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScriptInline"))) {
            pvalue->t = 8;
            pvalue->u.missionScriptInline
                = rtxMemAllocType (pctxt, StringElementType);

            if (pvalue->u.missionScriptInline == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StringElementType (pvalue->u.missionScriptInline);
            DOMTest_StringElementType (pctxt, pvalue->u.missionScriptInline, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Quit"))) {
            pvalue->t = 9;
            pvalue->u.quit = rtxMemAllocType (pctxt, QuitCommandType);

            if (pvalue->u.quit == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_QuitCommandType (pvalue->u.quit);
            DOMTest_QuitCommandType (pctxt, pvalue->u.quit, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Realtime"))) {
            pvalue->t = 10;
            pvalue->u.realtime
                = rtxMemAllocType (pctxt, BooleanElementType_derivations);

            if (pvalue->u.realtime == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BooleanElementType_derivations (pvalue->u.realtime);
            DOMTest_BooleanElementType_derivations (pctxt, pvalue->u.realtime, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SendMessage"))) {
            pvalue->t = 11;
            pvalue->u.sendMessage
                = rtxMemAllocType (pctxt, SendMessageCommandType);

            if (pvalue->u.sendMessage == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SendMessageCommandType (pvalue->u.sendMessage);
            DOMTest_SendMessageCommandType (pctxt, pvalue->u.sendMessage, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPosition"))) {
            pvalue->t = 12;
            pvalue->u.setPosition
                = rtxMemAllocType (pctxt, UgvPositionCommandType);

            if (pvalue->u.setPosition == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UgvPositionCommandType (pvalue->u.setPosition);
            DOMTest_UgvPositionCommandType (pctxt, pvalue->u.setPosition, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetStandoff"))) {
            pvalue->t = 13;
            pvalue->u.setStandoff
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.setStandoff == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.setStandoff);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.setStandoff, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTime"))) {
            pvalue->t = 14;
            pvalue->u.setTime = rtxMemAllocType (pctxt, ScalarElementType);

            if (pvalue->u.setTime == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ScalarElementType (pvalue->u.setTime);
            DOMTest_ScalarElementType (pctxt, pvalue->u.setTime, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTimeStep"))) {
            pvalue->t = 15;
            pvalue->u.setTimeStep
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.setTimeStep == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.setTimeStep);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.setTimeStep, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Trace"))) {
            pvalue->t = 16;
            pvalue->u.trace
                = rtxMemAllocType (pctxt, BooleanElementType_derivations);

            if (pvalue->u.trace == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BooleanElementType_derivations (pvalue->u.trace);
            DOMTest_BooleanElementType_derivations (pctxt, pvalue->u.trace, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Wait"))) {
            pvalue->t = 17;
            pvalue->u.wait
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.wait == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.wait);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.wait, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("WaitUntilTime"))) {
            pvalue->t = 18;
            pvalue->u.waitUntilTime
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.waitUntilTime == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.waitUntilTime);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.waitUntilTime, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Waypoint"))) {
            pvalue->t = 19;
            pvalue->u.waypoint
                = rtxMemAllocType (pctxt, UgvWaypointCommandType);

            if (pvalue->u.waypoint == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UgvWaypointCommandType (pvalue->u.waypoint);
            DOMTest_UgvWaypointCommandType (pctxt, pvalue->u.waypoint, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AVCLMessage"))) {
            pvalue->t = 20;
            pvalue->u.aVCLMessage = rtxMemAllocType (pctxt, AvclMessageType);

            if (pvalue->u.aVCLMessage == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AvclMessageType ((AvclMessageType*)pvalue->u.aVCLMessage);
            DOMTest_AvclMessageType (pctxt, (AvclMessageType*)pvalue->u.aVCLMessage, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_UgvLoggableEventType (OSCTXT* pctxt, UgvLoggableEventType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("CompositeWaypoint")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Help")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Loiter")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeHeading")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeSpeed")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MetaCommand")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScript")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScriptInline")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Quit")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Realtime")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SendMessage")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPosition")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetStandoff")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTime")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTimeStep")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Trace")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Wait")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("WaitUntilTime")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Waypoint")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AVCLMessage"))) {
            { UgvLoggableEventType_element* pdata2;
            pdata2 = rtxMemAllocType (pctxt, UgvLoggableEventType_element);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UgvLoggableEventType_element (pdata2);
            DOMTest_UgvLoggableEventType_element (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_UsvLoggableEventType_element (OSCTXT* pctxt, 
   UsvLoggableEventType_element* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("CompositeWaypoint"))) {
            pvalue->t = 1;
            pvalue->u.compositeWaypoint
                = rtxMemAllocType (pctxt, UsvCompositeWaypointCommandType);

            if (pvalue->u.compositeWaypoint == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UsvCompositeWaypointCommandType (pvalue->u.compositeWaypoint);
            DOMTest_UsvCompositeWaypointCommandType (pctxt, pvalue->u.compositeWaypoint, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Help"))) {
            pvalue->t = 2;
            pvalue->u.help = rtxMemAllocType (pctxt, NoValueElementType);

            if (pvalue->u.help == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NoValueElementType (pvalue->u.help);
            DOMTest_NoValueElementType (pctxt, pvalue->u.help, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Loiter"))) {
            pvalue->t = 3;
            pvalue->u.loiter = rtxMemAllocType (pctxt, UsvLoiterCommandType);

            if (pvalue->u.loiter == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UsvLoiterCommandType (pvalue->u.loiter);
            DOMTest_UsvLoiterCommandType (pctxt, pvalue->u.loiter, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeHeading"))) {
            pvalue->t = 4;
            pvalue->u.makeHeading
                = rtxMemAllocType (pctxt, HeadingElementType);

            if (pvalue->u.makeHeading == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_HeadingElementType (pvalue->u.makeHeading);
            DOMTest_HeadingElementType (pctxt, pvalue->u.makeHeading, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeKnots"))) {
            pvalue->t = 5;
            pvalue->u.makeKnots = rtxMemAllocType (pctxt, SpeedElementType);

            if (pvalue->u.makeKnots == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SpeedElementType (pvalue->u.makeKnots);
            DOMTest_SpeedElementType (pctxt, pvalue->u.makeKnots, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeSpeed"))) {
            pvalue->t = 6;
            pvalue->u.makeSpeed = rtxMemAllocType (pctxt, SpeedElementType);

            if (pvalue->u.makeSpeed == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SpeedElementType (pvalue->u.makeSpeed);
            DOMTest_SpeedElementType (pctxt, pvalue->u.makeSpeed, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MetaCommand"))) {
            pvalue->t = 7;
            pvalue->u.metaCommand = rtxMemAllocType (pctxt, MetaDataType);

            if (pvalue->u.metaCommand == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MetaDataType (pvalue->u.metaCommand);
            DOMTest_MetaDataType (pctxt, pvalue->u.metaCommand, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScript"))) {
            pvalue->t = 8;
            pvalue->u.missionScript
                = rtxMemAllocType (pctxt, StringElementType);

            if (pvalue->u.missionScript == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StringElementType (pvalue->u.missionScript);
            DOMTest_StringElementType (pctxt, pvalue->u.missionScript, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScriptInline"))) {
            pvalue->t = 9;
            pvalue->u.missionScriptInline
                = rtxMemAllocType (pctxt, StringElementType);

            if (pvalue->u.missionScriptInline == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StringElementType (pvalue->u.missionScriptInline);
            DOMTest_StringElementType (pctxt, pvalue->u.missionScriptInline, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Quit"))) {
            pvalue->t = 10;
            pvalue->u.quit = rtxMemAllocType (pctxt, QuitCommandType);

            if (pvalue->u.quit == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_QuitCommandType (pvalue->u.quit);
            DOMTest_QuitCommandType (pctxt, pvalue->u.quit, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Realtime"))) {
            pvalue->t = 11;
            pvalue->u.realtime
                = rtxMemAllocType (pctxt, BooleanElementType_derivations);

            if (pvalue->u.realtime == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BooleanElementType_derivations (pvalue->u.realtime);
            DOMTest_BooleanElementType_derivations (pctxt, pvalue->u.realtime, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SendMessage"))) {
            pvalue->t = 12;
            pvalue->u.sendMessage
                = rtxMemAllocType (pctxt, SendMessageCommandType);

            if (pvalue->u.sendMessage == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SendMessageCommandType (pvalue->u.sendMessage);
            DOMTest_SendMessageCommandType (pctxt, pvalue->u.sendMessage, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPosition"))) {
            pvalue->t = 13;
            pvalue->u.setPosition
                = rtxMemAllocType (pctxt, UsvPositionCommandType);

            if (pvalue->u.setPosition == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UsvPositionCommandType (pvalue->u.setPosition);
            DOMTest_UsvPositionCommandType (pctxt, pvalue->u.setPosition, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPower"))) {
            pvalue->t = 14;
            pvalue->u.setPower
                = rtxMemAllocType (pctxt, SetPropellerCommandType);

            if (pvalue->u.setPower == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SetPropellerCommandType (pvalue->u.setPower);
            DOMTest_SetPropellerCommandType (pctxt, pvalue->u.setPower, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetRudder"))) {
            pvalue->t = 15;
            pvalue->u.setRudder
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.setRudder == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.setRudder);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.setRudder, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetStandoff"))) {
            pvalue->t = 16;
            pvalue->u.setStandoff
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.setStandoff == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.setStandoff);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.setStandoff, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTime"))) {
            pvalue->t = 17;
            pvalue->u.setTime = rtxMemAllocType (pctxt, ScalarElementType);

            if (pvalue->u.setTime == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ScalarElementType (pvalue->u.setTime);
            DOMTest_ScalarElementType (pctxt, pvalue->u.setTime, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTimeStep"))) {
            pvalue->t = 18;
            pvalue->u.setTimeStep
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.setTimeStep == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.setTimeStep);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.setTimeStep, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Trace"))) {
            pvalue->t = 19;
            pvalue->u.trace
                = rtxMemAllocType (pctxt, BooleanElementType_derivations);

            if (pvalue->u.trace == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BooleanElementType_derivations (pvalue->u.trace);
            DOMTest_BooleanElementType_derivations (pctxt, pvalue->u.trace, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Wait"))) {
            pvalue->t = 20;
            pvalue->u.wait
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.wait == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.wait);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.wait, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("WaitUntilTime"))) {
            pvalue->t = 21;
            pvalue->u.waitUntilTime
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.waitUntilTime == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.waitUntilTime);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.waitUntilTime, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Waypoint"))) {
            pvalue->t = 22;
            pvalue->u.waypoint
                = rtxMemAllocType (pctxt, UsvWaypointCommandType);

            if (pvalue->u.waypoint == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UsvWaypointCommandType (pvalue->u.waypoint);
            DOMTest_UsvWaypointCommandType (pctxt, pvalue->u.waypoint, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AVCLMessage"))) {
            pvalue->t = 23;
            pvalue->u.aVCLMessage = rtxMemAllocType (pctxt, AvclMessageType);

            if (pvalue->u.aVCLMessage == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AvclMessageType ((AvclMessageType*)pvalue->u.aVCLMessage);
            DOMTest_AvclMessageType (pctxt, (AvclMessageType*)pvalue->u.aVCLMessage, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_UsvLoggableEventType (OSCTXT* pctxt, UsvLoggableEventType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("CompositeWaypoint")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Help")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Loiter")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeHeading")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeKnots")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeSpeed")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MetaCommand")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScript")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScriptInline")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Quit")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Realtime")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SendMessage")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPosition")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPower")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetRudder")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetStandoff")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTime")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTimeStep")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Trace")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Wait")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("WaitUntilTime")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Waypoint")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AVCLMessage"))) {
            { UsvLoggableEventType_element* pdata2;
            pdata2 = rtxMemAllocType (pctxt, UsvLoggableEventType_element);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UsvLoggableEventType_element (pdata2);
            DOMTest_UsvLoggableEventType_element (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_UavLoggableEventType_element (OSCTXT* pctxt, 
   UavLoggableEventType_element* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("CompositeWaypoint"))) {
            pvalue->t = 1;
            pvalue->u.compositeWaypoint
                = rtxMemAllocType (pctxt, UavCompositeWaypointCommandType);

            if (pvalue->u.compositeWaypoint == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UavCompositeWaypointCommandType (pvalue->u.compositeWaypoint);
            DOMTest_UavCompositeWaypointCommandType (pctxt, pvalue->u.compositeWaypoint, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Help"))) {
            pvalue->t = 2;
            pvalue->u.help = rtxMemAllocType (pctxt, NoValueElementType);

            if (pvalue->u.help == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NoValueElementType (pvalue->u.help);
            DOMTest_NoValueElementType (pctxt, pvalue->u.help, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Loiter"))) {
            pvalue->t = 3;
            pvalue->u.loiter = rtxMemAllocType (pctxt, UavLoiterCommandType);

            if (pvalue->u.loiter == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UavLoiterCommandType (pvalue->u.loiter);
            DOMTest_UavLoiterCommandType (pctxt, pvalue->u.loiter, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeAltitudeAGL"))) {
            pvalue->t = 4;
            pvalue->u.makeAltitudeAGL
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.makeAltitudeAGL == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeAltitudeAGL);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.makeAltitudeAGL, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeAltitudeMSL"))) {
            pvalue->t = 5;
            pvalue->u.makeAltitudeMSL
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.makeAltitudeMSL == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeAltitudeMSL);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.makeAltitudeMSL, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeClimbRate"))) {
            pvalue->t = 6;
            pvalue->u.makeClimbRate
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.makeClimbRate == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.makeClimbRate);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.makeClimbRate, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeHeading"))) {
            pvalue->t = 7;
            pvalue->u.makeHeading
                = rtxMemAllocType (pctxt, HeadingElementType);

            if (pvalue->u.makeHeading == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_HeadingElementType (pvalue->u.makeHeading);
            DOMTest_HeadingElementType (pctxt, pvalue->u.makeHeading, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeKnots"))) {
            pvalue->t = 8;
            pvalue->u.makeKnots = rtxMemAllocType (pctxt, SpeedElementType);

            if (pvalue->u.makeKnots == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SpeedElementType (pvalue->u.makeKnots);
            DOMTest_SpeedElementType (pctxt, pvalue->u.makeKnots, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeSpeed"))) {
            pvalue->t = 9;
            pvalue->u.makeSpeed = rtxMemAllocType (pctxt, SpeedElementType);

            if (pvalue->u.makeSpeed == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SpeedElementType (pvalue->u.makeSpeed);
            DOMTest_SpeedElementType (pctxt, pvalue->u.makeSpeed, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeTurnRate"))) {
            pvalue->t = 10;
            pvalue->u.makeTurnRate
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.makeTurnRate == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.makeTurnRate);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.makeTurnRate, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MetaCommand"))) {
            pvalue->t = 11;
            pvalue->u.metaCommand = rtxMemAllocType (pctxt, MetaDataType);

            if (pvalue->u.metaCommand == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MetaDataType (pvalue->u.metaCommand);
            DOMTest_MetaDataType (pctxt, pvalue->u.metaCommand, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScript"))) {
            pvalue->t = 12;
            pvalue->u.missionScript
                = rtxMemAllocType (pctxt, StringElementType);

            if (pvalue->u.missionScript == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StringElementType (pvalue->u.missionScript);
            DOMTest_StringElementType (pctxt, pvalue->u.missionScript, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScriptInline"))) {
            pvalue->t = 13;
            pvalue->u.missionScriptInline
                = rtxMemAllocType (pctxt, StringElementType);

            if (pvalue->u.missionScriptInline == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StringElementType (pvalue->u.missionScriptInline);
            DOMTest_StringElementType (pctxt, pvalue->u.missionScriptInline, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Quit"))) {
            pvalue->t = 14;
            pvalue->u.quit = rtxMemAllocType (pctxt, QuitCommandType);

            if (pvalue->u.quit == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_QuitCommandType (pvalue->u.quit);
            DOMTest_QuitCommandType (pctxt, pvalue->u.quit, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Realtime"))) {
            pvalue->t = 15;
            pvalue->u.realtime
                = rtxMemAllocType (pctxt, BooleanElementType_derivations);

            if (pvalue->u.realtime == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BooleanElementType_derivations (pvalue->u.realtime);
            DOMTest_BooleanElementType_derivations (pctxt, pvalue->u.realtime, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SendMessage"))) {
            pvalue->t = 16;
            pvalue->u.sendMessage
                = rtxMemAllocType (pctxt, SendMessageCommandType);

            if (pvalue->u.sendMessage == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SendMessageCommandType (pvalue->u.sendMessage);
            DOMTest_SendMessageCommandType (pctxt, pvalue->u.sendMessage, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetAileron"))) {
            pvalue->t = 17;
            pvalue->u.setAileron
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.setAileron == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.setAileron);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.setAileron, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetElevator"))) {
            pvalue->t = 18;
            pvalue->u.setElevator
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.setElevator == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.setElevator);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.setElevator, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPosition"))) {
            pvalue->t = 19;
            pvalue->u.setPosition
                = rtxMemAllocType (pctxt, UavPositionCommandType);

            if (pvalue->u.setPosition == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UavPositionCommandType (pvalue->u.setPosition);
            DOMTest_UavPositionCommandType (pctxt, pvalue->u.setPosition, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPower"))) {
            pvalue->t = 20;
            pvalue->u.setPower = rtxMemAllocType (pctxt, PercentElementType);

            if (pvalue->u.setPower == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PercentElementType (pvalue->u.setPower);
            DOMTest_PercentElementType (pctxt, pvalue->u.setPower, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetRudder"))) {
            pvalue->t = 21;
            pvalue->u.setRudder
                = rtxMemAllocType (pctxt, SignedPercentElementType);

            if (pvalue->u.setRudder == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignedPercentElementType (pvalue->u.setRudder);
            DOMTest_SignedPercentElementType (pctxt, pvalue->u.setRudder, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetStandoff"))) {
            pvalue->t = 22;
            pvalue->u.setStandoff
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.setStandoff == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.setStandoff);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.setStandoff, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTime"))) {
            pvalue->t = 23;
            pvalue->u.setTime = rtxMemAllocType (pctxt, ScalarElementType);

            if (pvalue->u.setTime == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ScalarElementType (pvalue->u.setTime);
            DOMTest_ScalarElementType (pctxt, pvalue->u.setTime, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTimeStep"))) {
            pvalue->t = 24;
            pvalue->u.setTimeStep
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.setTimeStep == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.setTimeStep);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.setTimeStep, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Trace"))) {
            pvalue->t = 25;
            pvalue->u.trace
                = rtxMemAllocType (pctxt, BooleanElementType_derivations);

            if (pvalue->u.trace == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BooleanElementType_derivations (pvalue->u.trace);
            DOMTest_BooleanElementType_derivations (pctxt, pvalue->u.trace, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Wait"))) {
            pvalue->t = 26;
            pvalue->u.wait
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.wait == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.wait);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.wait, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("WaitUntilTime"))) {
            pvalue->t = 27;
            pvalue->u.waitUntilTime
                = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

            if (pvalue->u.waitUntilTime == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PositiveScalarElementType_derivations (pvalue->u.waitUntilTime);
            DOMTest_PositiveScalarElementType_derivations (pctxt, pvalue->u.waitUntilTime, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Waypoint"))) {
            pvalue->t = 28;
            pvalue->u.waypoint
                = rtxMemAllocType (pctxt, UavWaypointCommandType);

            if (pvalue->u.waypoint == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UavWaypointCommandType (pvalue->u.waypoint);
            DOMTest_UavWaypointCommandType (pctxt, pvalue->u.waypoint, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AVCLMessage"))) {
            pvalue->t = 29;
            pvalue->u.aVCLMessage = rtxMemAllocType (pctxt, AvclMessageType);

            if (pvalue->u.aVCLMessage == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AvclMessageType ((AvclMessageType*)pvalue->u.aVCLMessage);
            DOMTest_AvclMessageType (pctxt, (AvclMessageType*)pvalue->u.aVCLMessage, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_UavLoggableEventType (OSCTXT* pctxt, UavLoggableEventType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("CompositeWaypoint")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Help")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Loiter")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeAltitudeAGL")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeAltitudeMSL")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeClimbRate")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeHeading")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeKnots")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeSpeed")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MakeTurnRate")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MetaCommand")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScript")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionScriptInline")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Quit")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Realtime")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SendMessage")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetAileron")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetElevator")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPosition")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetPower")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetRudder")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetStandoff")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTime")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SetTimeStep")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Trace")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Wait")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("WaitUntilTime")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Waypoint")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AVCLMessage"))) {
            { UavLoggableEventType_element* pdata2;
            pdata2 = rtxMemAllocType (pctxt, UavLoggableEventType_element);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UavLoggableEventType_element (pdata2);
            DOMTest_UavLoggableEventType_element (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_LoggableEvent (OSCTXT* pctxt, LoggableEvent* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UUVEvent"))) {
            pvalue->t = 1;
            pvalue->u.uUVEvent
                = rtxMemAllocType (pctxt, UuvLoggableEventType);

            if (pvalue->u.uUVEvent == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UuvLoggableEventType (pvalue->u.uUVEvent);
            DOMTest_UuvLoggableEventType (pctxt, pvalue->u.uUVEvent, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UGVEvent"))) {
            pvalue->t = 2;
            pvalue->u.uGVEvent
                = rtxMemAllocType (pctxt, UgvLoggableEventType);

            if (pvalue->u.uGVEvent == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UgvLoggableEventType (pvalue->u.uGVEvent);
            DOMTest_UgvLoggableEventType (pctxt, pvalue->u.uGVEvent, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("USVEvent"))) {
            pvalue->t = 3;
            pvalue->u.uSVEvent
                = rtxMemAllocType (pctxt, UsvLoggableEventType);

            if (pvalue->u.uSVEvent == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UsvLoggableEventType (pvalue->u.uSVEvent);
            DOMTest_UsvLoggableEventType (pctxt, pvalue->u.uSVEvent, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UAVEvent"))) {
            pvalue->t = 4;
            pvalue->u.uAVEvent
                = rtxMemAllocType (pctxt, UavLoggableEventType);

            if (pvalue->u.uAVEvent == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UavLoggableEventType (pvalue->u.uAVEvent);
            DOMTest_UavLoggableEventType (pctxt, pvalue->u.uAVEvent, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_MessageBodyContent_sensorDataReport (OSCTXT* pctxt, 
   MessageBodyContent_sensorDataReport* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ActiveSonar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ImagingSonar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("BlazedArraySonar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SyntheticApertureSonar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PassiveSonar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Radar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("DopplerRadar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SyntheticApertureRadar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TrackWhileScanRadar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("EarlyWarningRadar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AcquisitionRadar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TrackingRadar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("FireControlRadar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SurfaceSearchRadar")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ESM")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PassiveSoundDetection")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ChemicalBiologicalRadiologicalDetection")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Video")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("FLIR")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MotionSensor"))) {
            pvalue->t = 1;
            pvalue->u.choice_list = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.choice_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.choice_list);
            {
            SensorElements* pdata2 = rtxMemAllocTypeZ (pctxt, SensorElements);
            DOMTest_SensorElements (pctxt, pdata2, pXmlNode, setChild);
            if (0 != pdata2)
               rtxDListAppend (pctxt, pvalue->u.choice_list, (void*)pdata2);
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_MessageBodyContent (OSCTXT* pctxt, MessageBodyContent* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UUVCommandScript")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("USVCommandScript")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UGVCommandScript")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UAVCommandScript")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AgendaMission"))) {
            pvalue->t = 1;
            pvalue->u.choice = rtxMemAllocType (pctxt, MissionSpecification);

            if (pvalue->u.choice == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MissionSpecification (pvalue->u.choice);
            DOMTest_MissionSpecification (pctxt, pvalue->u.choice, pXmlNode, FALSE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UUVCommand"))) {
            pvalue->t = 2;
            pvalue->u.uUVCommand
                = rtxMemAllocType (pctxt, UuvScriptCommandsType);

            if (pvalue->u.uUVCommand == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UuvScriptCommandsType (pvalue->u.uUVCommand);
            DOMTest_UuvScriptCommandsType (pctxt, pvalue->u.uUVCommand, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UGVCommand"))) {
            pvalue->t = 3;
            pvalue->u.uGVCommand
                = rtxMemAllocType (pctxt, UgvScriptCommandsType);

            if (pvalue->u.uGVCommand == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UgvScriptCommandsType (pvalue->u.uGVCommand);
            DOMTest_UgvScriptCommandsType (pctxt, pvalue->u.uGVCommand, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("USVCommand"))) {
            pvalue->t = 4;
            pvalue->u.uSVCommand
                = rtxMemAllocType (pctxt, UsvScriptCommandsType);

            if (pvalue->u.uSVCommand == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UsvScriptCommandsType (pvalue->u.uSVCommand);
            DOMTest_UsvScriptCommandsType (pctxt, pvalue->u.uSVCommand, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UAVCommand"))) {
            pvalue->t = 5;
            pvalue->u.uAVCommand
                = rtxMemAllocType (pctxt, UavScriptCommandsType);

            if (pvalue->u.uAVCommand == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UavScriptCommandsType (pvalue->u.uAVCommand);
            DOMTest_UavScriptCommandsType (pctxt, pvalue->u.uAVCommand, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("InformationRequest"))) {
            pvalue->t = 6;
            pvalue->u.informationRequest
                = rtxMemAllocType (pctxt, InformationRequestElementType);

            if (pvalue->u.informationRequest == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InformationRequestElementType (pvalue->u.informationRequest);
            DOMTest_InformationRequestElementType (pctxt, pvalue->u.informationRequest, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("GroupMaintenance"))) {
            pvalue->t = 7;
            pvalue->u.groupMaintenance
                = rtxMemAllocType (pctxt, VehicleGroupCompositionElementType);

            if (pvalue->u.groupMaintenance == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_VehicleGroupCompositionElementType (pvalue->u.groupMaintenance);
            DOMTest_VehicleGroupCompositionElementType (pctxt, pvalue->u.groupMaintenance, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UUVCharacteristics")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UGVCharacteristics")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("USVCharacteristics")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UAVCharacteristics"))) {
            pvalue->t = 8;
            pvalue->u.choice_1
                = rtxMemAllocType (pctxt, VehicleCharacteristicsGroup);

            if (pvalue->u.choice_1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_VehicleCharacteristicsGroup (pvalue->u.choice_1);
            DOMTest_VehicleCharacteristicsGroup (pctxt, pvalue->u.choice_1, pXmlNode, FALSE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("VehicleState"))) {
            pvalue->t = 9;
            pvalue->u.vehicleState
                = rtxMemAllocType (pctxt, DiscreteTimeResultsElementType);

            if (pvalue->u.vehicleState == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_DiscreteTimeResultsElementType (pvalue->u.vehicleState);
            DOMTest_DiscreteTimeResultsElementType (pctxt, pvalue->u.vehicleState, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UUVEvent")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UGVEvent")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("USVEvent")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UAVEvent"))) {
            pvalue->t = 10;
            pvalue->u.choice_2 = rtxMemAllocType (pctxt, LoggableEvent);

            if (pvalue->u.choice_2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_LoggableEvent (pvalue->u.choice_2);
            DOMTest_LoggableEvent (pctxt, pvalue->u.choice_2, pXmlNode, FALSE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SensorDataReport"))) {
            pvalue->t = 11;
            pvalue->u.sensorDataReport
                = rtxMemAllocType (pctxt, MessageBodyContent_sensorDataReport);

            if (pvalue->u.sensorDataReport == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MessageBodyContent_sensorDataReport (pvalue->u.sensorDataReport);
            DOMTest_MessageBodyContent_sensorDataReport (pctxt, pvalue->u.sensorDataReport, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_AvclMessageBodyType (OSCTXT* pctxt, AvclMessageBodyType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_MessageBodyContent (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_AvclMessageType (OSCTXT* pctxt, AvclMessageType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("transportStatus"))) {
            pvalue->m.transportStatusPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               AvclMessageType_transportStatus_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->transportStatus);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->version = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->version = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("head"))) {
            DOMTest_AvclMessageHeadType (pctxt, &pvalue->head, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("body"))) {
            DOMTest_AvclMessageBodyType (pctxt, &pvalue->body, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_AVCLMessage (OSCTXT* pctxt, AVCLMessage* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_AvclMessageType (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_AvclHeadType (OSCTXT* pctxt, AvclHeadType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   MetaDataType* pdata1;
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("meta"))) {
            pdata1 = rtxMemAllocType (pctxt, MetaDataType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MetaDataType (pdata1);
            DOMTest_MetaDataType (pctxt, pdata1, pXmlNode, TRUE);
            if (0 != pdata1)
               rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         }
      }
   }

   return 0;
}

int DOMTest_UnitsOfMeasureElementType (OSCTXT* pctxt, 
   UnitsOfMeasureElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("angle"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->angle = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->angle = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("distance"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->distance = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->distance = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mass"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mass = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->mass = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("time"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->time_ = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->time_ = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_ConfigurationElementType_choice (OSCTXT* pctxt, 
   ConfigurationElementType_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UnmannedUnderwaterVehicle"))) {
            pvalue->t = 1;
            pvalue->u.unmannedUnderwaterVehicle
                = rtxMemAllocType (pctxt, UuvCharacteristicsElementType);

            if (pvalue->u.unmannedUnderwaterVehicle == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UuvCharacteristicsElementType (pvalue->u.unmannedUnderwaterVehicle);
            DOMTest_UuvCharacteristicsElementType (pctxt, pvalue->u.unmannedUnderwaterVehicle, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UnmannedSurfaceVehicle"))) {
            pvalue->t = 2;
            pvalue->u.unmannedSurfaceVehicle
                = rtxMemAllocType (pctxt, UsvCharacteristicsElementType);

            if (pvalue->u.unmannedSurfaceVehicle == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UsvCharacteristicsElementType (pvalue->u.unmannedSurfaceVehicle);
            DOMTest_UsvCharacteristicsElementType (pctxt, pvalue->u.unmannedSurfaceVehicle, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UnmannedGroundVehicle"))) {
            pvalue->t = 3;
            pvalue->u.unmannedGroundVehicle
                = rtxMemAllocType (pctxt, UgvCharacteristicsElementType);

            if (pvalue->u.unmannedGroundVehicle == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UgvCharacteristicsElementType (pvalue->u.unmannedGroundVehicle);
            DOMTest_UgvCharacteristicsElementType (pctxt, pvalue->u.unmannedGroundVehicle, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UnmannedAerialVehicle"))) {
            pvalue->t = 4;
            pvalue->u.unmannedAerialVehicle
                = rtxMemAllocType (pctxt, UavCharacteristicsElementType);

            if (pvalue->u.unmannedAerialVehicle == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UavCharacteristicsElementType (pvalue->u.unmannedAerialVehicle);
            DOMTest_UavCharacteristicsElementType (pctxt, pvalue->u.unmannedAerialVehicle, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_ConfigurationElementType (OSCTXT* pctxt, 
   ConfigurationElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UnmannedUnderwaterVehicle")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UnmannedSurfaceVehicle")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UnmannedGroundVehicle")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UnmannedAerialVehicle"))) {
            DOMTest_ConfigurationElementType_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_MissionPreparationElementType (OSCTXT* pctxt, 
   MissionPreparationElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UnitsOfMeasure"))) {
            DOMTest_UnitsOfMeasureElementType (pctxt, &pvalue->unitsOfMeasure, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("GeoOrigin"))) {
            pvalue->m.geoOriginPresent = 1;
            DOMTest_GeoOriginElementType (pctxt, &pvalue->geoOrigin, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Configuration"))) {
            pvalue->m.configurationPresent = 1;
            DOMTest_ConfigurationElementType (pctxt, &pvalue->configuration, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UUVCommandScript")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("USVCommandScript")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UGVCommandScript")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UAVCommandScript")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AgendaMission"))) {
            pvalue->m.choicePresent = 1;
            DOMTest_MissionSpecification (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_EventLogElementType (OSCTXT* pctxt, EventLogElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UUVEvent")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UGVEvent")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("USVEvent")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UAVEvent"))) {
            { LoggableEvent* pdata2;
            pdata2 = rtxMemAllocType (pctxt, LoggableEvent);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_LoggableEvent (pdata2);
            DOMTest_LoggableEvent (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_DateTimeGroupElementType (OSCTXT* pctxt, 
   DateTimeGroupElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("day"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->day = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("hour"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->hour = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("minute"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->minute = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("month"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               MonthsType_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->month);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("second"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->second = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeZone"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->timeZone = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("year"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->year = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_MissionResultsElementType_element (OSCTXT* pctxt, 
   MissionResultsElementType_element* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SampledResults"))) {
            pvalue->t = 1;
            pvalue->u.sampledResults
                = rtxMemAllocType (pctxt, DiscreteTimeResultsElementType);

            if (pvalue->u.sampledResults == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_DiscreteTimeResultsElementType (pvalue->u.sampledResults);
            DOMTest_DiscreteTimeResultsElementType (pctxt, pvalue->u.sampledResults, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_MissionResultsElementType (OSCTXT* pctxt, 
   MissionResultsElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionStartTime"))) {
            pvalue->m.missionStartTimePresent = 1;
            DOMTest_DateTimeGroupElementType (pctxt, &pvalue->missionStartTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SampledResults"))) {
            { MissionResultsElementType_element* pdata2;
            pdata2
                = rtxMemAllocType (pctxt, MissionResultsElementType_element);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MissionResultsElementType_element (pdata2);
            DOMTest_MissionResultsElementType_element (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_AvclBodyType (OSCTXT* pctxt, AvclBodyType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   pvalue->_order.n = 0;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionPreparation"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 0;
            DOMTest_MissionPreparationElementType (pctxt, &pvalue->missionPreparation, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("EventLog"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 1;
            pvalue->m.eventLogPresent = 1;
            DOMTest_EventLogElementType (pctxt, &pvalue->eventLog, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MissionResults"))) {
            pvalue->_order.elem[pvalue->_order.n++] = 2;
            pvalue->m.missionResultsPresent = 1;
            DOMTest_MissionResultsElementType (pctxt, &pvalue->missionResults, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_AVCL (OSCTXT* pctxt, AVCL* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("date"))) {
            pvalue->m.datePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->date = (const char*)((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->date = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("vehicleID"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->vehicleID = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("vehicleType"))) {
            pvalue->m.vehicleTypePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->vehicleType = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->vehicleType = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("head"))) {
            pvalue->m.headPresent = 1;
            DOMTest_AvclHeadType (pctxt, &pvalue->head, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("body"))) {
            DOMTest_AvclBodyType (pctxt, &pvalue->body, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_AvclMessageListBodyType (OSCTXT* pctxt, 
   AvclMessageListBodyType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   AvclMessageType* pdata1;
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AVCLMessage"))) {
            pdata1 = rtxMemAllocType (pctxt, AvclMessageType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AvclMessageType (pdata1);
            DOMTest_AvclMessageType (pctxt, pdata1, pXmlNode, TRUE);
            if (0 != pdata1)
               rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         }
      }
   }

   return 0;
}

int DOMTest_AVCLMessageList (OSCTXT* pctxt, AVCLMessageList* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("date"))) {
            pvalue->m.datePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->date = (const char*)((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->date = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("vehicleID"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->vehicleID = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("vehicleType"))) {
            pvalue->m.vehicleTypePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->vehicleType = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->vehicleType = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("head"))) {
            pvalue->m.headPresent = 1;
            DOMTest_AvclHeadType (pctxt, &pvalue->head, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("body"))) {
            DOMTest_AvclMessageListBodyType (pctxt, &pvalue->body, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_NonNegativeScalarElementType (OSCTXT* pctxt, 
   NonNegativeScalarElementType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("value"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->value);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_IntegerElementType (OSCTXT* pctxt, IntegerElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("value"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->value = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_TokenElementType (OSCTXT* pctxt, TokenElementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->description = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeStamp"))) {
            pvalue->m.timeStampPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->timeStamp);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("value"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->value = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->value = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_TelemetryElement (OSCTXT* pctxt, TelemetryElement* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UUVTelemetry"))) {
            pvalue->t = 1;
            pvalue->u.uUVTelemetry
                = rtxMemAllocType (pctxt, UuvTelemetryElementType);

            if (pvalue->u.uUVTelemetry == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UuvTelemetryElementType (pvalue->u.uUVTelemetry);
            DOMTest_UuvTelemetryElementType (pctxt, pvalue->u.uUVTelemetry, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("USVTelemetry"))) {
            pvalue->t = 2;
            pvalue->u.uSVTelemetry
                = rtxMemAllocType (pctxt, UsvTelemetryElementType);

            if (pvalue->u.uSVTelemetry == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UsvTelemetryElementType (pvalue->u.uSVTelemetry);
            DOMTest_UsvTelemetryElementType (pctxt, pvalue->u.uSVTelemetry, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UGVTelemetry"))) {
            pvalue->t = 3;
            pvalue->u.uGVTelemetry
                = rtxMemAllocType (pctxt, UgvTelemetryElementType);

            if (pvalue->u.uGVTelemetry == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UgvTelemetryElementType (pvalue->u.uGVTelemetry);
            DOMTest_UgvTelemetryElementType (pctxt, pvalue->u.uGVTelemetry, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UAVTelemetry"))) {
            pvalue->t = 4;
            pvalue->u.uAVTelemetry
                = rtxMemAllocType (pctxt, UavTelemetryElementType);

            if (pvalue->u.uAVTelemetry == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UavTelemetryElementType (pvalue->u.uAVTelemetry);
            DOMTest_UavTelemetryElementType (pctxt, pvalue->u.uAVTelemetry, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

