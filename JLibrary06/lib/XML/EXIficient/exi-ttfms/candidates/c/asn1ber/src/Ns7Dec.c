/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "Ns7.h"
#include "Ns12.h"
#include "Ns3.h"
#include "Ns10.h"
#include "Ns15.h"
#include "Odf.h"
#include "rtxsrc/rtxCommon.h"

/**************************************************************/
/*                                                            */
/*  Ambient_color                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns7_Ambient_color (OSCTXT* pctxt, Ns7_Ambient_color *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns7_Ambient_color (OSCTXT* pctxt, Ns7_Ambient_color* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Distance                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns7_Distance (OSCTXT* pctxt, Ns7_Distance *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns7_Distance (OSCTXT* pctxt, Ns7_Distance* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Focal_length                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns7_Focal_length (OSCTXT* pctxt, Ns7_Focal_length *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns7_Focal_length (OSCTXT* pctxt, Ns7_Focal_length* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Lighting_mode                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns7_Lighting_mode (OSCTXT* pctxt, Ns7_Lighting_mode *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns7_Lighting_mode (OSCTXT* pctxt, Ns7_Lighting_mode* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns7_Lighting_mode_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Projection                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns7_Projection (OSCTXT* pctxt, Ns7_Projection *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns7_Projection (OSCTXT* pctxt, Ns7_Projection* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns7_Projection_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Shade_mode                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns7_Shade_mode (OSCTXT* pctxt, Ns7_Shade_mode *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns7_Shade_mode (OSCTXT* pctxt, Ns7_Shade_mode* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns7_Shade_mode_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Shadow_slant                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns7_Shadow_slant (OSCTXT* pctxt, Ns7_Shadow_slant *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_unsigned (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns7_Shadow_slant (OSCTXT* pctxt, Ns7_Shadow_slant* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecUInt (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Transform                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns7_Transform (OSCTXT* pctxt, Ns7_Transform *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns7_Transform (OSCTXT* pctxt, Ns7_Transform* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Vpn                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns7_Vpn (OSCTXT* pctxt, Ns7_Vpn *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns7_Vpn (OSCTXT* pctxt, Ns7_Vpn* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Vrp                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns7_Vrp (OSCTXT* pctxt, Ns7_Vrp *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns7_Vrp (OSCTXT* pctxt, Ns7_Vrp* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Vup                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns7_Vup (OSCTXT* pctxt, Ns7_Vup *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns7_Vup (OSCTXT* pctxt, Ns7_Vup* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Light_enabled                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns7_Light_enabled (OSCTXT* pctxt, Ns7_Light_enabled *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns7_Light_enabled (OSCTXT* pctxt, Ns7_Light_enabled* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns7_Light_enabled_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Light_specular                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns7_Light_specular (OSCTXT* pctxt, 
   Ns7_Light_specular *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns7_Light_specular (OSCTXT* pctxt, Ns7_Light_specular* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns7_Light_specular_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Light                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns7_Light (OSCTXT* pctxt, Ns7_Light *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode diffuse_color */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->diffuse_color, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.diffuse_colorPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode direction */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->direction, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode enabled */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns7_Light_enabled (pctxt, 
               &pvalue->enabled, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.enabledPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode specular */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns7_Light_specular (pctxt, 
               &pvalue->specular, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.specularPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns7_Light (OSCTXT* pctxt, Ns7_Light* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("diffuse-color"), 13}, 0 },
         { {OSUTF8("direction"), 9}, 0 },
         { {OSUTF8("enabled"), 7}, 0 },
         { {OSUTF8("specular"), 8}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* diffuse-color */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->diffuse_color);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.diffuse_colorPresent = TRUE;
            break;

         case 1: /* direction */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->direction);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* enabled */
            stat = XmlDec_Ns7_Light_enabled (pctxt, &pvalue->enabled);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.enabledPresent = TRUE;
            break;

         case 3: /* specular */
            stat = XmlDec_Ns7_Light_specular (pctxt, &pvalue->specular);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.specularPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns7_Light");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns7_Light");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Extrude                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns7_Extrude (OSCTXT* pctxt, Ns7_Extrude *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode transform */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns7_Transform (pctxt, 
               &pvalue->transform, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.transformPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode class_names */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               (Ns3_Class_names*)&pvalue->class_names, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_namesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Id (pctxt, 
               (Ns3_Id*)&pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode layer */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Layer_1 (pctxt, 
               (Ns3_Layer_1*)&pvalue->layer, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.layerPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->style_name = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name);
            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name);

            stat = asn1D_Ns3_Style_name (pctxt, 
               (Ns3_Style_name*)pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode z_index */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Z_index (pctxt, 
               (Ns3_Z_index*)&pvalue->z_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.z_indexPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode class_names_1 */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               (Ns3_Class_names*)&pvalue->class_names_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_names_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode style_name_1 */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->style_name_1 = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name_1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name_1);
            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name_1);

            stat = asn1D_Ns3_Style_name (pctxt, 
               (Ns3_Style_name*)pvalue->style_name_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_name_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode d */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_D (pctxt, 
               (D*)&pvalue->d, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 9:
         /* decode viewBox */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ViewBox (pctxt, 
               (ViewBox*)&pvalue->viewBox, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns7_Extrude (OSCTXT* pctxt, Ns7_Extrude* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("transform"), 9}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("layer"), 5}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("z-index"), 7}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("d"), 1}, 0 },
         { {OSUTF8("viewBox"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 10, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* transform */
            stat = XmlDec_Ns7_Transform (pctxt, &pvalue->transform);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.transformPresent = TRUE;
            break;

         case 1: /* class-names */
            rtxDListInit (&pvalue->class_names);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_namesPresent = TRUE;
            break;

         case 2: /* id */
            stat = XmlDec_Ns3_Id (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 3: /* layer */
            stat = XmlDec_Ns3_Layer_1 (pctxt, &pvalue->layer);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.layerPresent = TRUE;
            break;

         case 4: /* style-name */
            pvalue->style_name = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name);

            stat = XmlDec_Ns3_Style_name (pctxt, pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 5: /* z-index */
            stat = XmlDec_Ns3_Z_index (pctxt, &pvalue->z_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.z_indexPresent = TRUE;
            break;

         case 6: /* class-names */
            rtxDListInit (&pvalue->class_names_1);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_names_1Present = TRUE;
            break;

         case 7: /* style-name */
            pvalue->style_name_1 = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name_1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name_1);

            stat = XmlDec_Ns3_Style_name (pctxt, pvalue->style_name_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_name_1Present = TRUE;
            break;

         case 8: /* d */
            stat = XmlDec_D (pctxt, &pvalue->d);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 9: /* viewBox */
            rtxDListInit (&pvalue->viewBox);
            rtXmlpSetListMode (pctxt);

            while (rtXmlpListHasItem(pctxt)) {
               ViewBox_element* pdata1 = rtxMemAllocType (pctxt, 
                  ViewBox_element);
               if (0 == pdata1) LOG_RTERR (pctxt, RTERR_NOMEM);

               stat = XmlDec_ViewBox_element (pctxt, pdata1);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               if (0 == rtxDListAppend (pctxt, &pvalue->viewBox, pdata1)) {
                  return LOG_RTERR (pctxt, RTERR_NOMEM);
               }
            }
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns7_Extrude");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns7_Extrude");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sphere                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns7_Sphere (OSCTXT* pctxt, Ns7_Sphere *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode center */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->center, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.centerPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode size */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->size, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sizePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode transform */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns7_Transform (pctxt, 
               &pvalue->transform, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.transformPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode class_names */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               (Ns3_Class_names*)&pvalue->class_names, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_namesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Id (pctxt, 
               (Ns3_Id*)&pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode layer */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Layer_1 (pctxt, 
               (Ns3_Layer_1*)&pvalue->layer, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.layerPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->style_name = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name);
            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name);

            stat = asn1D_Ns3_Style_name (pctxt, 
               (Ns3_Style_name*)pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode z_index */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Z_index (pctxt, 
               (Ns3_Z_index*)&pvalue->z_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.z_indexPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode class_names_1 */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               (Ns3_Class_names*)&pvalue->class_names_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_names_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode style_name_1 */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->style_name_1 = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name_1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name_1);
            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name_1);

            stat = asn1D_Ns3_Style_name (pctxt, 
               (Ns3_Style_name*)pvalue->style_name_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_name_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns7_Sphere (OSCTXT* pctxt, Ns7_Sphere* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("center"), 6}, 0 },
         { {OSUTF8("size"), 4}, 0 },
         { {OSUTF8("transform"), 9}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("layer"), 5}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("z-index"), 7}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 10, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* center */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->center);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.centerPresent = TRUE;
            break;

         case 1: /* size */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->size);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.sizePresent = TRUE;
            break;

         case 2: /* transform */
            stat = XmlDec_Ns7_Transform (pctxt, &pvalue->transform);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.transformPresent = TRUE;
            break;

         case 3: /* class-names */
            rtxDListInit (&pvalue->class_names);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_namesPresent = TRUE;
            break;

         case 4: /* id */
            stat = XmlDec_Ns3_Id (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 5: /* layer */
            stat = XmlDec_Ns3_Layer_1 (pctxt, &pvalue->layer);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.layerPresent = TRUE;
            break;

         case 6: /* style-name */
            pvalue->style_name = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name);

            stat = XmlDec_Ns3_Style_name (pctxt, pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 7: /* z-index */
            stat = XmlDec_Ns3_Z_index (pctxt, &pvalue->z_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.z_indexPresent = TRUE;
            break;

         case 8: /* class-names */
            rtxDListInit (&pvalue->class_names_1);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_names_1Present = TRUE;
            break;

         case 9: /* style-name */
            pvalue->style_name_1 = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name_1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name_1);

            stat = XmlDec_Ns3_Style_name (pctxt, pvalue->style_name_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_name_1Present = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns7_Sphere");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns7_Sphere");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Rotate                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns7_Rotate (OSCTXT* pctxt, Ns7_Rotate *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode transform */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns7_Transform (pctxt, 
               &pvalue->transform, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.transformPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode class_names */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               (Ns3_Class_names*)&pvalue->class_names, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_namesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Id (pctxt, 
               (Ns3_Id*)&pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode layer */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Layer_1 (pctxt, 
               (Ns3_Layer_1*)&pvalue->layer, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.layerPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->style_name = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name);
            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name);

            stat = asn1D_Ns3_Style_name (pctxt, 
               (Ns3_Style_name*)pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode z_index */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Z_index (pctxt, 
               (Ns3_Z_index*)&pvalue->z_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.z_indexPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode class_names_1 */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               (Ns3_Class_names*)&pvalue->class_names_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_names_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode style_name_1 */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->style_name_1 = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name_1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name_1);
            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name_1);

            stat = asn1D_Ns3_Style_name (pctxt, 
               (Ns3_Style_name*)pvalue->style_name_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_name_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode d */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_D (pctxt, 
               (D*)&pvalue->d, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 9:
         /* decode viewBox */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ViewBox (pctxt, 
               (ViewBox*)&pvalue->viewBox, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns7_Rotate (OSCTXT* pctxt, Ns7_Rotate* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("transform"), 9}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("layer"), 5}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("z-index"), 7}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("d"), 1}, 0 },
         { {OSUTF8("viewBox"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 10, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* transform */
            stat = XmlDec_Ns7_Transform (pctxt, &pvalue->transform);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.transformPresent = TRUE;
            break;

         case 1: /* class-names */
            rtxDListInit (&pvalue->class_names);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_namesPresent = TRUE;
            break;

         case 2: /* id */
            stat = XmlDec_Ns3_Id (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 3: /* layer */
            stat = XmlDec_Ns3_Layer_1 (pctxt, &pvalue->layer);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.layerPresent = TRUE;
            break;

         case 4: /* style-name */
            pvalue->style_name = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name);

            stat = XmlDec_Ns3_Style_name (pctxt, pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 5: /* z-index */
            stat = XmlDec_Ns3_Z_index (pctxt, &pvalue->z_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.z_indexPresent = TRUE;
            break;

         case 6: /* class-names */
            rtxDListInit (&pvalue->class_names_1);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_names_1Present = TRUE;
            break;

         case 7: /* style-name */
            pvalue->style_name_1 = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name_1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name_1);

            stat = XmlDec_Ns3_Style_name (pctxt, pvalue->style_name_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_name_1Present = TRUE;
            break;

         case 8: /* d */
            stat = XmlDec_D (pctxt, &pvalue->d);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 9: /* viewBox */
            rtxDListInit (&pvalue->viewBox);
            rtXmlpSetListMode (pctxt);

            while (rtXmlpListHasItem(pctxt)) {
               ViewBox_element* pdata1 = rtxMemAllocType (pctxt, 
                  ViewBox_element);
               if (0 == pdata1) LOG_RTERR (pctxt, RTERR_NOMEM);

               stat = XmlDec_ViewBox_element (pctxt, pdata1);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               if (0 == rtxDListAppend (pctxt, &pvalue->viewBox, pdata1)) {
                  return LOG_RTERR (pctxt, RTERR_NOMEM);
               }
            }
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns7_Rotate");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns7_Rotate");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cube                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns7_Cube (OSCTXT* pctxt, Ns7_Cube *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode max_edge */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->max_edge, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.max_edgePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode min_edge */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->min_edge, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.min_edgePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode transform */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns7_Transform (pctxt, 
               &pvalue->transform, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.transformPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode class_names */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               (Ns3_Class_names*)&pvalue->class_names, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_namesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Id (pctxt, 
               (Ns3_Id*)&pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode layer */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Layer_1 (pctxt, 
               (Ns3_Layer_1*)&pvalue->layer, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.layerPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->style_name = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name);
            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name);

            stat = asn1D_Ns3_Style_name (pctxt, 
               (Ns3_Style_name*)pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode z_index */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Z_index (pctxt, 
               (Ns3_Z_index*)&pvalue->z_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.z_indexPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode class_names_1 */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               (Ns3_Class_names*)&pvalue->class_names_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_names_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode style_name_1 */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->style_name_1 = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name_1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name_1);
            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name_1);

            stat = asn1D_Ns3_Style_name (pctxt, 
               (Ns3_Style_name*)pvalue->style_name_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_name_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns7_Cube (OSCTXT* pctxt, Ns7_Cube* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("max-edge"), 8}, 0 },
         { {OSUTF8("min-edge"), 8}, 0 },
         { {OSUTF8("transform"), 9}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("layer"), 5}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("z-index"), 7}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 10, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* max-edge */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->max_edge);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.max_edgePresent = TRUE;
            break;

         case 1: /* min-edge */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->min_edge);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.min_edgePresent = TRUE;
            break;

         case 2: /* transform */
            stat = XmlDec_Ns7_Transform (pctxt, &pvalue->transform);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.transformPresent = TRUE;
            break;

         case 3: /* class-names */
            rtxDListInit (&pvalue->class_names);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_namesPresent = TRUE;
            break;

         case 4: /* id */
            stat = XmlDec_Ns3_Id (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 5: /* layer */
            stat = XmlDec_Ns3_Layer_1 (pctxt, &pvalue->layer);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.layerPresent = TRUE;
            break;

         case 6: /* style-name */
            pvalue->style_name = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name);

            stat = XmlDec_Ns3_Style_name (pctxt, pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 7: /* z-index */
            stat = XmlDec_Ns3_Z_index (pctxt, &pvalue->z_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.z_indexPresent = TRUE;
            break;

         case 8: /* class-names */
            rtxDListInit (&pvalue->class_names_1);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_names_1Present = TRUE;
            break;

         case 9: /* style-name */
            pvalue->style_name_1 = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name_1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name_1);

            stat = XmlDec_Ns3_Style_name (pctxt, pvalue->style_name_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_name_1Present = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns7_Cube");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns7_Cube");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Scene_element                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns7_Scene_element (OSCTXT* pctxt, Ns7_Scene_element *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

         if (pvalue->u.scene == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);
         stat = asn1D_Ns7_Scene (pctxt, 
            (Ns7_Scene*)pvalue->u.scene, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.extrude = rtxMemAllocType (pctxt, Ns7_Extrude);

         if (pvalue->u.extrude == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns7_Extrude (pvalue->u.extrude);
         stat = asn1D_Ns7_Extrude (pctxt, 
            pvalue->u.extrude, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.sphere = rtxMemAllocType (pctxt, Ns7_Sphere);

         if (pvalue->u.sphere == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns7_Sphere (pvalue->u.sphere);
         stat = asn1D_Ns7_Sphere (pctxt, 
            pvalue->u.sphere, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.rotate = rtxMemAllocType (pctxt, Ns7_Rotate);

         if (pvalue->u.rotate == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns7_Rotate (pvalue->u.rotate);
         stat = asn1D_Ns7_Rotate (pctxt, 
            pvalue->u.rotate, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.cube = rtxMemAllocType (pctxt, Ns7_Cube);

         if (pvalue->u.cube == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns7_Cube (pvalue->u.cube);
         stat = asn1D_Ns7_Cube (pctxt, 
            pvalue->u.cube, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns7_Scene_element (OSCTXT* pctxt, Ns7_Scene_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("scene"), 5}, 0}, 0 },
      {{{OSUTF8("extrude"), 7}, 0}, 1 },
      {{{OSUTF8("sphere"), 6}, 0}, 2 },
      {{{OSUTF8("rotate"), 6}, 0}, 3 },
      {{{OSUTF8("cube"), 4}, 0}, 4 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 5, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* scene */
      pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

      if (pvalue->u.scene == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);

      stat = XmlDec_Ns7_Scene (pctxt, pvalue->u.scene);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* extrude */
      pvalue->u.extrude = rtxMemAllocType (pctxt, Ns7_Extrude);

      if (pvalue->u.extrude == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns7_Extrude (pvalue->u.extrude);

      stat = XmlDec_Ns7_Extrude (pctxt, pvalue->u.extrude);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* sphere */
      pvalue->u.sphere = rtxMemAllocType (pctxt, Ns7_Sphere);

      if (pvalue->u.sphere == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns7_Sphere (pvalue->u.sphere);

      stat = XmlDec_Ns7_Sphere (pctxt, pvalue->u.sphere);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* rotate */
      pvalue->u.rotate = rtxMemAllocType (pctxt, Ns7_Rotate);

      if (pvalue->u.rotate == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns7_Rotate (pvalue->u.rotate);

      stat = XmlDec_Ns7_Rotate (pctxt, pvalue->u.rotate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* cube */
      pvalue->u.cube = rtxMemAllocType (pctxt, Ns7_Cube);

      if (pvalue->u.cube == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns7_Cube (pvalue->u.cube);

      stat = XmlDec_Ns7_Cube (pctxt, pvalue->u.cube);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Scene                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns7_Scene (OSCTXT* pctxt, Ns7_Scene *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode ambient_color */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns7_Ambient_color (pctxt, 
               &pvalue->ambient_color, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.ambient_colorPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode distance */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns7_Distance (pctxt, 
               &pvalue->distance, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.distancePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode focal_length */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns7_Focal_length (pctxt, 
               &pvalue->focal_length, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.focal_lengthPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode lighting_mode */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns7_Lighting_mode (pctxt, 
               &pvalue->lighting_mode, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.lighting_modePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode projection */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns7_Projection (pctxt, 
               &pvalue->projection, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.projectionPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode shade_mode */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns7_Shade_mode (pctxt, 
               &pvalue->shade_mode, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.shade_modePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode shadow_slant */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns7_Shadow_slant (pctxt, 
               &pvalue->shadow_slant, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.shadow_slantPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode transform */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns7_Transform (pctxt, 
               &pvalue->transform, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.transformPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode vpn */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns7_Vpn (pctxt, 
               &pvalue->vpn, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.vpnPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode vrp */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns7_Vrp (pctxt, 
               &pvalue->vrp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.vrpPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode vup */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns7_Vup (pctxt, 
               &pvalue->vup, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.vupPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode class_names */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               (Ns3_Class_names*)&pvalue->class_names, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_namesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 12:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Id (pctxt, 
               (Ns3_Id*)&pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode layer */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Layer_1 (pctxt, 
               (Ns3_Layer_1*)&pvalue->layer, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.layerPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->style_name = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name);
            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name);

            stat = asn1D_Ns3_Style_name (pctxt, 
               (Ns3_Style_name*)pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 15:
         /* decode z_index */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Z_index (pctxt, 
               (Ns3_Z_index*)&pvalue->z_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.z_indexPresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode class_names_1 */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               (Ns3_Class_names*)&pvalue->class_names_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_names_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 17:
         /* decode style_name_1 */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->style_name_1 = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name_1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name_1);
            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name_1);

            stat = asn1D_Ns3_Style_name (pctxt, 
               (Ns3_Style_name*)pvalue->style_name_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_name_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 18:
         /* decode height */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->height, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.heightPresent = TRUE;
            }
         }
         break;

      case 19:
         /* decode width */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->width, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.widthPresent = TRUE;
            }
         }
         break;

      case 20:
         /* decode x */
         if (XD_PEEKTAG (pctxt, 0x94)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.xPresent = TRUE;
            }
         }
         break;

      case 21:
         /* decode y */
         if (XD_PEEKTAG (pctxt, 0x95)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.yPresent = TRUE;
            }
         }
         break;

      case 22:
         /* decode end_cell_address */
         if (XD_PEEKTAG (pctxt, 0x96)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_cell_address (pctxt, 
               (End_cell_address*)&pvalue->end_cell_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_cell_addressPresent = TRUE;
            }
         }
         break;

      case 23:
         /* decode end_x */
         if (XD_PEEKTAG (pctxt, 0x97)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_x (pctxt, 
               (End_x*)&pvalue->end_x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_xPresent = TRUE;
            }
         }
         break;

      case 24:
         /* decode end_y */
         if (XD_PEEKTAG (pctxt, 0x98)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_y (pctxt, 
               (End_y*)&pvalue->end_y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_yPresent = TRUE;
            }
         }
         break;

      case 25:
         /* decode table_background */
         if (XD_PEEKTAG (pctxt, 0x99)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_background (pctxt, 
               (Table_background*)&pvalue->table_background, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_backgroundPresent = TRUE;
            }
         }
         break;

      case 26:
         /* decode anchor_page_number */
         if (XD_PEEKTAG (pctxt, 0x9a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_page_number (pctxt, 
               (Odf_Anchor_page_number*)&pvalue->anchor_page_number, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_page_numberPresent = TRUE;
            }
         }
         break;

      case 27:
         /* decode anchor_type */
         if (XD_PEEKTAG (pctxt, 0x9b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_type (pctxt, 
               (Odf_Anchor_type*)&pvalue->anchor_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_typePresent = TRUE;
            }
         }
         break;

      case 28:
         /* decode light_list */
         if (XD_PEEKTAG (pctxt, 0x9c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns7_Light* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->light_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns7_Light, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns7_Light (pdata2);

                  stat = asn1D_Ns7_Light (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->light_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 29:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x9d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns7_Scene_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns7_Scene_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns7_Scene_element (pdata2);

                  stat = asn1D_Ns7_Scene_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_PRIM|18):
         case (TM_CTXT|TM_CONS|18):
         case (TM_CTXT|TM_PRIM|19):
         case (TM_CTXT|TM_CONS|19):
         case (TM_CTXT|TM_PRIM|20):
         case (TM_CTXT|TM_CONS|20):
         case (TM_CTXT|TM_PRIM|21):
         case (TM_CTXT|TM_CONS|21):
         case (TM_CTXT|TM_PRIM|22):
         case (TM_CTXT|TM_CONS|22):
         case (TM_CTXT|TM_PRIM|23):
         case (TM_CTXT|TM_CONS|23):
         case (TM_CTXT|TM_PRIM|24):
         case (TM_CTXT|TM_CONS|24):
         case (TM_CTXT|TM_PRIM|25):
         case (TM_CTXT|TM_PRIM|26):
         case (TM_CTXT|TM_PRIM|27):
         case (TM_CTXT|TM_CONS|28):
         case (TM_CTXT|TM_CONS|29):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns7_Scene (OSCTXT* pctxt, Ns7_Scene* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("ambient-color"), 13}, 0 },
         { {OSUTF8("distance"), 8}, 0 },
         { {OSUTF8("focal-length"), 12}, 0 },
         { {OSUTF8("lighting-mode"), 13}, 0 },
         { {OSUTF8("projection"), 10}, 0 },
         { {OSUTF8("shade-mode"), 10}, 0 },
         { {OSUTF8("shadow-slant"), 12}, 0 },
         { {OSUTF8("transform"), 9}, 0 },
         { {OSUTF8("vpn"), 3}, 0 },
         { {OSUTF8("vrp"), 3}, 0 },
         { {OSUTF8("vup"), 3}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("layer"), 5}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("z-index"), 7}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("height"), 6}, 0 },
         { {OSUTF8("width"), 5}, 0 },
         { {OSUTF8("x"), 1}, 0 },
         { {OSUTF8("y"), 1}, 0 },
         { {OSUTF8("end-cell-address"), 16}, 0 },
         { {OSUTF8("end-x"), 5}, 0 },
         { {OSUTF8("end-y"), 5}, 0 },
         { {OSUTF8("table-background"), 16}, 0 },
         { {OSUTF8("anchor-page-number"), 18}, 0 },
         { {OSUTF8("anchor-type"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 28, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* ambient-color */
            stat = XmlDec_Ns7_Ambient_color (pctxt, &pvalue->ambient_color);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.ambient_colorPresent = TRUE;
            break;

         case 1: /* distance */
            stat = XmlDec_Ns7_Distance (pctxt, &pvalue->distance);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.distancePresent = TRUE;
            break;

         case 2: /* focal-length */
            stat = XmlDec_Ns7_Focal_length (pctxt, &pvalue->focal_length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.focal_lengthPresent = TRUE;
            break;

         case 3: /* lighting-mode */
            stat = XmlDec_Ns7_Lighting_mode (pctxt, &pvalue->lighting_mode);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.lighting_modePresent = TRUE;
            break;

         case 4: /* projection */
            stat = XmlDec_Ns7_Projection (pctxt, &pvalue->projection);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.projectionPresent = TRUE;
            break;

         case 5: /* shade-mode */
            stat = XmlDec_Ns7_Shade_mode (pctxt, &pvalue->shade_mode);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.shade_modePresent = TRUE;
            break;

         case 6: /* shadow-slant */
            stat = XmlDec_Ns7_Shadow_slant (pctxt, &pvalue->shadow_slant);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.shadow_slantPresent = TRUE;
            break;

         case 7: /* transform */
            stat = XmlDec_Ns7_Transform (pctxt, &pvalue->transform);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.transformPresent = TRUE;
            break;

         case 8: /* vpn */
            stat = XmlDec_Ns7_Vpn (pctxt, &pvalue->vpn);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.vpnPresent = TRUE;
            break;

         case 9: /* vrp */
            stat = XmlDec_Ns7_Vrp (pctxt, &pvalue->vrp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.vrpPresent = TRUE;
            break;

         case 10: /* vup */
            stat = XmlDec_Ns7_Vup (pctxt, &pvalue->vup);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.vupPresent = TRUE;
            break;

         case 11: /* class-names */
            rtxDListInit (&pvalue->class_names);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_namesPresent = TRUE;
            break;

         case 12: /* id */
            stat = XmlDec_Ns3_Id (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 13: /* layer */
            stat = XmlDec_Ns3_Layer_1 (pctxt, &pvalue->layer);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.layerPresent = TRUE;
            break;

         case 14: /* style-name */
            pvalue->style_name = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name);

            stat = XmlDec_Ns3_Style_name (pctxt, pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 15: /* z-index */
            stat = XmlDec_Ns3_Z_index (pctxt, &pvalue->z_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.z_indexPresent = TRUE;
            break;

         case 16: /* class-names */
            rtxDListInit (&pvalue->class_names_1);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_names_1Present = TRUE;
            break;

         case 17: /* style-name */
            pvalue->style_name_1 = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name_1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name_1);

            stat = XmlDec_Ns3_Style_name (pctxt, pvalue->style_name_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_name_1Present = TRUE;
            break;

         case 18: /* height */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->height);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.heightPresent = TRUE;
            break;

         case 19: /* width */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->width);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.widthPresent = TRUE;
            break;

         case 20: /* x */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.xPresent = TRUE;
            break;

         case 21: /* y */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.yPresent = TRUE;
            break;

         case 22: /* end-cell-address */
            stat = XmlDec_End_cell_address (pctxt, &pvalue->end_cell_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_cell_addressPresent = TRUE;
            break;

         case 23: /* end-x */
            stat = XmlDec_End_x (pctxt, &pvalue->end_x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_xPresent = TRUE;
            break;

         case 24: /* end-y */
            stat = XmlDec_End_y (pctxt, &pvalue->end_y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_yPresent = TRUE;
            break;

         case 25: /* table-background */
            stat = XmlDec_Table_background (pctxt, &pvalue->table_background);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.table_backgroundPresent = TRUE;
            break;

         case 26: /* anchor-page-number */
            stat = XmlDec_Odf_Anchor_page_number (pctxt, &pvalue->
               anchor_page_number);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_page_numberPresent = TRUE;
            break;

         case 27: /* anchor-type */
            stat = XmlDec_Odf_Anchor_type (pctxt, &pvalue->anchor_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_typePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns7_Scene");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns7_Scene");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("light"), 5}, 0}, 0 },
      {{{OSUTF8("scene"), 5}, 0}, 1 },
      {{{OSUTF8("extrude"), 7}, 0}, 1 },
      {{{OSUTF8("sphere"), 6}, 0}, 1 },
      {{{OSUTF8("rotate"), 6}, 0}, 1 },
      {{{OSUTF8("cube"), 4}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 6, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Ns7_Light* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns7_Light);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns7_Light (pdata1);

            stat = XmlDec_Ns7_Light (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->light_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 1: {
         Ns7_Scene_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns7_Scene_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns7_Scene_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns7_Scene_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 5, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

