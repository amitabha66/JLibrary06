/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "Periodic.h"
#include "rtxsrc/rtxCommon.h"

/**************************************************************/
/*                                                            */
/*  PERIODIC_TABLE_aTOM_element_bOILING_POINT                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PERIODIC_TABLE_aTOM_element_bOILING_POINT (OSCTXT* pctxt,
   PERIODIC_TABLE_aTOM_element_bOILING_POINT *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_real (pctxt, &pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode uNITS */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->uNITS, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PERIODIC_TABLE_aTOM_element_bOILING_POINT (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_bOILING_POINT* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" UNITS=\""), 8);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->uNITS, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   /* encode base */

   stat = rtXmlEncDouble (pctxt, pvalue->base, 0, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PERIODIC_TABLE_aTOM_element_mELTING_POINT                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PERIODIC_TABLE_aTOM_element_mELTING_POINT (OSCTXT* pctxt,
   PERIODIC_TABLE_aTOM_element_mELTING_POINT *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_real (pctxt, &pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode uNITS */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->uNITS, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PERIODIC_TABLE_aTOM_element_mELTING_POINT (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_mELTING_POINT* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" UNITS=\""), 8);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->uNITS, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   /* encode base */

   stat = rtXmlEncDouble (pctxt, pvalue->base, 0, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PERIODIC_TABLE_aTOM_element_dENSITY                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PERIODIC_TABLE_aTOM_element_dENSITY (OSCTXT* pctxt,
   PERIODIC_TABLE_aTOM_element_dENSITY *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_real (pctxt, &pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode uNITS */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->uNITS, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PERIODIC_TABLE_aTOM_element_dENSITY (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_dENSITY* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" UNITS=\""), 8);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->uNITS, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   /* encode base */

   stat = rtXmlEncDouble (pctxt, pvalue->base, 0, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PERIODIC_TABLE_aTOM_element_cOVALENT_RADIUS               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PERIODIC_TABLE_aTOM_element_cOVALENT_RADIUS (OSCTXT* pctxt,
   PERIODIC_TABLE_aTOM_element_cOVALENT_RADIUS *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_real (pctxt, &pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode uNITS */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->uNITS, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PERIODIC_TABLE_aTOM_element_cOVALENT_RADIUS (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_cOVALENT_RADIUS* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" UNITS=\""), 8);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->uNITS, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   /* encode base */

   stat = rtXmlEncDouble (pctxt, pvalue->base, 0, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PERIODIC_TABLE_aTOM_element_aTOMIC_RADIUS                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PERIODIC_TABLE_aTOM_element_aTOMIC_RADIUS (OSCTXT* pctxt,
   PERIODIC_TABLE_aTOM_element_aTOMIC_RADIUS *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_real (pctxt, &pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode uNITS */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->uNITS, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PERIODIC_TABLE_aTOM_element_aTOMIC_RADIUS (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_aTOMIC_RADIUS* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" UNITS=\""), 8);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->uNITS, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   /* encode base */

   stat = rtXmlEncDouble (pctxt, pvalue->base, 0, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PERIODIC_TABLE_aTOM_element_hEAT_OF_VAPORIZATION          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PERIODIC_TABLE_aTOM_element_hEAT_OF_VAPORIZATION (OSCTXT* pctxt,
   PERIODIC_TABLE_aTOM_element_hEAT_OF_VAPORIZATION *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_real (pctxt, &pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode uNITS */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->uNITS, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PERIODIC_TABLE_aTOM_element_hEAT_OF_VAPORIZATION (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_hEAT_OF_VAPORIZATION* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" UNITS=\""), 8);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->uNITS, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   /* encode base */

   stat = rtXmlEncDouble (pctxt, pvalue->base, 0, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PERIODIC_TABLE_aTOM_element_aTOMIC_VOLUME                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PERIODIC_TABLE_aTOM_element_aTOMIC_VOLUME (OSCTXT* pctxt,
   PERIODIC_TABLE_aTOM_element_aTOMIC_VOLUME *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_real (pctxt, &pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode uNITS */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->uNITS, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PERIODIC_TABLE_aTOM_element_aTOMIC_VOLUME (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_aTOMIC_VOLUME* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" UNITS=\""), 8);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->uNITS, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   /* encode base */

   stat = rtXmlEncDouble (pctxt, pvalue->base, 0, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PERIODIC_TABLE_aTOM_element_hEAT_OF_FUSION                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PERIODIC_TABLE_aTOM_element_hEAT_OF_FUSION (OSCTXT* pctxt,
   PERIODIC_TABLE_aTOM_element_hEAT_OF_FUSION *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_real (pctxt, &pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode uNITS */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->uNITS, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PERIODIC_TABLE_aTOM_element_hEAT_OF_FUSION (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_hEAT_OF_FUSION* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" UNITS=\""), 8);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->uNITS, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   /* encode base */

   stat = rtXmlEncDouble (pctxt, pvalue->base, 0, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PERIODIC_TABLE_aTOM_element_sPECIFIC_HEAT_CAPACITY        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PERIODIC_TABLE_aTOM_element_sPECIFIC_HEAT_CAPACITY (OSCTXT* pctxt,
   PERIODIC_TABLE_aTOM_element_sPECIFIC_HEAT_CAPACITY *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_real (pctxt, &pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode uNITS */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->uNITS, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PERIODIC_TABLE_aTOM_element_sPECIFIC_HEAT_CAPACITY (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_sPECIFIC_HEAT_CAPACITY* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" UNITS=\""), 8);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->uNITS, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   /* encode base */

   stat = rtXmlEncDouble (pctxt, pvalue->base, 0, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PERIODIC_TABLE_aTOM_element_tHERMAL_CONDUCTIVITY          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PERIODIC_TABLE_aTOM_element_tHERMAL_CONDUCTIVITY (OSCTXT* pctxt,
   PERIODIC_TABLE_aTOM_element_tHERMAL_CONDUCTIVITY *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_real (pctxt, &pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode uNITS */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->uNITS, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PERIODIC_TABLE_aTOM_element_tHERMAL_CONDUCTIVITY (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_tHERMAL_CONDUCTIVITY* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" UNITS=\""), 8);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->uNITS, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   /* encode base */

   stat = rtXmlEncDouble (pctxt, pvalue->base, 0, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PERIODIC_TABLE_aTOM_element                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PERIODIC_TABLE_aTOM_element (OSCTXT* pctxt,
   PERIODIC_TABLE_aTOM_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            xe_utf8str (pctxt, pvalue->u.nAME, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
            xe_real (pctxt, &pvalue->u.aTOMIC_WEIGHT, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
            xe_uint8 (pctxt, &pvalue->u.aTOMIC_NUMBER, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 4:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
            xe_utf8str (pctxt, pvalue->u.oXIDATION_STATES, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 5:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
            asn1E_PERIODIC_TABLE_aTOM_element_bOILING_POINT (pctxt, pvalue->u.bOILING_POINT, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 6:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
            asn1E_PERIODIC_TABLE_aTOM_element_mELTING_POINT (pctxt, pvalue->u.mELTING_POINT, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 7:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
            xe_utf8str (pctxt, pvalue->u.sYMBOL, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 8:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
            asn1E_PERIODIC_TABLE_aTOM_element_dENSITY (pctxt, pvalue->u.dENSITY, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 9:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|8,
            xe_utf8str (pctxt, pvalue->u.eLECTRON_CONFIGURATION, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 10:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9,
            asn1E_PERIODIC_TABLE_aTOM_element_cOVALENT_RADIUS (pctxt, pvalue->u.cOVALENT_RADIUS, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 11:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|10,
            xe_real (pctxt, &pvalue->u.eLECTRONEGATIVITY, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 12:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|11,
            asn1E_PERIODIC_TABLE_aTOM_element_aTOMIC_RADIUS (pctxt, pvalue->u.aTOMIC_RADIUS, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 13:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|12,
            asn1E_PERIODIC_TABLE_aTOM_element_hEAT_OF_VAPORIZATION (pctxt, pvalue->u.hEAT_OF_VAPORIZATION, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 14:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|13,
            asn1E_PERIODIC_TABLE_aTOM_element_aTOMIC_VOLUME (pctxt, pvalue->u.aTOMIC_VOLUME, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 15:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|14,
            asn1E_PERIODIC_TABLE_aTOM_element_hEAT_OF_FUSION (pctxt, pvalue->u.hEAT_OF_FUSION, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 16:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|15,
            asn1E_PERIODIC_TABLE_aTOM_element_sPECIFIC_HEAT_CAPACITY (pctxt, pvalue->u.sPECIFIC_HEAT_CAPACITY, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 17:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|16,
            xe_real (pctxt, &pvalue->u.iONIZATION_POTENTIAL, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 18:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|17,
            asn1E_PERIODIC_TABLE_aTOM_element_tHERMAL_CONDUCTIVITY (pctxt, pvalue->u.tHERMAL_CONDUCTIVITY, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_PERIODIC_TABLE_aTOM_element (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode nAME */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.nAME
            , OSUTF8("NAME"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode aTOMIC_WEIGHT */

         stat = rtXmlEncDouble (pctxt, pvalue->u.aTOMIC_WEIGHT
            , OSUTF8("ATOMIC_WEIGHT"), nsPrefix, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode aTOMIC_NUMBER */

         stat = rtXmlEncUInt (pctxt, pvalue->u.aTOMIC_NUMBER
            , OSUTF8("ATOMIC_NUMBER"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 4:
         /* encode oXIDATION_STATES */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.oXIDATION_STATES
            , OSUTF8("OXIDATION_STATES"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 5:
         /* encode bOILING_POINT */

         stat = XmlEnc_PERIODIC_TABLE_aTOM_element_bOILING_POINT (pctxt, pvalue
            ->u.bOILING_POINT, OSUTF8("BOILING_POINT"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 6:
         /* encode mELTING_POINT */

         stat = XmlEnc_PERIODIC_TABLE_aTOM_element_mELTING_POINT (pctxt, pvalue
            ->u.mELTING_POINT, OSUTF8("MELTING_POINT"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 7:
         /* encode sYMBOL */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.sYMBOL
            , OSUTF8("SYMBOL"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 8:
         /* encode dENSITY */

         stat = XmlEnc_PERIODIC_TABLE_aTOM_element_dENSITY (pctxt, pvalue->
            u.dENSITY, OSUTF8("DENSITY"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 9:
         /* encode eLECTRON_CONFIGURATION */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.eLECTRON_CONFIGURATION
            , OSUTF8("ELECTRON_CONFIGURATION"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 10:
         /* encode cOVALENT_RADIUS */

         stat = XmlEnc_PERIODIC_TABLE_aTOM_element_cOVALENT_RADIUS (pctxt, 
            pvalue->u.cOVALENT_RADIUS, OSUTF8("COVALENT_RADIUS"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 11:
         /* encode eLECTRONEGATIVITY */

         stat = rtXmlEncDouble (pctxt, pvalue->u.eLECTRONEGATIVITY
            , OSUTF8("ELECTRONEGATIVITY"), nsPrefix, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 12:
         /* encode aTOMIC_RADIUS */

         stat = XmlEnc_PERIODIC_TABLE_aTOM_element_aTOMIC_RADIUS (pctxt, pvalue
            ->u.aTOMIC_RADIUS, OSUTF8("ATOMIC_RADIUS"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 13:
         /* encode hEAT_OF_VAPORIZATION */

         stat = XmlEnc_PERIODIC_TABLE_aTOM_element_hEAT_OF_VAPORIZATION (pctxt
            , pvalue->u.hEAT_OF_VAPORIZATION
            , OSUTF8("HEAT_OF_VAPORIZATION"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 14:
         /* encode aTOMIC_VOLUME */

         stat = XmlEnc_PERIODIC_TABLE_aTOM_element_aTOMIC_VOLUME (pctxt, pvalue
            ->u.aTOMIC_VOLUME, OSUTF8("ATOMIC_VOLUME"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 15:
         /* encode hEAT_OF_FUSION */

         stat = XmlEnc_PERIODIC_TABLE_aTOM_element_hEAT_OF_FUSION (pctxt, 
            pvalue->u.hEAT_OF_FUSION, OSUTF8("HEAT_OF_FUSION"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 16:
         /* encode sPECIFIC_HEAT_CAPACITY */

         stat = XmlEnc_PERIODIC_TABLE_aTOM_element_sPECIFIC_HEAT_CAPACITY (pctxt
            , pvalue->u.sPECIFIC_HEAT_CAPACITY
            , OSUTF8("SPECIFIC_HEAT_CAPACITY"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 17:
         /* encode iONIZATION_POTENTIAL */

         stat = rtXmlEncDouble (pctxt, pvalue->u.iONIZATION_POTENTIAL
            , OSUTF8("IONIZATION_POTENTIAL"), nsPrefix, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 18:
         /* encode tHERMAL_CONDUCTIVITY */

         stat = XmlEnc_PERIODIC_TABLE_aTOM_element_tHERMAL_CONDUCTIVITY (pctxt
            , pvalue->u.tHERMAL_CONDUCTIVITY
            , OSUTF8("THERMAL_CONDUCTIVITY"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PERIODIC_TABLE_aTOM                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PERIODIC_TABLE_aTOM (OSCTXT* pctxt,
   PERIODIC_TABLE_aTOM *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode choice_list */

   if (!(pvalue->choice_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "PERIODIC_TABLE_aTOM.choice_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->choice_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->choice_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PERIODIC_TABLE_aTOM_element (pctxt, ((PERIODIC_TABLE_aTOM_element*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode sTATE */

   if (pvalue->m.sTATEPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->sTATE, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PERIODIC_TABLE_aTOM (OSCTXT* pctxt, PERIODIC_TABLE_aTOM* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.sTATEPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" STATE=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->sTATE, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode choice_list */

   if (!(pvalue->choice_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "PERIODIC_TABLE_aTOM.choice_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->choice_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->choice_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PERIODIC_TABLE_aTOM_element (pctxt, 
         ((PERIODIC_TABLE_aTOM_element*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PERIODIC_TABLE                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PERIODIC_TABLE (OSCTXT* pctxt,
   PERIODIC_TABLE *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "PERIODIC_TABLE.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_PERIODIC_TABLE_aTOM (pctxt, ((PERIODIC_TABLE_aTOM*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PERIODIC_TABLE (OSCTXT* pctxt, PERIODIC_TABLE* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "PERIODIC_TABLE.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_PERIODIC_TABLE_aTOM (pctxt, 
         ((PERIODIC_TABLE_aTOM*)pnode->data), OSUTF8("ATOM"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlEnc_PERIODIC_TABLE_PDU (OSCTXT* pctxt, PERIODIC_TABLE* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("PERIODIC_TABLE"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_PERIODIC_TABLE (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("PERIODIC_TABLE"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
