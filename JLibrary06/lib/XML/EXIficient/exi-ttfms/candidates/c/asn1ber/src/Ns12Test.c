/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "Ns12.h"
#include "Xlink.h"
#include "Ns3.h"
#include "Odf.h"
#include "Ns8.h"
#include "Ns10.h"
#include "Ns6.h"
#include "Ns7.h"
#include "Ns15.h"
#include "Ns13.h"
#include "Elements.h"
#include "Ns16.h"
#include "Ns4.h"
#include "Xforms.h"
#include "Ns2.h"
#include "Ns14.h"
#include "Ns5.h"
#include "Ns1.h"
#include "Ns9.h"
#include "Ns11.h"
#include "MathML.h"
#include "libxml/parser.h"
#include "rtxmlsrc/osrtxml.h"
#include "rtxsrc/rtxCommon.h"

int DOMTest_ViewBox_element (OSCTXT* pctxt, ViewBox_element* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{

   return 0;
}

int DOMTest_ViewBox (OSCTXT* pctxt, ViewBox* pvalue, 
   xmlAttrPtr pXmlNode, OSBOOL setChild)
{
   ViewBox_element* pdata1 = rtxMemAllocTypeZ (pctxt, ViewBox_element);
   DOMTest_ViewBox_element (pctxt, pdata1, pXmlNode, setChild);
   if (0 != pdata1)
      rtxDListAppend (pctxt, pvalue, (void*)pdata1);

   return 0;
}

int DOMTest_Font_face_format (OSCTXT* pctxt, Font_face_format* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("string"))) {
            pvalue->m.stringPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->string = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->string = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_Font_face_uri (OSCTXT* pctxt, Font_face_uri* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("actuate"))) {
            pvalue->m.actuatePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               Font_face_uri_actuate_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->actuate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            pvalue->m.typePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               Xlink_Type_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->type);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("font-face-format"))) {
            { Font_face_format* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Font_face_format);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Font_face_format (pdata2);
            DOMTest_Font_face_format (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->font_face_format_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Font_face_name (OSCTXT* pctxt, Font_face_name* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("name"))) {
            pvalue->m.namePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->name = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->name = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_Font_face_src_element (OSCTXT* pctxt, 
   Font_face_src_element* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("font-face-uri"))) {
            pvalue->t = 1;
            pvalue->u.font_face_uri = rtxMemAllocType (pctxt, Font_face_uri);

            if (pvalue->u.font_face_uri == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Font_face_uri (pvalue->u.font_face_uri);
            DOMTest_Font_face_uri (pctxt, pvalue->u.font_face_uri, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("font-face-name"))) {
            pvalue->t = 2;
            pvalue->u.font_face_name
                = rtxMemAllocType (pctxt, Font_face_name);

            if (pvalue->u.font_face_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Font_face_name (pvalue->u.font_face_name);
            DOMTest_Font_face_name (pctxt, pvalue->u.font_face_name, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_Font_face_src (OSCTXT* pctxt, Font_face_src* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   Font_face_src_element* pdata1 = rtxMemAllocTypeZ (pctxt, Font_face_src_element);
   DOMTest_Font_face_src_element (pctxt, pdata1, pXmlNode, setChild);
   if (0 != pdata1)
      rtxDListAppend (pctxt, pvalue, (void*)pdata1);

   return 0;
}

int DOMTest_Definition_src (OSCTXT* pctxt, Definition_src* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("actuate"))) {
            pvalue->m.actuatePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               Definition_src_actuate_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->actuate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            pvalue->m.typePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               Xlink_Type_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->type);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_LinearGradient_x1 (OSCTXT* pctxt, LinearGradient_x1* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   pvalue->t = 1;
   if (0 != pXmlNode->children) {
      pvalue->u.alt = pXmlNode->children->content;
   }
   else {
      pvalue->u.alt = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_LinearGradient_x2 (OSCTXT* pctxt, LinearGradient_x2* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   pvalue->t = 1;
   if (0 != pXmlNode->children) {
      pvalue->u.alt = pXmlNode->children->content;
   }
   else {
      pvalue->u.alt = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_LinearGradient_y1 (OSCTXT* pctxt, LinearGradient_y1* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   pvalue->t = 1;
   if (0 != pXmlNode->children) {
      pvalue->u.alt = pXmlNode->children->content;
   }
   else {
      pvalue->u.alt = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_LinearGradient_y2 (OSCTXT* pctxt, LinearGradient_y2* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   pvalue->t = 1;
   if (0 != pXmlNode->children) {
      pvalue->u.alt = pXmlNode->children->content;
   }
   else {
      pvalue->u.alt = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_Stop_offset (OSCTXT* pctxt, Stop_offset* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   pvalue->t = 2;
   if (0 != pXmlNode->children) {
      pvalue->u.alt_1 = pXmlNode->children->content;
   }
   else {
      pvalue->u.alt_1 = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_Stop (OSCTXT* pctxt, Stop* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("offset"))) {
            DOMTest_Stop_offset (pctxt, &pvalue->offset, ((xmlNodePtr)pXmlAttr), FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("stop-color"))) {
            pvalue->m.stop_colorPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->stop_color = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->stop_color = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("stop-opacity"))) {
            pvalue->m.stop_opacityPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->stop_opacity);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_LinearGradient (OSCTXT* pctxt, LinearGradient* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("display-name"))) {
            pvalue->m.display_namePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->display_name = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->display_name = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("name"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->name = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->name = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("gradientTransform"))) {
            pvalue->m.gradientTransformPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->gradientTransform = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->gradientTransform = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("gradientUnits"))) {
            pvalue->m.gradientUnitsPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               LinearGradient_gradientUnits_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->gradientUnits);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("spreadMethod"))) {
            pvalue->m.spreadMethodPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               LinearGradient_spreadMethod_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->spreadMethod);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("x1"))) {
            pvalue->m.x1Present = 1;
            DOMTest_LinearGradient_x1 (pctxt, &pvalue->x1, ((xmlNodePtr)pXmlAttr), FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("x2"))) {
            pvalue->m.x2Present = 1;
            DOMTest_LinearGradient_x2 (pctxt, &pvalue->x2, ((xmlNodePtr)pXmlAttr), FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("y1"))) {
            pvalue->m.y1Present = 1;
            DOMTest_LinearGradient_y1 (pctxt, &pvalue->y1, ((xmlNodePtr)pXmlAttr), FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("y2"))) {
            pvalue->m.y2Present = 1;
            DOMTest_LinearGradient_y2 (pctxt, &pvalue->y2, ((xmlNodePtr)pXmlAttr), FALSE);
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("stop"))) {
            { Stop* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Stop);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Stop (pdata2);
            DOMTest_Stop (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->stop_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_RadialGradient_cx (OSCTXT* pctxt, RadialGradient_cx* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   pvalue->t = 1;
   if (0 != pXmlNode->children) {
      pvalue->u.alt = pXmlNode->children->content;
   }
   else {
      pvalue->u.alt = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_RadialGradient_cy (OSCTXT* pctxt, RadialGradient_cy* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   pvalue->t = 1;
   if (0 != pXmlNode->children) {
      pvalue->u.alt = pXmlNode->children->content;
   }
   else {
      pvalue->u.alt = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_RadialGradient_fx (OSCTXT* pctxt, RadialGradient_fx* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   pvalue->t = 1;
   if (0 != pXmlNode->children) {
      pvalue->u.alt = pXmlNode->children->content;
   }
   else {
      pvalue->u.alt = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_RadialGradient_fy (OSCTXT* pctxt, RadialGradient_fy* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   pvalue->t = 1;
   if (0 != pXmlNode->children) {
      pvalue->u.alt = pXmlNode->children->content;
   }
   else {
      pvalue->u.alt = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_RadialGradient_r (OSCTXT* pctxt, RadialGradient_r* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   pvalue->t = 1;
   if (0 != pXmlNode->children) {
      pvalue->u.alt = pXmlNode->children->content;
   }
   else {
      pvalue->u.alt = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_RadialGradient (OSCTXT* pctxt, RadialGradient* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("display-name"))) {
            pvalue->m.display_namePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->display_name = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->display_name = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("name"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->name = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->name = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("cx"))) {
            pvalue->m.cxPresent = 1;
            DOMTest_RadialGradient_cx (pctxt, &pvalue->cx, ((xmlNodePtr)pXmlAttr), FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("cy"))) {
            pvalue->m.cyPresent = 1;
            DOMTest_RadialGradient_cy (pctxt, &pvalue->cy, ((xmlNodePtr)pXmlAttr), FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("fx"))) {
            pvalue->m.fxPresent = 1;
            DOMTest_RadialGradient_fx (pctxt, &pvalue->fx, ((xmlNodePtr)pXmlAttr), FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("fy"))) {
            pvalue->m.fyPresent = 1;
            DOMTest_RadialGradient_fy (pctxt, &pvalue->fy, ((xmlNodePtr)pXmlAttr), FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("gradientTransform"))) {
            pvalue->m.gradientTransformPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->gradientTransform = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->gradientTransform = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("gradientUnits"))) {
            pvalue->m.gradientUnitsPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               RadialGradient_gradientUnits_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->gradientUnits);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("r"))) {
            pvalue->m.rPresent = 1;
            DOMTest_RadialGradient_r (pctxt, &pvalue->r, ((xmlNodePtr)pXmlAttr), FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("spreadMethod"))) {
            pvalue->m.spreadMethodPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               RadialGradient_spreadMethod_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->spreadMethod);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("stop"))) {
            { Stop* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Stop);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Stop (pdata2);
            DOMTest_Stop (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->stop_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

