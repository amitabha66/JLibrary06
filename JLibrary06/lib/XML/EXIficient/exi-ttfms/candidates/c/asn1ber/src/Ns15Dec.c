/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "Ns15.h"
#include "Ns3.h"
#include "Ns7.h"
#include "Odf.h"
#include "Ns13.h"
#include "rtxsrc/rtxCommon.h"

/**************************************************************/
/*                                                            */
/*  End_cell_address                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_End_cell_address (OSCTXT* pctxt, End_cell_address *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_End_cell_address (OSCTXT* pctxt, End_cell_address* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  End_x                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_End_x (OSCTXT* pctxt, End_x *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_End_x (OSCTXT* pctxt, End_x* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  End_y                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_End_y (OSCTXT* pctxt, End_y *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_End_y (OSCTXT* pctxt, End_y* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_background                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_background (OSCTXT* pctxt, Table_background *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Table_background (OSCTXT* pctxt, Table_background* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Table_background_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_is_sub_table                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_is_sub_table (OSCTXT* pctxt, 
   Table_is_sub_table *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Table_is_sub_table (OSCTXT* pctxt, Table_is_sub_table* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Table_is_sub_table_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_print                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_print (OSCTXT* pctxt, Table_print *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Table_print (OSCTXT* pctxt, Table_print* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Table_print_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_protected_                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_protected_ (OSCTXT* pctxt, Table_protected_ *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Table_protected_ (OSCTXT* pctxt, Table_protected_* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Table_protected__ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_style_name                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_style_name (OSCTXT* pctxt, Table_style_name *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Table_style_name (OSCTXT* pctxt, Table_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_source_actuate                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_source_actuate (OSCTXT* pctxt, 
   Table_source_actuate *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Table_source_actuate (OSCTXT* pctxt, Table_source_actuate* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Table_source_actuate_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_source_mode                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_source_mode (OSCTXT* pctxt, Table_source_mode *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Table_source_mode (OSCTXT* pctxt, Table_source_mode* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Table_source_mode_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_source                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_source (OSCTXT* pctxt, Table_source *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode actuate */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_source_actuate (pctxt, 
               &pvalue->actuate, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.actuatePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode href */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Href (pctxt, 
               &pvalue->href, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Type (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.typePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode filter_name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->filter_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.filter_namePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode filter_options */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->filter_options, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.filter_optionsPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode mode */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_source_mode (pctxt, 
               &pvalue->mode, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.modePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode refresh_delay */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->refresh_delay, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.refresh_delayPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode table_name */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->table_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_namePresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Table_source (OSCTXT* pctxt, Table_source* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("actuate"), 7}, 0 },
         { {OSUTF8("href"), 4}, 0 },
         { {OSUTF8("type"), 4}, 0 },
         { {OSUTF8("filter-name"), 11}, 0 },
         { {OSUTF8("filter-options"), 14}, 0 },
         { {OSUTF8("mode"), 4}, 0 },
         { {OSUTF8("refresh-delay"), 13}, 0 },
         { {OSUTF8("table-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 8, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* actuate */
            stat = XmlDec_Table_source_actuate (pctxt, &pvalue->actuate);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.actuatePresent = TRUE;
            break;

         case 1: /* href */
            stat = XmlDec_Xlink_Href (pctxt, &pvalue->href);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* type */
            stat = XmlDec_Xlink_Type (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.typePresent = TRUE;
            break;

         case 3: /* filter-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->filter_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.filter_namePresent = TRUE;
            break;

         case 4: /* filter-options */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->filter_options);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.filter_optionsPresent = TRUE;
            break;

         case 5: /* mode */
            stat = XmlDec_Table_source_mode (pctxt, &pvalue->mode);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.modePresent = TRUE;
            break;

         case 6: /* refresh-delay */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->refresh_delay);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.refresh_delayPresent = TRUE;
            break;

         case 7: /* table-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->table_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.table_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Table_source");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Table_source");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Scenario_copy_back                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Scenario_copy_back (OSCTXT* pctxt, 
   Scenario_copy_back *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Scenario_copy_back (OSCTXT* pctxt, Scenario_copy_back* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Scenario_copy_back_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Scenario_copy_formulas                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Scenario_copy_formulas (OSCTXT* pctxt, 
   Scenario_copy_formulas *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Scenario_copy_formulas (OSCTXT* pctxt, 
   Scenario_copy_formulas* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Scenario_copy_formulas_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Scenario_copy_styles                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Scenario_copy_styles (OSCTXT* pctxt, 
   Scenario_copy_styles *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Scenario_copy_styles (OSCTXT* pctxt, Scenario_copy_styles* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Scenario_copy_styles_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Scenario_display_border                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Scenario_display_border (OSCTXT* pctxt, 
   Scenario_display_border *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Scenario_display_border (OSCTXT* pctxt, 
   Scenario_display_border* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Scenario_display_border_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Scenario_is_active                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Scenario_is_active (OSCTXT* pctxt, 
   Scenario_is_active *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Scenario_is_active (OSCTXT* pctxt, Scenario_is_active* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Scenario_is_active_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Scenario_protected_                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Scenario_protected_ (OSCTXT* pctxt, 
   Scenario_protected_ *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Scenario_protected_ (OSCTXT* pctxt, Scenario_protected_* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Scenario_protected__ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Scenario                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Scenario (OSCTXT* pctxt, Scenario *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode border_color */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->border_color, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.border_colorPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode comment */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->comment, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.commentPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode copy_back */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Scenario_copy_back (pctxt, 
               &pvalue->copy_back, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.copy_backPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode copy_formulas */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Scenario_copy_formulas (pctxt, 
               &pvalue->copy_formulas, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.copy_formulasPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode copy_styles */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Scenario_copy_styles (pctxt, 
               &pvalue->copy_styles, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.copy_stylesPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode display_border */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Scenario_display_border (pctxt, 
               &pvalue->display_border, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.display_borderPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode is_active */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Scenario_is_active (pctxt, 
               &pvalue->is_active, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode protected_ */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Scenario_protected_ (pctxt, 
               &pvalue->protected_, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.protected_Present = TRUE;
            }
         }
         break;

      case 8:
         /* decode scenario_ranges */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->scenario_ranges, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Scenario (OSCTXT* pctxt, Scenario* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("border-color"), 12}, 0 },
         { {OSUTF8("comment"), 7}, 0 },
         { {OSUTF8("copy-back"), 9}, 0 },
         { {OSUTF8("copy-formulas"), 13}, 0 },
         { {OSUTF8("copy-styles"), 11}, 0 },
         { {OSUTF8("display-border"), 14}, 0 },
         { {OSUTF8("is-active"), 9}, 0 },
         { {OSUTF8("protected"), 9}, 0 },
         { {OSUTF8("scenario-ranges"), 15}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 9, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* border-color */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->border_color);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.border_colorPresent = TRUE;
            break;

         case 1: /* comment */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->comment);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.commentPresent = TRUE;
            break;

         case 2: /* copy-back */
            stat = XmlDec_Scenario_copy_back (pctxt, &pvalue->copy_back);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.copy_backPresent = TRUE;
            break;

         case 3: /* copy-formulas */
            stat = XmlDec_Scenario_copy_formulas (pctxt, &pvalue->copy_formulas
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.copy_formulasPresent = TRUE;
            break;

         case 4: /* copy-styles */
            stat = XmlDec_Scenario_copy_styles (pctxt, &pvalue->copy_styles);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.copy_stylesPresent = TRUE;
            break;

         case 5: /* display-border */
            stat = XmlDec_Scenario_display_border (pctxt, &pvalue->
               display_border);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.display_borderPresent = TRUE;
            break;

         case 6: /* is-active */
            stat = XmlDec_Scenario_is_active (pctxt, &pvalue->is_active);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 7: /* protected */
            stat = XmlDec_Scenario_protected_ (pctxt, &pvalue->protected_);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.protected_Present = TRUE;
            break;

         case 8: /* scenario-ranges */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->scenario_ranges);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Scenario");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Scenario");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Shapes_element                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Shapes_element (OSCTXT* pctxt, Shapes_element *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

         if (pvalue->u.rect == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);
         stat = asn1D_Ns3_Rect (pctxt, 
            (Ns3_Rect*)pvalue->u.rect, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

         if (pvalue->u.line == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);
         stat = asn1D_Ns3_Line (pctxt, 
            (Ns3_Line*)pvalue->u.line, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

         if (pvalue->u.polyline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);
         stat = asn1D_Ns3_Polyline (pctxt, 
            (Ns3_Polyline*)pvalue->u.polyline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

         if (pvalue->u.polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);
         stat = asn1D_Ns3_Polygon (pctxt, 
            (Ns3_Polygon*)pvalue->u.polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.regular_polygon
             = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

         if (pvalue->u.regular_polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->u.regular_polygon);
         stat = asn1D_Ns3_Regular_polygon (pctxt, 
            (Ns3_Regular_polygon*)pvalue->u.regular_polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

         if (pvalue->u.path == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);
         stat = asn1D_Ns3_Path (pctxt, 
            (Ns3_Path*)pvalue->u.path, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

         if (pvalue->u.circle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);
         stat = asn1D_Ns3_Circle (pctxt, 
            (Ns3_Circle*)pvalue->u.circle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

         if (pvalue->u.ellipse == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);
         stat = asn1D_Ns3_Ellipse (pctxt, 
            (Ns3_Ellipse*)pvalue->u.ellipse, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

         if (pvalue->u.g == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);
         stat = asn1D_Ns3_G (pctxt, 
            (Ns3_G*)pvalue->u.g, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.page_thumbnail
             = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

         if (pvalue->u.page_thumbnail == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->u.page_thumbnail);
         stat = asn1D_Ns3_Page_thumbnail (pctxt, 
            (Ns3_Page_thumbnail*)pvalue->u.page_thumbnail, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

         if (pvalue->u.frame == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);
         stat = asn1D_Ns3_Frame (pctxt, 
            (Ns3_Frame*)pvalue->u.frame, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

         if (pvalue->u.measure == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);
         stat = asn1D_Ns3_Measure (pctxt, 
            (Ns3_Measure*)pvalue->u.measure, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

         if (pvalue->u.caption == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);
         stat = asn1D_Ns3_Caption (pctxt, 
            (Ns3_Caption*)pvalue->u.caption, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

         if (pvalue->u.connector == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);
         stat = asn1D_Ns3_Connector (pctxt, 
            (Ns3_Connector*)pvalue->u.connector, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

         if (pvalue->u.control == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);
         stat = asn1D_Ns3_Control (pctxt, 
            (Ns3_Control*)pvalue->u.control, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

         if (pvalue->u.scene == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);
         stat = asn1D_Ns7_Scene (pctxt, 
            (Ns7_Scene*)pvalue->u.scene, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

         if (pvalue->u.custom_shape == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);
         stat = asn1D_Ns3_Custom_shape (pctxt, 
            (Ns3_Custom_shape*)pvalue->u.custom_shape, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Shapes_element (OSCTXT* pctxt, Shapes_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("rect"), 4}, 0}, 0 },
      {{{OSUTF8("line"), 4}, 0}, 1 },
      {{{OSUTF8("polyline"), 8}, 0}, 2 },
      {{{OSUTF8("polygon"), 7}, 0}, 3 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 4 },
      {{{OSUTF8("path"), 4}, 0}, 5 },
      {{{OSUTF8("circle"), 6}, 0}, 6 },
      {{{OSUTF8("ellipse"), 7}, 0}, 7 },
      {{{OSUTF8("g"), 1}, 0}, 8 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 9 },
      {{{OSUTF8("frame"), 5}, 0}, 10 },
      {{{OSUTF8("measure"), 7}, 0}, 11 },
      {{{OSUTF8("caption"), 7}, 0}, 12 },
      {{{OSUTF8("connector"), 9}, 0}, 13 },
      {{{OSUTF8("control"), 7}, 0}, 14 },
      {{{OSUTF8("scene"), 5}, 0}, 15 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 16 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 17, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* rect */
      pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

      if (pvalue->u.rect == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);

      stat = XmlDec_Ns3_Rect (pctxt, pvalue->u.rect);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* line */
      pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

      if (pvalue->u.line == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);

      stat = XmlDec_Ns3_Line (pctxt, pvalue->u.line);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* polyline */
      pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

      if (pvalue->u.polyline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);

      stat = XmlDec_Ns3_Polyline (pctxt, pvalue->u.polyline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* polygon */
      pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

      if (pvalue->u.polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);

      stat = XmlDec_Ns3_Polygon (pctxt, pvalue->u.polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* regular-polygon */
      pvalue->u.regular_polygon
          = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

      if (pvalue->u.regular_polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->
         u.regular_polygon);

      stat = XmlDec_Ns3_Regular_polygon (pctxt, pvalue->u.regular_polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* path */
      pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

      if (pvalue->u.path == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);

      stat = XmlDec_Ns3_Path (pctxt, pvalue->u.path);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* circle */
      pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

      if (pvalue->u.circle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);

      stat = XmlDec_Ns3_Circle (pctxt, pvalue->u.circle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* ellipse */
      pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

      if (pvalue->u.ellipse == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);

      stat = XmlDec_Ns3_Ellipse (pctxt, pvalue->u.ellipse);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* g */
      pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

      if (pvalue->u.g == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);

      stat = XmlDec_Ns3_G (pctxt, pvalue->u.g);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* page-thumbnail */
      pvalue->u.page_thumbnail = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

      if (pvalue->u.page_thumbnail == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->
         u.page_thumbnail);

      stat = XmlDec_Ns3_Page_thumbnail (pctxt, pvalue->u.page_thumbnail);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* frame */
      pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

      if (pvalue->u.frame == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);

      stat = XmlDec_Ns3_Frame (pctxt, pvalue->u.frame);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* measure */
      pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

      if (pvalue->u.measure == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);

      stat = XmlDec_Ns3_Measure (pctxt, pvalue->u.measure);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* caption */
      pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

      if (pvalue->u.caption == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);

      stat = XmlDec_Ns3_Caption (pctxt, pvalue->u.caption);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* connector */
      pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

      if (pvalue->u.connector == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);

      stat = XmlDec_Ns3_Connector (pctxt, pvalue->u.connector);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* control */
      pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

      if (pvalue->u.control == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);

      stat = XmlDec_Ns3_Control (pctxt, pvalue->u.control);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* scene */
      pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

      if (pvalue->u.scene == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);

      stat = XmlDec_Ns7_Scene (pctxt, pvalue->u.scene);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* custom-shape */
      pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

      if (pvalue->u.custom_shape == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);

      stat = XmlDec_Ns3_Custom_shape (pctxt, pvalue->u.custom_shape);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Shapes                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Shapes (OSCTXT* pctxt, Shapes *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   Shapes_element* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (XD_PEEKTAG (pctxt, 0x30)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_UNIV|TM_CONS|16));

   if (XD_PEEKTAG (pctxt, 0xa0)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_CTXT|TM_CONS|0));

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      rtxDListAllocNodeAndData (pctxt, Shapes_element, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Shapes_element (pdata1);

      stat = asn1D_Shapes_element (pctxt, 
         pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

int XmlDec_Shapes (OSCTXT* pctxt, Shapes* pvalue)
{
   int stat = 0;

   { int elemID;
   Shapes_element* pdata1;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("rect"), 4}, 0}, 0 },
      {{{OSUTF8("line"), 4}, 0}, 0 },
      {{{OSUTF8("polyline"), 8}, 0}, 0 },
      {{{OSUTF8("polygon"), 7}, 0}, 0 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 0 },
      {{{OSUTF8("path"), 4}, 0}, 0 },
      {{{OSUTF8("circle"), 6}, 0}, 0 },
      {{{OSUTF8("ellipse"), 7}, 0}, 0 },
      {{{OSUTF8("g"), 1}, 0}, 0 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 0 },
      {{{OSUTF8("frame"), 5}, 0}, 0 },
      {{{OSUTF8("measure"), 7}, 0}, 0 },
      {{{OSUTF8("caption"), 7}, 0}, 0 },
      {{{OSUTF8("connector"), 9}, 0}, 0 },
      {{{OSUTF8("control"), 7}, 0}, 0 },
      {{{OSUTF8("scene"), 5}, 0}, 0 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 0 }
   } ;

   rtxDListInit (pvalue);
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 17, -1, FALSE);
      if (elemID < 0 || elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0:
         rtXmlpMarkLastEventActive (pctxt);

         pdata1 = rtxMemAllocType (pctxt, Shapes_element);

         if (pdata1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Shapes_element (pdata1);

         stat = XmlDec_Shapes_element (pctxt, pdata1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         break;

      }
   }

   if (elemID == RTERR_UNEXPELEM || elemID == XML_OK_EOB) {
      stat = 0;
   }
   else return LOG_RTERR (pctxt, elemID);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_column_group_display                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_column_group_display (OSCTXT* pctxt, 
   Table_column_group_display *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Table_column_group_display (OSCTXT* pctxt, 
   Table_column_group_display* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Table_column_group_display_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_column_default_cell_style_name                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_column_default_cell_style_name (OSCTXT* pctxt, 
   Table_column_default_cell_style_name *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Table_column_default_cell_style_name (OSCTXT* pctxt, 
   Table_column_default_cell_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_column_style_name                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_column_style_name (OSCTXT* pctxt, 
   Table_column_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Table_column_style_name (OSCTXT* pctxt, 
   Table_column_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_column_visibility                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_column_visibility (OSCTXT* pctxt, 
   Table_column_visibility *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Table_column_visibility (OSCTXT* pctxt, 
   Table_column_visibility* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Table_column_visibility_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_column                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_column (OSCTXT* pctxt, Table_column *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode default_cell_style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_column_default_cell_style_name (pctxt, 
               &pvalue->default_cell_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.default_cell_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode number_columns_repeated */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->number_columns_repeated, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.number_columns_repeatedPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_column_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode visibility */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_column_visibility (pctxt, 
               &pvalue->visibility, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.visibilityPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Table_column (OSCTXT* pctxt, Table_column* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("default-cell-style-name"), 23}, 0 },
         { {OSUTF8("number-columns-repeated"), 23}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("visibility"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* default-cell-style-name */
            stat = XmlDec_Table_column_default_cell_style_name (pctxt, &pvalue
               ->default_cell_style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.default_cell_style_namePresent = TRUE;
            break;

         case 1: /* number-columns-repeated */
            stat = rtXmlpDecUInt (pctxt, &pvalue->number_columns_repeated);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.number_columns_repeatedPresent = TRUE;
            break;

         case 2: /* style-name */
            stat = XmlDec_Table_column_style_name (pctxt, &pvalue->style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 3: /* visibility */
            stat = XmlDec_Table_column_visibility (pctxt, &pvalue->visibility
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.visibilityPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Table_column");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Table_column");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_columns                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_columns (OSCTXT* pctxt, Table_columns *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode table_column_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Table_column* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->table_column_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Table_column, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Table_column (pdata2);

                  stat = asn1D_Table_column (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->table_column_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Table_columns (OSCTXT* pctxt, Table_columns* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("table-column"), 12}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Table_column* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Table_column);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Table_column (pdata1);

            stat = XmlDec_Table_column (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->table_column_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_header_columns                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_header_columns (OSCTXT* pctxt, 
   Table_header_columns *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode table_column_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Table_column* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->table_column_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Table_column, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Table_column (pdata2);

                  stat = asn1D_Table_column (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->table_column_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Table_header_columns (OSCTXT* pctxt, Table_header_columns* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("table-column"), 12}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Table_column* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Table_column);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Table_column (pdata1);

            stat = XmlDec_Table_column (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->table_column_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_column_group_element                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_column_group_element (OSCTXT* pctxt, 
   Table_column_group_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.table_column_group
             = rtxMemAllocType (pctxt, Table_column_group);

         if (pvalue->u.table_column_group == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table_column_group ((Table_column_group*)pvalue->u.table_column_group);
         stat = asn1D_Table_column_group (pctxt, 
            (Table_column_group*)pvalue->u.table_column_group, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.table_columns = rtxMemAllocType (pctxt, Table_columns);

         if (pvalue->u.table_columns == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table_columns (pvalue->u.table_columns);
         stat = asn1D_Table_columns (pctxt, 
            pvalue->u.table_columns, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.table_column = rtxMemAllocType (pctxt, Table_column);

         if (pvalue->u.table_column == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table_column (pvalue->u.table_column);
         stat = asn1D_Table_column (pctxt, 
            pvalue->u.table_column, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.table_header_columns
             = rtxMemAllocType (pctxt, Table_header_columns);

         if (pvalue->u.table_header_columns == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table_header_columns (pvalue->u.table_header_columns);
         stat = asn1D_Table_header_columns (pctxt, 
            pvalue->u.table_header_columns, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Table_column_group_element (OSCTXT* pctxt, 
   Table_column_group_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("table-column-group"), 18}, 0}, 0 },
      {{{OSUTF8("table-columns"), 13}, 0}, 1 },
      {{{OSUTF8("table-column"), 12}, 0}, 2 },
      {{{OSUTF8("table-header-columns"), 20}, 0}, 3 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 4, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* table-column-group */
      pvalue->u.table_column_group
          = rtxMemAllocType (pctxt, Table_column_group);

      if (pvalue->u.table_column_group == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table_column_group ((Table_column_group*)pvalue->
         u.table_column_group);

      stat = XmlDec_Table_column_group (pctxt, pvalue->u.table_column_group);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* table-columns */
      pvalue->u.table_columns = rtxMemAllocType (pctxt, Table_columns);

      if (pvalue->u.table_columns == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table_columns (pvalue->u.table_columns);

      stat = XmlDec_Table_columns (pctxt, pvalue->u.table_columns);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* table-column */
      pvalue->u.table_column = rtxMemAllocType (pctxt, Table_column);

      if (pvalue->u.table_column == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table_column (pvalue->u.table_column);

      stat = XmlDec_Table_column (pctxt, pvalue->u.table_column);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* table-header-columns */
      pvalue->u.table_header_columns
          = rtxMemAllocType (pctxt, Table_header_columns);

      if (pvalue->u.table_header_columns == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table_header_columns (pvalue->u.table_header_columns);

      stat = XmlDec_Table_header_columns (pctxt, pvalue->u.table_header_columns
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_column_group                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_column_group (OSCTXT* pctxt, 
   Table_column_group *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode display */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_column_group_display (pctxt, 
               &pvalue->display, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.displayPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Table_column_group_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Table_column_group_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Table_column_group_element (pdata2);

                  stat = asn1D_Table_column_group_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Table_column_group (OSCTXT* pctxt, Table_column_group* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("display"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* display */
            stat = XmlDec_Table_column_group_display (pctxt, &pvalue->display
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.displayPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Table_column_group");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Table_column_group");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("table-column-group"), 18}, 0}, 0 },
      {{{OSUTF8("table-columns"), 13}, 0}, 0 },
      {{{OSUTF8("table-column"), 12}, 0}, 0 },
      {{{OSUTF8("table-header-columns"), 20}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Table_column_group_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Table_column_group_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Table_column_group_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Table_column_group_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 4, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_element                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_element (OSCTXT* pctxt, Table_element *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.table_column_group
             = rtxMemAllocType (pctxt, Table_column_group);

         if (pvalue->u.table_column_group == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table_column_group (pvalue->u.table_column_group);
         stat = asn1D_Table_column_group (pctxt, 
            pvalue->u.table_column_group, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.table_columns = rtxMemAllocType (pctxt, Table_columns);

         if (pvalue->u.table_columns == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table_columns (pvalue->u.table_columns);
         stat = asn1D_Table_columns (pctxt, 
            pvalue->u.table_columns, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.table_column = rtxMemAllocType (pctxt, Table_column);

         if (pvalue->u.table_column == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table_column (pvalue->u.table_column);
         stat = asn1D_Table_column (pctxt, 
            pvalue->u.table_column, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.table_header_columns
             = rtxMemAllocType (pctxt, Table_header_columns);

         if (pvalue->u.table_header_columns == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table_header_columns (pvalue->u.table_header_columns);
         stat = asn1D_Table_header_columns (pctxt, 
            pvalue->u.table_header_columns, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Table_element (OSCTXT* pctxt, Table_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("table-column-group"), 18}, 0}, 0 },
      {{{OSUTF8("table-columns"), 13}, 0}, 1 },
      {{{OSUTF8("table-column"), 12}, 0}, 2 },
      {{{OSUTF8("table-header-columns"), 20}, 0}, 3 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 4, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* table-column-group */
      pvalue->u.table_column_group
          = rtxMemAllocType (pctxt, Table_column_group);

      if (pvalue->u.table_column_group == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table_column_group (pvalue->u.table_column_group);

      stat = XmlDec_Table_column_group (pctxt, pvalue->u.table_column_group);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* table-columns */
      pvalue->u.table_columns = rtxMemAllocType (pctxt, Table_columns);

      if (pvalue->u.table_columns == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table_columns (pvalue->u.table_columns);

      stat = XmlDec_Table_columns (pctxt, pvalue->u.table_columns);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* table-column */
      pvalue->u.table_column = rtxMemAllocType (pctxt, Table_column);

      if (pvalue->u.table_column == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table_column (pvalue->u.table_column);

      stat = XmlDec_Table_column (pctxt, pvalue->u.table_column);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* table-header-columns */
      pvalue->u.table_header_columns
          = rtxMemAllocType (pctxt, Table_header_columns);

      if (pvalue->u.table_header_columns == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table_header_columns (pvalue->u.table_header_columns);

      stat = XmlDec_Table_header_columns (pctxt, pvalue->u.table_header_columns
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_row_group_display                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_row_group_display (OSCTXT* pctxt, 
   Table_row_group_display *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Table_row_group_display (OSCTXT* pctxt, 
   Table_row_group_display* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Table_row_group_display_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_row_default_cell_style_name                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_row_default_cell_style_name (OSCTXT* pctxt, 
   Table_row_default_cell_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Table_row_default_cell_style_name (OSCTXT* pctxt, 
   Table_row_default_cell_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_row_style_name                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_row_style_name (OSCTXT* pctxt, 
   Table_row_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Table_row_style_name (OSCTXT* pctxt, Table_row_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_row_visibility                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_row_visibility (OSCTXT* pctxt, 
   Table_row_visibility *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Table_row_visibility (OSCTXT* pctxt, Table_row_visibility* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Table_row_visibility_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_cell_value_type                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_cell_value_type (OSCTXT* pctxt, 
   Table_cell_value_type *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Table_cell_value_type (OSCTXT* pctxt, Table_cell_value_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Table_cell_value_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_cell_protect                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_cell_protect (OSCTXT* pctxt, 
   Table_cell_protect *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Table_cell_protect (OSCTXT* pctxt, Table_cell_protect* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Table_cell_protect_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_cell_style_name                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_cell_style_name (OSCTXT* pctxt, 
   Table_cell_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Table_cell_style_name (OSCTXT* pctxt, Table_cell_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cell_range_source_actuate                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Cell_range_source_actuate (OSCTXT* pctxt, 
   Cell_range_source_actuate *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Cell_range_source_actuate (OSCTXT* pctxt, 
   Cell_range_source_actuate* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Cell_range_source_actuate_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cell_range_source                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Cell_range_source (OSCTXT* pctxt, Cell_range_source *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode actuate */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Cell_range_source_actuate (pctxt, 
               &pvalue->actuate, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.actuatePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode href */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Href (pctxt, 
               &pvalue->href, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Type (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.typePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode filter_name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->filter_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.filter_namePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode filter_options */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->filter_options, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.filter_optionsPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode last_column_spanned */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->last_column_spanned, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode last_row_spanned */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->last_row_spanned, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 8:
         /* decode refresh_delay */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->refresh_delay, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.refresh_delayPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 4) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Cell_range_source (OSCTXT* pctxt, Cell_range_source* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("actuate"), 7}, 0 },
         { {OSUTF8("href"), 4}, 0 },
         { {OSUTF8("type"), 4}, 0 },
         { {OSUTF8("filter-name"), 11}, 0 },
         { {OSUTF8("filter-options"), 14}, 0 },
         { {OSUTF8("last-column-spanned"), 19}, 0 },
         { {OSUTF8("last-row-spanned"), 16}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("refresh-delay"), 13}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 9, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* actuate */
            stat = XmlDec_Cell_range_source_actuate (pctxt, &pvalue->actuate);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.actuatePresent = TRUE;
            break;

         case 1: /* href */
            stat = XmlDec_Xlink_Href (pctxt, &pvalue->href);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* type */
            stat = XmlDec_Xlink_Type (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.typePresent = TRUE;
            break;

         case 3: /* filter-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->filter_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.filter_namePresent = TRUE;
            break;

         case 4: /* filter-options */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->filter_options);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.filter_optionsPresent = TRUE;
            break;

         case 5: /* last-column-spanned */
            stat = rtXmlpDecUInt (pctxt, &pvalue->last_column_spanned);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 6: /* last-row-spanned */
            stat = rtXmlpDecUInt (pctxt, &pvalue->last_row_spanned);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 7: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 8: /* refresh-delay */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->refresh_delay);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.refresh_delayPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Cell_range_source");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Cell_range_source");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cell_range_address                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Cell_range_address (OSCTXT* pctxt, 
   Cell_range_address *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Cell_range_address (OSCTXT* pctxt, Cell_range_address* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Highlighted_range_contains_error                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Highlighted_range_contains_error (OSCTXT* pctxt, 
   Highlighted_range_contains_error *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Highlighted_range_contains_error (OSCTXT* pctxt, 
   Highlighted_range_contains_error* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Highlighted_range_contains_error_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Highlighted_range_direction                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Highlighted_range_direction (OSCTXT* pctxt, 
   Highlighted_range_direction *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Highlighted_range_direction (OSCTXT* pctxt, 
   Highlighted_range_direction* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Highlighted_range_direction_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Highlighted_range_marked_invalid                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Highlighted_range_marked_invalid (OSCTXT* pctxt, 
   Highlighted_range_marked_invalid *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Highlighted_range_marked_invalid (OSCTXT* pctxt, 
   Highlighted_range_marked_invalid* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Highlighted_range_marked_invalid_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Highlighted_range                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Highlighted_range (OSCTXT* pctxt, Highlighted_range *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode cell_range_address */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Cell_range_address (pctxt, 
               &pvalue->cell_range_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.cell_range_addressPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode contains_error */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Highlighted_range_contains_error (pctxt, 
               &pvalue->contains_error, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.contains_errorPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode direction */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Highlighted_range_direction (pctxt, 
               &pvalue->direction, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.directionPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode marked_invalid */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Highlighted_range_marked_invalid (pctxt, 
               &pvalue->marked_invalid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.marked_invalidPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Highlighted_range (OSCTXT* pctxt, Highlighted_range* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("cell-range-address"), 18}, 0 },
         { {OSUTF8("contains-error"), 14}, 0 },
         { {OSUTF8("direction"), 9}, 0 },
         { {OSUTF8("marked-invalid"), 14}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* cell-range-address */
            stat = XmlDec_Cell_range_address (pctxt, &pvalue->
               cell_range_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.cell_range_addressPresent = TRUE;
            break;

         case 1: /* contains-error */
            stat = XmlDec_Highlighted_range_contains_error (pctxt, &pvalue->
               contains_error);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.contains_errorPresent = TRUE;
            break;

         case 2: /* direction */
            stat = XmlDec_Highlighted_range_direction (pctxt, &pvalue->
               direction);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.directionPresent = TRUE;
            break;

         case 3: /* marked-invalid */
            stat = XmlDec_Highlighted_range_marked_invalid (pctxt, &pvalue->
               marked_invalid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.marked_invalidPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Highlighted_range");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Highlighted_range");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Operation_name                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Operation_name (OSCTXT* pctxt, Operation_name *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Operation_name (OSCTXT* pctxt, Operation_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Operation_name_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Operation                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Operation (OSCTXT* pctxt, Operation *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode index */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->index, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Operation_name (pctxt, 
               &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Operation (OSCTXT* pctxt, Operation* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("index"), 5}, 0 },
         { {OSUTF8("name"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* index */
            stat = rtXmlpDecUInt (pctxt, &pvalue->index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* name */
            stat = XmlDec_Operation_name (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Operation");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Operation");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Detective                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Detective (OSCTXT* pctxt, Detective *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode highlighted_range_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Highlighted_range* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->highlighted_range_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Highlighted_range, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Highlighted_range (pdata2);

                  stat = asn1D_Highlighted_range (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->highlighted_range_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode operation_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Operation* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->operation_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Operation, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Operation (pdata2);

                  stat = asn1D_Operation (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->operation_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Detective (OSCTXT* pctxt, Detective* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("highlighted-range"), 17}, 0}, 0 },
      {{{OSUTF8("operation"), 9}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Highlighted_range* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Highlighted_range);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Highlighted_range (pdata1);

            stat = XmlDec_Highlighted_range (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->highlighted_range_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 1: {
         Operation* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Operation);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Operation (pdata1);

            stat = XmlDec_Operation (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->operation_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_cell_element                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_cell_element (OSCTXT* pctxt, 
   Table_cell_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

         if (pvalue->u.h == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_H ((Odf_H*)pvalue->u.h);
         stat = asn1D_Odf_H (pctxt, 
            (Odf_H*)pvalue->u.h, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P ((Odf_P*)pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            (Odf_P*)pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List ((Odf_List*)pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            (Odf_List*)pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.numbered_paragraph
             = rtxMemAllocType (pctxt, Odf_Numbered_paragraph);

         if (pvalue->u.numbered_paragraph == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Numbered_paragraph ((Odf_Numbered_paragraph*)pvalue->u.numbered_paragraph);
         stat = asn1D_Odf_Numbered_paragraph (pctxt, 
            (Odf_Numbered_paragraph*)pvalue->u.numbered_paragraph, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.table = rtxMemAllocType (pctxt, Table);

         if (pvalue->u.table == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table ((Table*)pvalue->u.table);
         stat = asn1D_Table (pctxt, 
            (Table*)pvalue->u.table, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.a = rtxMemAllocType (pctxt, Ns3_A);

         if (pvalue->u.a == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_A ((Ns3_A*)pvalue->u.a);
         stat = asn1D_Ns3_A (pctxt, 
            (Ns3_A*)pvalue->u.a, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.section = rtxMemAllocType (pctxt, Odf_Section);

         if (pvalue->u.section == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Section ((Odf_Section*)pvalue->u.section);
         stat = asn1D_Odf_Section (pctxt, 
            (Odf_Section*)pvalue->u.section, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.table_of_content
             = rtxMemAllocType (pctxt, Odf_Table_of_content);

         if (pvalue->u.table_of_content == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_of_content ((Odf_Table_of_content*)pvalue->u.table_of_content);
         stat = asn1D_Odf_Table_of_content (pctxt, 
            (Odf_Table_of_content*)pvalue->u.table_of_content, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.illustration_index
             = rtxMemAllocType (pctxt, Odf_Illustration_index);

         if (pvalue->u.illustration_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Illustration_index ((Odf_Illustration_index*)pvalue->u.illustration_index);
         stat = asn1D_Odf_Illustration_index (pctxt, 
            (Odf_Illustration_index*)pvalue->u.illustration_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.table_index = rtxMemAllocType (pctxt, Odf_Table_index);

         if (pvalue->u.table_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_index ((Odf_Table_index*)pvalue->u.table_index);
         stat = asn1D_Odf_Table_index (pctxt, 
            (Odf_Table_index*)pvalue->u.table_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.object_index = rtxMemAllocType (pctxt, Odf_Object_index);

         if (pvalue->u.object_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Object_index ((Odf_Object_index*)pvalue->u.object_index);
         stat = asn1D_Odf_Object_index (pctxt, 
            (Odf_Object_index*)pvalue->u.object_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.user_index = rtxMemAllocType (pctxt, Odf_User_index);

         if (pvalue->u.user_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index ((Odf_User_index*)pvalue->u.user_index);
         stat = asn1D_Odf_User_index (pctxt, 
            (Odf_User_index*)pvalue->u.user_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.alphabetical_index
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index);

         if (pvalue->u.alphabetical_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index ((Odf_Alphabetical_index*)pvalue->u.alphabetical_index);
         stat = asn1D_Odf_Alphabetical_index (pctxt, 
            (Odf_Alphabetical_index*)pvalue->u.alphabetical_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.bibliography = rtxMemAllocType (pctxt, Odf_Bibliography);

         if (pvalue->u.bibliography == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bibliography ((Odf_Bibliography*)pvalue->u.bibliography);
         stat = asn1D_Odf_Bibliography (pctxt, 
            (Odf_Bibliography*)pvalue->u.bibliography, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

         if (pvalue->u.rect == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);
         stat = asn1D_Ns3_Rect (pctxt, 
            (Ns3_Rect*)pvalue->u.rect, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

         if (pvalue->u.line == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);
         stat = asn1D_Ns3_Line (pctxt, 
            (Ns3_Line*)pvalue->u.line, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

         if (pvalue->u.polyline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);
         stat = asn1D_Ns3_Polyline (pctxt, 
            (Ns3_Polyline*)pvalue->u.polyline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      case (TM_CTXT|TM_CONS|17):
         pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

         if (pvalue->u.polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);
         stat = asn1D_Ns3_Polygon (pctxt, 
            (Ns3_Polygon*)pvalue->u.polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 18;
         break;

      case (TM_CTXT|TM_CONS|18):
         pvalue->u.regular_polygon
             = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

         if (pvalue->u.regular_polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->u.regular_polygon);
         stat = asn1D_Ns3_Regular_polygon (pctxt, 
            (Ns3_Regular_polygon*)pvalue->u.regular_polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 19;
         break;

      case (TM_CTXT|TM_CONS|19):
         pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

         if (pvalue->u.path == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);
         stat = asn1D_Ns3_Path (pctxt, 
            (Ns3_Path*)pvalue->u.path, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 20;
         break;

      case (TM_CTXT|TM_CONS|20):
         pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

         if (pvalue->u.circle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);
         stat = asn1D_Ns3_Circle (pctxt, 
            (Ns3_Circle*)pvalue->u.circle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 21;
         break;

      case (TM_CTXT|TM_CONS|21):
         pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

         if (pvalue->u.ellipse == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);
         stat = asn1D_Ns3_Ellipse (pctxt, 
            (Ns3_Ellipse*)pvalue->u.ellipse, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 22;
         break;

      case (TM_CTXT|TM_CONS|22):
         pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

         if (pvalue->u.g == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);
         stat = asn1D_Ns3_G (pctxt, 
            (Ns3_G*)pvalue->u.g, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 23;
         break;

      case (TM_CTXT|TM_CONS|23):
         pvalue->u.page_thumbnail
             = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

         if (pvalue->u.page_thumbnail == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->u.page_thumbnail);
         stat = asn1D_Ns3_Page_thumbnail (pctxt, 
            (Ns3_Page_thumbnail*)pvalue->u.page_thumbnail, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 24;
         break;

      case (TM_CTXT|TM_CONS|24):
         pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

         if (pvalue->u.frame == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);
         stat = asn1D_Ns3_Frame (pctxt, 
            (Ns3_Frame*)pvalue->u.frame, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 25;
         break;

      case (TM_CTXT|TM_CONS|25):
         pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

         if (pvalue->u.measure == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);
         stat = asn1D_Ns3_Measure (pctxt, 
            (Ns3_Measure*)pvalue->u.measure, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 26;
         break;

      case (TM_CTXT|TM_CONS|26):
         pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

         if (pvalue->u.caption == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);
         stat = asn1D_Ns3_Caption (pctxt, 
            (Ns3_Caption*)pvalue->u.caption, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 27;
         break;

      case (TM_CTXT|TM_CONS|27):
         pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

         if (pvalue->u.connector == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);
         stat = asn1D_Ns3_Connector (pctxt, 
            (Ns3_Connector*)pvalue->u.connector, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 28;
         break;

      case (TM_CTXT|TM_CONS|28):
         pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

         if (pvalue->u.control == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);
         stat = asn1D_Ns3_Control (pctxt, 
            (Ns3_Control*)pvalue->u.control, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 29;
         break;

      case (TM_CTXT|TM_CONS|29):
         pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

         if (pvalue->u.scene == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);
         stat = asn1D_Ns7_Scene (pctxt, 
            (Ns7_Scene*)pvalue->u.scene, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 30;
         break;

      case (TM_CTXT|TM_CONS|30):
         pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

         if (pvalue->u.custom_shape == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);
         stat = asn1D_Ns3_Custom_shape (pctxt, 
            (Ns3_Custom_shape*)pvalue->u.custom_shape, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 31;
         break;

      case (TM_CTXT|TM_CONS|31):
         pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

         if (pvalue->u.change == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change ((Odf_Change*)pvalue->u.change);
         stat = asn1D_Odf_Change (pctxt, 
            (Odf_Change*)pvalue->u.change, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 32;
         break;

      case (TM_CTXT|TM_CONS|32):
         pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

         if (pvalue->u.change_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_start ((Odf_Change_start*)pvalue->u.change_start);
         stat = asn1D_Odf_Change_start (pctxt, 
            (Odf_Change_start*)pvalue->u.change_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 33;
         break;

      case (TM_CTXT|TM_CONS|33):
         pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

         if (pvalue->u.change_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_end ((Odf_Change_end*)pvalue->u.change_end);
         stat = asn1D_Odf_Change_end (pctxt, 
            (Odf_Change_end*)pvalue->u.change_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 34;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Table_cell_element (OSCTXT* pctxt, Table_cell_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("h"), 1}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 1 },
      {{{OSUTF8("list"), 4}, 0}, 2 },
      {{{OSUTF8("numbered-paragraph"), 18}, 0}, 3 },
      {{{OSUTF8("table"), 5}, 0}, 4 },
      {{{OSUTF8("a"), 1}, 0}, 5 },
      {{{OSUTF8("section"), 7}, 0}, 6 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 7 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 8 },
      {{{OSUTF8("table-index"), 11}, 0}, 9 },
      {{{OSUTF8("object-index"), 12}, 0}, 10 },
      {{{OSUTF8("user-index"), 10}, 0}, 11 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 12 },
      {{{OSUTF8("bibliography"), 12}, 0}, 13 },
      {{{OSUTF8("rect"), 4}, 0}, 14 },
      {{{OSUTF8("line"), 4}, 0}, 15 },
      {{{OSUTF8("polyline"), 8}, 0}, 16 },
      {{{OSUTF8("polygon"), 7}, 0}, 17 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 18 },
      {{{OSUTF8("path"), 4}, 0}, 19 },
      {{{OSUTF8("circle"), 6}, 0}, 20 },
      {{{OSUTF8("ellipse"), 7}, 0}, 21 },
      {{{OSUTF8("g"), 1}, 0}, 22 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 23 },
      {{{OSUTF8("frame"), 5}, 0}, 24 },
      {{{OSUTF8("measure"), 7}, 0}, 25 },
      {{{OSUTF8("caption"), 7}, 0}, 26 },
      {{{OSUTF8("connector"), 9}, 0}, 27 },
      {{{OSUTF8("control"), 7}, 0}, 28 },
      {{{OSUTF8("scene"), 5}, 0}, 29 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 30 },
      {{{OSUTF8("change"), 6}, 0}, 31 },
      {{{OSUTF8("change-start"), 12}, 0}, 32 },
      {{{OSUTF8("change-end"), 10}, 0}, 33 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 34, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* h */
      pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

      if (pvalue->u.h == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_H ((Odf_H*)pvalue->u.h);

      stat = XmlDec_Odf_H (pctxt, pvalue->u.h);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P ((Odf_P*)pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List ((Odf_List*)pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* numbered-paragraph */
      pvalue->u.numbered_paragraph
          = rtxMemAllocType (pctxt, Odf_Numbered_paragraph);

      if (pvalue->u.numbered_paragraph == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Numbered_paragraph ((Odf_Numbered_paragraph*)pvalue->
         u.numbered_paragraph);

      stat = XmlDec_Odf_Numbered_paragraph (pctxt, pvalue->u.numbered_paragraph
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* table */
      pvalue->u.table = rtxMemAllocType (pctxt, Table);

      if (pvalue->u.table == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table ((Table*)pvalue->u.table);

      stat = XmlDec_Table (pctxt, pvalue->u.table);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* a */
      pvalue->u.a = rtxMemAllocType (pctxt, Ns3_A);

      if (pvalue->u.a == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_A ((Ns3_A*)pvalue->u.a);

      stat = XmlDec_Ns3_A (pctxt, pvalue->u.a);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* section */
      pvalue->u.section = rtxMemAllocType (pctxt, Odf_Section);

      if (pvalue->u.section == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Section ((Odf_Section*)pvalue->u.section);

      stat = XmlDec_Odf_Section (pctxt, pvalue->u.section);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* table-of-content */
      pvalue->u.table_of_content
          = rtxMemAllocType (pctxt, Odf_Table_of_content);

      if (pvalue->u.table_of_content == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_of_content ((Odf_Table_of_content*)pvalue->
         u.table_of_content);

      stat = XmlDec_Odf_Table_of_content (pctxt, pvalue->u.table_of_content);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* illustration-index */
      pvalue->u.illustration_index
          = rtxMemAllocType (pctxt, Odf_Illustration_index);

      if (pvalue->u.illustration_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Illustration_index ((Odf_Illustration_index*)pvalue->
         u.illustration_index);

      stat = XmlDec_Odf_Illustration_index (pctxt, pvalue->u.illustration_index
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* table-index */
      pvalue->u.table_index = rtxMemAllocType (pctxt, Odf_Table_index);

      if (pvalue->u.table_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_index ((Odf_Table_index*)pvalue->u.table_index);

      stat = XmlDec_Odf_Table_index (pctxt, pvalue->u.table_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* object-index */
      pvalue->u.object_index = rtxMemAllocType (pctxt, Odf_Object_index);

      if (pvalue->u.object_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Object_index ((Odf_Object_index*)pvalue->u.object_index);

      stat = XmlDec_Odf_Object_index (pctxt, pvalue->u.object_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* user-index */
      pvalue->u.user_index = rtxMemAllocType (pctxt, Odf_User_index);

      if (pvalue->u.user_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index ((Odf_User_index*)pvalue->u.user_index);

      stat = XmlDec_Odf_User_index (pctxt, pvalue->u.user_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* alphabetical-index */
      pvalue->u.alphabetical_index
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index);

      if (pvalue->u.alphabetical_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index ((Odf_Alphabetical_index*)pvalue->
         u.alphabetical_index);

      stat = XmlDec_Odf_Alphabetical_index (pctxt, pvalue->u.alphabetical_index
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* bibliography */
      pvalue->u.bibliography = rtxMemAllocType (pctxt, Odf_Bibliography);

      if (pvalue->u.bibliography == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bibliography ((Odf_Bibliography*)pvalue->u.bibliography);

      stat = XmlDec_Odf_Bibliography (pctxt, pvalue->u.bibliography);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* rect */
      pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

      if (pvalue->u.rect == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);

      stat = XmlDec_Ns3_Rect (pctxt, pvalue->u.rect);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* line */
      pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

      if (pvalue->u.line == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);

      stat = XmlDec_Ns3_Line (pctxt, pvalue->u.line);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* polyline */
      pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

      if (pvalue->u.polyline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);

      stat = XmlDec_Ns3_Polyline (pctxt, pvalue->u.polyline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 17: { /* polygon */
      pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

      if (pvalue->u.polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);

      stat = XmlDec_Ns3_Polygon (pctxt, pvalue->u.polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 18: { /* regular-polygon */
      pvalue->u.regular_polygon
          = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

      if (pvalue->u.regular_polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->
         u.regular_polygon);

      stat = XmlDec_Ns3_Regular_polygon (pctxt, pvalue->u.regular_polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 19: { /* path */
      pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

      if (pvalue->u.path == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);

      stat = XmlDec_Ns3_Path (pctxt, pvalue->u.path);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 20: { /* circle */
      pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

      if (pvalue->u.circle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);

      stat = XmlDec_Ns3_Circle (pctxt, pvalue->u.circle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 21: { /* ellipse */
      pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

      if (pvalue->u.ellipse == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);

      stat = XmlDec_Ns3_Ellipse (pctxt, pvalue->u.ellipse);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 22: { /* g */
      pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

      if (pvalue->u.g == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);

      stat = XmlDec_Ns3_G (pctxt, pvalue->u.g);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 23: { /* page-thumbnail */
      pvalue->u.page_thumbnail = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

      if (pvalue->u.page_thumbnail == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->
         u.page_thumbnail);

      stat = XmlDec_Ns3_Page_thumbnail (pctxt, pvalue->u.page_thumbnail);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 24: { /* frame */
      pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

      if (pvalue->u.frame == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);

      stat = XmlDec_Ns3_Frame (pctxt, pvalue->u.frame);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 25: { /* measure */
      pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

      if (pvalue->u.measure == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);

      stat = XmlDec_Ns3_Measure (pctxt, pvalue->u.measure);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 26: { /* caption */
      pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

      if (pvalue->u.caption == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);

      stat = XmlDec_Ns3_Caption (pctxt, pvalue->u.caption);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 27: { /* connector */
      pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

      if (pvalue->u.connector == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);

      stat = XmlDec_Ns3_Connector (pctxt, pvalue->u.connector);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 28: { /* control */
      pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

      if (pvalue->u.control == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);

      stat = XmlDec_Ns3_Control (pctxt, pvalue->u.control);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 29: { /* scene */
      pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

      if (pvalue->u.scene == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);

      stat = XmlDec_Ns7_Scene (pctxt, pvalue->u.scene);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 30: { /* custom-shape */
      pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

      if (pvalue->u.custom_shape == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);

      stat = XmlDec_Ns3_Custom_shape (pctxt, pvalue->u.custom_shape);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 31: { /* change */
      pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

      if (pvalue->u.change == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change ((Odf_Change*)pvalue->u.change);

      stat = XmlDec_Odf_Change (pctxt, pvalue->u.change);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 32: { /* change-start */
      pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

      if (pvalue->u.change_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_start ((Odf_Change_start*)pvalue->u.change_start);

      stat = XmlDec_Odf_Change_start (pctxt, pvalue->u.change_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 33: { /* change-end */
      pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

      if (pvalue->u.change_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_end ((Odf_Change_end*)pvalue->u.change_end);

      stat = XmlDec_Odf_Change_end (pctxt, pvalue->u.change_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_cell                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_cell (OSCTXT* pctxt, Table_cell *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode boolean_value */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Boolean_value (pctxt, 
               (Ns13_Boolean_value*)&pvalue->boolean_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.boolean_valuePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode currency */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Currency (pctxt, 
               (Ns13_Currency*)&pvalue->currency, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.currencyPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode date_value */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->date_value = rtxMemAllocType (pctxt, Ns13_Date_value);

            if (pvalue->date_value == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);
            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);

            stat = asn1D_Ns13_Date_value (pctxt, 
               (Ns13_Date_value*)pvalue->date_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.date_valuePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode string_value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_String_value (pctxt, 
               (Ns13_String_value*)&pvalue->string_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.string_valuePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode time_value */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Time_value (pctxt, 
               (Ns13_Time_value*)&pvalue->time_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.time_valuePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Value (pctxt, 
               (Ns13_Value*)&pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode value_type */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_cell_value_type (pctxt, 
               &pvalue->value_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.value_typePresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode content_validation_name */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->content_validation_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.content_validation_namePresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode formula */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->formula, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.formulaPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode number_columns_repeated */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->number_columns_repeated, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.number_columns_repeatedPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode number_columns_spanned */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->number_columns_spanned, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.number_columns_spannedPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode number_matrix_columns_spanned */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->number_matrix_columns_spanned, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.number_matrix_columns_spannedPresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode number_matrix_rows_spanned */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->number_matrix_rows_spanned, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.number_matrix_rows_spannedPresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode number_rows_spanned */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->number_rows_spanned, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.number_rows_spannedPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode protect */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_cell_protect (pctxt, 
               &pvalue->protect, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.protectPresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_cell_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 16:
         /* decode cell_range_source */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Cell_range_source (pctxt, 
               &pvalue->cell_range_source, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.cell_range_sourcePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 17:
         /* decode annotation */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->annotation = rtxMemAllocType (pctxt, Ns13_Annotation);

            if (pvalue->annotation == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Annotation ((Ns13_Annotation*)pvalue->annotation);
            asn1Init_Ns13_Annotation ((Ns13_Annotation*)pvalue->annotation);

            stat = asn1D_Ns13_Annotation (pctxt, 
               (Ns13_Annotation*)pvalue->annotation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.annotationPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 18:
         /* decode detective */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Detective (pctxt, 
               &pvalue->detective, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.detectivePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 19:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Table_cell_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Table_cell_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Table_cell_element (pdata2);

                  stat = asn1D_Table_cell_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_CONS|18):
         case (TM_CTXT|TM_CONS|19):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Table_cell (OSCTXT* pctxt, Table_cell* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("boolean-value"), 13}, 0 },
         { {OSUTF8("currency"), 8}, 0 },
         { {OSUTF8("date-value"), 10}, 0 },
         { {OSUTF8("string-value"), 12}, 0 },
         { {OSUTF8("time-value"), 10}, 0 },
         { {OSUTF8("value"), 5}, 0 },
         { {OSUTF8("value-type"), 10}, 0 },
         { {OSUTF8("content-validation-name"), 23}, 0 },
         { {OSUTF8("formula"), 7}, 0 },
         { {OSUTF8("number-columns-repeated"), 23}, 0 },
         { {OSUTF8("number-columns-spanned"), 22}, 0 },
         { {OSUTF8("number-matrix-columns-spanned"), 29}, 0 },
         { {OSUTF8("number-matrix-rows-spanned"), 26}, 0 },
         { {OSUTF8("number-rows-spanned"), 19}, 0 },
         { {OSUTF8("protect"), 7}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 16, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* boolean-value */
            stat = XmlDec_Ns13_Boolean_value (pctxt, &pvalue->boolean_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.boolean_valuePresent = TRUE;
            break;

         case 1: /* currency */
            stat = XmlDec_Ns13_Currency (pctxt, &pvalue->currency);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.currencyPresent = TRUE;
            break;

         case 2: /* date-value */
            pvalue->date_value = rtxMemAllocType (pctxt, Ns13_Date_value);

            if (pvalue->date_value == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);

            stat = XmlDec_Ns13_Date_value (pctxt, pvalue->date_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.date_valuePresent = TRUE;
            break;

         case 3: /* string-value */
            stat = XmlDec_Ns13_String_value (pctxt, &pvalue->string_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.string_valuePresent = TRUE;
            break;

         case 4: /* time-value */
            stat = XmlDec_Ns13_Time_value (pctxt, &pvalue->time_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.time_valuePresent = TRUE;
            break;

         case 5: /* value */
            stat = XmlDec_Ns13_Value (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         case 6: /* value-type */
            stat = XmlDec_Table_cell_value_type (pctxt, &pvalue->value_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.value_typePresent = TRUE;
            break;

         case 7: /* content-validation-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->content_validation_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.content_validation_namePresent = TRUE;
            break;

         case 8: /* formula */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->formula);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.formulaPresent = TRUE;
            break;

         case 9: /* number-columns-repeated */
            stat = rtXmlpDecUInt (pctxt, &pvalue->number_columns_repeated);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.number_columns_repeatedPresent = TRUE;
            break;

         case 10: /* number-columns-spanned */
            stat = rtXmlpDecUInt (pctxt, &pvalue->number_columns_spanned);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.number_columns_spannedPresent = TRUE;
            break;

         case 11: /* number-matrix-columns-spanned */
            stat = rtXmlpDecUInt (pctxt, &pvalue->number_matrix_columns_spanned
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.number_matrix_columns_spannedPresent = TRUE;
            break;

         case 12: /* number-matrix-rows-spanned */
            stat = rtXmlpDecUInt (pctxt, &pvalue->number_matrix_rows_spanned);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.number_matrix_rows_spannedPresent = TRUE;
            break;

         case 13: /* number-rows-spanned */
            stat = rtXmlpDecUInt (pctxt, &pvalue->number_rows_spanned);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.number_rows_spannedPresent = TRUE;
            break;

         case 14: /* protect */
            stat = XmlDec_Table_cell_protect (pctxt, &pvalue->protect);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.protectPresent = TRUE;
            break;

         case 15: /* style-name */
            stat = XmlDec_Table_cell_style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Table_cell");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Table_cell");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("cell-range-source"), 17}, 0}, 0 },
      {{{OSUTF8("annotation"), 10}, 0}, 1 },
      {{{OSUTF8("detective"), 9}, 0}, 2 },
      {{{OSUTF8("h"), 1}, 0}, 3 },
      {{{OSUTF8("p"), 1}, 0}, 3 },
      {{{OSUTF8("list"), 4}, 0}, 3 },
      {{{OSUTF8("numbered-paragraph"), 18}, 0}, 3 },
      {{{OSUTF8("table"), 5}, 0}, 3 },
      {{{OSUTF8("a"), 1}, 0}, 3 },
      {{{OSUTF8("section"), 7}, 0}, 3 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 3 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 3 },
      {{{OSUTF8("table-index"), 11}, 0}, 3 },
      {{{OSUTF8("object-index"), 12}, 0}, 3 },
      {{{OSUTF8("user-index"), 10}, 0}, 3 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 3 },
      {{{OSUTF8("bibliography"), 12}, 0}, 3 },
      {{{OSUTF8("rect"), 4}, 0}, 3 },
      {{{OSUTF8("line"), 4}, 0}, 3 },
      {{{OSUTF8("polyline"), 8}, 0}, 3 },
      {{{OSUTF8("polygon"), 7}, 0}, 3 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 3 },
      {{{OSUTF8("path"), 4}, 0}, 3 },
      {{{OSUTF8("circle"), 6}, 0}, 3 },
      {{{OSUTF8("ellipse"), 7}, 0}, 3 },
      {{{OSUTF8("g"), 1}, 0}, 3 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 3 },
      {{{OSUTF8("frame"), 5}, 0}, 3 },
      {{{OSUTF8("measure"), 7}, 0}, 3 },
      {{{OSUTF8("caption"), 7}, 0}, 3 },
      {{{OSUTF8("connector"), 9}, 0}, 3 },
      {{{OSUTF8("control"), 7}, 0}, 3 },
      {{{OSUTF8("scene"), 5}, 0}, 3 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 3 },
      {{{OSUTF8("change"), 6}, 0}, 3 },
      {{{OSUTF8("change-start"), 12}, 0}, 3 },
      {{{OSUTF8("change-end"), 10}, 0}, 3 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 37, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 4; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* cell-range-source */
         stat = XmlDec_Cell_range_source (pctxt, &pvalue->cell_range_source);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.cell_range_sourcePresent = TRUE;
         break;
      }
      case 1: { /* annotation */
         pvalue->annotation = rtxMemAllocType (pctxt, Ns13_Annotation);

         if (pvalue->annotation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Annotation ((Ns13_Annotation*)pvalue->annotation);

         stat = XmlDec_Ns13_Annotation (pctxt, pvalue->annotation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.annotationPresent = TRUE;
         break;
      }
      case 2: { /* detective */
         stat = XmlDec_Detective (pctxt, &pvalue->detective);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.detectivePresent = TRUE;
         break;
      }
      case 3: {
         Table_cell_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Table_cell_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Table_cell_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Table_cell_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 3, 34, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 3);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Covered_table_cell_value_type                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Covered_table_cell_value_type (OSCTXT* pctxt, 
   Covered_table_cell_value_type *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Covered_table_cell_value_type (OSCTXT* pctxt, 
   Covered_table_cell_value_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Covered_table_cell_value_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Covered_table_cell_protect                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Covered_table_cell_protect (OSCTXT* pctxt, 
   Covered_table_cell_protect *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Covered_table_cell_protect (OSCTXT* pctxt, 
   Covered_table_cell_protect* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Covered_table_cell_protect_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Covered_table_cell_style_name                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Covered_table_cell_style_name (OSCTXT* pctxt, 
   Covered_table_cell_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Covered_table_cell_style_name (OSCTXT* pctxt, 
   Covered_table_cell_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Covered_table_cell_element                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Covered_table_cell_element (OSCTXT* pctxt, 
   Covered_table_cell_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

         if (pvalue->u.h == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_H ((Odf_H*)pvalue->u.h);
         stat = asn1D_Odf_H (pctxt, 
            (Odf_H*)pvalue->u.h, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P ((Odf_P*)pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            (Odf_P*)pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List ((Odf_List*)pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            (Odf_List*)pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.numbered_paragraph
             = rtxMemAllocType (pctxt, Odf_Numbered_paragraph);

         if (pvalue->u.numbered_paragraph == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Numbered_paragraph ((Odf_Numbered_paragraph*)pvalue->u.numbered_paragraph);
         stat = asn1D_Odf_Numbered_paragraph (pctxt, 
            (Odf_Numbered_paragraph*)pvalue->u.numbered_paragraph, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.table = rtxMemAllocType (pctxt, Table);

         if (pvalue->u.table == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table ((Table*)pvalue->u.table);
         stat = asn1D_Table (pctxt, 
            (Table*)pvalue->u.table, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.a = rtxMemAllocType (pctxt, Ns3_A);

         if (pvalue->u.a == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_A ((Ns3_A*)pvalue->u.a);
         stat = asn1D_Ns3_A (pctxt, 
            (Ns3_A*)pvalue->u.a, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.section = rtxMemAllocType (pctxt, Odf_Section);

         if (pvalue->u.section == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Section ((Odf_Section*)pvalue->u.section);
         stat = asn1D_Odf_Section (pctxt, 
            (Odf_Section*)pvalue->u.section, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.table_of_content
             = rtxMemAllocType (pctxt, Odf_Table_of_content);

         if (pvalue->u.table_of_content == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_of_content ((Odf_Table_of_content*)pvalue->u.table_of_content);
         stat = asn1D_Odf_Table_of_content (pctxt, 
            (Odf_Table_of_content*)pvalue->u.table_of_content, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.illustration_index
             = rtxMemAllocType (pctxt, Odf_Illustration_index);

         if (pvalue->u.illustration_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Illustration_index ((Odf_Illustration_index*)pvalue->u.illustration_index);
         stat = asn1D_Odf_Illustration_index (pctxt, 
            (Odf_Illustration_index*)pvalue->u.illustration_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.table_index = rtxMemAllocType (pctxt, Odf_Table_index);

         if (pvalue->u.table_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_index ((Odf_Table_index*)pvalue->u.table_index);
         stat = asn1D_Odf_Table_index (pctxt, 
            (Odf_Table_index*)pvalue->u.table_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.object_index = rtxMemAllocType (pctxt, Odf_Object_index);

         if (pvalue->u.object_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Object_index ((Odf_Object_index*)pvalue->u.object_index);
         stat = asn1D_Odf_Object_index (pctxt, 
            (Odf_Object_index*)pvalue->u.object_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.user_index = rtxMemAllocType (pctxt, Odf_User_index);

         if (pvalue->u.user_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index ((Odf_User_index*)pvalue->u.user_index);
         stat = asn1D_Odf_User_index (pctxt, 
            (Odf_User_index*)pvalue->u.user_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.alphabetical_index
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index);

         if (pvalue->u.alphabetical_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index ((Odf_Alphabetical_index*)pvalue->u.alphabetical_index);
         stat = asn1D_Odf_Alphabetical_index (pctxt, 
            (Odf_Alphabetical_index*)pvalue->u.alphabetical_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.bibliography = rtxMemAllocType (pctxt, Odf_Bibliography);

         if (pvalue->u.bibliography == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bibliography ((Odf_Bibliography*)pvalue->u.bibliography);
         stat = asn1D_Odf_Bibliography (pctxt, 
            (Odf_Bibliography*)pvalue->u.bibliography, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

         if (pvalue->u.rect == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);
         stat = asn1D_Ns3_Rect (pctxt, 
            (Ns3_Rect*)pvalue->u.rect, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

         if (pvalue->u.line == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);
         stat = asn1D_Ns3_Line (pctxt, 
            (Ns3_Line*)pvalue->u.line, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

         if (pvalue->u.polyline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);
         stat = asn1D_Ns3_Polyline (pctxt, 
            (Ns3_Polyline*)pvalue->u.polyline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      case (TM_CTXT|TM_CONS|17):
         pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

         if (pvalue->u.polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);
         stat = asn1D_Ns3_Polygon (pctxt, 
            (Ns3_Polygon*)pvalue->u.polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 18;
         break;

      case (TM_CTXT|TM_CONS|18):
         pvalue->u.regular_polygon
             = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

         if (pvalue->u.regular_polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->u.regular_polygon);
         stat = asn1D_Ns3_Regular_polygon (pctxt, 
            (Ns3_Regular_polygon*)pvalue->u.regular_polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 19;
         break;

      case (TM_CTXT|TM_CONS|19):
         pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

         if (pvalue->u.path == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);
         stat = asn1D_Ns3_Path (pctxt, 
            (Ns3_Path*)pvalue->u.path, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 20;
         break;

      case (TM_CTXT|TM_CONS|20):
         pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

         if (pvalue->u.circle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);
         stat = asn1D_Ns3_Circle (pctxt, 
            (Ns3_Circle*)pvalue->u.circle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 21;
         break;

      case (TM_CTXT|TM_CONS|21):
         pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

         if (pvalue->u.ellipse == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);
         stat = asn1D_Ns3_Ellipse (pctxt, 
            (Ns3_Ellipse*)pvalue->u.ellipse, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 22;
         break;

      case (TM_CTXT|TM_CONS|22):
         pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

         if (pvalue->u.g == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);
         stat = asn1D_Ns3_G (pctxt, 
            (Ns3_G*)pvalue->u.g, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 23;
         break;

      case (TM_CTXT|TM_CONS|23):
         pvalue->u.page_thumbnail
             = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

         if (pvalue->u.page_thumbnail == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->u.page_thumbnail);
         stat = asn1D_Ns3_Page_thumbnail (pctxt, 
            (Ns3_Page_thumbnail*)pvalue->u.page_thumbnail, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 24;
         break;

      case (TM_CTXT|TM_CONS|24):
         pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

         if (pvalue->u.frame == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);
         stat = asn1D_Ns3_Frame (pctxt, 
            (Ns3_Frame*)pvalue->u.frame, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 25;
         break;

      case (TM_CTXT|TM_CONS|25):
         pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

         if (pvalue->u.measure == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);
         stat = asn1D_Ns3_Measure (pctxt, 
            (Ns3_Measure*)pvalue->u.measure, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 26;
         break;

      case (TM_CTXT|TM_CONS|26):
         pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

         if (pvalue->u.caption == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);
         stat = asn1D_Ns3_Caption (pctxt, 
            (Ns3_Caption*)pvalue->u.caption, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 27;
         break;

      case (TM_CTXT|TM_CONS|27):
         pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

         if (pvalue->u.connector == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);
         stat = asn1D_Ns3_Connector (pctxt, 
            (Ns3_Connector*)pvalue->u.connector, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 28;
         break;

      case (TM_CTXT|TM_CONS|28):
         pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

         if (pvalue->u.control == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);
         stat = asn1D_Ns3_Control (pctxt, 
            (Ns3_Control*)pvalue->u.control, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 29;
         break;

      case (TM_CTXT|TM_CONS|29):
         pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

         if (pvalue->u.scene == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);
         stat = asn1D_Ns7_Scene (pctxt, 
            (Ns7_Scene*)pvalue->u.scene, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 30;
         break;

      case (TM_CTXT|TM_CONS|30):
         pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

         if (pvalue->u.custom_shape == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);
         stat = asn1D_Ns3_Custom_shape (pctxt, 
            (Ns3_Custom_shape*)pvalue->u.custom_shape, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 31;
         break;

      case (TM_CTXT|TM_CONS|31):
         pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

         if (pvalue->u.change == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change ((Odf_Change*)pvalue->u.change);
         stat = asn1D_Odf_Change (pctxt, 
            (Odf_Change*)pvalue->u.change, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 32;
         break;

      case (TM_CTXT|TM_CONS|32):
         pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

         if (pvalue->u.change_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_start ((Odf_Change_start*)pvalue->u.change_start);
         stat = asn1D_Odf_Change_start (pctxt, 
            (Odf_Change_start*)pvalue->u.change_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 33;
         break;

      case (TM_CTXT|TM_CONS|33):
         pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

         if (pvalue->u.change_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_end ((Odf_Change_end*)pvalue->u.change_end);
         stat = asn1D_Odf_Change_end (pctxt, 
            (Odf_Change_end*)pvalue->u.change_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 34;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Covered_table_cell_element (OSCTXT* pctxt, 
   Covered_table_cell_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("h"), 1}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 1 },
      {{{OSUTF8("list"), 4}, 0}, 2 },
      {{{OSUTF8("numbered-paragraph"), 18}, 0}, 3 },
      {{{OSUTF8("table"), 5}, 0}, 4 },
      {{{OSUTF8("a"), 1}, 0}, 5 },
      {{{OSUTF8("section"), 7}, 0}, 6 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 7 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 8 },
      {{{OSUTF8("table-index"), 11}, 0}, 9 },
      {{{OSUTF8("object-index"), 12}, 0}, 10 },
      {{{OSUTF8("user-index"), 10}, 0}, 11 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 12 },
      {{{OSUTF8("bibliography"), 12}, 0}, 13 },
      {{{OSUTF8("rect"), 4}, 0}, 14 },
      {{{OSUTF8("line"), 4}, 0}, 15 },
      {{{OSUTF8("polyline"), 8}, 0}, 16 },
      {{{OSUTF8("polygon"), 7}, 0}, 17 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 18 },
      {{{OSUTF8("path"), 4}, 0}, 19 },
      {{{OSUTF8("circle"), 6}, 0}, 20 },
      {{{OSUTF8("ellipse"), 7}, 0}, 21 },
      {{{OSUTF8("g"), 1}, 0}, 22 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 23 },
      {{{OSUTF8("frame"), 5}, 0}, 24 },
      {{{OSUTF8("measure"), 7}, 0}, 25 },
      {{{OSUTF8("caption"), 7}, 0}, 26 },
      {{{OSUTF8("connector"), 9}, 0}, 27 },
      {{{OSUTF8("control"), 7}, 0}, 28 },
      {{{OSUTF8("scene"), 5}, 0}, 29 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 30 },
      {{{OSUTF8("change"), 6}, 0}, 31 },
      {{{OSUTF8("change-start"), 12}, 0}, 32 },
      {{{OSUTF8("change-end"), 10}, 0}, 33 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 34, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* h */
      pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

      if (pvalue->u.h == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_H ((Odf_H*)pvalue->u.h);

      stat = XmlDec_Odf_H (pctxt, pvalue->u.h);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P ((Odf_P*)pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List ((Odf_List*)pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* numbered-paragraph */
      pvalue->u.numbered_paragraph
          = rtxMemAllocType (pctxt, Odf_Numbered_paragraph);

      if (pvalue->u.numbered_paragraph == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Numbered_paragraph ((Odf_Numbered_paragraph*)pvalue->
         u.numbered_paragraph);

      stat = XmlDec_Odf_Numbered_paragraph (pctxt, pvalue->u.numbered_paragraph
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* table */
      pvalue->u.table = rtxMemAllocType (pctxt, Table);

      if (pvalue->u.table == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table ((Table*)pvalue->u.table);

      stat = XmlDec_Table (pctxt, pvalue->u.table);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* a */
      pvalue->u.a = rtxMemAllocType (pctxt, Ns3_A);

      if (pvalue->u.a == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_A ((Ns3_A*)pvalue->u.a);

      stat = XmlDec_Ns3_A (pctxt, pvalue->u.a);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* section */
      pvalue->u.section = rtxMemAllocType (pctxt, Odf_Section);

      if (pvalue->u.section == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Section ((Odf_Section*)pvalue->u.section);

      stat = XmlDec_Odf_Section (pctxt, pvalue->u.section);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* table-of-content */
      pvalue->u.table_of_content
          = rtxMemAllocType (pctxt, Odf_Table_of_content);

      if (pvalue->u.table_of_content == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_of_content ((Odf_Table_of_content*)pvalue->
         u.table_of_content);

      stat = XmlDec_Odf_Table_of_content (pctxt, pvalue->u.table_of_content);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* illustration-index */
      pvalue->u.illustration_index
          = rtxMemAllocType (pctxt, Odf_Illustration_index);

      if (pvalue->u.illustration_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Illustration_index ((Odf_Illustration_index*)pvalue->
         u.illustration_index);

      stat = XmlDec_Odf_Illustration_index (pctxt, pvalue->u.illustration_index
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* table-index */
      pvalue->u.table_index = rtxMemAllocType (pctxt, Odf_Table_index);

      if (pvalue->u.table_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_index ((Odf_Table_index*)pvalue->u.table_index);

      stat = XmlDec_Odf_Table_index (pctxt, pvalue->u.table_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* object-index */
      pvalue->u.object_index = rtxMemAllocType (pctxt, Odf_Object_index);

      if (pvalue->u.object_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Object_index ((Odf_Object_index*)pvalue->u.object_index);

      stat = XmlDec_Odf_Object_index (pctxt, pvalue->u.object_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* user-index */
      pvalue->u.user_index = rtxMemAllocType (pctxt, Odf_User_index);

      if (pvalue->u.user_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index ((Odf_User_index*)pvalue->u.user_index);

      stat = XmlDec_Odf_User_index (pctxt, pvalue->u.user_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* alphabetical-index */
      pvalue->u.alphabetical_index
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index);

      if (pvalue->u.alphabetical_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index ((Odf_Alphabetical_index*)pvalue->
         u.alphabetical_index);

      stat = XmlDec_Odf_Alphabetical_index (pctxt, pvalue->u.alphabetical_index
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* bibliography */
      pvalue->u.bibliography = rtxMemAllocType (pctxt, Odf_Bibliography);

      if (pvalue->u.bibliography == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bibliography ((Odf_Bibliography*)pvalue->u.bibliography);

      stat = XmlDec_Odf_Bibliography (pctxt, pvalue->u.bibliography);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* rect */
      pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

      if (pvalue->u.rect == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);

      stat = XmlDec_Ns3_Rect (pctxt, pvalue->u.rect);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* line */
      pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

      if (pvalue->u.line == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);

      stat = XmlDec_Ns3_Line (pctxt, pvalue->u.line);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* polyline */
      pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

      if (pvalue->u.polyline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);

      stat = XmlDec_Ns3_Polyline (pctxt, pvalue->u.polyline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 17: { /* polygon */
      pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

      if (pvalue->u.polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);

      stat = XmlDec_Ns3_Polygon (pctxt, pvalue->u.polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 18: { /* regular-polygon */
      pvalue->u.regular_polygon
          = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

      if (pvalue->u.regular_polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->
         u.regular_polygon);

      stat = XmlDec_Ns3_Regular_polygon (pctxt, pvalue->u.regular_polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 19: { /* path */
      pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

      if (pvalue->u.path == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);

      stat = XmlDec_Ns3_Path (pctxt, pvalue->u.path);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 20: { /* circle */
      pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

      if (pvalue->u.circle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);

      stat = XmlDec_Ns3_Circle (pctxt, pvalue->u.circle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 21: { /* ellipse */
      pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

      if (pvalue->u.ellipse == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);

      stat = XmlDec_Ns3_Ellipse (pctxt, pvalue->u.ellipse);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 22: { /* g */
      pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

      if (pvalue->u.g == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);

      stat = XmlDec_Ns3_G (pctxt, pvalue->u.g);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 23: { /* page-thumbnail */
      pvalue->u.page_thumbnail = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

      if (pvalue->u.page_thumbnail == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->
         u.page_thumbnail);

      stat = XmlDec_Ns3_Page_thumbnail (pctxt, pvalue->u.page_thumbnail);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 24: { /* frame */
      pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

      if (pvalue->u.frame == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);

      stat = XmlDec_Ns3_Frame (pctxt, pvalue->u.frame);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 25: { /* measure */
      pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

      if (pvalue->u.measure == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);

      stat = XmlDec_Ns3_Measure (pctxt, pvalue->u.measure);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 26: { /* caption */
      pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

      if (pvalue->u.caption == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);

      stat = XmlDec_Ns3_Caption (pctxt, pvalue->u.caption);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 27: { /* connector */
      pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

      if (pvalue->u.connector == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);

      stat = XmlDec_Ns3_Connector (pctxt, pvalue->u.connector);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 28: { /* control */
      pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

      if (pvalue->u.control == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);

      stat = XmlDec_Ns3_Control (pctxt, pvalue->u.control);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 29: { /* scene */
      pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

      if (pvalue->u.scene == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);

      stat = XmlDec_Ns7_Scene (pctxt, pvalue->u.scene);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 30: { /* custom-shape */
      pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

      if (pvalue->u.custom_shape == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);

      stat = XmlDec_Ns3_Custom_shape (pctxt, pvalue->u.custom_shape);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 31: { /* change */
      pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

      if (pvalue->u.change == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change ((Odf_Change*)pvalue->u.change);

      stat = XmlDec_Odf_Change (pctxt, pvalue->u.change);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 32: { /* change-start */
      pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

      if (pvalue->u.change_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_start ((Odf_Change_start*)pvalue->u.change_start);

      stat = XmlDec_Odf_Change_start (pctxt, pvalue->u.change_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 33: { /* change-end */
      pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

      if (pvalue->u.change_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_end ((Odf_Change_end*)pvalue->u.change_end);

      stat = XmlDec_Odf_Change_end (pctxt, pvalue->u.change_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Covered_table_cell                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Covered_table_cell (OSCTXT* pctxt, 
   Covered_table_cell *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode boolean_value */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Boolean_value (pctxt, 
               (Ns13_Boolean_value*)&pvalue->boolean_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.boolean_valuePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode currency */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Currency (pctxt, 
               (Ns13_Currency*)&pvalue->currency, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.currencyPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode date_value */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->date_value = rtxMemAllocType (pctxt, Ns13_Date_value);

            if (pvalue->date_value == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);
            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);

            stat = asn1D_Ns13_Date_value (pctxt, 
               (Ns13_Date_value*)pvalue->date_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.date_valuePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode string_value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_String_value (pctxt, 
               (Ns13_String_value*)&pvalue->string_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.string_valuePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode time_value */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Time_value (pctxt, 
               (Ns13_Time_value*)&pvalue->time_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.time_valuePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Value (pctxt, 
               (Ns13_Value*)&pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode value_type */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Covered_table_cell_value_type (pctxt, 
               &pvalue->value_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.value_typePresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode content_validation_name */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->content_validation_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.content_validation_namePresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode formula */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->formula, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.formulaPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode number_columns_repeated */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->number_columns_repeated, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.number_columns_repeatedPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode protect */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Covered_table_cell_protect (pctxt, 
               &pvalue->protect, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.protectPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Covered_table_cell_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 12:
         /* decode cell_range_source */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Cell_range_source (pctxt, 
               &pvalue->cell_range_source, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.cell_range_sourcePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 13:
         /* decode annotation */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->annotation = rtxMemAllocType (pctxt, Ns13_Annotation);

            if (pvalue->annotation == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Annotation ((Ns13_Annotation*)pvalue->annotation);
            asn1Init_Ns13_Annotation ((Ns13_Annotation*)pvalue->annotation);

            stat = asn1D_Ns13_Annotation (pctxt, 
               (Ns13_Annotation*)pvalue->annotation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.annotationPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 14:
         /* decode detective */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Detective (pctxt, 
               &pvalue->detective, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.detectivePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 15:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Covered_table_cell_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Covered_table_cell_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Covered_table_cell_element (pdata2);

                  stat = asn1D_Covered_table_cell_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_CONS|15):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Covered_table_cell (OSCTXT* pctxt, Covered_table_cell* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("boolean-value"), 13}, 0 },
         { {OSUTF8("currency"), 8}, 0 },
         { {OSUTF8("date-value"), 10}, 0 },
         { {OSUTF8("string-value"), 12}, 0 },
         { {OSUTF8("time-value"), 10}, 0 },
         { {OSUTF8("value"), 5}, 0 },
         { {OSUTF8("value-type"), 10}, 0 },
         { {OSUTF8("content-validation-name"), 23}, 0 },
         { {OSUTF8("formula"), 7}, 0 },
         { {OSUTF8("number-columns-repeated"), 23}, 0 },
         { {OSUTF8("protect"), 7}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 12, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* boolean-value */
            stat = XmlDec_Ns13_Boolean_value (pctxt, &pvalue->boolean_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.boolean_valuePresent = TRUE;
            break;

         case 1: /* currency */
            stat = XmlDec_Ns13_Currency (pctxt, &pvalue->currency);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.currencyPresent = TRUE;
            break;

         case 2: /* date-value */
            pvalue->date_value = rtxMemAllocType (pctxt, Ns13_Date_value);

            if (pvalue->date_value == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);

            stat = XmlDec_Ns13_Date_value (pctxt, pvalue->date_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.date_valuePresent = TRUE;
            break;

         case 3: /* string-value */
            stat = XmlDec_Ns13_String_value (pctxt, &pvalue->string_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.string_valuePresent = TRUE;
            break;

         case 4: /* time-value */
            stat = XmlDec_Ns13_Time_value (pctxt, &pvalue->time_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.time_valuePresent = TRUE;
            break;

         case 5: /* value */
            stat = XmlDec_Ns13_Value (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         case 6: /* value-type */
            stat = XmlDec_Covered_table_cell_value_type (pctxt, &pvalue->
               value_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.value_typePresent = TRUE;
            break;

         case 7: /* content-validation-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->content_validation_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.content_validation_namePresent = TRUE;
            break;

         case 8: /* formula */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->formula);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.formulaPresent = TRUE;
            break;

         case 9: /* number-columns-repeated */
            stat = rtXmlpDecUInt (pctxt, &pvalue->number_columns_repeated);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.number_columns_repeatedPresent = TRUE;
            break;

         case 10: /* protect */
            stat = XmlDec_Covered_table_cell_protect (pctxt, &pvalue->protect
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.protectPresent = TRUE;
            break;

         case 11: /* style-name */
            stat = XmlDec_Covered_table_cell_style_name (pctxt, &pvalue->
               style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Covered_table_cell");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Covered_table_cell");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("cell-range-source"), 17}, 0}, 0 },
      {{{OSUTF8("annotation"), 10}, 0}, 1 },
      {{{OSUTF8("detective"), 9}, 0}, 2 },
      {{{OSUTF8("h"), 1}, 0}, 3 },
      {{{OSUTF8("p"), 1}, 0}, 3 },
      {{{OSUTF8("list"), 4}, 0}, 3 },
      {{{OSUTF8("numbered-paragraph"), 18}, 0}, 3 },
      {{{OSUTF8("table"), 5}, 0}, 3 },
      {{{OSUTF8("a"), 1}, 0}, 3 },
      {{{OSUTF8("section"), 7}, 0}, 3 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 3 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 3 },
      {{{OSUTF8("table-index"), 11}, 0}, 3 },
      {{{OSUTF8("object-index"), 12}, 0}, 3 },
      {{{OSUTF8("user-index"), 10}, 0}, 3 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 3 },
      {{{OSUTF8("bibliography"), 12}, 0}, 3 },
      {{{OSUTF8("rect"), 4}, 0}, 3 },
      {{{OSUTF8("line"), 4}, 0}, 3 },
      {{{OSUTF8("polyline"), 8}, 0}, 3 },
      {{{OSUTF8("polygon"), 7}, 0}, 3 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 3 },
      {{{OSUTF8("path"), 4}, 0}, 3 },
      {{{OSUTF8("circle"), 6}, 0}, 3 },
      {{{OSUTF8("ellipse"), 7}, 0}, 3 },
      {{{OSUTF8("g"), 1}, 0}, 3 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 3 },
      {{{OSUTF8("frame"), 5}, 0}, 3 },
      {{{OSUTF8("measure"), 7}, 0}, 3 },
      {{{OSUTF8("caption"), 7}, 0}, 3 },
      {{{OSUTF8("connector"), 9}, 0}, 3 },
      {{{OSUTF8("control"), 7}, 0}, 3 },
      {{{OSUTF8("scene"), 5}, 0}, 3 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 3 },
      {{{OSUTF8("change"), 6}, 0}, 3 },
      {{{OSUTF8("change-start"), 12}, 0}, 3 },
      {{{OSUTF8("change-end"), 10}, 0}, 3 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 37, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 4; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* cell-range-source */
         stat = XmlDec_Cell_range_source (pctxt, &pvalue->cell_range_source);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.cell_range_sourcePresent = TRUE;
         break;
      }
      case 1: { /* annotation */
         pvalue->annotation = rtxMemAllocType (pctxt, Ns13_Annotation);

         if (pvalue->annotation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Annotation ((Ns13_Annotation*)pvalue->annotation);

         stat = XmlDec_Ns13_Annotation (pctxt, pvalue->annotation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.annotationPresent = TRUE;
         break;
      }
      case 2: { /* detective */
         stat = XmlDec_Detective (pctxt, &pvalue->detective);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.detectivePresent = TRUE;
         break;
      }
      case 3: {
         Covered_table_cell_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Covered_table_cell_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Covered_table_cell_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Covered_table_cell_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 3, 34, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 3);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_row_element                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_row_element (OSCTXT* pctxt, Table_row_element *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.table_cell = rtxMemAllocType (pctxt, Table_cell);

         if (pvalue->u.table_cell == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table_cell (pvalue->u.table_cell);
         stat = asn1D_Table_cell (pctxt, 
            pvalue->u.table_cell, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.covered_table_cell
             = rtxMemAllocType (pctxt, Covered_table_cell);

         if (pvalue->u.covered_table_cell == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Covered_table_cell (pvalue->u.covered_table_cell);
         stat = asn1D_Covered_table_cell (pctxt, 
            pvalue->u.covered_table_cell, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Table_row_element (OSCTXT* pctxt, Table_row_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("table-cell"), 10}, 0}, 0 },
      {{{OSUTF8("covered-table-cell"), 18}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* table-cell */
      pvalue->u.table_cell = rtxMemAllocType (pctxt, Table_cell);

      if (pvalue->u.table_cell == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table_cell (pvalue->u.table_cell);

      stat = XmlDec_Table_cell (pctxt, pvalue->u.table_cell);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* covered-table-cell */
      pvalue->u.covered_table_cell
          = rtxMemAllocType (pctxt, Covered_table_cell);

      if (pvalue->u.covered_table_cell == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Covered_table_cell (pvalue->u.covered_table_cell);

      stat = XmlDec_Covered_table_cell (pctxt, pvalue->u.covered_table_cell);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_row                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_row (OSCTXT* pctxt, Table_row *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode default_cell_style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_row_default_cell_style_name (pctxt, 
               &pvalue->default_cell_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.default_cell_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode number_rows_repeated */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->number_rows_repeated, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.number_rows_repeatedPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_row_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode visibility */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_row_visibility (pctxt, 
               &pvalue->visibility, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.visibilityPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Table_row_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Table_row_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Table_row_element (pdata2);

                  stat = asn1D_Table_row_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Table_row (OSCTXT* pctxt, Table_row* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("default-cell-style-name"), 23}, 0 },
         { {OSUTF8("number-rows-repeated"), 20}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("visibility"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* default-cell-style-name */
            stat = XmlDec_Table_row_default_cell_style_name (pctxt, &pvalue->
               default_cell_style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.default_cell_style_namePresent = TRUE;
            break;

         case 1: /* number-rows-repeated */
            stat = rtXmlpDecUInt (pctxt, &pvalue->number_rows_repeated);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.number_rows_repeatedPresent = TRUE;
            break;

         case 2: /* style-name */
            stat = XmlDec_Table_row_style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 3: /* visibility */
            stat = XmlDec_Table_row_visibility (pctxt, &pvalue->visibility);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.visibilityPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Table_row");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Table_row");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("table-cell"), 10}, 0}, 0 },
      {{{OSUTF8("covered-table-cell"), 18}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Table_row_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Table_row_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Table_row_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Table_row_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 2, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_rows                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_rows (OSCTXT* pctxt, Table_rows *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode table_row_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Table_row* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->table_row_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Table_row, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Table_row (pdata2);

                  stat = asn1D_Table_row (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->table_row_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Table_rows (OSCTXT* pctxt, Table_rows* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("table-row"), 9}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Table_row* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Table_row);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Table_row (pdata1);

            stat = XmlDec_Table_row (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->table_row_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_header_rows                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_header_rows (OSCTXT* pctxt, Table_header_rows *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode table_row_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Table_row* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->table_row_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Table_row, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Table_row (pdata2);

                  stat = asn1D_Table_row (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->table_row_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Table_header_rows (OSCTXT* pctxt, Table_header_rows* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("table-row"), 9}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Table_row* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Table_row);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Table_row (pdata1);

            stat = XmlDec_Table_row (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->table_row_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_row_group_element                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_row_group_element (OSCTXT* pctxt, 
   Table_row_group_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.table_row_group = rtxMemAllocType (pctxt, Table_row_group);

         if (pvalue->u.table_row_group == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table_row_group ((Table_row_group*)pvalue->u.table_row_group);
         stat = asn1D_Table_row_group (pctxt, 
            (Table_row_group*)pvalue->u.table_row_group, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.table_rows = rtxMemAllocType (pctxt, Table_rows);

         if (pvalue->u.table_rows == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table_rows (pvalue->u.table_rows);
         stat = asn1D_Table_rows (pctxt, 
            pvalue->u.table_rows, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.table_row = rtxMemAllocType (pctxt, Table_row);

         if (pvalue->u.table_row == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table_row (pvalue->u.table_row);
         stat = asn1D_Table_row (pctxt, 
            pvalue->u.table_row, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.table_header_rows
             = rtxMemAllocType (pctxt, Table_header_rows);

         if (pvalue->u.table_header_rows == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table_header_rows (pvalue->u.table_header_rows);
         stat = asn1D_Table_header_rows (pctxt, 
            pvalue->u.table_header_rows, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Table_row_group_element (OSCTXT* pctxt, 
   Table_row_group_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("table-row-group"), 15}, 0}, 0 },
      {{{OSUTF8("table-rows"), 10}, 0}, 1 },
      {{{OSUTF8("table-row"), 9}, 0}, 2 },
      {{{OSUTF8("table-header-rows"), 17}, 0}, 3 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 4, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* table-row-group */
      pvalue->u.table_row_group = rtxMemAllocType (pctxt, Table_row_group);

      if (pvalue->u.table_row_group == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table_row_group ((Table_row_group*)pvalue->u.table_row_group);

      stat = XmlDec_Table_row_group (pctxt, pvalue->u.table_row_group);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* table-rows */
      pvalue->u.table_rows = rtxMemAllocType (pctxt, Table_rows);

      if (pvalue->u.table_rows == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table_rows (pvalue->u.table_rows);

      stat = XmlDec_Table_rows (pctxt, pvalue->u.table_rows);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* table-row */
      pvalue->u.table_row = rtxMemAllocType (pctxt, Table_row);

      if (pvalue->u.table_row == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table_row (pvalue->u.table_row);

      stat = XmlDec_Table_row (pctxt, pvalue->u.table_row);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* table-header-rows */
      pvalue->u.table_header_rows
          = rtxMemAllocType (pctxt, Table_header_rows);

      if (pvalue->u.table_header_rows == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table_header_rows (pvalue->u.table_header_rows);

      stat = XmlDec_Table_header_rows (pctxt, pvalue->u.table_header_rows);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_row_group                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_row_group (OSCTXT* pctxt, Table_row_group *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode display */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_row_group_display (pctxt, 
               &pvalue->display, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.displayPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Table_row_group_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Table_row_group_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Table_row_group_element (pdata2);

                  stat = asn1D_Table_row_group_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Table_row_group (OSCTXT* pctxt, Table_row_group* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("display"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* display */
            stat = XmlDec_Table_row_group_display (pctxt, &pvalue->display);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.displayPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Table_row_group");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Table_row_group");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("table-row-group"), 15}, 0}, 0 },
      {{{OSUTF8("table-rows"), 10}, 0}, 0 },
      {{{OSUTF8("table-row"), 9}, 0}, 0 },
      {{{OSUTF8("table-header-rows"), 17}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Table_row_group_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Table_row_group_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Table_row_group_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Table_row_group_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 4, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_element_1                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table_element_1 (OSCTXT* pctxt, Table_element_1 *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.table_row_group = rtxMemAllocType (pctxt, Table_row_group);

         if (pvalue->u.table_row_group == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table_row_group (pvalue->u.table_row_group);
         stat = asn1D_Table_row_group (pctxt, 
            pvalue->u.table_row_group, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.table_rows = rtxMemAllocType (pctxt, Table_rows);

         if (pvalue->u.table_rows == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table_rows (pvalue->u.table_rows);
         stat = asn1D_Table_rows (pctxt, 
            pvalue->u.table_rows, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.table_row = rtxMemAllocType (pctxt, Table_row);

         if (pvalue->u.table_row == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table_row (pvalue->u.table_row);
         stat = asn1D_Table_row (pctxt, 
            pvalue->u.table_row, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.table_header_rows
             = rtxMemAllocType (pctxt, Table_header_rows);

         if (pvalue->u.table_header_rows == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table_header_rows (pvalue->u.table_header_rows);
         stat = asn1D_Table_header_rows (pctxt, 
            pvalue->u.table_header_rows, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Table_element_1 (OSCTXT* pctxt, Table_element_1* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("table-row-group"), 15}, 0}, 0 },
      {{{OSUTF8("table-rows"), 10}, 0}, 1 },
      {{{OSUTF8("table-row"), 9}, 0}, 2 },
      {{{OSUTF8("table-header-rows"), 17}, 0}, 3 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 4, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* table-row-group */
      pvalue->u.table_row_group = rtxMemAllocType (pctxt, Table_row_group);

      if (pvalue->u.table_row_group == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table_row_group (pvalue->u.table_row_group);

      stat = XmlDec_Table_row_group (pctxt, pvalue->u.table_row_group);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* table-rows */
      pvalue->u.table_rows = rtxMemAllocType (pctxt, Table_rows);

      if (pvalue->u.table_rows == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table_rows (pvalue->u.table_rows);

      stat = XmlDec_Table_rows (pctxt, pvalue->u.table_rows);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* table-row */
      pvalue->u.table_row = rtxMemAllocType (pctxt, Table_row);

      if (pvalue->u.table_row == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table_row (pvalue->u.table_row);

      stat = XmlDec_Table_row (pctxt, pvalue->u.table_row);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* table-header-rows */
      pvalue->u.table_header_rows
          = rtxMemAllocType (pctxt, Table_header_rows);

      if (pvalue->u.table_header_rows == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table_header_rows (pvalue->u.table_header_rows);

      stat = XmlDec_Table_header_rows (pctxt, pvalue->u.table_header_rows);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Table (OSCTXT* pctxt, Table *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode is_sub_table */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_is_sub_table (pctxt, 
               &pvalue->is_sub_table, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.is_sub_tablePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode print */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_print (pctxt, 
               &pvalue->print, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.printPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode print_ranges */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->print_ranges, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.print_rangesPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode protected_ */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_protected_ (pctxt, 
               &pvalue->protected_, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.protected_Present = TRUE;
            }
         }
         break;

      case 5:
         /* decode protection_key */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->protection_key, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.protection_keyPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode table_source */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_source (pctxt, 
               &pvalue->table_source, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_sourcePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode dde_source */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->dde_source = rtxMemAllocType (pctxt, Ns13_Dde_source);

            if (pvalue->dde_source == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Dde_source ((Ns13_Dde_source*)pvalue->dde_source);
            asn1Init_Ns13_Dde_source ((Ns13_Dde_source*)pvalue->dde_source);

            stat = asn1D_Ns13_Dde_source (pctxt, 
               (Ns13_Dde_source*)pvalue->dde_source, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dde_sourcePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode scenario */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Scenario (pctxt, 
               &pvalue->scenario, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.scenarioPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 10:
         /* decode forms */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->forms = rtxMemAllocType (pctxt, Ns13_Forms);

            if (pvalue->forms == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Forms ((Ns13_Forms*)pvalue->forms);
            asn1Init_Ns13_Forms ((Ns13_Forms*)pvalue->forms);

            stat = asn1D_Ns13_Forms (pctxt, 
               (Ns13_Forms*)pvalue->forms, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.formsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 11:
         /* decode shapes */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Shapes (pctxt, 
               &pvalue->shapes, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.shapesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 12:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Table_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Table_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Table_element (pdata2);

                  stat = asn1D_Table_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 13:
         /* decode choice_1_list */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Table_element_1* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_1_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Table_element_1, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Table_element_1 (pdata2);

                  stat = asn1D_Table_element_1 (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_1_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_CONS|13):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Table (OSCTXT* pctxt, Table* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("is-sub-table"), 12}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("print"), 5}, 0 },
         { {OSUTF8("print-ranges"), 12}, 0 },
         { {OSUTF8("protected"), 9}, 0 },
         { {OSUTF8("protection-key"), 14}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 7, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* is-sub-table */
            stat = XmlDec_Table_is_sub_table (pctxt, &pvalue->is_sub_table);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.is_sub_tablePresent = TRUE;
            break;

         case 1: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 2: /* print */
            stat = XmlDec_Table_print (pctxt, &pvalue->print);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.printPresent = TRUE;
            break;

         case 3: /* print-ranges */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->print_ranges);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.print_rangesPresent = TRUE;
            break;

         case 4: /* protected */
            stat = XmlDec_Table_protected_ (pctxt, &pvalue->protected_);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.protected_Present = TRUE;
            break;

         case 5: /* protection-key */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->protection_key);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.protection_keyPresent = TRUE;
            break;

         case 6: /* style-name */
            stat = XmlDec_Table_style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Table");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Table");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("table-source"), 12}, 0}, 0 },
      {{{OSUTF8("dde-source"), 10}, 0}, 1 },
      {{{OSUTF8("scenario"), 8}, 0}, 2 },
      {{{OSUTF8("forms"), 5}, 0}, 3 },
      {{{OSUTF8("shapes"), 6}, 0}, 4 },
      {{{OSUTF8("table-column-group"), 18}, 0}, 5 },
      {{{OSUTF8("table-columns"), 13}, 0}, 5 },
      {{{OSUTF8("table-column"), 12}, 0}, 5 },
      {{{OSUTF8("table-header-columns"), 20}, 0}, 5 },
      {{{OSUTF8("table-row-group"), 15}, 0}, 6 },
      {{{OSUTF8("table-rows"), 10}, 0}, 6 },
      {{{OSUTF8("table-row"), 9}, 0}, 6 },
      {{{OSUTF8("table-header-rows"), 17}, 0}, 6 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 13, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 7; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* table-source */
         stat = XmlDec_Table_source (pctxt, &pvalue->table_source);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.table_sourcePresent = TRUE;
         break;
      }
      case 1: { /* dde-source */
         pvalue->dde_source = rtxMemAllocType (pctxt, Ns13_Dde_source);

         if (pvalue->dde_source == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Dde_source ((Ns13_Dde_source*)pvalue->dde_source);

         stat = XmlDec_Ns13_Dde_source (pctxt, pvalue->dde_source);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dde_sourcePresent = TRUE;
         break;
      }
      case 2: { /* scenario */
         stat = XmlDec_Scenario (pctxt, &pvalue->scenario);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.scenarioPresent = TRUE;
         break;
      }
      case 3: { /* forms */
         pvalue->forms = rtxMemAllocType (pctxt, Ns13_Forms);

         if (pvalue->forms == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Forms ((Ns13_Forms*)pvalue->forms);

         stat = XmlDec_Ns13_Forms (pctxt, pvalue->forms);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.formsPresent = TRUE;
         break;
      }
      case 4: { /* shapes */
         stat = XmlDec_Shapes (pctxt, &pvalue->shapes);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.shapesPresent = TRUE;
         break;
      }
      case 5: {
         Table_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Table_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Table_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Table_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 5, 4, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 5);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 6: {
         Table_element_1* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Table_element_1);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Table_element_1 (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Table_element_1 (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_1_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 9, 4, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 6);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Calculation_settings_automatic_find_labels                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Calculation_settings_automatic_find_labels (OSCTXT* pctxt, 
   Calculation_settings_automatic_find_labels *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Calculation_settings_automatic_find_labels (OSCTXT* pctxt, 
   Calculation_settings_automatic_find_labels* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Calculation_settings_automatic_find_labels_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Calculation_settings_case_sensitive                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Calculation_settings_case_sensitive (OSCTXT* pctxt, 
   Calculation_settings_case_sensitive *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Calculation_settings_case_sensitive (OSCTXT* pctxt, 
   Calculation_settings_case_sensitive* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Calculation_settings_case_sensitive_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Calculation_settings_precision_as_shown                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Calculation_settings_precision_as_shown (OSCTXT* pctxt, 
   Calculation_settings_precision_as_shown *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Calculation_settings_precision_as_shown (OSCTXT* pctxt, 
   Calculation_settings_precision_as_shown* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Calculation_settings_precision_as_shown_ToEnum (pctxt, strval, pvalue
      );
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Calculation_settings_search_criteria_must_apply_to_whole  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Calculation_settings_search_criteria_must_apply_to_whole_cell (
   OSCTXT* pctxt, 
   Calculation_settings_search_criteria_must_apply_to_whole_cell *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Calculation_settings_search_criteria_must_apply_to_whole_cell 
   (OSCTXT* pctxt, 
   Calculation_settings_search_criteria_must_apply_to_whole_cell* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Calculation_settings_search_criteria_must_apply_to_whole_cell_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Calculation_settings_use_regular_expressions              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Calculation_settings_use_regular_expressions (OSCTXT* pctxt, 
   Calculation_settings_use_regular_expressions *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Calculation_settings_use_regular_expressions (OSCTXT* pctxt, 
   Calculation_settings_use_regular_expressions* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Calculation_settings_use_regular_expressions_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Null_date_value_type                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Null_date_value_type (OSCTXT* pctxt, 
   Null_date_value_type *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Null_date_value_type (OSCTXT* pctxt, Null_date_value_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Null_date_value_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Null_date                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Null_date (OSCTXT* pctxt, Null_date *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode date_value_type */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->date_value_type, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
               pvalue->m.date_value_typePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode value_type */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Null_date_value_type (pctxt, 
               &pvalue->value_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.value_typePresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Null_date (OSCTXT* pctxt, Null_date* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("date-value-type"), 15}, 0 },
         { {OSUTF8("value-type"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* date-value-type */
            stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->
               date_value_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.date_value_typePresent = TRUE;
            break;

         case 1: /* value-type */
            stat = XmlDec_Null_date_value_type (pctxt, &pvalue->value_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.value_typePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Null_date");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Null_date");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iteration_status                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Iteration_status (OSCTXT* pctxt, Iteration_status *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Iteration_status (OSCTXT* pctxt, Iteration_status* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Iteration_status_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Iteration                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Iteration (OSCTXT* pctxt, Iteration *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode maximum_difference */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->maximum_difference, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.maximum_differencePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode status */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Iteration_status (pctxt, 
               &pvalue->status, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.statusPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode steps */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->steps, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.stepsPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Iteration (OSCTXT* pctxt, Iteration* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("maximum-difference"), 18}, 0 },
         { {OSUTF8("status"), 6}, 0 },
         { {OSUTF8("steps"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* maximum-difference */
            stat = rtXmlpDecDouble (pctxt, &pvalue->maximum_difference
               , -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.maximum_differencePresent = TRUE;
            break;

         case 1: /* status */
            stat = XmlDec_Iteration_status (pctxt, &pvalue->status);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.statusPresent = TRUE;
            break;

         case 2: /* steps */
            stat = rtXmlpDecUInt (pctxt, &pvalue->steps);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.stepsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Iteration");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Iteration");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Calculation_settings                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Calculation_settings (OSCTXT* pctxt, 
   Calculation_settings *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode automatic_find_labels */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Calculation_settings_automatic_find_labels (pctxt, 
               &pvalue->automatic_find_labels, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.automatic_find_labelsPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode case_sensitive */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Calculation_settings_case_sensitive (pctxt, 
               &pvalue->case_sensitive, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.case_sensitivePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode null_year */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->null_year, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.null_yearPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode precision_as_shown */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Calculation_settings_precision_as_shown (pctxt, 
               &pvalue->precision_as_shown, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.precision_as_shownPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode search_criteria_must_apply_to_whole_cell */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Calculation_settings_search_criteria_must_apply_to_whole_cell (pctxt, 
               &pvalue->search_criteria_must_apply_to_whole_cell, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.search_criteria_must_apply_to_whole_cellPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode use_regular_expressions */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Calculation_settings_use_regular_expressions (pctxt, 
               &pvalue->use_regular_expressions, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.use_regular_expressionsPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode null_date */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Null_date (pctxt, 
               &pvalue->null_date, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.null_datePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode iteration */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Iteration (pctxt, 
               &pvalue->iteration, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.iterationPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Calculation_settings (OSCTXT* pctxt, Calculation_settings* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("automatic-find-labels"), 21}, 0 },
         { {OSUTF8("case-sensitive"), 14}, 0 },
         { {OSUTF8("null-year"), 9}, 0 },
         { {OSUTF8("precision-as-shown"), 18}, 0 },
         { {OSUTF8("search-criteria-must-apply-to-whole-cell"), 40}, 0 },
         { {OSUTF8("use-regular-expressions"), 23}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 6, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* automatic-find-labels */
            stat = XmlDec_Calculation_settings_automatic_find_labels (pctxt, &
               pvalue->automatic_find_labels);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.automatic_find_labelsPresent = TRUE;
            break;

         case 1: /* case-sensitive */
            stat = XmlDec_Calculation_settings_case_sensitive (pctxt, &pvalue->
               case_sensitive);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.case_sensitivePresent = TRUE;
            break;

         case 2: /* null-year */
            stat = rtXmlpDecUInt (pctxt, &pvalue->null_year);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.null_yearPresent = TRUE;
            break;

         case 3: /* precision-as-shown */
            stat = XmlDec_Calculation_settings_precision_as_shown (pctxt, &
               pvalue->precision_as_shown);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.precision_as_shownPresent = TRUE;
            break;

         case 4: /* search-criteria-must-apply-to-whole-cell */
            stat = XmlDec_Calculation_settings_search_criteria_must_apply_to_whole_cell 
               (pctxt, &pvalue->search_criteria_must_apply_to_whole_cell);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.search_criteria_must_apply_to_whole_cellPresent = TRUE;
            break;

         case 5: /* use-regular-expressions */
            stat = XmlDec_Calculation_settings_use_regular_expressions (pctxt, 
               &pvalue->use_regular_expressions);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.use_regular_expressionsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Calculation_settings");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Calculation_settings");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("null-date"), 9}, 0}, 0 },
      {{{OSUTF8("iteration"), 9}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* null-date */
         stat = XmlDec_Null_date (pctxt, &pvalue->null_date);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.null_datePresent = TRUE;
         break;
      }
      case 1: { /* iteration */
         stat = XmlDec_Iteration (pctxt, &pvalue->iteration);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.iterationPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Content_validation_allow_empty_cell                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Content_validation_allow_empty_cell (OSCTXT* pctxt, 
   Content_validation_allow_empty_cell *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Content_validation_allow_empty_cell (OSCTXT* pctxt, 
   Content_validation_allow_empty_cell* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Content_validation_allow_empty_cell_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Content_validation_display_list                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Content_validation_display_list (OSCTXT* pctxt, 
   Content_validation_display_list *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Content_validation_display_list (OSCTXT* pctxt, 
   Content_validation_display_list* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Content_validation_display_list_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Help_message_display                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Help_message_display (OSCTXT* pctxt, 
   Help_message_display *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Help_message_display (OSCTXT* pctxt, Help_message_display* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Help_message_display_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Help_message                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Help_message (OSCTXT* pctxt, Help_message *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode display */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Help_message_display (pctxt, 
               &pvalue->display, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.displayPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode title */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->title, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.titlePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode p_list */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_P* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->p_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_P, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_P ((Odf_P*)pdata2);

                  stat = asn1D_Odf_P (pctxt, 
                     (Odf_P*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->p_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Help_message (OSCTXT* pctxt, Help_message* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("display"), 7}, 0 },
         { {OSUTF8("title"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* display */
            stat = XmlDec_Help_message_display (pctxt, &pvalue->display);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.displayPresent = TRUE;
            break;

         case 1: /* title */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->title);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.titlePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Help_message");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Help_message");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("p"), 1}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_P* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_P);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_P ((Odf_P*)pdata1);

            stat = XmlDec_Odf_P (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->p_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Error_message_display                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Error_message_display (OSCTXT* pctxt, 
   Error_message_display *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Error_message_display (OSCTXT* pctxt, Error_message_display* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Error_message_display_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Error_message_message_type                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Error_message_message_type (OSCTXT* pctxt, 
   Error_message_message_type *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Error_message_message_type (OSCTXT* pctxt, 
   Error_message_message_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Error_message_message_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Error_message                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Error_message (OSCTXT* pctxt, Error_message *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode display */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Error_message_display (pctxt, 
               &pvalue->display, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.displayPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode message_type */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Error_message_message_type (pctxt, 
               &pvalue->message_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.message_typePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode title */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->title, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.titlePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode p_list */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_P* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->p_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_P, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_P ((Odf_P*)pdata2);

                  stat = asn1D_Odf_P (pctxt, 
                     (Odf_P*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->p_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Error_message (OSCTXT* pctxt, Error_message* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("display"), 7}, 0 },
         { {OSUTF8("message-type"), 12}, 0 },
         { {OSUTF8("title"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* display */
            stat = XmlDec_Error_message_display (pctxt, &pvalue->display);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.displayPresent = TRUE;
            break;

         case 1: /* message-type */
            stat = XmlDec_Error_message_message_type (pctxt, &pvalue->
               message_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.message_typePresent = TRUE;
            break;

         case 2: /* title */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->title);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.titlePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Error_message");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Error_message");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("p"), 1}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_P* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_P);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_P ((Odf_P*)pdata1);

            stat = XmlDec_Odf_P (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->p_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Error_macro_execute                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Error_macro_execute (OSCTXT* pctxt, 
   Error_macro_execute *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Error_macro_execute (OSCTXT* pctxt, Error_macro_execute* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Error_macro_execute_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Error_macro                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Error_macro (OSCTXT* pctxt, Error_macro *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode execute */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Error_macro_execute (pctxt, 
               &pvalue->execute, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.executePresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Error_macro (OSCTXT* pctxt, Error_macro* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("execute"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* execute */
            stat = XmlDec_Error_macro_execute (pctxt, &pvalue->execute);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.executePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Error_macro");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Error_macro");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Content_validation_sequence                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Content_validation_sequence (OSCTXT* pctxt, 
   Content_validation_sequence *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode error_macro */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Error_macro (pctxt, 
               &pvalue->error_macro, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Content_validation_sequence (OSCTXT* pctxt, 
   Content_validation_sequence* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("error-macro"), 11}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* error-macro */
         stat = XmlDec_Error_macro (pctxt, &pvalue->error_macro);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Content_validation_choice                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Content_validation_choice (OSCTXT* pctxt, 
   Content_validation_choice *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.error_message = rtxMemAllocType (pctxt, Error_message);

         if (pvalue->u.error_message == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Error_message (pvalue->u.error_message);
         stat = asn1D_Error_message (pctxt, 
            pvalue->u.error_message, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.sequence
             = rtxMemAllocType (pctxt, Content_validation_sequence);

         if (pvalue->u.sequence == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Content_validation_sequence (pvalue->u.sequence);
         stat = asn1D_Content_validation_sequence (pctxt, 
            pvalue->u.sequence, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Content_validation_choice (OSCTXT* pctxt, 
   Content_validation_choice* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("error-message"), 13}, 0}, 0 },
      {{{OSUTF8("error-macro"), 11}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* error-message */
      pvalue->u.error_message = rtxMemAllocType (pctxt, Error_message);

      if (pvalue->u.error_message == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Error_message (pvalue->u.error_message);

      stat = XmlDec_Error_message (pctxt, pvalue->u.error_message);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /*  */
      pvalue->u.sequence
          = rtxMemAllocType (pctxt, Content_validation_sequence);

      if (pvalue->u.sequence == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Content_validation_sequence (pvalue->u.sequence);

      stat = XmlDec_Content_validation_sequence (pctxt, pvalue->u.sequence);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Content_validation                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Content_validation (OSCTXT* pctxt, 
   Content_validation *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode allow_empty_cell */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Content_validation_allow_empty_cell (pctxt, 
               &pvalue->allow_empty_cell, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.allow_empty_cellPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode base_cell_address */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->base_cell_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.base_cell_addressPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode condition */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->condition, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.conditionPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode display_list */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Content_validation_display_list (pctxt, 
               &pvalue->display_list, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.display_listPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode help_message */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Help_message (pctxt, 
               &pvalue->help_message, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.help_messagePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Content_validation_choice (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choicePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Content_validation (OSCTXT* pctxt, Content_validation* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("allow-empty-cell"), 16}, 0 },
         { {OSUTF8("base-cell-address"), 17}, 0 },
         { {OSUTF8("condition"), 9}, 0 },
         { {OSUTF8("display-list"), 12}, 0 },
         { {OSUTF8("name"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* allow-empty-cell */
            stat = XmlDec_Content_validation_allow_empty_cell (pctxt, &pvalue->
               allow_empty_cell);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.allow_empty_cellPresent = TRUE;
            break;

         case 1: /* base-cell-address */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->base_cell_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.base_cell_addressPresent = TRUE;
            break;

         case 2: /* condition */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->condition);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.conditionPresent = TRUE;
            break;

         case 3: /* display-list */
            stat = XmlDec_Content_validation_display_list (pctxt, &pvalue->
               display_list);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.display_listPresent = TRUE;
            break;

         case 4: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Content_validation");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Content_validation");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("help-message"), 12}, 0}, 0 },
      {{{OSUTF8("error-message"), 13}, 0}, 1 },
      {{{OSUTF8("error-macro"), 11}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* help-message */
         stat = XmlDec_Help_message (pctxt, &pvalue->help_message);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.help_messagePresent = TRUE;
         break;
      }
      case 1: { /*  */
         stat = XmlDec_Content_validation_choice (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choicePresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Content_validations                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Content_validations (OSCTXT* pctxt, 
   Content_validations *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode content_validation_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Content_validation* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->content_validation_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Content_validation, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Content_validation (pdata2);

                  stat = asn1D_Content_validation (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->content_validation_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Content_validations (OSCTXT* pctxt, Content_validations* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("content-validation"), 18}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Content_validation* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Content_validation);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Content_validation (pdata1);

            stat = XmlDec_Content_validation (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->content_validation_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Label_range_orientation                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Label_range_orientation (OSCTXT* pctxt, 
   Label_range_orientation *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Label_range_orientation (OSCTXT* pctxt, 
   Label_range_orientation* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Label_range_orientation_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Label_range                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Label_range (OSCTXT* pctxt, Label_range *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode data_cell_range_address */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->data_cell_range_address, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode label_cell_range_address */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->label_cell_range_address, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode orientation */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Label_range_orientation (pctxt, 
               &pvalue->orientation, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Label_range (OSCTXT* pctxt, Label_range* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("data-cell-range-address"), 23}, 0 },
         { {OSUTF8("label-cell-range-address"), 24}, 0 },
         { {OSUTF8("orientation"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* data-cell-range-address */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->data_cell_range_address
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* label-cell-range-address */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->
               label_cell_range_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* orientation */
            stat = XmlDec_Label_range_orientation (pctxt, &pvalue->orientation
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Label_range");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Label_range");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Label_ranges                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Label_ranges (OSCTXT* pctxt, Label_ranges *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode label_range_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Label_range* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->label_range_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Label_range, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Label_range (pdata2);

                  stat = asn1D_Label_range (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->label_range_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Label_ranges (OSCTXT* pctxt, Label_ranges* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("label-range"), 11}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Label_range* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Label_range);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Label_range (pdata1);

            stat = XmlDec_Label_range (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->label_range_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Named_range_range_usable_as_alt                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Named_range_range_usable_as_alt (OSCTXT* pctxt, 
   Named_range_range_usable_as_alt *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Named_range_range_usable_as_alt (OSCTXT* pctxt, 
   Named_range_range_usable_as_alt* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Named_range_range_usable_as_alt_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Named_range_range_usable_as_alt_1_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Named_range_range_usable_as_alt_1_element (OSCTXT* pctxt, 
   Named_range_range_usable_as_alt_1_element *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Named_range_range_usable_as_alt_1_element (OSCTXT* pctxt, 
   Named_range_range_usable_as_alt_1_element* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Named_range_range_usable_as_alt_1_element_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Named_range_range_usable_as_alt_1                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Named_range_range_usable_as_alt_1 (OSCTXT* pctxt, 
   Named_range_range_usable_as_alt_1 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   Named_range_range_usable_as_alt_1_element* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      rtxDListAllocNodeAndData (pctxt, Named_range_range_usable_as_alt_1_element, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1D_Named_range_range_usable_as_alt_1_element (pctxt, 
         pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      rtxDListAppendNode (pvalue, pnode);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Named_range_range_usable_as_alt_1 (OSCTXT* pctxt, 
   Named_range_range_usable_as_alt_1* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);
   rtXmlpSetListMode (pctxt);

   while (rtXmlpListHasItem(pctxt)) {
      Named_range_range_usable_as_alt_1_element*
          pdata1 = rtxMemAllocType (pctxt, 
         Named_range_range_usable_as_alt_1_element);
      if (0 == pdata1) LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = XmlDec_Named_range_range_usable_as_alt_1_element (pctxt, pdata1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      if (0 == rtxDListAppend (pctxt, pvalue, pdata1)) {
         return LOG_RTERR (pctxt, RTERR_NOMEM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Named_range_range_usable_as                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Named_range_range_usable_as (OSCTXT* pctxt, 
   Named_range_range_usable_as *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
         stat = asn1D_Named_range_range_usable_as_alt (pctxt, 
            &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.alt_1
             = rtxMemAllocType (pctxt, Named_range_range_usable_as_alt_1);

         if (pvalue->u.alt_1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Named_range_range_usable_as_alt_1 (pvalue->u.alt_1);
         stat = asn1D_Named_range_range_usable_as_alt_1 (pctxt, 
            pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Named_range_range_usable_as (OSCTXT* pctxt, 
   Named_range_range_usable_as* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      stat = Named_range_range_usable_as_alt_ToEnum (pctxt, pdata1, &pvalue->
         u.alt);
      if (stat == 0) pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      /* list alternative in union case */
      Named_range_range_usable_as_alt_1_element tmpval;
      Named_range_range_usable_as_alt_1_element* plistval;
      OSUTF8CHAR* ptmpstr = rtxUTF8Strdup (pctxt, pdata1);
      const OSUTF8CHAR* psavedstr = pdata1;
      OSRTDList tmplist;

      rtxDListFastInit (&tmplist);

      while ((pdata1 = (OSUTF8CHAR*)rtxUTF8StrNextTok 
         (ptmpstr, &ptmpstr)) != 0) {
         stat = Named_range_range_usable_as_alt_1_element_ToEnum (pctxt, pdata1, 
            &tmpval);
         if (0 != stat) break;

         /* add tmp value to tmp list */
         plistval = rtxMemAllocType (pctxt, 
            Named_range_range_usable_as_alt_1_element);
         if (0 == plistval) return LOG_RTERR (pctxt, RTERR_NOMEM);

         *plistval = tmpval;
         if (0 == rtxDListAppend (pctxt, &tmplist, plistval))
            return LOG_RTERR (pctxt, RTERR_NOMEM);
      }

      if (stat == 0) {
         pvalue->u.alt_1 = rtxMemAllocType (pctxt, 
            Named_range_range_usable_as_alt_1);
         pvalue->u.alt_1->count = tmplist.count;
         pvalue->u.alt_1->head = tmplist.head;
         pvalue->u.alt_1->tail = tmplist.tail;
         pvalue->t = 2;
         rtxMemFreePtr (pctxt, (void*)psavedstr);
      }
      else {
         rtxDListFreeAll (pctxt, &tmplist);
         pdata1 = psavedstr;
      }
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Named_range                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Named_range (OSCTXT* pctxt, Named_range *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode base_cell_address */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->base_cell_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.base_cell_addressPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode cell_range_address */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Cell_range_address (pctxt, 
               &pvalue->cell_range_address, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode range_usable_as */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Named_range_range_usable_as (pctxt, 
               &pvalue->range_usable_as, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.range_usable_asPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Named_range (OSCTXT* pctxt, Named_range* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("base-cell-address"), 17}, 0 },
         { {OSUTF8("cell-range-address"), 18}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("range-usable-as"), 15}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* base-cell-address */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->base_cell_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.base_cell_addressPresent = TRUE;
            break;

         case 1: /* cell-range-address */
            stat = XmlDec_Cell_range_address (pctxt, &pvalue->
               cell_range_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* range-usable-as */
            stat = XmlDec_Named_range_range_usable_as (pctxt, &pvalue->
               range_usable_as);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.range_usable_asPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Named_range");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Named_range");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Named_expression                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Named_expression (OSCTXT* pctxt, Named_expression *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode base_cell_address */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->base_cell_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.base_cell_addressPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode expression */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->expression, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Named_expression (OSCTXT* pctxt, Named_expression* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("base-cell-address"), 17}, 0 },
         { {OSUTF8("expression"), 10}, 0 },
         { {OSUTF8("name"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* base-cell-address */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->base_cell_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.base_cell_addressPresent = TRUE;
            break;

         case 1: /* expression */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->expression);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Named_expression");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Named_expression");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Named_expressions_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Named_expressions_element (OSCTXT* pctxt, 
   Named_expressions_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.named_range = rtxMemAllocType (pctxt, Named_range);

         if (pvalue->u.named_range == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Named_range (pvalue->u.named_range);
         stat = asn1D_Named_range (pctxt, 
            pvalue->u.named_range, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.named_expression
             = rtxMemAllocType (pctxt, Named_expression);

         if (pvalue->u.named_expression == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Named_expression (pvalue->u.named_expression);
         stat = asn1D_Named_expression (pctxt, 
            pvalue->u.named_expression, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Named_expressions_element (OSCTXT* pctxt, 
   Named_expressions_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("named-range"), 11}, 0}, 0 },
      {{{OSUTF8("named-expression"), 16}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* named-range */
      pvalue->u.named_range = rtxMemAllocType (pctxt, Named_range);

      if (pvalue->u.named_range == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Named_range (pvalue->u.named_range);

      stat = XmlDec_Named_range (pctxt, pvalue->u.named_range);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* named-expression */
      pvalue->u.named_expression = rtxMemAllocType (pctxt, Named_expression);

      if (pvalue->u.named_expression == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Named_expression (pvalue->u.named_expression);

      stat = XmlDec_Named_expression (pctxt, pvalue->u.named_expression);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Named_expressions                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Named_expressions (OSCTXT* pctxt, Named_expressions *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   Named_expressions_element* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (XD_PEEKTAG (pctxt, 0x30)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_UNIV|TM_CONS|16));

   if (XD_PEEKTAG (pctxt, 0xa0)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_CTXT|TM_CONS|0));

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      rtxDListAllocNodeAndData (pctxt, Named_expressions_element, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Named_expressions_element (pdata1);

      stat = asn1D_Named_expressions_element (pctxt, 
         pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

int XmlDec_Named_expressions (OSCTXT* pctxt, Named_expressions* pvalue)
{
   int stat = 0;

   { int elemID;
   Named_expressions_element* pdata1;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("named-range"), 11}, 0}, 0 },
      {{{OSUTF8("named-expression"), 16}, 0}, 0 }
   } ;

   rtxDListInit (pvalue);
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, FALSE);
      if (elemID < 0 || elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0:
         rtXmlpMarkLastEventActive (pctxt);

         pdata1 = rtxMemAllocType (pctxt, Named_expressions_element);

         if (pdata1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Named_expressions_element (pdata1);

         stat = XmlDec_Named_expressions_element (pctxt, pdata1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         break;

      }
   }

   if (elemID == RTERR_UNEXPELEM || elemID == XML_OK_EOB) {
      stat = 0;
   }
   else return LOG_RTERR (pctxt, elemID);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_range_contains_header                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Database_range_contains_header (OSCTXT* pctxt, 
   Database_range_contains_header *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Database_range_contains_header (OSCTXT* pctxt, 
   Database_range_contains_header* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Database_range_contains_header_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_range_display_filter_buttons                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Database_range_display_filter_buttons (OSCTXT* pctxt, 
   Database_range_display_filter_buttons *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Database_range_display_filter_buttons (OSCTXT* pctxt, 
   Database_range_display_filter_buttons* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Database_range_display_filter_buttons_ToEnum (pctxt, strval, pvalue
      );
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_range_has_persistent_data                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Database_range_has_persistent_data (OSCTXT* pctxt, 
   Database_range_has_persistent_data *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Database_range_has_persistent_data (OSCTXT* pctxt, 
   Database_range_has_persistent_data* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Database_range_has_persistent_data_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_range_is_selection                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Database_range_is_selection (OSCTXT* pctxt, 
   Database_range_is_selection *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Database_range_is_selection (OSCTXT* pctxt, 
   Database_range_is_selection* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Database_range_is_selection_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_range_on_update_keep_size                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Database_range_on_update_keep_size (OSCTXT* pctxt, 
   Database_range_on_update_keep_size *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Database_range_on_update_keep_size (OSCTXT* pctxt, 
   Database_range_on_update_keep_size* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Database_range_on_update_keep_size_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_range_on_update_keep_styles                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Database_range_on_update_keep_styles (OSCTXT* pctxt, 
   Database_range_on_update_keep_styles *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Database_range_on_update_keep_styles (OSCTXT* pctxt, 
   Database_range_on_update_keep_styles* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Database_range_on_update_keep_styles_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_range_orientation                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Database_range_orientation (OSCTXT* pctxt, 
   Database_range_orientation *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Database_range_orientation (OSCTXT* pctxt, 
   Database_range_orientation* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Database_range_orientation_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_range_refresh_delay                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Database_range_refresh_delay (OSCTXT* pctxt, 
   Database_range_refresh_delay *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Database_range_refresh_delay (OSCTXT* pctxt, 
   Database_range_refresh_delay* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Database_range_refresh_delay_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_source_sql_parse_sql_statement                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Database_source_sql_parse_sql_statement (OSCTXT* pctxt, 
   Database_source_sql_parse_sql_statement *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Database_source_sql_parse_sql_statement (OSCTXT* pctxt, 
   Database_source_sql_parse_sql_statement* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Database_source_sql_parse_sql_statement_ToEnum (pctxt, strval, pvalue
      );
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_source_sql                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Database_source_sql (OSCTXT* pctxt, 
   Database_source_sql *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode database_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->database_name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode parse_sql_statement */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Database_source_sql_parse_sql_statement (pctxt, 
               &pvalue->parse_sql_statement, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.parse_sql_statementPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode sql_statement */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->sql_statement, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Database_source_sql (OSCTXT* pctxt, Database_source_sql* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("database-name"), 13}, 0 },
         { {OSUTF8("parse-sql-statement"), 19}, 0 },
         { {OSUTF8("sql-statement"), 13}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* database-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->database_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* parse-sql-statement */
            stat = XmlDec_Database_source_sql_parse_sql_statement (pctxt, &
               pvalue->parse_sql_statement);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.parse_sql_statementPresent = TRUE;
            break;

         case 2: /* sql-statement */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->sql_statement);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Database_source_sql");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Database_source_sql");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_source_query                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Database_source_query (OSCTXT* pctxt, 
   Database_source_query *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode database_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->database_name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode query_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->query_name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Database_source_query (OSCTXT* pctxt, Database_source_query* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("database-name"), 13}, 0 },
         { {OSUTF8("query-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* database-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->database_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* query-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->query_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Database_source_query");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Database_source_query");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_source_table                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Database_source_table (OSCTXT* pctxt, 
   Database_source_table *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode database_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->database_name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode database_table_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->database_table_name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Database_source_table (OSCTXT* pctxt, Database_source_table* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("database-name"), 13}, 0 },
         { {OSUTF8("database-table-name"), 19}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* database-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->database_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* database-table-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->database_table_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Database_source_table");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Database_source_table");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_range_choice                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Database_range_choice (OSCTXT* pctxt, 
   Database_range_choice *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.database_source_sql
             = rtxMemAllocType (pctxt, Database_source_sql);

         if (pvalue->u.database_source_sql == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Database_source_sql (pvalue->u.database_source_sql);
         stat = asn1D_Database_source_sql (pctxt, 
            pvalue->u.database_source_sql, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.database_source_query
             = rtxMemAllocType (pctxt, Database_source_query);

         if (pvalue->u.database_source_query == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Database_source_query (pvalue->u.database_source_query);
         stat = asn1D_Database_source_query (pctxt, 
            pvalue->u.database_source_query, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.database_source_table
             = rtxMemAllocType (pctxt, Database_source_table);

         if (pvalue->u.database_source_table == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Database_source_table (pvalue->u.database_source_table);
         stat = asn1D_Database_source_table (pctxt, 
            pvalue->u.database_source_table, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Database_range_choice (OSCTXT* pctxt, Database_range_choice* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("database-source-sql"), 19}, 0}, 0 },
      {{{OSUTF8("database-source-query"), 21}, 0}, 1 },
      {{{OSUTF8("database-source-table"), 21}, 0}, 2 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* database-source-sql */
      pvalue->u.database_source_sql
          = rtxMemAllocType (pctxt, Database_source_sql);

      if (pvalue->u.database_source_sql == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Database_source_sql (pvalue->u.database_source_sql);

      stat = XmlDec_Database_source_sql (pctxt, pvalue->u.database_source_sql
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* database-source-query */
      pvalue->u.database_source_query
          = rtxMemAllocType (pctxt, Database_source_query);

      if (pvalue->u.database_source_query == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Database_source_query (pvalue->u.database_source_query);

      stat = XmlDec_Database_source_query (pctxt, pvalue->
         u.database_source_query);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* database-source-table */
      pvalue->u.database_source_table
          = rtxMemAllocType (pctxt, Database_source_table);

      if (pvalue->u.database_source_table == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Database_source_table (pvalue->u.database_source_table);

      stat = XmlDec_Database_source_table (pctxt, pvalue->
         u.database_source_table);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Filter_condition_source                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Filter_condition_source (OSCTXT* pctxt, 
   Filter_condition_source *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Filter_condition_source (OSCTXT* pctxt, 
   Filter_condition_source* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Filter_condition_source_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Filter_display_duplicates                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Filter_display_duplicates (OSCTXT* pctxt, 
   Filter_display_duplicates *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Filter_display_duplicates (OSCTXT* pctxt, 
   Filter_display_duplicates* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Filter_display_duplicates_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Filter_condition_data_type                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Filter_condition_data_type (OSCTXT* pctxt, 
   Filter_condition_data_type *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Filter_condition_data_type (OSCTXT* pctxt, 
   Filter_condition_data_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Filter_condition_data_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Filter_condition                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Filter_condition (OSCTXT* pctxt, Filter_condition *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode case_sensitive */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->case_sensitive, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.case_sensitivePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode data_type */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Filter_condition_data_type (pctxt, 
               &pvalue->data_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_typePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode field_number */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->field_number, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode operator_ */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->operator_, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Filter_condition (OSCTXT* pctxt, Filter_condition* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("case-sensitive"), 14}, 0 },
         { {OSUTF8("data-type"), 9}, 0 },
         { {OSUTF8("field-number"), 12}, 0 },
         { {OSUTF8("operator"), 8}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* case-sensitive */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->case_sensitive);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.case_sensitivePresent = TRUE;
            break;

         case 1: /* data-type */
            stat = XmlDec_Filter_condition_data_type (pctxt, &pvalue->data_type
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_typePresent = TRUE;
            break;

         case 2: /* field-number */
            stat = rtXmlpDecUInt (pctxt, &pvalue->field_number);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* operator */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->operator_);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Filter_condition");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Filter_condition");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Filter_or_element                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Filter_or_element (OSCTXT* pctxt, Filter_or_element *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.filter_and = rtxMemAllocType (pctxt, Filter_and);

         if (pvalue->u.filter_and == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Filter_and ((Filter_and*)pvalue->u.filter_and);
         stat = asn1D_Filter_and (pctxt, 
            (Filter_and*)pvalue->u.filter_and, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.filter_condition
             = rtxMemAllocType (pctxt, Filter_condition);

         if (pvalue->u.filter_condition == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Filter_condition (pvalue->u.filter_condition);
         stat = asn1D_Filter_condition (pctxt, 
            pvalue->u.filter_condition, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Filter_or_element (OSCTXT* pctxt, Filter_or_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("filter-and"), 10}, 0}, 0 },
      {{{OSUTF8("filter-condition"), 16}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* filter-and */
      pvalue->u.filter_and = rtxMemAllocType (pctxt, Filter_and);

      if (pvalue->u.filter_and == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Filter_and ((Filter_and*)pvalue->u.filter_and);

      stat = XmlDec_Filter_and (pctxt, pvalue->u.filter_and);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* filter-condition */
      pvalue->u.filter_condition = rtxMemAllocType (pctxt, Filter_condition);

      if (pvalue->u.filter_condition == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Filter_condition (pvalue->u.filter_condition);

      stat = XmlDec_Filter_condition (pctxt, pvalue->u.filter_condition);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Filter_or                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Filter_or (OSCTXT* pctxt, Filter_or *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   Filter_or_element* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (XD_PEEKTAG (pctxt, 0x30)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_UNIV|TM_CONS|16));

   if (XD_PEEKTAG (pctxt, 0xa0)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_CTXT|TM_CONS|0));

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      rtxDListAllocNodeAndData (pctxt, Filter_or_element, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Filter_or_element (pdata1);

      stat = asn1D_Filter_or_element (pctxt, 
         pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

int XmlDec_Filter_or (OSCTXT* pctxt, Filter_or* pvalue)
{
   int stat = 0;

   { int elemID;
   Filter_or_element* pdata1;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("filter-and"), 10}, 0}, 0 },
      {{{OSUTF8("filter-condition"), 16}, 0}, 0 }
   } ;

   rtxDListInit (pvalue);
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, FALSE);
      if (elemID < 0 || elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0:
         rtXmlpMarkLastEventActive (pctxt);

         pdata1 = rtxMemAllocType (pctxt, Filter_or_element);

         if (pdata1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Filter_or_element (pdata1);

         stat = XmlDec_Filter_or_element (pctxt, pdata1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         break;

      }
   }

   if (elemID == RTERR_UNEXPELEM || elemID == XML_OK_EOB) {
      stat = 0;
   }
   else return LOG_RTERR (pctxt, elemID);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Filter_and_element                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Filter_and_element (OSCTXT* pctxt, 
   Filter_and_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.filter_or = rtxMemAllocType (pctxt, Filter_or);

         if (pvalue->u.filter_or == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Filter_or (pvalue->u.filter_or);
         stat = asn1D_Filter_or (pctxt, 
            pvalue->u.filter_or, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.filter_condition
             = rtxMemAllocType (pctxt, Filter_condition);

         if (pvalue->u.filter_condition == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Filter_condition (pvalue->u.filter_condition);
         stat = asn1D_Filter_condition (pctxt, 
            pvalue->u.filter_condition, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Filter_and_element (OSCTXT* pctxt, Filter_and_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("filter-or"), 9}, 0}, 0 },
      {{{OSUTF8("filter-condition"), 16}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* filter-or */
      pvalue->u.filter_or = rtxMemAllocType (pctxt, Filter_or);

      if (pvalue->u.filter_or == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Filter_or (pvalue->u.filter_or);

      stat = XmlDec_Filter_or (pctxt, pvalue->u.filter_or);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* filter-condition */
      pvalue->u.filter_condition = rtxMemAllocType (pctxt, Filter_condition);

      if (pvalue->u.filter_condition == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Filter_condition (pvalue->u.filter_condition);

      stat = XmlDec_Filter_condition (pctxt, pvalue->u.filter_condition);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Filter_and                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Filter_and (OSCTXT* pctxt, Filter_and *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   Filter_and_element* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (XD_PEEKTAG (pctxt, 0xa0)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_CTXT|TM_CONS|0));

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      rtxDListAllocNodeAndData (pctxt, Filter_and_element, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Filter_and_element (pdata1);

      stat = asn1D_Filter_and_element (pctxt, 
         pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      rtxDListAppendNode (pvalue, pnode);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Filter_and (OSCTXT* pctxt, Filter_and* pvalue)
{
   int stat = 0;

   { int elemID;
   Filter_and_element* pdata1;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("filter-or"), 9}, 0}, 0 },
      {{{OSUTF8("filter-condition"), 16}, 0}, 0 }
   } ;

   rtxDListInit (pvalue);
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, FALSE);
      if (elemID < 0 || elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0:
         rtXmlpMarkLastEventActive (pctxt);

         pdata1 = rtxMemAllocType (pctxt, Filter_and_element);

         if (pdata1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Filter_and_element (pdata1);

         stat = XmlDec_Filter_and_element (pctxt, pdata1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         break;

      }
   }

   if (elemID == RTERR_UNEXPELEM || elemID == XML_OK_EOB) {
      stat = 0;
   }
   else return LOG_RTERR (pctxt, elemID);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Filter_choice                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Filter_choice (OSCTXT* pctxt, Filter_choice *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.filter_condition
             = rtxMemAllocType (pctxt, Filter_condition);

         if (pvalue->u.filter_condition == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Filter_condition (pvalue->u.filter_condition);
         stat = asn1D_Filter_condition (pctxt, 
            pvalue->u.filter_condition, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.filter_and = rtxMemAllocType (pctxt, Filter_and);

         if (pvalue->u.filter_and == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Filter_and (pvalue->u.filter_and);
         stat = asn1D_Filter_and (pctxt, 
            pvalue->u.filter_and, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.filter_or = rtxMemAllocType (pctxt, Filter_or);

         if (pvalue->u.filter_or == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Filter_or (pvalue->u.filter_or);
         stat = asn1D_Filter_or (pctxt, 
            pvalue->u.filter_or, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Filter_choice (OSCTXT* pctxt, Filter_choice* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("filter-condition"), 16}, 0}, 0 },
      {{{OSUTF8("filter-and"), 10}, 0}, 1 },
      {{{OSUTF8("filter-or"), 9}, 0}, 2 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* filter-condition */
      pvalue->u.filter_condition = rtxMemAllocType (pctxt, Filter_condition);

      if (pvalue->u.filter_condition == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Filter_condition (pvalue->u.filter_condition);

      stat = XmlDec_Filter_condition (pctxt, pvalue->u.filter_condition);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* filter-and */
      pvalue->u.filter_and = rtxMemAllocType (pctxt, Filter_and);

      if (pvalue->u.filter_and == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Filter_and (pvalue->u.filter_and);

      stat = XmlDec_Filter_and (pctxt, pvalue->u.filter_and);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* filter-or */
      pvalue->u.filter_or = rtxMemAllocType (pctxt, Filter_or);

      if (pvalue->u.filter_or == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Filter_or (pvalue->u.filter_or);

      stat = XmlDec_Filter_or (pctxt, pvalue->u.filter_or);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Filter                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Filter (OSCTXT* pctxt, Filter *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode condition_source */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Filter_condition_source (pctxt, 
               &pvalue->condition_source, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.condition_sourcePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode condition_source_range_address */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->condition_source_range_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.condition_source_range_addressPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode display_duplicates */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Filter_display_duplicates (pctxt, 
               &pvalue->display_duplicates, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.display_duplicatesPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode target_range_address */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->target_range_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.target_range_addressPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Filter_choice (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Filter (OSCTXT* pctxt, Filter* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("condition-source"), 16}, 0 },
         { {OSUTF8("condition-source-range-address"), 30}, 0 },
         { {OSUTF8("display-duplicates"), 18}, 0 },
         { {OSUTF8("target-range-address"), 20}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* condition-source */
            stat = XmlDec_Filter_condition_source (pctxt, &pvalue->
               condition_source);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.condition_sourcePresent = TRUE;
            break;

         case 1: /* condition-source-range-address */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->
               condition_source_range_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.condition_source_range_addressPresent = TRUE;
            break;

         case 2: /* display-duplicates */
            stat = XmlDec_Filter_display_duplicates (pctxt, &pvalue->
               display_duplicates);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.display_duplicatesPresent = TRUE;
            break;

         case 3: /* target-range-address */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->target_range_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.target_range_addressPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Filter");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Filter");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("filter-condition"), 16}, 0}, 0 },
      {{{OSUTF8("filter-and"), 10}, 0}, 0 },
      {{{OSUTF8("filter-or"), 9}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}, {3, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_Filter_choice (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sort_bind_styles_to_content                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Sort_bind_styles_to_content (OSCTXT* pctxt, 
   Sort_bind_styles_to_content *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Sort_bind_styles_to_content (OSCTXT* pctxt, 
   Sort_bind_styles_to_content* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Sort_bind_styles_to_content_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sort_case_sensitive                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Sort_case_sensitive (OSCTXT* pctxt, 
   Sort_case_sensitive *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Sort_case_sensitive (OSCTXT* pctxt, Sort_case_sensitive* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Sort_case_sensitive_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sort_by_data_type_alt_1                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Sort_by_data_type_alt_1 (OSCTXT* pctxt, 
   Sort_by_data_type_alt_1 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Sort_by_data_type_alt_1 (OSCTXT* pctxt, 
   Sort_by_data_type_alt_1* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Sort_by_data_type_alt_1_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sort_by_data_type_alt_2                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Sort_by_data_type_alt_2 (OSCTXT* pctxt, 
   Sort_by_data_type_alt_2 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Sort_by_data_type_alt_2 (OSCTXT* pctxt, 
   Sort_by_data_type_alt_2* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Sort_by_data_type_alt_2_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sort_by_data_type_alt_3                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Sort_by_data_type_alt_3 (OSCTXT* pctxt, 
   Sort_by_data_type_alt_3 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Sort_by_data_type_alt_3 (OSCTXT* pctxt, 
   Sort_by_data_type_alt_3* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Sort_by_data_type_alt_3_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sort_by_data_type                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Sort_by_data_type (OSCTXT* pctxt, Sort_by_data_type *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
         stat = asn1D_Sort_by_data_type_alt_1 (pctxt, 
            &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_PRIM|2):
         stat = asn1D_Sort_by_data_type_alt_2 (pctxt, 
            &pvalue->u.alt_2, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_PRIM|3):
         stat = asn1D_Sort_by_data_type_alt_3 (pctxt, 
            &pvalue->u.alt_3, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Sort_by_data_type (OSCTXT* pctxt, Sort_by_data_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      stat = Sort_by_data_type_alt_1_ToEnum (pctxt, pdata1, &pvalue->u.alt_1);
      if (stat == 0) pvalue->t = 2;
   }
   if (pvalue->t == 0) {
      stat = Sort_by_data_type_alt_2_ToEnum (pctxt, pdata1, &pvalue->u.alt_2);
      if (stat == 0) pvalue->t = 3;
   }
   if (pvalue->t == 0) {
      stat = Sort_by_data_type_alt_3_ToEnum (pctxt, pdata1, &pvalue->u.alt_3);
      if (stat == 0) pvalue->t = 4;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sort_by_order                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Sort_by_order (OSCTXT* pctxt, Sort_by_order *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Sort_by_order (OSCTXT* pctxt, Sort_by_order* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Sort_by_order_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sort_by                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Sort_by (OSCTXT* pctxt, Sort_by *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode data_type */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Sort_by_data_type (pctxt, 
               &pvalue->data_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_typePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode field_number */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->field_number, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode order */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Sort_by_order (pctxt, 
               &pvalue->order, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.orderPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Sort_by (OSCTXT* pctxt, Sort_by* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("data-type"), 9}, 0 },
         { {OSUTF8("field-number"), 12}, 0 },
         { {OSUTF8("order"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* data-type */
            stat = XmlDec_Sort_by_data_type (pctxt, &pvalue->data_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_typePresent = TRUE;
            break;

         case 1: /* field-number */
            stat = rtXmlpDecUInt (pctxt, &pvalue->field_number);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* order */
            stat = XmlDec_Sort_by_order (pctxt, &pvalue->order);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.orderPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Sort_by");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Sort_by");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sort                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Sort (OSCTXT* pctxt, Sort *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode algorithm */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->algorithm, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.algorithmPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode bind_styles_to_content */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Sort_bind_styles_to_content (pctxt, 
               &pvalue->bind_styles_to_content, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bind_styles_to_contentPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode case_sensitive */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Sort_case_sensitive (pctxt, 
               &pvalue->case_sensitive, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.case_sensitivePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode country */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->country, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.countryPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode target_range_address */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->target_range_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.target_range_addressPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode sort_by_list */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Sort_by* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->sort_by_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Sort_by, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Sort_by (pdata2);

                  stat = asn1D_Sort_by (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->sort_by_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Sort (OSCTXT* pctxt, Sort* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("algorithm"), 9}, 0 },
         { {OSUTF8("bind-styles-to-content"), 22}, 0 },
         { {OSUTF8("case-sensitive"), 14}, 0 },
         { {OSUTF8("country"), 7}, 0 },
         { {OSUTF8("language"), 8}, 0 },
         { {OSUTF8("target-range-address"), 20}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 6, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* algorithm */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->algorithm);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.algorithmPresent = TRUE;
            break;

         case 1: /* bind-styles-to-content */
            stat = XmlDec_Sort_bind_styles_to_content (pctxt, &pvalue->
               bind_styles_to_content);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bind_styles_to_contentPresent = TRUE;
            break;

         case 2: /* case-sensitive */
            stat = XmlDec_Sort_case_sensitive (pctxt, &pvalue->case_sensitive
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.case_sensitivePresent = TRUE;
            break;

         case 3: /* country */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->country);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.countryPresent = TRUE;
            break;

         case 4: /* language */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         case 5: /* target-range-address */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->target_range_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.target_range_addressPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Sort");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Sort");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("sort-by"), 7}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Sort_by* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Sort_by);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Sort_by (pdata1);

            stat = XmlDec_Sort_by (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->sort_by_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Subtotal_rules_bind_styles_to_content                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Subtotal_rules_bind_styles_to_content (OSCTXT* pctxt, 
   Subtotal_rules_bind_styles_to_content *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Subtotal_rules_bind_styles_to_content (OSCTXT* pctxt, 
   Subtotal_rules_bind_styles_to_content* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Subtotal_rules_bind_styles_to_content_ToEnum (pctxt, strval, pvalue
      );
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Subtotal_rules_case_sensitive                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Subtotal_rules_case_sensitive (OSCTXT* pctxt, 
   Subtotal_rules_case_sensitive *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Subtotal_rules_case_sensitive (OSCTXT* pctxt, 
   Subtotal_rules_case_sensitive* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Subtotal_rules_case_sensitive_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Subtotal_rules_page_breaks_on_group_change                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Subtotal_rules_page_breaks_on_group_change (OSCTXT* pctxt, 
   Subtotal_rules_page_breaks_on_group_change *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Subtotal_rules_page_breaks_on_group_change (OSCTXT* pctxt, 
   Subtotal_rules_page_breaks_on_group_change* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Subtotal_rules_page_breaks_on_group_change_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sort_groups_data_type_alt_1                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Sort_groups_data_type_alt_1 (OSCTXT* pctxt, 
   Sort_groups_data_type_alt_1 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Sort_groups_data_type_alt_1 (OSCTXT* pctxt, 
   Sort_groups_data_type_alt_1* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Sort_groups_data_type_alt_1_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sort_groups_data_type_alt_2                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Sort_groups_data_type_alt_2 (OSCTXT* pctxt, 
   Sort_groups_data_type_alt_2 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Sort_groups_data_type_alt_2 (OSCTXT* pctxt, 
   Sort_groups_data_type_alt_2* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Sort_groups_data_type_alt_2_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sort_groups_data_type_alt_3                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Sort_groups_data_type_alt_3 (OSCTXT* pctxt, 
   Sort_groups_data_type_alt_3 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Sort_groups_data_type_alt_3 (OSCTXT* pctxt, 
   Sort_groups_data_type_alt_3* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Sort_groups_data_type_alt_3_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sort_groups_data_type                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Sort_groups_data_type (OSCTXT* pctxt, 
   Sort_groups_data_type *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
         stat = asn1D_Sort_groups_data_type_alt_1 (pctxt, 
            &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_PRIM|2):
         stat = asn1D_Sort_groups_data_type_alt_2 (pctxt, 
            &pvalue->u.alt_2, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_PRIM|3):
         stat = asn1D_Sort_groups_data_type_alt_3 (pctxt, 
            &pvalue->u.alt_3, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Sort_groups_data_type (OSCTXT* pctxt, Sort_groups_data_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      stat = Sort_groups_data_type_alt_1_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_1);
      if (stat == 0) pvalue->t = 2;
   }
   if (pvalue->t == 0) {
      stat = Sort_groups_data_type_alt_2_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_2);
      if (stat == 0) pvalue->t = 3;
   }
   if (pvalue->t == 0) {
      stat = Sort_groups_data_type_alt_3_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_3);
      if (stat == 0) pvalue->t = 4;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sort_groups_order                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Sort_groups_order (OSCTXT* pctxt, Sort_groups_order *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Sort_groups_order (OSCTXT* pctxt, Sort_groups_order* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Sort_groups_order_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sort_groups                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Sort_groups (OSCTXT* pctxt, Sort_groups *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode data_type */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Sort_groups_data_type (pctxt, 
               &pvalue->data_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_typePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode order */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Sort_groups_order (pctxt, 
               &pvalue->order, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.orderPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Sort_groups (OSCTXT* pctxt, Sort_groups* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("data-type"), 9}, 0 },
         { {OSUTF8("order"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* data-type */
            stat = XmlDec_Sort_groups_data_type (pctxt, &pvalue->data_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_typePresent = TRUE;
            break;

         case 1: /* order */
            stat = XmlDec_Sort_groups_order (pctxt, &pvalue->order);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.orderPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Sort_groups");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Sort_groups");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Subtotal_field_function_alt_1                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Subtotal_field_function_alt_1 (OSCTXT* pctxt, 
   Subtotal_field_function_alt_1 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Subtotal_field_function_alt_1 (OSCTXT* pctxt, 
   Subtotal_field_function_alt_1* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Subtotal_field_function_alt_1_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Subtotal_field_function_alt_2                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Subtotal_field_function_alt_2 (OSCTXT* pctxt, 
   Subtotal_field_function_alt_2 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Subtotal_field_function_alt_2 (OSCTXT* pctxt, 
   Subtotal_field_function_alt_2* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Subtotal_field_function_alt_2_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Subtotal_field_function_alt_3                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Subtotal_field_function_alt_3 (OSCTXT* pctxt, 
   Subtotal_field_function_alt_3 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Subtotal_field_function_alt_3 (OSCTXT* pctxt, 
   Subtotal_field_function_alt_3* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Subtotal_field_function_alt_3_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Subtotal_field_function_alt_4                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Subtotal_field_function_alt_4 (OSCTXT* pctxt, 
   Subtotal_field_function_alt_4 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Subtotal_field_function_alt_4 (OSCTXT* pctxt, 
   Subtotal_field_function_alt_4* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Subtotal_field_function_alt_4_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Subtotal_field_function_alt_5                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Subtotal_field_function_alt_5 (OSCTXT* pctxt, 
   Subtotal_field_function_alt_5 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Subtotal_field_function_alt_5 (OSCTXT* pctxt, 
   Subtotal_field_function_alt_5* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Subtotal_field_function_alt_5_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Subtotal_field_function_alt_6                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Subtotal_field_function_alt_6 (OSCTXT* pctxt, 
   Subtotal_field_function_alt_6 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Subtotal_field_function_alt_6 (OSCTXT* pctxt, 
   Subtotal_field_function_alt_6* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Subtotal_field_function_alt_6_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Subtotal_field_function_alt_7                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Subtotal_field_function_alt_7 (OSCTXT* pctxt, 
   Subtotal_field_function_alt_7 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Subtotal_field_function_alt_7 (OSCTXT* pctxt, 
   Subtotal_field_function_alt_7* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Subtotal_field_function_alt_7_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Subtotal_field_function_alt_8                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Subtotal_field_function_alt_8 (OSCTXT* pctxt, 
   Subtotal_field_function_alt_8 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Subtotal_field_function_alt_8 (OSCTXT* pctxt, 
   Subtotal_field_function_alt_8* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Subtotal_field_function_alt_8_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Subtotal_field_function_alt_9                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Subtotal_field_function_alt_9 (OSCTXT* pctxt, 
   Subtotal_field_function_alt_9 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Subtotal_field_function_alt_9 (OSCTXT* pctxt, 
   Subtotal_field_function_alt_9* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Subtotal_field_function_alt_9_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Subtotal_field_function_alt_10                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Subtotal_field_function_alt_10 (OSCTXT* pctxt, 
   Subtotal_field_function_alt_10 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Subtotal_field_function_alt_10 (OSCTXT* pctxt, 
   Subtotal_field_function_alt_10* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Subtotal_field_function_alt_10_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Subtotal_field_function_alt_11                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Subtotal_field_function_alt_11 (OSCTXT* pctxt, 
   Subtotal_field_function_alt_11 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Subtotal_field_function_alt_11 (OSCTXT* pctxt, 
   Subtotal_field_function_alt_11* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Subtotal_field_function_alt_11_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Subtotal_field_function_alt_12                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Subtotal_field_function_alt_12 (OSCTXT* pctxt, 
   Subtotal_field_function_alt_12 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Subtotal_field_function_alt_12 (OSCTXT* pctxt, 
   Subtotal_field_function_alt_12* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Subtotal_field_function_alt_12_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Subtotal_field_function                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Subtotal_field_function (OSCTXT* pctxt, 
   Subtotal_field_function *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
         stat = asn1D_Subtotal_field_function_alt_1 (pctxt, 
            &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_PRIM|2):
         stat = asn1D_Subtotal_field_function_alt_2 (pctxt, 
            &pvalue->u.alt_2, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_PRIM|3):
         stat = asn1D_Subtotal_field_function_alt_3 (pctxt, 
            &pvalue->u.alt_3, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_PRIM|4):
         stat = asn1D_Subtotal_field_function_alt_4 (pctxt, 
            &pvalue->u.alt_4, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_PRIM|5):
         stat = asn1D_Subtotal_field_function_alt_5 (pctxt, 
            &pvalue->u.alt_5, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_PRIM|6):
         stat = asn1D_Subtotal_field_function_alt_6 (pctxt, 
            &pvalue->u.alt_6, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_PRIM|7):
         stat = asn1D_Subtotal_field_function_alt_7 (pctxt, 
            &pvalue->u.alt_7, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_PRIM|8):
         stat = asn1D_Subtotal_field_function_alt_8 (pctxt, 
            &pvalue->u.alt_8, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_PRIM|9):
         stat = asn1D_Subtotal_field_function_alt_9 (pctxt, 
            &pvalue->u.alt_9, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_PRIM|10):
         stat = asn1D_Subtotal_field_function_alt_10 (pctxt, 
            &pvalue->u.alt_10, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_PRIM|11):
         stat = asn1D_Subtotal_field_function_alt_11 (pctxt, 
            &pvalue->u.alt_11, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_PRIM|12):
         stat = asn1D_Subtotal_field_function_alt_12 (pctxt, 
            &pvalue->u.alt_12, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Subtotal_field_function (OSCTXT* pctxt, 
   Subtotal_field_function* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      stat = Subtotal_field_function_alt_1_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_1);
      if (stat == 0) pvalue->t = 2;
   }
   if (pvalue->t == 0) {
      stat = Subtotal_field_function_alt_2_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_2);
      if (stat == 0) pvalue->t = 3;
   }
   if (pvalue->t == 0) {
      stat = Subtotal_field_function_alt_3_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_3);
      if (stat == 0) pvalue->t = 4;
   }
   if (pvalue->t == 0) {
      stat = Subtotal_field_function_alt_4_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_4);
      if (stat == 0) pvalue->t = 5;
   }
   if (pvalue->t == 0) {
      stat = Subtotal_field_function_alt_5_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_5);
      if (stat == 0) pvalue->t = 6;
   }
   if (pvalue->t == 0) {
      stat = Subtotal_field_function_alt_6_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_6);
      if (stat == 0) pvalue->t = 7;
   }
   if (pvalue->t == 0) {
      stat = Subtotal_field_function_alt_7_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_7);
      if (stat == 0) pvalue->t = 8;
   }
   if (pvalue->t == 0) {
      stat = Subtotal_field_function_alt_8_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_8);
      if (stat == 0) pvalue->t = 9;
   }
   if (pvalue->t == 0) {
      stat = Subtotal_field_function_alt_9_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_9);
      if (stat == 0) pvalue->t = 10;
   }
   if (pvalue->t == 0) {
      stat = Subtotal_field_function_alt_10_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_10);
      if (stat == 0) pvalue->t = 11;
   }
   if (pvalue->t == 0) {
      stat = Subtotal_field_function_alt_11_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_11);
      if (stat == 0) pvalue->t = 12;
   }
   if (pvalue->t == 0) {
      stat = Subtotal_field_function_alt_12_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_12);
      if (stat == 0) pvalue->t = 13;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Subtotal_field                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Subtotal_field (OSCTXT* pctxt, Subtotal_field *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode field_number */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->field_number, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode function */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Subtotal_field_function (pctxt, 
               &pvalue->function, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Subtotal_field (OSCTXT* pctxt, Subtotal_field* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("field-number"), 12}, 0 },
         { {OSUTF8("function"), 8}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* field-number */
            stat = rtXmlpDecUInt (pctxt, &pvalue->field_number);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* function */
            stat = XmlDec_Subtotal_field_function (pctxt, &pvalue->function);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Subtotal_field");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Subtotal_field");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Subtotal_rule                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Subtotal_rule (OSCTXT* pctxt, Subtotal_rule *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode group_by_field_number */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->group_by_field_number, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode subtotal_field_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Subtotal_field* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->subtotal_field_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Subtotal_field, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Subtotal_field (pdata2);

                  stat = asn1D_Subtotal_field (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->subtotal_field_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Subtotal_rule (OSCTXT* pctxt, Subtotal_rule* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("group-by-field-number"), 21}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* group-by-field-number */
            stat = rtXmlpDecUInt (pctxt, &pvalue->group_by_field_number);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Subtotal_rule");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Subtotal_rule");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("subtotal-field"), 14}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Subtotal_field* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Subtotal_field);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Subtotal_field (pdata1);

            stat = XmlDec_Subtotal_field (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->subtotal_field_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Subtotal_rules                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Subtotal_rules (OSCTXT* pctxt, Subtotal_rules *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bind_styles_to_content */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Subtotal_rules_bind_styles_to_content (pctxt, 
               &pvalue->bind_styles_to_content, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bind_styles_to_contentPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode case_sensitive */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Subtotal_rules_case_sensitive (pctxt, 
               &pvalue->case_sensitive, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.case_sensitivePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode page_breaks_on_group_change */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Subtotal_rules_page_breaks_on_group_change (pctxt, 
               &pvalue->page_breaks_on_group_change, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.page_breaks_on_group_changePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode sort_groups */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Sort_groups (pctxt, 
               &pvalue->sort_groups, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sort_groupsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode subtotal_rule_list */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Subtotal_rule* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->subtotal_rule_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Subtotal_rule, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Subtotal_rule (pdata2);

                  stat = asn1D_Subtotal_rule (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->subtotal_rule_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Subtotal_rules (OSCTXT* pctxt, Subtotal_rules* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bind-styles-to-content"), 22}, 0 },
         { {OSUTF8("case-sensitive"), 14}, 0 },
         { {OSUTF8("page-breaks-on-group-change"), 27}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bind-styles-to-content */
            stat = XmlDec_Subtotal_rules_bind_styles_to_content (pctxt, &pvalue
               ->bind_styles_to_content);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bind_styles_to_contentPresent = TRUE;
            break;

         case 1: /* case-sensitive */
            stat = XmlDec_Subtotal_rules_case_sensitive (pctxt, &pvalue->
               case_sensitive);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.case_sensitivePresent = TRUE;
            break;

         case 2: /* page-breaks-on-group-change */
            stat = XmlDec_Subtotal_rules_page_breaks_on_group_change (pctxt, &
               pvalue->page_breaks_on_group_change);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.page_breaks_on_group_changePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Subtotal_rules");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Subtotal_rules");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("sort-groups"), 11}, 0}, 0 },
      {{{OSUTF8("subtotal-rule"), 13}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* sort-groups */
         stat = XmlDec_Sort_groups (pctxt, &pvalue->sort_groups);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.sort_groupsPresent = TRUE;
         break;
      }
      case 1: {
         Subtotal_rule* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Subtotal_rule);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Subtotal_rule (pdata1);

            stat = XmlDec_Subtotal_rule (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->subtotal_rule_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_range                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Database_range (OSCTXT* pctxt, Database_range *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode contains_header */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Database_range_contains_header (pctxt, 
               &pvalue->contains_header, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.contains_headerPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode display_filter_buttons */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Database_range_display_filter_buttons (pctxt, 
               &pvalue->display_filter_buttons, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.display_filter_buttonsPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode has_persistent_data */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Database_range_has_persistent_data (pctxt, 
               &pvalue->has_persistent_data, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.has_persistent_dataPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode is_selection */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Database_range_is_selection (pctxt, 
               &pvalue->is_selection, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.is_selectionPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode on_update_keep_size */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Database_range_on_update_keep_size (pctxt, 
               &pvalue->on_update_keep_size, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.on_update_keep_sizePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode on_update_keep_styles */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Database_range_on_update_keep_styles (pctxt, 
               &pvalue->on_update_keep_styles, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.on_update_keep_stylesPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode orientation */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Database_range_orientation (pctxt, 
               &pvalue->orientation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.orientationPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode refresh_delay */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Database_range_refresh_delay (pctxt, 
               &pvalue->refresh_delay, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.refresh_delayPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode target_range_address */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->target_range_address, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 10:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Database_range_choice (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choicePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 11:
         /* decode filter */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Filter (pctxt, 
               &pvalue->filter, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.filterPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 12:
         /* decode sort */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Sort (pctxt, 
               &pvalue->sort, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sortPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 13:
         /* decode subtotal_rules */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Subtotal_rules (pctxt, 
               &pvalue->subtotal_rules, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.subtotal_rulesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_CONS|13):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Database_range (OSCTXT* pctxt, Database_range* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("contains-header"), 15}, 0 },
         { {OSUTF8("display-filter-buttons"), 22}, 0 },
         { {OSUTF8("has-persistent-data"), 19}, 0 },
         { {OSUTF8("is-selection"), 12}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("on-update-keep-size"), 19}, 0 },
         { {OSUTF8("on-update-keep-styles"), 21}, 0 },
         { {OSUTF8("orientation"), 11}, 0 },
         { {OSUTF8("refresh-delay"), 13}, 0 },
         { {OSUTF8("target-range-address"), 20}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 10, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* contains-header */
            stat = XmlDec_Database_range_contains_header (pctxt, &pvalue->
               contains_header);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.contains_headerPresent = TRUE;
            break;

         case 1: /* display-filter-buttons */
            stat = XmlDec_Database_range_display_filter_buttons (pctxt, &pvalue
               ->display_filter_buttons);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.display_filter_buttonsPresent = TRUE;
            break;

         case 2: /* has-persistent-data */
            stat = XmlDec_Database_range_has_persistent_data (pctxt, &pvalue->
               has_persistent_data);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.has_persistent_dataPresent = TRUE;
            break;

         case 3: /* is-selection */
            stat = XmlDec_Database_range_is_selection (pctxt, &pvalue->
               is_selection);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.is_selectionPresent = TRUE;
            break;

         case 4: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 5: /* on-update-keep-size */
            stat = XmlDec_Database_range_on_update_keep_size (pctxt, &pvalue->
               on_update_keep_size);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.on_update_keep_sizePresent = TRUE;
            break;

         case 6: /* on-update-keep-styles */
            stat = XmlDec_Database_range_on_update_keep_styles (pctxt, &pvalue
               ->on_update_keep_styles);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.on_update_keep_stylesPresent = TRUE;
            break;

         case 7: /* orientation */
            stat = XmlDec_Database_range_orientation (pctxt, &pvalue->
               orientation);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.orientationPresent = TRUE;
            break;

         case 8: /* refresh-delay */
            stat = XmlDec_Database_range_refresh_delay (pctxt, &pvalue->
               refresh_delay);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.refresh_delayPresent = TRUE;
            break;

         case 9: /* target-range-address */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->target_range_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Database_range");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Database_range");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("database-source-sql"), 19}, 0}, 0 },
      {{{OSUTF8("database-source-query"), 21}, 0}, 0 },
      {{{OSUTF8("database-source-table"), 21}, 0}, 0 },
      {{{OSUTF8("filter"), 6}, 0}, 1 },
      {{{OSUTF8("sort"), 4}, 0}, 2 },
      {{{OSUTF8("subtotal-rules"), 14}, 0}, 3 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 6, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 4; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /*  */
         stat = XmlDec_Database_range_choice (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choicePresent = TRUE;
         break;
      }
      case 1: { /* filter */
         stat = XmlDec_Filter (pctxt, &pvalue->filter);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.filterPresent = TRUE;
         break;
      }
      case 2: { /* sort */
         stat = XmlDec_Sort (pctxt, &pvalue->sort);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.sortPresent = TRUE;
         break;
      }
      case 3: { /* subtotal-rules */
         stat = XmlDec_Subtotal_rules (pctxt, &pvalue->subtotal_rules);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.subtotal_rulesPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_ranges                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Database_ranges (OSCTXT* pctxt, Database_ranges *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode database_range_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Database_range* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->database_range_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Database_range, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Database_range (pdata2);

                  stat = asn1D_Database_range (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->database_range_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Database_ranges (OSCTXT* pctxt, Database_ranges* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("database-range"), 14}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Database_range* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Database_range);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Database_range (pdata1);

            stat = XmlDec_Database_range (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->database_range_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_table_drill_down_on_double_click               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_table_drill_down_on_double_click (OSCTXT* pctxt, 
   Data_pilot_table_drill_down_on_double_click *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_table_drill_down_on_double_click (OSCTXT* pctxt, 
   Data_pilot_table_drill_down_on_double_click* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_table_drill_down_on_double_click_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_table_grand_total                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_table_grand_total (OSCTXT* pctxt, 
   Data_pilot_table_grand_total *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_table_grand_total (OSCTXT* pctxt, 
   Data_pilot_table_grand_total* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_table_grand_total_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_table_identify_categories                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_table_identify_categories (OSCTXT* pctxt, 
   Data_pilot_table_identify_categories *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_table_identify_categories (OSCTXT* pctxt, 
   Data_pilot_table_identify_categories* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_table_identify_categories_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_table_ignore_empty_rows                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_table_ignore_empty_rows (OSCTXT* pctxt, 
   Data_pilot_table_ignore_empty_rows *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_table_ignore_empty_rows (OSCTXT* pctxt, 
   Data_pilot_table_ignore_empty_rows* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_table_ignore_empty_rows_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_table_show_filter_button                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_table_show_filter_button (OSCTXT* pctxt, 
   Data_pilot_table_show_filter_button *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_table_show_filter_button (OSCTXT* pctxt, 
   Data_pilot_table_show_filter_button* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_table_show_filter_button_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Source_service                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Source_service (OSCTXT* pctxt, Source_service *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode object_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->object_name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode password */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->password, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.passwordPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode source_name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->source_name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode user_name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->user_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.user_namePresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Source_service (OSCTXT* pctxt, Source_service* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("object-name"), 11}, 0 },
         { {OSUTF8("password"), 8}, 0 },
         { {OSUTF8("source-name"), 11}, 0 },
         { {OSUTF8("user-name"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* object-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->object_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* password */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->password);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.passwordPresent = TRUE;
            break;

         case 3: /* source-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->source_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* user-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->user_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.user_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Source_service");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Source_service");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Source_cell_range                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Source_cell_range (OSCTXT* pctxt, Source_cell_range *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode cell_range_address */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Cell_range_address (pctxt, 
               &pvalue->cell_range_address, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode filter */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Filter (pctxt, 
               &pvalue->filter, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.filterPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Source_cell_range (OSCTXT* pctxt, Source_cell_range* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("cell-range-address"), 18}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* cell-range-address */
            stat = XmlDec_Cell_range_address (pctxt, &pvalue->
               cell_range_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Source_cell_range");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Source_cell_range");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("filter"), 6}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* filter */
         stat = XmlDec_Filter (pctxt, &pvalue->filter);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.filterPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_table_choice                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_table_choice (OSCTXT* pctxt, 
   Data_pilot_table_choice *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.database_source_sql
             = rtxMemAllocType (pctxt, Database_source_sql);

         if (pvalue->u.database_source_sql == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Database_source_sql (pvalue->u.database_source_sql);
         stat = asn1D_Database_source_sql (pctxt, 
            pvalue->u.database_source_sql, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.database_source_query
             = rtxMemAllocType (pctxt, Database_source_query);

         if (pvalue->u.database_source_query == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Database_source_query (pvalue->u.database_source_query);
         stat = asn1D_Database_source_query (pctxt, 
            pvalue->u.database_source_query, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.database_source_table
             = rtxMemAllocType (pctxt, Database_source_table);

         if (pvalue->u.database_source_table == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Database_source_table (pvalue->u.database_source_table);
         stat = asn1D_Database_source_table (pctxt, 
            pvalue->u.database_source_table, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.source_service = rtxMemAllocType (pctxt, Source_service);

         if (pvalue->u.source_service == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Source_service (pvalue->u.source_service);
         stat = asn1D_Source_service (pctxt, 
            pvalue->u.source_service, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.source_cell_range
             = rtxMemAllocType (pctxt, Source_cell_range);

         if (pvalue->u.source_cell_range == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Source_cell_range (pvalue->u.source_cell_range);
         stat = asn1D_Source_cell_range (pctxt, 
            pvalue->u.source_cell_range, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Data_pilot_table_choice (OSCTXT* pctxt, 
   Data_pilot_table_choice* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("database-source-sql"), 19}, 0}, 0 },
      {{{OSUTF8("database-source-query"), 21}, 0}, 1 },
      {{{OSUTF8("database-source-table"), 21}, 0}, 2 },
      {{{OSUTF8("source-service"), 14}, 0}, 3 },
      {{{OSUTF8("source-cell-range"), 17}, 0}, 4 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 5, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* database-source-sql */
      pvalue->u.database_source_sql
          = rtxMemAllocType (pctxt, Database_source_sql);

      if (pvalue->u.database_source_sql == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Database_source_sql (pvalue->u.database_source_sql);

      stat = XmlDec_Database_source_sql (pctxt, pvalue->u.database_source_sql
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* database-source-query */
      pvalue->u.database_source_query
          = rtxMemAllocType (pctxt, Database_source_query);

      if (pvalue->u.database_source_query == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Database_source_query (pvalue->u.database_source_query);

      stat = XmlDec_Database_source_query (pctxt, pvalue->
         u.database_source_query);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* database-source-table */
      pvalue->u.database_source_table
          = rtxMemAllocType (pctxt, Database_source_table);

      if (pvalue->u.database_source_table == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Database_source_table (pvalue->u.database_source_table);

      stat = XmlDec_Database_source_table (pctxt, pvalue->
         u.database_source_table);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* source-service */
      pvalue->u.source_service = rtxMemAllocType (pctxt, Source_service);

      if (pvalue->u.source_service == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Source_service (pvalue->u.source_service);

      stat = XmlDec_Source_service (pctxt, pvalue->u.source_service);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* source-cell-range */
      pvalue->u.source_cell_range
          = rtxMemAllocType (pctxt, Source_cell_range);

      if (pvalue->u.source_cell_range == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Source_cell_range (pvalue->u.source_cell_range);

      stat = XmlDec_Source_cell_range (pctxt, pvalue->u.source_cell_range);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_field_function_alt_1                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_field_function_alt_1 (OSCTXT* pctxt, 
   Data_pilot_field_function_alt_1 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_field_function_alt_1 (OSCTXT* pctxt, 
   Data_pilot_field_function_alt_1* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_field_function_alt_1_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_field_function_alt_2                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_field_function_alt_2 (OSCTXT* pctxt, 
   Data_pilot_field_function_alt_2 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_field_function_alt_2 (OSCTXT* pctxt, 
   Data_pilot_field_function_alt_2* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_field_function_alt_2_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_field_function_alt_3                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_field_function_alt_3 (OSCTXT* pctxt, 
   Data_pilot_field_function_alt_3 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_field_function_alt_3 (OSCTXT* pctxt, 
   Data_pilot_field_function_alt_3* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_field_function_alt_3_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_field_function_alt_4                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_field_function_alt_4 (OSCTXT* pctxt, 
   Data_pilot_field_function_alt_4 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_field_function_alt_4 (OSCTXT* pctxt, 
   Data_pilot_field_function_alt_4* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_field_function_alt_4_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_field_function_alt_5                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_field_function_alt_5 (OSCTXT* pctxt, 
   Data_pilot_field_function_alt_5 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_field_function_alt_5 (OSCTXT* pctxt, 
   Data_pilot_field_function_alt_5* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_field_function_alt_5_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_field_function_alt_6                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_field_function_alt_6 (OSCTXT* pctxt, 
   Data_pilot_field_function_alt_6 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_field_function_alt_6 (OSCTXT* pctxt, 
   Data_pilot_field_function_alt_6* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_field_function_alt_6_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_field_function_alt_7                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_field_function_alt_7 (OSCTXT* pctxt, 
   Data_pilot_field_function_alt_7 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_field_function_alt_7 (OSCTXT* pctxt, 
   Data_pilot_field_function_alt_7* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_field_function_alt_7_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_field_function_alt_8                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_field_function_alt_8 (OSCTXT* pctxt, 
   Data_pilot_field_function_alt_8 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_field_function_alt_8 (OSCTXT* pctxt, 
   Data_pilot_field_function_alt_8* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_field_function_alt_8_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_field_function_alt_9                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_field_function_alt_9 (OSCTXT* pctxt, 
   Data_pilot_field_function_alt_9 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_field_function_alt_9 (OSCTXT* pctxt, 
   Data_pilot_field_function_alt_9* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_field_function_alt_9_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_field_function_alt_10                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_field_function_alt_10 (OSCTXT* pctxt, 
   Data_pilot_field_function_alt_10 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_field_function_alt_10 (OSCTXT* pctxt, 
   Data_pilot_field_function_alt_10* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_field_function_alt_10_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_field_function_alt_11                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_field_function_alt_11 (OSCTXT* pctxt, 
   Data_pilot_field_function_alt_11 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_field_function_alt_11 (OSCTXT* pctxt, 
   Data_pilot_field_function_alt_11* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_field_function_alt_11_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_field_function_alt_12                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_field_function_alt_12 (OSCTXT* pctxt, 
   Data_pilot_field_function_alt_12 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_field_function_alt_12 (OSCTXT* pctxt, 
   Data_pilot_field_function_alt_12* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_field_function_alt_12_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_field_function                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_field_function (OSCTXT* pctxt, 
   Data_pilot_field_function *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
         stat = asn1D_Data_pilot_field_function_alt_1 (pctxt, 
            &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_PRIM|2):
         stat = asn1D_Data_pilot_field_function_alt_2 (pctxt, 
            &pvalue->u.alt_2, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_PRIM|3):
         stat = asn1D_Data_pilot_field_function_alt_3 (pctxt, 
            &pvalue->u.alt_3, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_PRIM|4):
         stat = asn1D_Data_pilot_field_function_alt_4 (pctxt, 
            &pvalue->u.alt_4, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_PRIM|5):
         stat = asn1D_Data_pilot_field_function_alt_5 (pctxt, 
            &pvalue->u.alt_5, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_PRIM|6):
         stat = asn1D_Data_pilot_field_function_alt_6 (pctxt, 
            &pvalue->u.alt_6, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_PRIM|7):
         stat = asn1D_Data_pilot_field_function_alt_7 (pctxt, 
            &pvalue->u.alt_7, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_PRIM|8):
         stat = asn1D_Data_pilot_field_function_alt_8 (pctxt, 
            &pvalue->u.alt_8, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_PRIM|9):
         stat = asn1D_Data_pilot_field_function_alt_9 (pctxt, 
            &pvalue->u.alt_9, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_PRIM|10):
         stat = asn1D_Data_pilot_field_function_alt_10 (pctxt, 
            &pvalue->u.alt_10, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_PRIM|11):
         stat = asn1D_Data_pilot_field_function_alt_11 (pctxt, 
            &pvalue->u.alt_11, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_PRIM|12):
         stat = asn1D_Data_pilot_field_function_alt_12 (pctxt, 
            &pvalue->u.alt_12, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Data_pilot_field_function (OSCTXT* pctxt, 
   Data_pilot_field_function* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_field_function_alt_1_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_1);
      if (stat == 0) pvalue->t = 2;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_field_function_alt_2_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_2);
      if (stat == 0) pvalue->t = 3;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_field_function_alt_3_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_3);
      if (stat == 0) pvalue->t = 4;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_field_function_alt_4_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_4);
      if (stat == 0) pvalue->t = 5;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_field_function_alt_5_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_5);
      if (stat == 0) pvalue->t = 6;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_field_function_alt_6_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_6);
      if (stat == 0) pvalue->t = 7;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_field_function_alt_7_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_7);
      if (stat == 0) pvalue->t = 8;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_field_function_alt_8_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_8);
      if (stat == 0) pvalue->t = 9;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_field_function_alt_9_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_9);
      if (stat == 0) pvalue->t = 10;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_field_function_alt_10_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_10);
      if (stat == 0) pvalue->t = 11;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_field_function_alt_11_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_11);
      if (stat == 0) pvalue->t = 12;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_field_function_alt_12_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_12);
      if (stat == 0) pvalue->t = 13;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_field_orientation                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_field_orientation (OSCTXT* pctxt, 
   Data_pilot_field_orientation *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_field_orientation (OSCTXT* pctxt, 
   Data_pilot_field_orientation* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_field_orientation_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_level_show_empty                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_level_show_empty (OSCTXT* pctxt, 
   Data_pilot_level_show_empty *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_level_show_empty (OSCTXT* pctxt, 
   Data_pilot_level_show_empty* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_level_show_empty_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_subtotal_function_alt_1                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_subtotal_function_alt_1 (OSCTXT* pctxt, 
   Data_pilot_subtotal_function_alt_1 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_subtotal_function_alt_1 (OSCTXT* pctxt, 
   Data_pilot_subtotal_function_alt_1* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_subtotal_function_alt_1_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_subtotal_function_alt_2                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_subtotal_function_alt_2 (OSCTXT* pctxt, 
   Data_pilot_subtotal_function_alt_2 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_subtotal_function_alt_2 (OSCTXT* pctxt, 
   Data_pilot_subtotal_function_alt_2* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_subtotal_function_alt_2_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_subtotal_function_alt_3                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_subtotal_function_alt_3 (OSCTXT* pctxt, 
   Data_pilot_subtotal_function_alt_3 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_subtotal_function_alt_3 (OSCTXT* pctxt, 
   Data_pilot_subtotal_function_alt_3* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_subtotal_function_alt_3_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_subtotal_function_alt_4                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_subtotal_function_alt_4 (OSCTXT* pctxt, 
   Data_pilot_subtotal_function_alt_4 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_subtotal_function_alt_4 (OSCTXT* pctxt, 
   Data_pilot_subtotal_function_alt_4* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_subtotal_function_alt_4_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_subtotal_function_alt_5                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_subtotal_function_alt_5 (OSCTXT* pctxt, 
   Data_pilot_subtotal_function_alt_5 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_subtotal_function_alt_5 (OSCTXT* pctxt, 
   Data_pilot_subtotal_function_alt_5* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_subtotal_function_alt_5_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_subtotal_function_alt_6                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_subtotal_function_alt_6 (OSCTXT* pctxt, 
   Data_pilot_subtotal_function_alt_6 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_subtotal_function_alt_6 (OSCTXT* pctxt, 
   Data_pilot_subtotal_function_alt_6* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_subtotal_function_alt_6_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_subtotal_function_alt_7                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_subtotal_function_alt_7 (OSCTXT* pctxt, 
   Data_pilot_subtotal_function_alt_7 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_subtotal_function_alt_7 (OSCTXT* pctxt, 
   Data_pilot_subtotal_function_alt_7* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_subtotal_function_alt_7_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_subtotal_function_alt_8                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_subtotal_function_alt_8 (OSCTXT* pctxt, 
   Data_pilot_subtotal_function_alt_8 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_subtotal_function_alt_8 (OSCTXT* pctxt, 
   Data_pilot_subtotal_function_alt_8* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_subtotal_function_alt_8_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_subtotal_function_alt_9                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_subtotal_function_alt_9 (OSCTXT* pctxt, 
   Data_pilot_subtotal_function_alt_9 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_subtotal_function_alt_9 (OSCTXT* pctxt, 
   Data_pilot_subtotal_function_alt_9* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_subtotal_function_alt_9_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_subtotal_function_alt_10                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_subtotal_function_alt_10 (OSCTXT* pctxt, 
   Data_pilot_subtotal_function_alt_10 *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_subtotal_function_alt_10 (OSCTXT* pctxt, 
   Data_pilot_subtotal_function_alt_10* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_subtotal_function_alt_10_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_subtotal_function_alt_11                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_subtotal_function_alt_11 (OSCTXT* pctxt, 
   Data_pilot_subtotal_function_alt_11 *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_subtotal_function_alt_11 (OSCTXT* pctxt, 
   Data_pilot_subtotal_function_alt_11* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_subtotal_function_alt_11_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_subtotal_function_alt_12                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_subtotal_function_alt_12 (OSCTXT* pctxt, 
   Data_pilot_subtotal_function_alt_12 *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_subtotal_function_alt_12 (OSCTXT* pctxt, 
   Data_pilot_subtotal_function_alt_12* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_subtotal_function_alt_12_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_subtotal_function                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_subtotal_function (OSCTXT* pctxt, 
   Data_pilot_subtotal_function *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
         stat = asn1D_Data_pilot_subtotal_function_alt_1 (pctxt, 
            &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_PRIM|2):
         stat = asn1D_Data_pilot_subtotal_function_alt_2 (pctxt, 
            &pvalue->u.alt_2, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_PRIM|3):
         stat = asn1D_Data_pilot_subtotal_function_alt_3 (pctxt, 
            &pvalue->u.alt_3, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_PRIM|4):
         stat = asn1D_Data_pilot_subtotal_function_alt_4 (pctxt, 
            &pvalue->u.alt_4, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_PRIM|5):
         stat = asn1D_Data_pilot_subtotal_function_alt_5 (pctxt, 
            &pvalue->u.alt_5, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_PRIM|6):
         stat = asn1D_Data_pilot_subtotal_function_alt_6 (pctxt, 
            &pvalue->u.alt_6, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_PRIM|7):
         stat = asn1D_Data_pilot_subtotal_function_alt_7 (pctxt, 
            &pvalue->u.alt_7, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_PRIM|8):
         stat = asn1D_Data_pilot_subtotal_function_alt_8 (pctxt, 
            &pvalue->u.alt_8, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_PRIM|9):
         stat = asn1D_Data_pilot_subtotal_function_alt_9 (pctxt, 
            &pvalue->u.alt_9, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_PRIM|10):
         stat = asn1D_Data_pilot_subtotal_function_alt_10 (pctxt, 
            &pvalue->u.alt_10, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_PRIM|11):
         stat = asn1D_Data_pilot_subtotal_function_alt_11 (pctxt, 
            &pvalue->u.alt_11, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_PRIM|12):
         stat = asn1D_Data_pilot_subtotal_function_alt_12 (pctxt, 
            &pvalue->u.alt_12, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Data_pilot_subtotal_function (OSCTXT* pctxt, 
   Data_pilot_subtotal_function* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_subtotal_function_alt_1_ToEnum (pctxt, pdata1, &pvalue
         ->u.alt_1);
      if (stat == 0) pvalue->t = 2;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_subtotal_function_alt_2_ToEnum (pctxt, pdata1, &pvalue
         ->u.alt_2);
      if (stat == 0) pvalue->t = 3;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_subtotal_function_alt_3_ToEnum (pctxt, pdata1, &pvalue
         ->u.alt_3);
      if (stat == 0) pvalue->t = 4;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_subtotal_function_alt_4_ToEnum (pctxt, pdata1, &pvalue
         ->u.alt_4);
      if (stat == 0) pvalue->t = 5;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_subtotal_function_alt_5_ToEnum (pctxt, pdata1, &pvalue
         ->u.alt_5);
      if (stat == 0) pvalue->t = 6;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_subtotal_function_alt_6_ToEnum (pctxt, pdata1, &pvalue
         ->u.alt_6);
      if (stat == 0) pvalue->t = 7;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_subtotal_function_alt_7_ToEnum (pctxt, pdata1, &pvalue
         ->u.alt_7);
      if (stat == 0) pvalue->t = 8;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_subtotal_function_alt_8_ToEnum (pctxt, pdata1, &pvalue
         ->u.alt_8);
      if (stat == 0) pvalue->t = 9;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_subtotal_function_alt_9_ToEnum (pctxt, pdata1, &pvalue
         ->u.alt_9);
      if (stat == 0) pvalue->t = 10;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_subtotal_function_alt_10_ToEnum (pctxt, pdata1, &pvalue
         ->u.alt_10);
      if (stat == 0) pvalue->t = 11;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_subtotal_function_alt_11_ToEnum (pctxt, pdata1, &pvalue
         ->u.alt_11);
      if (stat == 0) pvalue->t = 12;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_subtotal_function_alt_12_ToEnum (pctxt, pdata1, &pvalue
         ->u.alt_12);
      if (stat == 0) pvalue->t = 13;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_subtotal                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_subtotal (OSCTXT* pctxt, 
   Data_pilot_subtotal *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode function */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_subtotal_function (pctxt, 
               &pvalue->function, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Data_pilot_subtotal (OSCTXT* pctxt, Data_pilot_subtotal* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("function"), 8}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* function */
            stat = XmlDec_Data_pilot_subtotal_function (pctxt, &pvalue->
               function);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Data_pilot_subtotal");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Data_pilot_subtotal");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_subtotals                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_subtotals (OSCTXT* pctxt, 
   Data_pilot_subtotals *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode data_pilot_subtotal_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Data_pilot_subtotal* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->data_pilot_subtotal_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Data_pilot_subtotal, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Data_pilot_subtotal (pdata2);

                  stat = asn1D_Data_pilot_subtotal (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->data_pilot_subtotal_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Data_pilot_subtotals (OSCTXT* pctxt, Data_pilot_subtotals* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("data-pilot-subtotal"), 19}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Data_pilot_subtotal* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Data_pilot_subtotal);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Data_pilot_subtotal (pdata1);

            stat = XmlDec_Data_pilot_subtotal (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->data_pilot_subtotal_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_member_display                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_member_display (OSCTXT* pctxt, 
   Data_pilot_member_display *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_member_display (OSCTXT* pctxt, 
   Data_pilot_member_display* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_member_display_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_member_show_details                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_member_show_details (OSCTXT* pctxt, 
   Data_pilot_member_show_details *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_member_show_details (OSCTXT* pctxt, 
   Data_pilot_member_show_details* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_member_show_details_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_member                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_member (OSCTXT* pctxt, Data_pilot_member *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode display */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_member_display (pctxt, 
               &pvalue->display, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.displayPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode show_details */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_member_show_details (pctxt, 
               &pvalue->show_details, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.show_detailsPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Data_pilot_member (OSCTXT* pctxt, Data_pilot_member* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("display"), 7}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("show-details"), 12}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* display */
            stat = XmlDec_Data_pilot_member_display (pctxt, &pvalue->display);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.displayPresent = TRUE;
            break;

         case 1: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* show-details */
            stat = XmlDec_Data_pilot_member_show_details (pctxt, &pvalue->
               show_details);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.show_detailsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Data_pilot_member");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Data_pilot_member");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_members                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_members (OSCTXT* pctxt, 
   Data_pilot_members *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode data_pilot_member_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Data_pilot_member* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->data_pilot_member_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Data_pilot_member, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Data_pilot_member (pdata2);

                  stat = asn1D_Data_pilot_member (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->data_pilot_member_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Data_pilot_members (OSCTXT* pctxt, Data_pilot_members* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("data-pilot-member"), 17}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Data_pilot_member* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Data_pilot_member);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Data_pilot_member (pdata1);

            stat = XmlDec_Data_pilot_member (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->data_pilot_member_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_display_info_display_member_mode               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_display_info_display_member_mode (OSCTXT* pctxt, 
   Data_pilot_display_info_display_member_mode *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_display_info_display_member_mode (OSCTXT* pctxt, 
   Data_pilot_display_info_display_member_mode* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_display_info_display_member_mode_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_display_info_enabled                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_display_info_enabled (OSCTXT* pctxt, 
   Data_pilot_display_info_enabled *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_display_info_enabled (OSCTXT* pctxt, 
   Data_pilot_display_info_enabled* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_display_info_enabled_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_display_info                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_display_info (OSCTXT* pctxt, 
   Data_pilot_display_info *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode data_field */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->data_field, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode display_member_mode */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_display_info_display_member_mode (pctxt, 
               &pvalue->display_member_mode, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode enabled */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_display_info_enabled (pctxt, 
               &pvalue->enabled, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode member_count */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->member_count, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 4) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Data_pilot_display_info (OSCTXT* pctxt, 
   Data_pilot_display_info* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("data-field"), 10}, 0 },
         { {OSUTF8("display-member-mode"), 19}, 0 },
         { {OSUTF8("enabled"), 7}, 0 },
         { {OSUTF8("member-count"), 12}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* data-field */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->data_field);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* display-member-mode */
            stat = XmlDec_Data_pilot_display_info_display_member_mode (pctxt, &
               pvalue->display_member_mode);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* enabled */
            stat = XmlDec_Data_pilot_display_info_enabled (pctxt, &pvalue->
               enabled);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* member-count */
            stat = rtXmlpDecUInt (pctxt, &pvalue->member_count);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Data_pilot_display_info");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Data_pilot_display_info");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_sort_info_order                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_sort_info_order (OSCTXT* pctxt, 
   Data_pilot_sort_info_order *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_sort_info_order (OSCTXT* pctxt, 
   Data_pilot_sort_info_order* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_sort_info_order_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_sort_info_sort_mode                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_sort_info_sort_mode (OSCTXT* pctxt, 
   Data_pilot_sort_info_sort_mode *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_sort_info_sort_mode (OSCTXT* pctxt, 
   Data_pilot_sort_info_sort_mode* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_sort_info_sort_mode_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_sort_info                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_sort_info (OSCTXT* pctxt, 
   Data_pilot_sort_info *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode data_field */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->data_field, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_fieldPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode order */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_sort_info_order (pctxt, 
               &pvalue->order, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode sort_mode */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_sort_info_sort_mode (pctxt, 
               &pvalue->sort_mode, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Data_pilot_sort_info (OSCTXT* pctxt, Data_pilot_sort_info* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("data-field"), 10}, 0 },
         { {OSUTF8("order"), 5}, 0 },
         { {OSUTF8("sort-mode"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* data-field */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->data_field);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_fieldPresent = TRUE;
            break;

         case 1: /* order */
            stat = XmlDec_Data_pilot_sort_info_order (pctxt, &pvalue->order);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* sort-mode */
            stat = XmlDec_Data_pilot_sort_info_sort_mode (pctxt, &pvalue->
               sort_mode);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Data_pilot_sort_info");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Data_pilot_sort_info");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_layout_info_add_empty_lines                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_layout_info_add_empty_lines (OSCTXT* pctxt, 
   Data_pilot_layout_info_add_empty_lines *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_layout_info_add_empty_lines (OSCTXT* pctxt, 
   Data_pilot_layout_info_add_empty_lines* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_layout_info_add_empty_lines_ToEnum (pctxt, strval, pvalue
      );
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_layout_info_layout_mode                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_layout_info_layout_mode (OSCTXT* pctxt, 
   Data_pilot_layout_info_layout_mode *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_layout_info_layout_mode (OSCTXT* pctxt, 
   Data_pilot_layout_info_layout_mode* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_layout_info_layout_mode_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_layout_info                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_layout_info (OSCTXT* pctxt, 
   Data_pilot_layout_info *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode add_empty_lines */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_layout_info_add_empty_lines (pctxt, 
               &pvalue->add_empty_lines, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode layout_mode */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_layout_info_layout_mode (pctxt, 
               &pvalue->layout_mode, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Data_pilot_layout_info (OSCTXT* pctxt, 
   Data_pilot_layout_info* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("add-empty-lines"), 15}, 0 },
         { {OSUTF8("layout-mode"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* add-empty-lines */
            stat = XmlDec_Data_pilot_layout_info_add_empty_lines (pctxt, &
               pvalue->add_empty_lines);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* layout-mode */
            stat = XmlDec_Data_pilot_layout_info_layout_mode (pctxt, &pvalue->
               layout_mode);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Data_pilot_layout_info");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Data_pilot_layout_info");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_level                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_level (OSCTXT* pctxt, Data_pilot_level *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode show_empty */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_level_show_empty (pctxt, 
               &pvalue->show_empty, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.show_emptyPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode data_pilot_subtotals */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_subtotals (pctxt, 
               &pvalue->data_pilot_subtotals, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_pilot_subtotalsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode data_pilot_members */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_members (pctxt, 
               &pvalue->data_pilot_members, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_pilot_membersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode data_pilot_display_info */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_display_info (pctxt, 
               &pvalue->data_pilot_display_info, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_pilot_display_infoPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode data_pilot_sort_info */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_sort_info (pctxt, 
               &pvalue->data_pilot_sort_info, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_pilot_sort_infoPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode data_pilot_layout_info */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_layout_info (pctxt, 
               &pvalue->data_pilot_layout_info, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_pilot_layout_infoPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Data_pilot_level (OSCTXT* pctxt, Data_pilot_level* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("show-empty"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* show-empty */
            stat = XmlDec_Data_pilot_level_show_empty (pctxt, &pvalue->
               show_empty);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.show_emptyPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Data_pilot_level");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Data_pilot_level");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("data-pilot-subtotals"), 20}, 0}, 0 },
      {{{OSUTF8("data-pilot-members"), 18}, 0}, 1 },
      {{{OSUTF8("data-pilot-display-info"), 23}, 0}, 2 },
      {{{OSUTF8("data-pilot-sort-info"), 20}, 0}, 3 },
      {{{OSUTF8("data-pilot-layout-info"), 22}, 0}, 4 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 5, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 5; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* data-pilot-subtotals */
         stat = XmlDec_Data_pilot_subtotals (pctxt, &pvalue->
            data_pilot_subtotals);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.data_pilot_subtotalsPresent = TRUE;
         break;
      }
      case 1: { /* data-pilot-members */
         stat = XmlDec_Data_pilot_members (pctxt, &pvalue->data_pilot_members
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.data_pilot_membersPresent = TRUE;
         break;
      }
      case 2: { /* data-pilot-display-info */
         stat = XmlDec_Data_pilot_display_info (pctxt, &pvalue->
            data_pilot_display_info);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.data_pilot_display_infoPresent = TRUE;
         break;
      }
      case 3: { /* data-pilot-sort-info */
         stat = XmlDec_Data_pilot_sort_info (pctxt, &pvalue->
            data_pilot_sort_info);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.data_pilot_sort_infoPresent = TRUE;
         break;
      }
      case 4: { /* data-pilot-layout-info */
         stat = XmlDec_Data_pilot_layout_info (pctxt, &pvalue->
            data_pilot_layout_info);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.data_pilot_layout_infoPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_field_reference_member_type                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_field_reference_member_type (OSCTXT* pctxt, 
   Data_pilot_field_reference_member_type *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_field_reference_member_type (OSCTXT* pctxt, 
   Data_pilot_field_reference_member_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_field_reference_member_type_ToEnum (pctxt, strval, pvalue
      );
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_field_reference_type                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_field_reference_type (OSCTXT* pctxt, 
   Data_pilot_field_reference_type *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_field_reference_type (OSCTXT* pctxt, 
   Data_pilot_field_reference_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_field_reference_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_field_reference                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_field_reference (OSCTXT* pctxt, 
   Data_pilot_field_reference *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode field_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->field_name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode member_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->member_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.member_namePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode member_type */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_field_reference_member_type (pctxt, 
               &pvalue->member_type, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_field_reference_type (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Data_pilot_field_reference (OSCTXT* pctxt, 
   Data_pilot_field_reference* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("field-name"), 10}, 0 },
         { {OSUTF8("member-name"), 11}, 0 },
         { {OSUTF8("member-type"), 11}, 0 },
         { {OSUTF8("type"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* field-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->field_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* member-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->member_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.member_namePresent = TRUE;
            break;

         case 2: /* member-type */
            stat = XmlDec_Data_pilot_field_reference_member_type (pctxt, &
               pvalue->member_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* type */
            stat = XmlDec_Data_pilot_field_reference_type (pctxt, &pvalue->type
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Data_pilot_field_reference");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Data_pilot_field_reference");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_groups_date_end_alt_2                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_groups_date_end_alt_2 (OSCTXT* pctxt, 
   Data_pilot_groups_date_end_alt_2 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_groups_date_end_alt_2 (OSCTXT* pctxt, 
   Data_pilot_groups_date_end_alt_2* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_groups_date_end_alt_2_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_groups_date_end                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_groups_date_end (OSCTXT* pctxt, 
   Data_pilot_groups_date_end *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_charstr (pctxt, &pvalue->u.alt, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|26), length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_charstr (pctxt, &pvalue->u.alt_1, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|26), length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|2):
         stat = asn1D_Data_pilot_groups_date_end_alt_2 (pctxt, 
            &pvalue->u.alt_2, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Data_pilot_groups_date_end (OSCTXT* pctxt, 
   Data_pilot_groups_date_end* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = (const char*)pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = (const char*)pdata1;
      pvalue->t = 2;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_groups_date_end_alt_2_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_2);
      if (stat == 0) pvalue->t = 3;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_groups_date_start_alt_2                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_groups_date_start_alt_2 (OSCTXT* pctxt, 
   Data_pilot_groups_date_start_alt_2 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_groups_date_start_alt_2 (OSCTXT* pctxt, 
   Data_pilot_groups_date_start_alt_2* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_groups_date_start_alt_2_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_groups_date_start                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_groups_date_start (OSCTXT* pctxt, 
   Data_pilot_groups_date_start *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_charstr (pctxt, &pvalue->u.alt, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|26), length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_charstr (pctxt, &pvalue->u.alt_1, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|26), length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|2):
         stat = asn1D_Data_pilot_groups_date_start_alt_2 (pctxt, 
            &pvalue->u.alt_2, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Data_pilot_groups_date_start (OSCTXT* pctxt, 
   Data_pilot_groups_date_start* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = (const char*)pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = (const char*)pdata1;
      pvalue->t = 2;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_groups_date_start_alt_2_ToEnum (pctxt, pdata1, &pvalue
         ->u.alt_2);
      if (stat == 0) pvalue->t = 3;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_groups_end_alt_1                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_groups_end_alt_1 (OSCTXT* pctxt, 
   Data_pilot_groups_end_alt_1 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_groups_end_alt_1 (OSCTXT* pctxt, 
   Data_pilot_groups_end_alt_1* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_groups_end_alt_1_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_groups_end                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_groups_end (OSCTXT* pctxt, 
   Data_pilot_groups_end *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
         stat = xd_real (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_PRIM|1):
         stat = asn1D_Data_pilot_groups_end_alt_1 (pctxt, 
            &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Data_pilot_groups_end (OSCTXT* pctxt, Data_pilot_groups_end* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      stat = rtxUTF8StrToDouble (pdata1, &pvalue->u.alt);
      if (stat == 0) pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_groups_end_alt_1_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_1);
      if (stat == 0) pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_groups_grouped_by                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_groups_grouped_by (OSCTXT* pctxt, 
   Data_pilot_groups_grouped_by *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_groups_grouped_by (OSCTXT* pctxt, 
   Data_pilot_groups_grouped_by* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_groups_grouped_by_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_groups_start_alt_1                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_groups_start_alt_1 (OSCTXT* pctxt, 
   Data_pilot_groups_start_alt_1 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Data_pilot_groups_start_alt_1 (OSCTXT* pctxt, 
   Data_pilot_groups_start_alt_1* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Data_pilot_groups_start_alt_1_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_groups_start                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_groups_start (OSCTXT* pctxt, 
   Data_pilot_groups_start *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
         stat = xd_real (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_PRIM|1):
         stat = asn1D_Data_pilot_groups_start_alt_1 (pctxt, 
            &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Data_pilot_groups_start (OSCTXT* pctxt, 
   Data_pilot_groups_start* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      stat = rtxUTF8StrToDouble (pdata1, &pvalue->u.alt);
      if (stat == 0) pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      stat = Data_pilot_groups_start_alt_1_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_1);
      if (stat == 0) pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_group_member                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_group_member (OSCTXT* pctxt, 
   Data_pilot_group_member *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Data_pilot_group_member (OSCTXT* pctxt, 
   Data_pilot_group_member* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("name"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Data_pilot_group_member");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Data_pilot_group_member");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_group                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_group (OSCTXT* pctxt, Data_pilot_group *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode data_pilot_group_member_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Data_pilot_group_member* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->data_pilot_group_member_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Data_pilot_group_member, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Data_pilot_group_member (pdata2);

                  stat = asn1D_Data_pilot_group_member (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->data_pilot_group_member_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Data_pilot_group (OSCTXT* pctxt, Data_pilot_group* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("name"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Data_pilot_group");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Data_pilot_group");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("data-pilot-group-member"), 23}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Data_pilot_group_member* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Data_pilot_group_member);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Data_pilot_group_member (pdata1);

            stat = XmlDec_Data_pilot_group_member (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->data_pilot_group_member_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_groups                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_groups (OSCTXT* pctxt, Data_pilot_groups *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode date_end */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_groups_date_end (pctxt, 
               &pvalue->date_end, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.date_endPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode date_start */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_groups_date_start (pctxt, 
               &pvalue->date_start, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.date_startPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode end */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_groups_end (pctxt, 
               &pvalue->end, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.endPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode grouped_by */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_groups_grouped_by (pctxt, 
               &pvalue->grouped_by, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode source_field_name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->source_field_name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode start */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_groups_start (pctxt, 
               &pvalue->start, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.startPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode step */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->step, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode data_pilot_group_list */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Data_pilot_group* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->data_pilot_group_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Data_pilot_group, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Data_pilot_group (pdata2);

                  stat = asn1D_Data_pilot_group (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->data_pilot_group_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 4) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Data_pilot_groups (OSCTXT* pctxt, Data_pilot_groups* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("date-end"), 8}, 0 },
         { {OSUTF8("date-start"), 10}, 0 },
         { {OSUTF8("end"), 3}, 0 },
         { {OSUTF8("grouped-by"), 10}, 0 },
         { {OSUTF8("source-field-name"), 17}, 0 },
         { {OSUTF8("start"), 5}, 0 },
         { {OSUTF8("step"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 7, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* date-end */
            stat = XmlDec_Data_pilot_groups_date_end (pctxt, &pvalue->date_end
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.date_endPresent = TRUE;
            break;

         case 1: /* date-start */
            stat = XmlDec_Data_pilot_groups_date_start (pctxt, &pvalue->
               date_start);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.date_startPresent = TRUE;
            break;

         case 2: /* end */
            stat = XmlDec_Data_pilot_groups_end (pctxt, &pvalue->end);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.endPresent = TRUE;
            break;

         case 3: /* grouped-by */
            stat = XmlDec_Data_pilot_groups_grouped_by (pctxt, &pvalue->
               grouped_by);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* source-field-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->source_field_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* start */
            stat = XmlDec_Data_pilot_groups_start (pctxt, &pvalue->start);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.startPresent = TRUE;
            break;

         case 6: /* step */
            stat = rtXmlpDecDouble (pctxt, &pvalue->step, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Data_pilot_groups");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Data_pilot_groups");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("data-pilot-group"), 16}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Data_pilot_group* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Data_pilot_group);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Data_pilot_group (pdata1);

            stat = XmlDec_Data_pilot_group (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->data_pilot_group_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_field                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_field (OSCTXT* pctxt, Data_pilot_field *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode function */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_field_function (pctxt, 
               &pvalue->function, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.functionPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode is_data_layout_field */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->is_data_layout_field, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.is_data_layout_fieldPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode orientation */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_field_orientation (pctxt, 
               &pvalue->orientation, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode selected_page */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->selected_page, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.selected_pagePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode source_field_name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->source_field_name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode used_hierarchy */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->used_hierarchy, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.used_hierarchyPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode data_pilot_level */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_level (pctxt, 
               &pvalue->data_pilot_level, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_pilot_levelPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode data_pilot_field_reference */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_field_reference (pctxt, 
               &pvalue->data_pilot_field_reference, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_pilot_field_referencePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode data_pilot_groups */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_groups (pctxt, 
               &pvalue->data_pilot_groups, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_pilot_groupsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Data_pilot_field (OSCTXT* pctxt, Data_pilot_field* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("function"), 8}, 0 },
         { {OSUTF8("is-data-layout-field"), 20}, 0 },
         { {OSUTF8("orientation"), 11}, 0 },
         { {OSUTF8("selected-page"), 13}, 0 },
         { {OSUTF8("source-field-name"), 17}, 0 },
         { {OSUTF8("used-hierarchy"), 14}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 6, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* function */
            stat = XmlDec_Data_pilot_field_function (pctxt, &pvalue->function
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.functionPresent = TRUE;
            break;

         case 1: /* is-data-layout-field */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->is_data_layout_field);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.is_data_layout_fieldPresent = TRUE;
            break;

         case 2: /* orientation */
            stat = XmlDec_Data_pilot_field_orientation (pctxt, &pvalue->
               orientation);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* selected-page */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->selected_page);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.selected_pagePresent = TRUE;
            break;

         case 4: /* source-field-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->source_field_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* used-hierarchy */
            stat = rtXmlpDecInt (pctxt, &pvalue->used_hierarchy);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.used_hierarchyPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Data_pilot_field");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Data_pilot_field");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("data-pilot-level"), 16}, 0}, 0 },
      {{{OSUTF8("data-pilot-field-reference"), 26}, 0}, 1 },
      {{{OSUTF8("data-pilot-groups"), 17}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* data-pilot-level */
         stat = XmlDec_Data_pilot_level (pctxt, &pvalue->data_pilot_level);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.data_pilot_levelPresent = TRUE;
         break;
      }
      case 1: { /* data-pilot-field-reference */
         stat = XmlDec_Data_pilot_field_reference (pctxt, &pvalue->
            data_pilot_field_reference);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.data_pilot_field_referencePresent = TRUE;
         break;
      }
      case 2: { /* data-pilot-groups */
         stat = XmlDec_Data_pilot_groups (pctxt, &pvalue->data_pilot_groups);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.data_pilot_groupsPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_table                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_table (OSCTXT* pctxt, Data_pilot_table *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode application_data */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->application_data, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.application_dataPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode buttons */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->buttons, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.buttonsPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode drill_down_on_double_click */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_table_drill_down_on_double_click (pctxt, 
               &pvalue->drill_down_on_double_click, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.drill_down_on_double_clickPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode grand_total */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_table_grand_total (pctxt, 
               &pvalue->grand_total, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.grand_totalPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode identify_categories */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_table_identify_categories (pctxt, 
               &pvalue->identify_categories, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.identify_categoriesPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode ignore_empty_rows */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_table_ignore_empty_rows (pctxt, 
               &pvalue->ignore_empty_rows, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.ignore_empty_rowsPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode show_filter_button */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_table_show_filter_button (pctxt, 
               &pvalue->show_filter_button, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.show_filter_buttonPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode target_range_address */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->target_range_address, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 9:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Data_pilot_table_choice (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choicePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 10:
         /* decode data_pilot_field_list */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Data_pilot_field* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->data_pilot_field_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Data_pilot_field, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Data_pilot_field (pdata2);

                  stat = asn1D_Data_pilot_field (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->data_pilot_field_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Data_pilot_table (OSCTXT* pctxt, Data_pilot_table* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("application-data"), 16}, 0 },
         { {OSUTF8("buttons"), 7}, 0 },
         { {OSUTF8("drill-down-on-double-click"), 26}, 0 },
         { {OSUTF8("grand-total"), 11}, 0 },
         { {OSUTF8("identify-categories"), 19}, 0 },
         { {OSUTF8("ignore-empty-rows"), 17}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("show-filter-button"), 18}, 0 },
         { {OSUTF8("target-range-address"), 20}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 9, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* application-data */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->application_data);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.application_dataPresent = TRUE;
            break;

         case 1: /* buttons */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->buttons);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.buttonsPresent = TRUE;
            break;

         case 2: /* drill-down-on-double-click */
            stat = XmlDec_Data_pilot_table_drill_down_on_double_click (pctxt, &
               pvalue->drill_down_on_double_click);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.drill_down_on_double_clickPresent = TRUE;
            break;

         case 3: /* grand-total */
            stat = XmlDec_Data_pilot_table_grand_total (pctxt, &pvalue->
               grand_total);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.grand_totalPresent = TRUE;
            break;

         case 4: /* identify-categories */
            stat = XmlDec_Data_pilot_table_identify_categories (pctxt, &pvalue
               ->identify_categories);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.identify_categoriesPresent = TRUE;
            break;

         case 5: /* ignore-empty-rows */
            stat = XmlDec_Data_pilot_table_ignore_empty_rows (pctxt, &pvalue->
               ignore_empty_rows);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.ignore_empty_rowsPresent = TRUE;
            break;

         case 6: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 7: /* show-filter-button */
            stat = XmlDec_Data_pilot_table_show_filter_button (pctxt, &pvalue->
               show_filter_button);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.show_filter_buttonPresent = TRUE;
            break;

         case 8: /* target-range-address */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->target_range_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Data_pilot_table");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Data_pilot_table");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("database-source-sql"), 19}, 0}, 0 },
      {{{OSUTF8("database-source-query"), 21}, 0}, 0 },
      {{{OSUTF8("database-source-table"), 21}, 0}, 0 },
      {{{OSUTF8("source-service"), 14}, 0}, 0 },
      {{{OSUTF8("source-cell-range"), 17}, 0}, 0 },
      {{{OSUTF8("data-pilot-field"), 16}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 6, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /*  */
         stat = XmlDec_Data_pilot_table_choice (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choicePresent = TRUE;
         break;
      }
      case 1: {
         Data_pilot_field* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Data_pilot_field);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Data_pilot_field (pdata1);

            stat = XmlDec_Data_pilot_field (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->data_pilot_field_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 5, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_pilot_tables                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Data_pilot_tables (OSCTXT* pctxt, Data_pilot_tables *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode data_pilot_table_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Data_pilot_table* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->data_pilot_table_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Data_pilot_table, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Data_pilot_table (pdata2);

                  stat = asn1D_Data_pilot_table (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->data_pilot_table_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Data_pilot_tables (OSCTXT* pctxt, Data_pilot_tables* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("data-pilot-table"), 16}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Data_pilot_table* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Data_pilot_table);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Data_pilot_table (pdata1);

            stat = XmlDec_Data_pilot_table (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->data_pilot_table_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Consolidation_function_alt_1                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Consolidation_function_alt_1 (OSCTXT* pctxt, 
   Consolidation_function_alt_1 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Consolidation_function_alt_1 (OSCTXT* pctxt, 
   Consolidation_function_alt_1* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Consolidation_function_alt_1_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Consolidation_function_alt_2                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Consolidation_function_alt_2 (OSCTXT* pctxt, 
   Consolidation_function_alt_2 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Consolidation_function_alt_2 (OSCTXT* pctxt, 
   Consolidation_function_alt_2* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Consolidation_function_alt_2_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Consolidation_function_alt_3                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Consolidation_function_alt_3 (OSCTXT* pctxt, 
   Consolidation_function_alt_3 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Consolidation_function_alt_3 (OSCTXT* pctxt, 
   Consolidation_function_alt_3* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Consolidation_function_alt_3_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Consolidation_function_alt_4                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Consolidation_function_alt_4 (OSCTXT* pctxt, 
   Consolidation_function_alt_4 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Consolidation_function_alt_4 (OSCTXT* pctxt, 
   Consolidation_function_alt_4* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Consolidation_function_alt_4_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Consolidation_function_alt_5                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Consolidation_function_alt_5 (OSCTXT* pctxt, 
   Consolidation_function_alt_5 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Consolidation_function_alt_5 (OSCTXT* pctxt, 
   Consolidation_function_alt_5* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Consolidation_function_alt_5_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Consolidation_function_alt_6                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Consolidation_function_alt_6 (OSCTXT* pctxt, 
   Consolidation_function_alt_6 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Consolidation_function_alt_6 (OSCTXT* pctxt, 
   Consolidation_function_alt_6* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Consolidation_function_alt_6_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Consolidation_function_alt_7                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Consolidation_function_alt_7 (OSCTXT* pctxt, 
   Consolidation_function_alt_7 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Consolidation_function_alt_7 (OSCTXT* pctxt, 
   Consolidation_function_alt_7* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Consolidation_function_alt_7_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Consolidation_function_alt_8                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Consolidation_function_alt_8 (OSCTXT* pctxt, 
   Consolidation_function_alt_8 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Consolidation_function_alt_8 (OSCTXT* pctxt, 
   Consolidation_function_alt_8* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Consolidation_function_alt_8_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Consolidation_function_alt_9                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Consolidation_function_alt_9 (OSCTXT* pctxt, 
   Consolidation_function_alt_9 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Consolidation_function_alt_9 (OSCTXT* pctxt, 
   Consolidation_function_alt_9* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Consolidation_function_alt_9_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Consolidation_function_alt_10                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Consolidation_function_alt_10 (OSCTXT* pctxt, 
   Consolidation_function_alt_10 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Consolidation_function_alt_10 (OSCTXT* pctxt, 
   Consolidation_function_alt_10* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Consolidation_function_alt_10_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Consolidation_function_alt_11                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Consolidation_function_alt_11 (OSCTXT* pctxt, 
   Consolidation_function_alt_11 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Consolidation_function_alt_11 (OSCTXT* pctxt, 
   Consolidation_function_alt_11* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Consolidation_function_alt_11_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Consolidation_function_alt_12                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Consolidation_function_alt_12 (OSCTXT* pctxt, 
   Consolidation_function_alt_12 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Consolidation_function_alt_12 (OSCTXT* pctxt, 
   Consolidation_function_alt_12* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Consolidation_function_alt_12_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Consolidation_function                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Consolidation_function (OSCTXT* pctxt, 
   Consolidation_function *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
         stat = asn1D_Consolidation_function_alt_1 (pctxt, 
            &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_PRIM|2):
         stat = asn1D_Consolidation_function_alt_2 (pctxt, 
            &pvalue->u.alt_2, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_PRIM|3):
         stat = asn1D_Consolidation_function_alt_3 (pctxt, 
            &pvalue->u.alt_3, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_PRIM|4):
         stat = asn1D_Consolidation_function_alt_4 (pctxt, 
            &pvalue->u.alt_4, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_PRIM|5):
         stat = asn1D_Consolidation_function_alt_5 (pctxt, 
            &pvalue->u.alt_5, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_PRIM|6):
         stat = asn1D_Consolidation_function_alt_6 (pctxt, 
            &pvalue->u.alt_6, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_PRIM|7):
         stat = asn1D_Consolidation_function_alt_7 (pctxt, 
            &pvalue->u.alt_7, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_PRIM|8):
         stat = asn1D_Consolidation_function_alt_8 (pctxt, 
            &pvalue->u.alt_8, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_PRIM|9):
         stat = asn1D_Consolidation_function_alt_9 (pctxt, 
            &pvalue->u.alt_9, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_PRIM|10):
         stat = asn1D_Consolidation_function_alt_10 (pctxt, 
            &pvalue->u.alt_10, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_PRIM|11):
         stat = asn1D_Consolidation_function_alt_11 (pctxt, 
            &pvalue->u.alt_11, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_PRIM|12):
         stat = asn1D_Consolidation_function_alt_12 (pctxt, 
            &pvalue->u.alt_12, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Consolidation_function (OSCTXT* pctxt, 
   Consolidation_function* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      stat = Consolidation_function_alt_1_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_1);
      if (stat == 0) pvalue->t = 2;
   }
   if (pvalue->t == 0) {
      stat = Consolidation_function_alt_2_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_2);
      if (stat == 0) pvalue->t = 3;
   }
   if (pvalue->t == 0) {
      stat = Consolidation_function_alt_3_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_3);
      if (stat == 0) pvalue->t = 4;
   }
   if (pvalue->t == 0) {
      stat = Consolidation_function_alt_4_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_4);
      if (stat == 0) pvalue->t = 5;
   }
   if (pvalue->t == 0) {
      stat = Consolidation_function_alt_5_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_5);
      if (stat == 0) pvalue->t = 6;
   }
   if (pvalue->t == 0) {
      stat = Consolidation_function_alt_6_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_6);
      if (stat == 0) pvalue->t = 7;
   }
   if (pvalue->t == 0) {
      stat = Consolidation_function_alt_7_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_7);
      if (stat == 0) pvalue->t = 8;
   }
   if (pvalue->t == 0) {
      stat = Consolidation_function_alt_8_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_8);
      if (stat == 0) pvalue->t = 9;
   }
   if (pvalue->t == 0) {
      stat = Consolidation_function_alt_9_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_9);
      if (stat == 0) pvalue->t = 10;
   }
   if (pvalue->t == 0) {
      stat = Consolidation_function_alt_10_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_10);
      if (stat == 0) pvalue->t = 11;
   }
   if (pvalue->t == 0) {
      stat = Consolidation_function_alt_11_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_11);
      if (stat == 0) pvalue->t = 12;
   }
   if (pvalue->t == 0) {
      stat = Consolidation_function_alt_12_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_12);
      if (stat == 0) pvalue->t = 13;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Consolidation_link_to_source_data                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Consolidation_link_to_source_data (OSCTXT* pctxt, 
   Consolidation_link_to_source_data *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Consolidation_link_to_source_data (OSCTXT* pctxt, 
   Consolidation_link_to_source_data* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Consolidation_link_to_source_data_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Consolidation_use_labels                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Consolidation_use_labels (OSCTXT* pctxt, 
   Consolidation_use_labels *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Consolidation_use_labels (OSCTXT* pctxt, 
   Consolidation_use_labels* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Consolidation_use_labels_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Consolidation                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Consolidation (OSCTXT* pctxt, Consolidation *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode function */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Consolidation_function (pctxt, 
               &pvalue->function, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode link_to_source_data */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Consolidation_link_to_source_data (pctxt, 
               &pvalue->link_to_source_data, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.link_to_source_dataPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode source_cell_range_addresses */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->source_cell_range_addresses, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode target_cell_address */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->target_cell_address, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode use_labels */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Consolidation_use_labels (pctxt, 
               &pvalue->use_labels, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.use_labelsPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Consolidation (OSCTXT* pctxt, Consolidation* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("function"), 8}, 0 },
         { {OSUTF8("link-to-source-data"), 19}, 0 },
         { {OSUTF8("source-cell-range-addresses"), 27}, 0 },
         { {OSUTF8("target-cell-address"), 19}, 0 },
         { {OSUTF8("use-labels"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* function */
            stat = XmlDec_Consolidation_function (pctxt, &pvalue->function);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* link-to-source-data */
            stat = XmlDec_Consolidation_link_to_source_data (pctxt, &pvalue->
               link_to_source_data);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.link_to_source_dataPresent = TRUE;
            break;

         case 2: /* source-cell-range-addresses */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->
               source_cell_range_addresses);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* target-cell-address */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->target_cell_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* use-labels */
            stat = XmlDec_Consolidation_use_labels (pctxt, &pvalue->use_labels
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.use_labelsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Consolidation");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Consolidation");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Dde_link                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Dde_link (OSCTXT* pctxt, Dde_link *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode dde_source */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->dde_source = rtxMemAllocType (pctxt, Ns13_Dde_source);

            if (pvalue->dde_source == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Dde_source ((Ns13_Dde_source*)pvalue->dde_source);
            asn1Init_Ns13_Dde_source ((Ns13_Dde_source*)pvalue->dde_source);

            stat = asn1D_Ns13_Dde_source (pctxt, 
               (Ns13_Dde_source*)pvalue->dde_source, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode table */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table (pctxt, 
               &pvalue->table, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Dde_link (OSCTXT* pctxt, Dde_link* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("dde-source"), 10}, 0}, 0 },
      {{{OSUTF8("table"), 5}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 1, -1}, {2, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* dde-source */
         pvalue->dde_source = rtxMemAllocType (pctxt, Ns13_Dde_source);

         if (pvalue->dde_source == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Dde_source ((Ns13_Dde_source*)pvalue->dde_source);

         stat = XmlDec_Ns13_Dde_source (pctxt, pvalue->dde_source);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* table */
         stat = XmlDec_Table (pctxt, &pvalue->table);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Dde_links                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Dde_links (OSCTXT* pctxt, Dde_links *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode dde_link_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Dde_link* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->dde_link_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Dde_link, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Dde_link (pdata2);

                  stat = asn1D_Dde_link (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->dde_link_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Dde_links (OSCTXT* pctxt, Dde_links* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("dde-link"), 8}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Dde_link* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Dde_link);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Dde_link (pdata1);

            stat = XmlDec_Dde_link (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->dde_link_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Protection_key                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Protection_key (OSCTXT* pctxt, Protection_key *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Protection_key (OSCTXT* pctxt, Protection_key* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Structure_protected                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Structure_protected (OSCTXT* pctxt, 
   Structure_protected *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Structure_protected (OSCTXT* pctxt, Structure_protected* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Structure_protected_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cell_range                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Cell_range (OSCTXT* pctxt, Cell_range *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Cell_range (OSCTXT* pctxt, Cell_range* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Tracked_changes_track_changes                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns15_Tracked_changes_track_changes (OSCTXT* pctxt, 
   Ns15_Tracked_changes_track_changes *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns15_Tracked_changes_track_changes (OSCTXT* pctxt, 
   Ns15_Tracked_changes_track_changes* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns15_Tracked_changes_track_changes_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cell_content_change_acceptance_state                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Cell_content_change_acceptance_state (OSCTXT* pctxt, 
   Cell_content_change_acceptance_state *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Cell_content_change_acceptance_state (OSCTXT* pctxt, 
   Cell_content_change_acceptance_state* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Cell_content_change_acceptance_state_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Insertion_acceptance_state                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Insertion_acceptance_state (OSCTXT* pctxt, 
   Insertion_acceptance_state *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Insertion_acceptance_state (OSCTXT* pctxt, 
   Insertion_acceptance_state* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Insertion_acceptance_state_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Insertion_type                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Insertion_type (OSCTXT* pctxt, Insertion_type *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Insertion_type (OSCTXT* pctxt, Insertion_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Insertion_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Deletion_acceptance_state                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Deletion_acceptance_state (OSCTXT* pctxt, 
   Deletion_acceptance_state *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Deletion_acceptance_state (OSCTXT* pctxt, 
   Deletion_acceptance_state* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Deletion_acceptance_state_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Deletion_type                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Deletion_type (OSCTXT* pctxt, Deletion_type *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Deletion_type (OSCTXT* pctxt, Deletion_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Deletion_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Movement_acceptance_state                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Movement_acceptance_state (OSCTXT* pctxt, 
   Movement_acceptance_state *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Movement_acceptance_state (OSCTXT* pctxt, 
   Movement_acceptance_state* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Movement_acceptance_state_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Change_track_table_cell_value_type                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Change_track_table_cell_value_type (OSCTXT* pctxt, 
   Change_track_table_cell_value_type *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Change_track_table_cell_value_type (OSCTXT* pctxt, 
   Change_track_table_cell_value_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Change_track_table_cell_value_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Change_track_table_cell_matrix_covered                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Change_track_table_cell_matrix_covered (OSCTXT* pctxt, 
   Change_track_table_cell_matrix_covered *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Change_track_table_cell_matrix_covered (OSCTXT* pctxt, 
   Change_track_table_cell_matrix_covered* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Change_track_table_cell_matrix_covered_ToEnum (pctxt, strval, pvalue
      );
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cell_address                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Cell_address (OSCTXT* pctxt, Cell_address *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode column */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->column, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode row */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->row, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode table */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->table, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Cell_address (OSCTXT* pctxt, Cell_address* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("column"), 6}, 0 },
         { {OSUTF8("row"), 3}, 0 },
         { {OSUTF8("table"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* column */
            stat = rtXmlpDecInt (pctxt, &pvalue->column);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* row */
            stat = rtXmlpDecInt (pctxt, &pvalue->row);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* table */
            stat = rtXmlpDecInt (pctxt, &pvalue->table);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Cell_address");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Cell_address");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Dependency                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Dependency (OSCTXT* pctxt, Dependency *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Dependency (OSCTXT* pctxt, Dependency* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("id"), 2}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Dependency");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Dependency");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Dependencies                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Dependencies (OSCTXT* pctxt, Dependencies *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode dependency_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Dependency* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->dependency_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Dependency, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Dependency (pdata2);

                  stat = asn1D_Dependency (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->dependency_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Dependencies (OSCTXT* pctxt, Dependencies* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("dependency"), 10}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Dependency* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Dependency);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Dependency (pdata1);

            stat = XmlDec_Dependency (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->dependency_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Change_track_table_cell                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Change_track_table_cell (OSCTXT* pctxt, 
   Change_track_table_cell *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode boolean_value */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Boolean_value (pctxt, 
               (Ns13_Boolean_value*)&pvalue->boolean_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.boolean_valuePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode currency */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Currency (pctxt, 
               (Ns13_Currency*)&pvalue->currency, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.currencyPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode date_value */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->date_value = rtxMemAllocType (pctxt, Ns13_Date_value);

            if (pvalue->date_value == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);
            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);

            stat = asn1D_Ns13_Date_value (pctxt, 
               (Ns13_Date_value*)pvalue->date_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.date_valuePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode string_value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_String_value (pctxt, 
               (Ns13_String_value*)&pvalue->string_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.string_valuePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode time_value */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Time_value (pctxt, 
               (Ns13_Time_value*)&pvalue->time_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.time_valuePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Value (pctxt, 
               (Ns13_Value*)&pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode value_type */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Change_track_table_cell_value_type (pctxt, 
               &pvalue->value_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.value_typePresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode cell_address */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->cell_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.cell_addressPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode formula */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->formula, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.formulaPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode matrix_covered */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Change_track_table_cell_matrix_covered (pctxt, 
               &pvalue->matrix_covered, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.matrix_coveredPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode number_matrix_columns_spanned */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->number_matrix_columns_spanned, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.number_matrix_columns_spannedPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode number_matrix_rows_spanned */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->number_matrix_rows_spanned, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.number_matrix_rows_spannedPresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode p_list */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_P* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->p_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_P, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_P ((Odf_P*)pdata2);

                  stat = asn1D_Odf_P (pctxt, 
                     (Odf_P*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->p_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_CONS|12):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Change_track_table_cell (OSCTXT* pctxt, 
   Change_track_table_cell* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("boolean-value"), 13}, 0 },
         { {OSUTF8("currency"), 8}, 0 },
         { {OSUTF8("date-value"), 10}, 0 },
         { {OSUTF8("string-value"), 12}, 0 },
         { {OSUTF8("time-value"), 10}, 0 },
         { {OSUTF8("value"), 5}, 0 },
         { {OSUTF8("value-type"), 10}, 0 },
         { {OSUTF8("cell-address"), 12}, 0 },
         { {OSUTF8("formula"), 7}, 0 },
         { {OSUTF8("matrix-covered"), 14}, 0 },
         { {OSUTF8("number-matrix-columns-spanned"), 29}, 0 },
         { {OSUTF8("number-matrix-rows-spanned"), 26}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 12, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* boolean-value */
            stat = XmlDec_Ns13_Boolean_value (pctxt, &pvalue->boolean_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.boolean_valuePresent = TRUE;
            break;

         case 1: /* currency */
            stat = XmlDec_Ns13_Currency (pctxt, &pvalue->currency);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.currencyPresent = TRUE;
            break;

         case 2: /* date-value */
            pvalue->date_value = rtxMemAllocType (pctxt, Ns13_Date_value);

            if (pvalue->date_value == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);

            stat = XmlDec_Ns13_Date_value (pctxt, pvalue->date_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.date_valuePresent = TRUE;
            break;

         case 3: /* string-value */
            stat = XmlDec_Ns13_String_value (pctxt, &pvalue->string_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.string_valuePresent = TRUE;
            break;

         case 4: /* time-value */
            stat = XmlDec_Ns13_Time_value (pctxt, &pvalue->time_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.time_valuePresent = TRUE;
            break;

         case 5: /* value */
            stat = XmlDec_Ns13_Value (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         case 6: /* value-type */
            stat = XmlDec_Change_track_table_cell_value_type (pctxt, &pvalue->
               value_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.value_typePresent = TRUE;
            break;

         case 7: /* cell-address */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->cell_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.cell_addressPresent = TRUE;
            break;

         case 8: /* formula */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->formula);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.formulaPresent = TRUE;
            break;

         case 9: /* matrix-covered */
            stat = XmlDec_Change_track_table_cell_matrix_covered (pctxt, &
               pvalue->matrix_covered);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.matrix_coveredPresent = TRUE;
            break;

         case 10: /* number-matrix-columns-spanned */
            stat = rtXmlpDecUInt (pctxt, &pvalue->number_matrix_columns_spanned
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.number_matrix_columns_spannedPresent = TRUE;
            break;

         case 11: /* number-matrix-rows-spanned */
            stat = rtXmlpDecUInt (pctxt, &pvalue->number_matrix_rows_spanned);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.number_matrix_rows_spannedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Change_track_table_cell");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Change_track_table_cell");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("p"), 1}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_P* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_P);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_P ((Odf_P*)pdata1);

            stat = XmlDec_Odf_P (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->p_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cell_content_deletion                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Cell_content_deletion (OSCTXT* pctxt, 
   Cell_content_deletion *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode cell_address */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Cell_address (pctxt, 
               &pvalue->cell_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.cell_addressPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode change_track_table_cell */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Change_track_table_cell (pctxt, 
               &pvalue->change_track_table_cell, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.change_track_table_cellPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Cell_content_deletion (OSCTXT* pctxt, Cell_content_deletion* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("id"), 2}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Cell_content_deletion");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Cell_content_deletion");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("cell-address"), 12}, 0}, 0 },
      {{{OSUTF8("change-track-table-cell"), 23}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* cell-address */
         stat = XmlDec_Cell_address (pctxt, &pvalue->cell_address);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.cell_addressPresent = TRUE;
         break;
      }
      case 1: { /* change-track-table-cell */
         stat = XmlDec_Change_track_table_cell (pctxt, &pvalue->
            change_track_table_cell);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.change_track_table_cellPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Change_deletion                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Change_deletion (OSCTXT* pctxt, Change_deletion *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Change_deletion (OSCTXT* pctxt, Change_deletion* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("id"), 2}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Change_deletion");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Change_deletion");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Deletions_element                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Deletions_element (OSCTXT* pctxt, Deletions_element *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.cell_content_deletion
             = rtxMemAllocType (pctxt, Cell_content_deletion);

         if (pvalue->u.cell_content_deletion == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Cell_content_deletion (pvalue->u.cell_content_deletion);
         stat = asn1D_Cell_content_deletion (pctxt, 
            pvalue->u.cell_content_deletion, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.change_deletion = rtxMemAllocType (pctxt, Change_deletion);

         if (pvalue->u.change_deletion == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Change_deletion (pvalue->u.change_deletion);
         stat = asn1D_Change_deletion (pctxt, 
            pvalue->u.change_deletion, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Deletions_element (OSCTXT* pctxt, Deletions_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("cell-content-deletion"), 21}, 0}, 0 },
      {{{OSUTF8("change-deletion"), 15}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* cell-content-deletion */
      pvalue->u.cell_content_deletion
          = rtxMemAllocType (pctxt, Cell_content_deletion);

      if (pvalue->u.cell_content_deletion == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Cell_content_deletion (pvalue->u.cell_content_deletion);

      stat = XmlDec_Cell_content_deletion (pctxt, pvalue->
         u.cell_content_deletion);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* change-deletion */
      pvalue->u.change_deletion = rtxMemAllocType (pctxt, Change_deletion);

      if (pvalue->u.change_deletion == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Change_deletion (pvalue->u.change_deletion);

      stat = XmlDec_Change_deletion (pctxt, pvalue->u.change_deletion);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Deletions                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Deletions (OSCTXT* pctxt, Deletions *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   Deletions_element* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (XD_PEEKTAG (pctxt, 0x30)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_UNIV|TM_CONS|16));

   if (XD_PEEKTAG (pctxt, 0xa0)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_CTXT|TM_CONS|0));

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      rtxDListAllocNodeAndData (pctxt, Deletions_element, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Deletions_element (pdata1);

      stat = asn1D_Deletions_element (pctxt, 
         pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

int XmlDec_Deletions (OSCTXT* pctxt, Deletions* pvalue)
{
   int stat = 0;

   { int elemID;
   Deletions_element* pdata1;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("cell-content-deletion"), 21}, 0}, 0 },
      {{{OSUTF8("change-deletion"), 15}, 0}, 0 }
   } ;

   rtxDListInit (pvalue);
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, FALSE);
      if (elemID < 0 || elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0:
         rtXmlpMarkLastEventActive (pctxt);

         pdata1 = rtxMemAllocType (pctxt, Deletions_element);

         if (pdata1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Deletions_element (pdata1);

         stat = XmlDec_Deletions_element (pctxt, pdata1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         break;

      }
   }

   if (elemID == RTERR_UNEXPELEM || elemID == XML_OK_EOB) {
      stat = 0;
   }
   else return LOG_RTERR (pctxt, elemID);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Previous                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Previous (OSCTXT* pctxt, Previous *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode change_track_table_cell */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Change_track_table_cell (pctxt, 
               &pvalue->change_track_table_cell, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Previous (OSCTXT* pctxt, Previous* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("id"), 2}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Previous");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Previous");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("change-track-table-cell"), 23}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* change-track-table-cell */
         stat = XmlDec_Change_track_table_cell (pctxt, &pvalue->
            change_track_table_cell);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cell_content_change                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Cell_content_change (OSCTXT* pctxt, 
   Cell_content_change *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode acceptance_state */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Cell_content_change_acceptance_state (pctxt, 
               &pvalue->acceptance_state, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.acceptance_statePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode rejecting_change_id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->rejecting_change_id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.rejecting_change_idPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode cell_address */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Cell_address (pctxt, 
               &pvalue->cell_address, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode change_info */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->change_info = rtxMemAllocType (pctxt, Ns13_Change_info);

            if (pvalue->change_info == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Change_info ((Ns13_Change_info*)pvalue->change_info);
            asn1Init_Ns13_Change_info ((Ns13_Change_info*)pvalue->change_info);

            stat = asn1D_Ns13_Change_info (pctxt, 
               (Ns13_Change_info*)pvalue->change_info, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode dependencies */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Dependencies (pctxt, 
               &pvalue->dependencies, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dependenciesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode deletions */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Deletions (pctxt, 
               &pvalue->deletions, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.deletionsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode previous */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Previous (pctxt, 
               &pvalue->previous, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 4) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Cell_content_change (OSCTXT* pctxt, Cell_content_change* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("acceptance-state"), 16}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("rejecting-change-id"), 19}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* acceptance-state */
            stat = XmlDec_Cell_content_change_acceptance_state (pctxt, &pvalue
               ->acceptance_state);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.acceptance_statePresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* rejecting-change-id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->rejecting_change_id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.rejecting_change_idPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Cell_content_change");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Cell_content_change");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("cell-address"), 12}, 0}, 0 },
      {{{OSUTF8("change-info"), 11}, 0}, 1 },
      {{{OSUTF8("dependencies"), 12}, 0}, 2 },
      {{{OSUTF8("deletions"), 9}, 0}, 3 },
      {{{OSUTF8("previous"), 8}, 0}, 4 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 1, -1}, {2, 3, -1}, {5, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 5; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* cell-address */
         stat = XmlDec_Cell_address (pctxt, &pvalue->cell_address);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* change-info */
         pvalue->change_info = rtxMemAllocType (pctxt, Ns13_Change_info);

         if (pvalue->change_info == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Change_info ((Ns13_Change_info*)pvalue->change_info);

         stat = XmlDec_Ns13_Change_info (pctxt, pvalue->change_info);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 2: { /* dependencies */
         stat = XmlDec_Dependencies (pctxt, &pvalue->dependencies);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dependenciesPresent = TRUE;
         break;
      }
      case 3: { /* deletions */
         stat = XmlDec_Deletions (pctxt, &pvalue->deletions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.deletionsPresent = TRUE;
         break;
      }
      case 4: { /* previous */
         stat = XmlDec_Previous (pctxt, &pvalue->previous);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Insertion                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns15_Insertion (OSCTXT* pctxt, Ns15_Insertion *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode acceptance_state */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Insertion_acceptance_state (pctxt, 
               &pvalue->acceptance_state, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.acceptance_statePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode count */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->count, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.countPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode position */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->position, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode rejecting_change_id */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->rejecting_change_id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.rejecting_change_idPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode table */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->table, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tablePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Insertion_type (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode change_info */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->change_info = rtxMemAllocType (pctxt, Ns13_Change_info);

            if (pvalue->change_info == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Change_info ((Ns13_Change_info*)pvalue->change_info);
            asn1Init_Ns13_Change_info ((Ns13_Change_info*)pvalue->change_info);

            stat = asn1D_Ns13_Change_info (pctxt, 
               (Ns13_Change_info*)pvalue->change_info, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 8:
         /* decode dependencies */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Dependencies (pctxt, 
               &pvalue->dependencies, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dependenciesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode deletions */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Deletions (pctxt, 
               &pvalue->deletions, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.deletionsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 4) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns15_Insertion (OSCTXT* pctxt, Ns15_Insertion* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("acceptance-state"), 16}, 0 },
         { {OSUTF8("count"), 5}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("position"), 8}, 0 },
         { {OSUTF8("rejecting-change-id"), 19}, 0 },
         { {OSUTF8("table"), 5}, 0 },
         { {OSUTF8("type"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 7, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* acceptance-state */
            stat = XmlDec_Insertion_acceptance_state (pctxt, &pvalue->
               acceptance_state);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.acceptance_statePresent = TRUE;
            break;

         case 1: /* count */
            stat = rtXmlpDecUInt (pctxt, &pvalue->count);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.countPresent = TRUE;
            break;

         case 2: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* position */
            stat = rtXmlpDecInt (pctxt, &pvalue->position);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* rejecting-change-id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->rejecting_change_id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.rejecting_change_idPresent = TRUE;
            break;

         case 5: /* table */
            stat = rtXmlpDecInt (pctxt, &pvalue->table);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tablePresent = TRUE;
            break;

         case 6: /* type */
            stat = XmlDec_Insertion_type (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns15_Insertion");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns15_Insertion");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("change-info"), 11}, 0}, 0 },
      {{{OSUTF8("dependencies"), 12}, 0}, 1 },
      {{{OSUTF8("deletions"), 9}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* change-info */
         pvalue->change_info = rtxMemAllocType (pctxt, Ns13_Change_info);

         if (pvalue->change_info == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Change_info ((Ns13_Change_info*)pvalue->change_info);

         stat = XmlDec_Ns13_Change_info (pctxt, pvalue->change_info);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* dependencies */
         stat = XmlDec_Dependencies (pctxt, &pvalue->dependencies);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dependenciesPresent = TRUE;
         break;
      }
      case 2: { /* deletions */
         stat = XmlDec_Deletions (pctxt, &pvalue->deletions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.deletionsPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Movement_cut_off                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Movement_cut_off (OSCTXT* pctxt, Movement_cut_off *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode end_position */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->end_position, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_positionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode position */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->position, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.positionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode start_position */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->start_position, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.start_positionPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Movement_cut_off (OSCTXT* pctxt, Movement_cut_off* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("end-position"), 12}, 0 },
         { {OSUTF8("position"), 8}, 0 },
         { {OSUTF8("start-position"), 14}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* end-position */
            stat = rtXmlpDecInt (pctxt, &pvalue->end_position);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_positionPresent = TRUE;
            break;

         case 1: /* position */
            stat = rtXmlpDecInt (pctxt, &pvalue->position);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.positionPresent = TRUE;
            break;

         case 2: /* start-position */
            stat = rtXmlpDecInt (pctxt, &pvalue->start_position);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.start_positionPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Movement_cut_off");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Movement_cut_off");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Insertion_cut_off                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Insertion_cut_off (OSCTXT* pctxt, Insertion_cut_off *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode position */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->position, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Insertion_cut_off (OSCTXT* pctxt, Insertion_cut_off* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("position"), 8}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* position */
            stat = rtXmlpDecInt (pctxt, &pvalue->position);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Insertion_cut_off");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Insertion_cut_off");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cut_offs_sequence                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Cut_offs_sequence (OSCTXT* pctxt, Cut_offs_sequence *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode insertion_cut_off */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Insertion_cut_off (pctxt, 
               &pvalue->insertion_cut_off, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode movement_cut_off_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Movement_cut_off* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->movement_cut_off_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Movement_cut_off, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Movement_cut_off (pdata2);

                  stat = asn1D_Movement_cut_off (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->movement_cut_off_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Cut_offs_sequence (OSCTXT* pctxt, Cut_offs_sequence* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("insertion-cut-off"), 17}, 0}, 0 },
      {{{OSUTF8("movement-cut-off"), 16}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* insertion-cut-off */
         stat = XmlDec_Insertion_cut_off (pctxt, &pvalue->insertion_cut_off);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: {
         Movement_cut_off* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Movement_cut_off);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Movement_cut_off (pdata1);

            stat = XmlDec_Movement_cut_off (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->movement_cut_off_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Cut_offs                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Cut_offs (OSCTXT* pctxt, Cut_offs *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   if (tagging == ASN1EXPL) {
      if (XD_PEEKTAG (pctxt, 0x30)) {
         stat = xd_Tag1AndLen (pctxt, &length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else return LOG_RTERR (pctxt,
         berErrUnexpTag(pctxt, TM_UNIV|TM_CONS|16));
   }

   if (XD_PEEKTAG (pctxt, 0xa0)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_CTXT|TM_CONS|0));

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.movement_cut_off_list = rtxMemAllocType (pctxt, OSRTDList);

         if (pvalue->u.movement_cut_off_list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         rtxDListFastInit (pvalue->u.movement_cut_off_list);
         /* decode inline SEQUENCE OF type */
         {
            int stat = 0;
            Movement_cut_off* pdata2;
            OSRTDListNode* pnode;
            ASN1CCB ccb;

            /* decode SEQUENCE OF or SET OF */

            rtxDListInit (pvalue->u.movement_cut_off_list);

            ccb.len = length;
            ccb.ptr = OSRTBUFPTR(pctxt);

            while (!XD_CHKEND (pctxt, &ccb))
            {
               rtxDListAllocNodeAndData (pctxt, Movement_cut_off, &pnode, &pdata2);

               if (pnode == NULL)
                  return LOG_RTERR (pctxt, RTERR_NOMEM);

               asn1Init_Movement_cut_off (pdata2);

               stat = asn1D_Movement_cut_off (pctxt, 
                  pdata2, ASN1EXPL, length);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               rtxDListAppendNode (pvalue->u.movement_cut_off_list, pnode);
            }

         }
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.sequence = rtxMemAllocType (pctxt, Cut_offs_sequence);

         if (pvalue->u.sequence == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Cut_offs_sequence (pvalue->u.sequence);
         stat = asn1D_Cut_offs_sequence (pctxt, 
            pvalue->u.sequence, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Cut_offs (OSCTXT* pctxt, Cut_offs* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("movement-cut-off"), 16}, 0}, 0 },
      {{{OSUTF8("insertion-cut-off"), 17}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: {
      Movement_cut_off* pdata1;

      pvalue->u.movement_cut_off_list = rtxMemAllocType (pctxt, OSRTDList);
      rtxDListInit (pvalue->u.movement_cut_off_list);

      do {
         pdata1 = rtxMemAllocType (pctxt, Movement_cut_off);

         if (pdata1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Movement_cut_off (pdata1);

         stat = XmlDec_Movement_cut_off (pctxt, pdata1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, pvalue->u.movement_cut_off_list
            , (void*)pdata1);

         stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
         if (stat < 0 && stat != RTERR_UNEXPELEM)
            return LOG_RTERR (pctxt, stat);
      }
      while (stat == 0);

      rtXmlpMarkLastEventActive (pctxt);
      stat = 0;
      break;
   }
   case 1: { /*  */
      pvalue->u.sequence = rtxMemAllocType (pctxt, Cut_offs_sequence);

      if (pvalue->u.sequence == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Cut_offs_sequence (pvalue->u.sequence);

      stat = XmlDec_Cut_offs_sequence (pctxt, pvalue->u.sequence);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Deletion                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns15_Deletion (OSCTXT* pctxt, Ns15_Deletion *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode acceptance_state */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Deletion_acceptance_state (pctxt, 
               &pvalue->acceptance_state, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.acceptance_statePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode multi_deletion_spanned */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->multi_deletion_spanned, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.multi_deletion_spannedPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode position */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->position, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode rejecting_change_id */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->rejecting_change_id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.rejecting_change_idPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode table */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->table, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tablePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Deletion_type (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode change_info */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->change_info = rtxMemAllocType (pctxt, Ns13_Change_info);

            if (pvalue->change_info == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Change_info ((Ns13_Change_info*)pvalue->change_info);
            asn1Init_Ns13_Change_info ((Ns13_Change_info*)pvalue->change_info);

            stat = asn1D_Ns13_Change_info (pctxt, 
               (Ns13_Change_info*)pvalue->change_info, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 8:
         /* decode dependencies */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Dependencies (pctxt, 
               &pvalue->dependencies, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dependenciesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode deletions */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Deletions (pctxt, 
               &pvalue->deletions, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.deletionsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 10:
         /* decode cut_offs */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Cut_offs (pctxt, 
               &pvalue->cut_offs, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.cut_offsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 4) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns15_Deletion (OSCTXT* pctxt, Ns15_Deletion* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("acceptance-state"), 16}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("multi-deletion-spanned"), 22}, 0 },
         { {OSUTF8("position"), 8}, 0 },
         { {OSUTF8("rejecting-change-id"), 19}, 0 },
         { {OSUTF8("table"), 5}, 0 },
         { {OSUTF8("type"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 7, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* acceptance-state */
            stat = XmlDec_Deletion_acceptance_state (pctxt, &pvalue->
               acceptance_state);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.acceptance_statePresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* multi-deletion-spanned */
            stat = rtXmlpDecInt (pctxt, &pvalue->multi_deletion_spanned);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.multi_deletion_spannedPresent = TRUE;
            break;

         case 3: /* position */
            stat = rtXmlpDecInt (pctxt, &pvalue->position);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* rejecting-change-id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->rejecting_change_id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.rejecting_change_idPresent = TRUE;
            break;

         case 5: /* table */
            stat = rtXmlpDecInt (pctxt, &pvalue->table);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tablePresent = TRUE;
            break;

         case 6: /* type */
            stat = XmlDec_Deletion_type (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns15_Deletion");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns15_Deletion");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("change-info"), 11}, 0}, 0 },
      {{{OSUTF8("dependencies"), 12}, 0}, 1 },
      {{{OSUTF8("deletions"), 9}, 0}, 2 },
      {{{OSUTF8("cut-offs"), 8}, 0}, 3 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 3, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 4; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* change-info */
         pvalue->change_info = rtxMemAllocType (pctxt, Ns13_Change_info);

         if (pvalue->change_info == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Change_info ((Ns13_Change_info*)pvalue->change_info);

         stat = XmlDec_Ns13_Change_info (pctxt, pvalue->change_info);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* dependencies */
         stat = XmlDec_Dependencies (pctxt, &pvalue->dependencies);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dependenciesPresent = TRUE;
         break;
      }
      case 2: { /* deletions */
         stat = XmlDec_Deletions (pctxt, &pvalue->deletions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.deletionsPresent = TRUE;
         break;
      }
      case 3: { /* cut-offs */
         stat = XmlDec_Cut_offs (pctxt, &pvalue->cut_offs);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.cut_offsPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Source_range_address                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Source_range_address (OSCTXT* pctxt, 
   Source_range_address *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode column */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->column, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.columnPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode end_column */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->end_column, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_columnPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode end_row */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->end_row, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_rowPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode end_table */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->end_table, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_tablePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode row */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->row, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.rowPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode start_column */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->start_column, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.start_columnPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode start_row */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->start_row, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.start_rowPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode start_table */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->start_table, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.start_tablePresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode table */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->table, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tablePresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Source_range_address (OSCTXT* pctxt, Source_range_address* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("column"), 6}, 0 },
         { {OSUTF8("end-column"), 10}, 0 },
         { {OSUTF8("end-row"), 7}, 0 },
         { {OSUTF8("end-table"), 9}, 0 },
         { {OSUTF8("row"), 3}, 0 },
         { {OSUTF8("start-column"), 12}, 0 },
         { {OSUTF8("start-row"), 9}, 0 },
         { {OSUTF8("start-table"), 11}, 0 },
         { {OSUTF8("table"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 9, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* column */
            stat = rtXmlpDecInt (pctxt, &pvalue->column);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.columnPresent = TRUE;
            break;

         case 1: /* end-column */
            stat = rtXmlpDecInt (pctxt, &pvalue->end_column);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_columnPresent = TRUE;
            break;

         case 2: /* end-row */
            stat = rtXmlpDecInt (pctxt, &pvalue->end_row);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_rowPresent = TRUE;
            break;

         case 3: /* end-table */
            stat = rtXmlpDecInt (pctxt, &pvalue->end_table);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_tablePresent = TRUE;
            break;

         case 4: /* row */
            stat = rtXmlpDecInt (pctxt, &pvalue->row);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.rowPresent = TRUE;
            break;

         case 5: /* start-column */
            stat = rtXmlpDecInt (pctxt, &pvalue->start_column);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.start_columnPresent = TRUE;
            break;

         case 6: /* start-row */
            stat = rtXmlpDecInt (pctxt, &pvalue->start_row);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.start_rowPresent = TRUE;
            break;

         case 7: /* start-table */
            stat = rtXmlpDecInt (pctxt, &pvalue->start_table);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.start_tablePresent = TRUE;
            break;

         case 8: /* table */
            stat = rtXmlpDecInt (pctxt, &pvalue->table);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tablePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Source_range_address");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Source_range_address");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Target_range_address                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Target_range_address (OSCTXT* pctxt, 
   Target_range_address *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode column */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->column, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.columnPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode end_column */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->end_column, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_columnPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode end_row */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->end_row, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_rowPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode end_table */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->end_table, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_tablePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode row */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->row, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.rowPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode start_column */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->start_column, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.start_columnPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode start_row */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->start_row, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.start_rowPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode start_table */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->start_table, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.start_tablePresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode table */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->table, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tablePresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Target_range_address (OSCTXT* pctxt, Target_range_address* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("column"), 6}, 0 },
         { {OSUTF8("end-column"), 10}, 0 },
         { {OSUTF8("end-row"), 7}, 0 },
         { {OSUTF8("end-table"), 9}, 0 },
         { {OSUTF8("row"), 3}, 0 },
         { {OSUTF8("start-column"), 12}, 0 },
         { {OSUTF8("start-row"), 9}, 0 },
         { {OSUTF8("start-table"), 11}, 0 },
         { {OSUTF8("table"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 9, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* column */
            stat = rtXmlpDecInt (pctxt, &pvalue->column);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.columnPresent = TRUE;
            break;

         case 1: /* end-column */
            stat = rtXmlpDecInt (pctxt, &pvalue->end_column);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_columnPresent = TRUE;
            break;

         case 2: /* end-row */
            stat = rtXmlpDecInt (pctxt, &pvalue->end_row);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_rowPresent = TRUE;
            break;

         case 3: /* end-table */
            stat = rtXmlpDecInt (pctxt, &pvalue->end_table);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_tablePresent = TRUE;
            break;

         case 4: /* row */
            stat = rtXmlpDecInt (pctxt, &pvalue->row);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.rowPresent = TRUE;
            break;

         case 5: /* start-column */
            stat = rtXmlpDecInt (pctxt, &pvalue->start_column);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.start_columnPresent = TRUE;
            break;

         case 6: /* start-row */
            stat = rtXmlpDecInt (pctxt, &pvalue->start_row);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.start_rowPresent = TRUE;
            break;

         case 7: /* start-table */
            stat = rtXmlpDecInt (pctxt, &pvalue->start_table);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.start_tablePresent = TRUE;
            break;

         case 8: /* table */
            stat = rtXmlpDecInt (pctxt, &pvalue->table);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tablePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Target_range_address");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Target_range_address");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Movement                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Movement (OSCTXT* pctxt, Movement *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode acceptance_state */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Movement_acceptance_state (pctxt, 
               &pvalue->acceptance_state, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.acceptance_statePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode rejecting_change_id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->rejecting_change_id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.rejecting_change_idPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode source_range_address */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Source_range_address (pctxt, 
               &pvalue->source_range_address, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode target_range_address */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Target_range_address (pctxt, 
               &pvalue->target_range_address, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode change_info */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->change_info = rtxMemAllocType (pctxt, Ns13_Change_info);

            if (pvalue->change_info == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Change_info ((Ns13_Change_info*)pvalue->change_info);
            asn1Init_Ns13_Change_info ((Ns13_Change_info*)pvalue->change_info);

            stat = asn1D_Ns13_Change_info (pctxt, 
               (Ns13_Change_info*)pvalue->change_info, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode dependencies */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Dependencies (pctxt, 
               &pvalue->dependencies, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dependenciesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode deletions */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Deletions (pctxt, 
               &pvalue->deletions, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.deletionsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 4) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Movement (OSCTXT* pctxt, Movement* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("acceptance-state"), 16}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("rejecting-change-id"), 19}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* acceptance-state */
            stat = XmlDec_Movement_acceptance_state (pctxt, &pvalue->
               acceptance_state);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.acceptance_statePresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* rejecting-change-id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->rejecting_change_id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.rejecting_change_idPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Movement");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Movement");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("source-range-address"), 20}, 0}, 0 },
      {{{OSUTF8("target-range-address"), 20}, 0}, 1 },
      {{{OSUTF8("change-info"), 11}, 0}, 2 },
      {{{OSUTF8("dependencies"), 12}, 0}, 3 },
      {{{OSUTF8("deletions"), 9}, 0}, 4 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 1, -1}, {2, 1, -1}, {3, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 5; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* source-range-address */
         stat = XmlDec_Source_range_address (pctxt, &pvalue->
            source_range_address);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* target-range-address */
         stat = XmlDec_Target_range_address (pctxt, &pvalue->
            target_range_address);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 2: { /* change-info */
         pvalue->change_info = rtxMemAllocType (pctxt, Ns13_Change_info);

         if (pvalue->change_info == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Change_info ((Ns13_Change_info*)pvalue->change_info);

         stat = XmlDec_Ns13_Change_info (pctxt, pvalue->change_info);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 3: { /* dependencies */
         stat = XmlDec_Dependencies (pctxt, &pvalue->dependencies);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dependenciesPresent = TRUE;
         break;
      }
      case 4: { /* deletions */
         stat = XmlDec_Deletions (pctxt, &pvalue->deletions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.deletionsPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Tracked_changes_element                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Tracked_changes_element (OSCTXT* pctxt, 
   Tracked_changes_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.cell_content_change
             = rtxMemAllocType (pctxt, Cell_content_change);

         if (pvalue->u.cell_content_change == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Cell_content_change (pvalue->u.cell_content_change);
         stat = asn1D_Cell_content_change (pctxt, 
            pvalue->u.cell_content_change, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.insertion = rtxMemAllocType (pctxt, Ns15_Insertion);

         if (pvalue->u.insertion == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns15_Insertion (pvalue->u.insertion);
         stat = asn1D_Ns15_Insertion (pctxt, 
            pvalue->u.insertion, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.deletion = rtxMemAllocType (pctxt, Ns15_Deletion);

         if (pvalue->u.deletion == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns15_Deletion (pvalue->u.deletion);
         stat = asn1D_Ns15_Deletion (pctxt, 
            pvalue->u.deletion, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.movement = rtxMemAllocType (pctxt, Movement);

         if (pvalue->u.movement == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Movement (pvalue->u.movement);
         stat = asn1D_Movement (pctxt, 
            pvalue->u.movement, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Tracked_changes_element (OSCTXT* pctxt, 
   Tracked_changes_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("cell-content-change"), 19}, 0}, 0 },
      {{{OSUTF8("insertion"), 9}, 0}, 1 },
      {{{OSUTF8("deletion"), 8}, 0}, 2 },
      {{{OSUTF8("movement"), 8}, 0}, 3 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 4, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* cell-content-change */
      pvalue->u.cell_content_change
          = rtxMemAllocType (pctxt, Cell_content_change);

      if (pvalue->u.cell_content_change == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Cell_content_change (pvalue->u.cell_content_change);

      stat = XmlDec_Cell_content_change (pctxt, pvalue->u.cell_content_change
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* insertion */
      pvalue->u.insertion = rtxMemAllocType (pctxt, Ns15_Insertion);

      if (pvalue->u.insertion == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns15_Insertion (pvalue->u.insertion);

      stat = XmlDec_Ns15_Insertion (pctxt, pvalue->u.insertion);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* deletion */
      pvalue->u.deletion = rtxMemAllocType (pctxt, Ns15_Deletion);

      if (pvalue->u.deletion == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns15_Deletion (pvalue->u.deletion);

      stat = XmlDec_Ns15_Deletion (pctxt, pvalue->u.deletion);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* movement */
      pvalue->u.movement = rtxMemAllocType (pctxt, Movement);

      if (pvalue->u.movement == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Movement (pvalue->u.movement);

      stat = XmlDec_Movement (pctxt, pvalue->u.movement);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Tracked_changes                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns15_Tracked_changes (OSCTXT* pctxt, 
   Ns15_Tracked_changes *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode track_changes */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns15_Tracked_changes_track_changes (pctxt, 
               &pvalue->track_changes, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.track_changesPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Tracked_changes_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Tracked_changes_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Tracked_changes_element (pdata2);

                  stat = asn1D_Tracked_changes_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns15_Tracked_changes (OSCTXT* pctxt, Ns15_Tracked_changes* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("track-changes"), 13}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* track-changes */
            stat = XmlDec_Ns15_Tracked_changes_track_changes (pctxt, &pvalue->
               track_changes);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.track_changesPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns15_Tracked_changes");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns15_Tracked_changes");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("cell-content-change"), 19}, 0}, 0 },
      {{{OSUTF8("insertion"), 9}, 0}, 0 },
      {{{OSUTF8("deletion"), 8}, 0}, 0 },
      {{{OSUTF8("movement"), 8}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Tracked_changes_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Tracked_changes_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Tracked_changes_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Tracked_changes_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 4, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

int XmlDec_Ns15_Tracked_changes_PDU (OSCTXT* pctxt, Ns15_Tracked_changes* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   asn1Init_Ns15_Tracked_changes (pvalue);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("tracked-changes"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_Ns15_Tracked_changes (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
