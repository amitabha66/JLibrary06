/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "Odf.h"
#include "Ns8.h"
#include "Ns13.h"
#include "Ns4.h"
#include "Ns15.h"
#include "Ns3.h"
#include "Ns7.h"
#include "Ns10.h"
#include "rtxsrc/rtxCommon.h"

/**************************************************************/
/*                                                            */
/*  Element446                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Element446 (OSCTXT* pctxt, Odf_Element446 *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   if (tagging == ASN1EXPL) {
      if (XD_PEEKTAG (pctxt, 0x30)) {
         stat = xd_Tag1AndLen (pctxt, &length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else return LOG_RTERR (pctxt,
         berErrUnexpTag(pctxt, TM_UNIV|TM_CONS|16));
   }

   if (XD_PEEKTAG (pctxt, 0x80)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_CTXT|TM_PRIM|0));

   tagging = ASN1IMPL;
   if (XD_PEEKPC (pctxt)) {
      pvalue->u.binary = rtxMemAllocType (pctxt, OSOpenType);
      stat = xd_OpenType (pctxt, &pvalue->u.binary->data,
         &pvalue->u.binary->numocts);
      pvalue->t = OSXSDAny_binary;
   } else {
      stat = xd_utf8str (pctxt, &pvalue->u.xmlText, tagging, length);
      pvalue->t = OSXSDAny_xmlText;
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Element446 (OSCTXT* pctxt, Odf_Element446* pvalue)
{
   int stat = 0;

   /* decode xsd:any element as XML text */
   stat = rtXmlpDecAny (pctxt, &pvalue->u.xmlText);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->t = OSXSDAny_xmlText;

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Element14                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Element14 (OSCTXT* pctxt, Odf_Element14 *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   if (tagging == ASN1EXPL) {
      if (XD_PEEKTAG (pctxt, 0x30)) {
         stat = xd_Tag1AndLen (pctxt, &length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else return LOG_RTERR (pctxt,
         berErrUnexpTag(pctxt, TM_UNIV|TM_CONS|16));
   }

   if (XD_PEEKTAG (pctxt, 0x80)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_CTXT|TM_PRIM|0));

   tagging = ASN1IMPL;
   if (XD_PEEKPC (pctxt)) {
      pvalue->u.binary = rtxMemAllocType (pctxt, OSOpenType);
      stat = xd_OpenType (pctxt, &pvalue->u.binary->data,
         &pvalue->u.binary->numocts);
      pvalue->t = OSXSDAny_binary;
   } else {
      stat = xd_utf8str (pctxt, &pvalue->u.xmlText, tagging, length);
      pvalue->t = OSXSDAny_xmlText;
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Element14 (OSCTXT* pctxt, Odf_Element14* pvalue)
{
   int stat = 0;

   /* decode xsd:any element as XML text */
   stat = rtXmlpDecAny (pctxt, &pvalue->u.xmlText);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->t = OSXSDAny_xmlText;

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Note_continuation_notice_forward                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Note_continuation_notice_forward (OSCTXT* pctxt, 
   Odf_Note_continuation_notice_forward *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Note_continuation_notice_forward (OSCTXT* pctxt, 
   Odf_Note_continuation_notice_forward* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Note_continuation_notice_backward                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Note_continuation_notice_backward (OSCTXT* pctxt, 
   Odf_Note_continuation_notice_backward *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Note_continuation_notice_backward (OSCTXT* pctxt, 
   Odf_Note_continuation_notice_backward* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Number                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Number (OSCTXT* pctxt, Odf_Number *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Number (OSCTXT* pctxt, Odf_Number* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sheet_name                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sheet_name (OSCTXT* pctxt, Odf_Sheet_name *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Sheet_name (OSCTXT* pctxt, Odf_Sheet_name* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Page_count                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Page_count (OSCTXT* pctxt, Odf_Page_count *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   if (XD_PEEKPC (pctxt)) {
      pvalue->u.binary = rtxMemAllocType (pctxt, OSOpenType);
      stat = xd_OpenType (pctxt, &pvalue->u.binary->data,
         &pvalue->u.binary->numocts);
      pvalue->t = OSXSDAny_binary;
   } else {
      stat = xd_utf8str (pctxt, &pvalue->u.xmlText, tagging, length);
      pvalue->t = OSXSDAny_xmlText;
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Page_count (OSCTXT* pctxt, Odf_Page_count* pvalue)
{
   int stat = 0;

   /* decode xsd:any element as XML text */
   stat = rtXmlpDecAny (pctxt, &pvalue->u.xmlText);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->t = OSXSDAny_xmlText;

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Paragraph_count                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Paragraph_count (OSCTXT* pctxt, 
   Odf_Paragraph_count *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   if (XD_PEEKPC (pctxt)) {
      pvalue->u.binary = rtxMemAllocType (pctxt, OSOpenType);
      stat = xd_OpenType (pctxt, &pvalue->u.binary->data,
         &pvalue->u.binary->numocts);
      pvalue->t = OSXSDAny_binary;
   } else {
      stat = xd_utf8str (pctxt, &pvalue->u.xmlText, tagging, length);
      pvalue->t = OSXSDAny_xmlText;
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Paragraph_count (OSCTXT* pctxt, Odf_Paragraph_count* pvalue)
{
   int stat = 0;

   /* decode xsd:any element as XML text */
   stat = rtXmlpDecAny (pctxt, &pvalue->u.xmlText);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->t = OSXSDAny_xmlText;

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Word_count                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Word_count (OSCTXT* pctxt, Odf_Word_count *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   if (XD_PEEKPC (pctxt)) {
      pvalue->u.binary = rtxMemAllocType (pctxt, OSOpenType);
      stat = xd_OpenType (pctxt, &pvalue->u.binary->data,
         &pvalue->u.binary->numocts);
      pvalue->t = OSXSDAny_binary;
   } else {
      stat = xd_utf8str (pctxt, &pvalue->u.xmlText, tagging, length);
      pvalue->t = OSXSDAny_xmlText;
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Word_count (OSCTXT* pctxt, Odf_Word_count* pvalue)
{
   int stat = 0;

   /* decode xsd:any element as XML text */
   stat = rtXmlpDecAny (pctxt, &pvalue->u.xmlText);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->t = OSXSDAny_xmlText;

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Character_count                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Character_count (OSCTXT* pctxt, 
   Odf_Character_count *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   if (XD_PEEKPC (pctxt)) {
      pvalue->u.binary = rtxMemAllocType (pctxt, OSOpenType);
      stat = xd_OpenType (pctxt, &pvalue->u.binary->data,
         &pvalue->u.binary->numocts);
      pvalue->t = OSXSDAny_binary;
   } else {
      stat = xd_utf8str (pctxt, &pvalue->u.xmlText, tagging, length);
      pvalue->t = OSXSDAny_xmlText;
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Character_count (OSCTXT* pctxt, Odf_Character_count* pvalue)
{
   int stat = 0;

   /* decode xsd:any element as XML text */
   stat = rtXmlpDecAny (pctxt, &pvalue->u.xmlText);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->t = OSXSDAny_xmlText;

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_count                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Table_count (OSCTXT* pctxt, Odf_Table_count *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   if (XD_PEEKPC (pctxt)) {
      pvalue->u.binary = rtxMemAllocType (pctxt, OSOpenType);
      stat = xd_OpenType (pctxt, &pvalue->u.binary->data,
         &pvalue->u.binary->numocts);
      pvalue->t = OSXSDAny_binary;
   } else {
      stat = xd_utf8str (pctxt, &pvalue->u.xmlText, tagging, length);
      pvalue->t = OSXSDAny_xmlText;
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Table_count (OSCTXT* pctxt, Odf_Table_count* pvalue)
{
   int stat = 0;

   /* decode xsd:any element as XML text */
   stat = rtXmlpDecAny (pctxt, &pvalue->u.xmlText);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->t = OSXSDAny_xmlText;

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Image_count                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Image_count (OSCTXT* pctxt, Odf_Image_count *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   if (XD_PEEKPC (pctxt)) {
      pvalue->u.binary = rtxMemAllocType (pctxt, OSOpenType);
      stat = xd_OpenType (pctxt, &pvalue->u.binary->data,
         &pvalue->u.binary->numocts);
      pvalue->t = OSXSDAny_binary;
   } else {
      stat = xd_utf8str (pctxt, &pvalue->u.xmlText, tagging, length);
      pvalue->t = OSXSDAny_xmlText;
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Image_count (OSCTXT* pctxt, Odf_Image_count* pvalue)
{
   int stat = 0;

   /* decode xsd:any element as XML text */
   stat = rtXmlpDecAny (pctxt, &pvalue->u.xmlText);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->t = OSXSDAny_xmlText;

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Object_count                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Object_count (OSCTXT* pctxt, Odf_Object_count *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   if (XD_PEEKPC (pctxt)) {
      pvalue->u.binary = rtxMemAllocType (pctxt, OSOpenType);
      stat = xd_OpenType (pctxt, &pvalue->u.binary->data,
         &pvalue->u.binary->numocts);
      pvalue->t = OSXSDAny_binary;
   } else {
      stat = xd_utf8str (pctxt, &pvalue->u.xmlText, tagging, length);
      pvalue->t = OSXSDAny_xmlText;
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Object_count (OSCTXT* pctxt, Odf_Object_count* pvalue)
{
   int stat = 0;

   /* decode xsd:any element as XML text */
   stat = rtXmlpDecAny (pctxt, &pvalue->u.xmlText);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->t = OSXSDAny_xmlText;

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reference_ref                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Reference_ref (OSCTXT* pctxt, Odf_Reference_ref *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   if (XD_PEEKPC (pctxt)) {
      pvalue->u.binary = rtxMemAllocType (pctxt, OSOpenType);
      stat = xd_OpenType (pctxt, &pvalue->u.binary->data,
         &pvalue->u.binary->numocts);
      pvalue->t = OSXSDAny_binary;
   } else {
      stat = xd_utf8str (pctxt, &pvalue->u.xmlText, tagging, length);
      pvalue->t = OSXSDAny_xmlText;
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Reference_ref (OSCTXT* pctxt, Odf_Reference_ref* pvalue)
{
   int stat = 0;

   /* decode xsd:any element as XML text */
   stat = rtXmlpDecAny (pctxt, &pvalue->u.xmlText);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->t = OSXSDAny_xmlText;

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Bookmark_ref                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Bookmark_ref (OSCTXT* pctxt, Odf_Bookmark_ref *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   if (XD_PEEKPC (pctxt)) {
      pvalue->u.binary = rtxMemAllocType (pctxt, OSOpenType);
      stat = xd_OpenType (pctxt, &pvalue->u.binary->data,
         &pvalue->u.binary->numocts);
      pvalue->t = OSXSDAny_binary;
   } else {
      stat = xd_utf8str (pctxt, &pvalue->u.xmlText, tagging, length);
      pvalue->t = OSXSDAny_xmlText;
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Bookmark_ref (OSCTXT* pctxt, Odf_Bookmark_ref* pvalue)
{
   int stat = 0;

   /* decode xsd:any element as XML text */
   stat = rtXmlpDecAny (pctxt, &pvalue->u.xmlText);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->t = OSXSDAny_xmlText;

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Global                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Global (OSCTXT* pctxt, Odf_Global *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Global (OSCTXT* pctxt, Odf_Global* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Global_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Anchor_type                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Anchor_type (OSCTXT* pctxt, Odf_Anchor_type *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Anchor_type (OSCTXT* pctxt, Odf_Anchor_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Anchor_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Anchor_page_number                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Anchor_page_number (OSCTXT* pctxt, 
   Odf_Anchor_page_number *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_unsigned (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Anchor_page_number (OSCTXT* pctxt, 
   Odf_Anchor_page_number* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecUInt (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  List_style_consecutive_numbering                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_List_style_consecutive_numbering (OSCTXT* pctxt, 
   Odf_List_style_consecutive_numbering *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_List_style_consecutive_numbering (OSCTXT* pctxt, 
   Odf_List_style_consecutive_numbering* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_List_style_consecutive_numbering_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Notes_configuration_footnotes_position                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Notes_configuration_footnotes_position (OSCTXT* pctxt, 
   Odf_Notes_configuration_footnotes_position *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Notes_configuration_footnotes_position (OSCTXT* pctxt, 
   Odf_Notes_configuration_footnotes_position* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Notes_configuration_footnotes_position_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Notes_configuration_note_class                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Notes_configuration_note_class (OSCTXT* pctxt, 
   Odf_Notes_configuration_note_class *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Notes_configuration_note_class (OSCTXT* pctxt, 
   Odf_Notes_configuration_note_class* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Notes_configuration_note_class_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Notes_configuration_start_numbering_at                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Notes_configuration_start_numbering_at (OSCTXT* pctxt, 
   Odf_Notes_configuration_start_numbering_at *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Notes_configuration_start_numbering_at (OSCTXT* pctxt, 
   Odf_Notes_configuration_start_numbering_at* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Notes_configuration_start_numbering_at_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Bibliography_configuration_numbered_entries               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Bibliography_configuration_numbered_entries (
   OSCTXT* pctxt, Odf_Bibliography_configuration_numbered_entries *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Bibliography_configuration_numbered_entries (OSCTXT* pctxt, 
   Odf_Bibliography_configuration_numbered_entries* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Bibliography_configuration_numbered_entries_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Bibliography_configuration_sort_by_position               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Bibliography_configuration_sort_by_position (
   OSCTXT* pctxt, Odf_Bibliography_configuration_sort_by_position *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Bibliography_configuration_sort_by_position (OSCTXT* pctxt, 
   Odf_Bibliography_configuration_sort_by_position* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Bibliography_configuration_sort_by_position_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Linenumbering_configuration_count_empty_lines             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Linenumbering_configuration_count_empty_lines (
   OSCTXT* pctxt, Odf_Linenumbering_configuration_count_empty_lines *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Linenumbering_configuration_count_empty_lines (OSCTXT* pctxt, 
   Odf_Linenumbering_configuration_count_empty_lines* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Linenumbering_configuration_count_empty_lines_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Linenumbering_configuration_count_in_text_boxes           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Linenumbering_configuration_count_in_text_boxes (
   OSCTXT* pctxt, Odf_Linenumbering_configuration_count_in_text_boxes *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Linenumbering_configuration_count_in_text_boxes (OSCTXT* pctxt, 
   Odf_Linenumbering_configuration_count_in_text_boxes* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Linenumbering_configuration_count_in_text_boxes_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Linenumbering_configuration_number_lines                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Linenumbering_configuration_number_lines (OSCTXT* pctxt, 
   Odf_Linenumbering_configuration_number_lines *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Linenumbering_configuration_number_lines (OSCTXT* pctxt, 
   Odf_Linenumbering_configuration_number_lines* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Linenumbering_configuration_number_lines_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Linenumbering_configuration_number_position               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Linenumbering_configuration_number_position (
   OSCTXT* pctxt, Odf_Linenumbering_configuration_number_position *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Linenumbering_configuration_number_position (OSCTXT* pctxt, 
   Odf_Linenumbering_configuration_number_position* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Linenumbering_configuration_number_position_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Linenumbering_configuration_restart_on_page               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Linenumbering_configuration_restart_on_page (
   OSCTXT* pctxt, Odf_Linenumbering_configuration_restart_on_page *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Linenumbering_configuration_restart_on_page (OSCTXT* pctxt, 
   Odf_Linenumbering_configuration_restart_on_page* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Linenumbering_configuration_restart_on_page_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  List_level_style_image_actuate                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_List_level_style_image_actuate (OSCTXT* pctxt, 
   Odf_List_level_style_image_actuate *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_List_level_style_image_actuate (OSCTXT* pctxt, 
   Odf_List_level_style_image_actuate* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_List_level_style_image_actuate_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  List_level_style_image_show                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_List_level_style_image_show (OSCTXT* pctxt, 
   Odf_List_level_style_image_show *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_List_level_style_image_show (OSCTXT* pctxt, 
   Odf_List_level_style_image_show* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_List_level_style_image_show_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sort_key_key                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sort_key_key (OSCTXT* pctxt, Odf_Sort_key_key *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Sort_key_key (OSCTXT* pctxt, Odf_Sort_key_key* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Sort_key_key_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sort_key_sort_ascending                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sort_key_sort_ascending (OSCTXT* pctxt, 
   Odf_Sort_key_sort_ascending *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Sort_key_sort_ascending (OSCTXT* pctxt, 
   Odf_Sort_key_sort_ascending* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Sort_key_sort_ascending_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Tracked_changes_track_changes                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Tracked_changes_track_changes (OSCTXT* pctxt, 
   Odf_Tracked_changes_track_changes *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Tracked_changes_track_changes (OSCTXT* pctxt, 
   Odf_Tracked_changes_track_changes* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Tracked_changes_track_changes_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H_is_list_header                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_H_is_list_header (OSCTXT* pctxt, 
   Odf_H_is_list_header *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_H_is_list_header (OSCTXT* pctxt, Odf_H_is_list_header* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_H_is_list_header_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H_restart_numbering                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_H_restart_numbering (OSCTXT* pctxt, 
   Odf_H_restart_numbering *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_H_restart_numbering (OSCTXT* pctxt, 
   Odf_H_restart_numbering* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_H_restart_numbering_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  List_continue_numbering                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_List_continue_numbering (OSCTXT* pctxt, 
   Odf_List_continue_numbering *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_List_continue_numbering (OSCTXT* pctxt, 
   Odf_List_continue_numbering* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_List_continue_numbering_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Numbered_paragraph_continue_numbering                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Numbered_paragraph_continue_numbering (OSCTXT* pctxt, 
   Odf_Numbered_paragraph_continue_numbering *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Numbered_paragraph_continue_numbering (OSCTXT* pctxt, 
   Odf_Numbered_paragraph_continue_numbering* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Numbered_paragraph_continue_numbering_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Section_display                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Section_display (OSCTXT* pctxt, 
   Odf_Section_display *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Section_display (OSCTXT* pctxt, Odf_Section_display* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Section_display_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Section_protected_                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Section_protected_ (OSCTXT* pctxt, 
   Odf_Section_protected_ *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Section_protected_ (OSCTXT* pctxt, 
   Odf_Section_protected_* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Section_protected__ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_of_content_protected_                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Table_of_content_protected_ (OSCTXT* pctxt, 
   Odf_Table_of_content_protected_ *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Table_of_content_protected_ (OSCTXT* pctxt, 
   Odf_Table_of_content_protected_* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Table_of_content_protected__ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Illustration_index_protected_                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Illustration_index_protected_ (OSCTXT* pctxt, 
   Odf_Illustration_index_protected_ *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Illustration_index_protected_ (OSCTXT* pctxt, 
   Odf_Illustration_index_protected_* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Illustration_index_protected__ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_index_protected_                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Table_index_protected_ (OSCTXT* pctxt, 
   Odf_Table_index_protected_ *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Table_index_protected_ (OSCTXT* pctxt, 
   Odf_Table_index_protected_* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Table_index_protected__ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Object_index_protected_                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Object_index_protected_ (OSCTXT* pctxt, 
   Odf_Object_index_protected_ *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Object_index_protected_ (OSCTXT* pctxt, 
   Odf_Object_index_protected_* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Object_index_protected__ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  User_index_protected_                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_User_index_protected_ (OSCTXT* pctxt, 
   Odf_User_index_protected_ *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_User_index_protected_ (OSCTXT* pctxt, 
   Odf_User_index_protected_* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_User_index_protected__ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alphabetical_index_protected_                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Alphabetical_index_protected_ (OSCTXT* pctxt, 
   Odf_Alphabetical_index_protected_ *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Alphabetical_index_protected_ (OSCTXT* pctxt, 
   Odf_Alphabetical_index_protected_* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Alphabetical_index_protected__ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Bibliography_protected_                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Bibliography_protected_ (OSCTXT* pctxt, 
   Odf_Bibliography_protected_ *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Bibliography_protected_ (OSCTXT* pctxt, 
   Odf_Bibliography_protected_* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Bibliography_protected__ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_title_protected_                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_title_protected_ (OSCTXT* pctxt, 
   Odf_Index_title_protected_ *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Index_title_protected_ (OSCTXT* pctxt, 
   Odf_Index_title_protected_* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Index_title_protected__ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Variable_decl_value_type                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Variable_decl_value_type (OSCTXT* pctxt, 
   Odf_Variable_decl_value_type *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Variable_decl_value_type (OSCTXT* pctxt, 
   Odf_Variable_decl_value_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Variable_decl_value_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  User_field_decl_value_type                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_User_field_decl_value_type (OSCTXT* pctxt, 
   Odf_User_field_decl_value_type *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_User_field_decl_value_type (OSCTXT* pctxt, 
   Odf_User_field_decl_value_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_User_field_decl_value_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  A_actuate                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_A_actuate (OSCTXT* pctxt, Odf_A_actuate *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_A_actuate (OSCTXT* pctxt, Odf_A_actuate* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_A_actuate_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  A_show                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_A_show (OSCTXT* pctxt, Odf_A_show *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_A_show (OSCTXT* pctxt, Odf_A_show* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_A_show_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Note_note_class                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Note_note_class (OSCTXT* pctxt, 
   Odf_Note_note_class *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Note_note_class (OSCTXT* pctxt, Odf_Note_note_class* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Note_note_class_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Date_fixed                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Date_fixed (OSCTXT* pctxt, Odf_Date_fixed *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Date_fixed (OSCTXT* pctxt, Odf_Date_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Date_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Time_fixed                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Time_fixed (OSCTXT* pctxt, Odf_Time_fixed *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Time_fixed (OSCTXT* pctxt, Odf_Time_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Time_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Page_number_fixed                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Page_number_fixed (OSCTXT* pctxt, 
   Odf_Page_number_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Page_number_fixed (OSCTXT* pctxt, Odf_Page_number_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Page_number_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Page_number_select_page                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Page_number_select_page (OSCTXT* pctxt, 
   Odf_Page_number_select_page *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Page_number_select_page (OSCTXT* pctxt, 
   Odf_Page_number_select_page* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Page_number_select_page_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Page_continuation_select_page                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Page_continuation_select_page (OSCTXT* pctxt, 
   Odf_Page_continuation_select_page *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Page_continuation_select_page (OSCTXT* pctxt, 
   Odf_Page_continuation_select_page* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Page_continuation_select_page_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_firstname_fixed                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_firstname_fixed (OSCTXT* pctxt, 
   Odf_Sender_firstname_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Sender_firstname_fixed (OSCTXT* pctxt, 
   Odf_Sender_firstname_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Sender_firstname_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_lastname_fixed                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_lastname_fixed (OSCTXT* pctxt, 
   Odf_Sender_lastname_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Sender_lastname_fixed (OSCTXT* pctxt, 
   Odf_Sender_lastname_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Sender_lastname_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_initials_fixed                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_initials_fixed (OSCTXT* pctxt, 
   Odf_Sender_initials_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Sender_initials_fixed (OSCTXT* pctxt, 
   Odf_Sender_initials_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Sender_initials_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_title_fixed                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_title_fixed (OSCTXT* pctxt, 
   Odf_Sender_title_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Sender_title_fixed (OSCTXT* pctxt, 
   Odf_Sender_title_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Sender_title_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_position_fixed                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_position_fixed (OSCTXT* pctxt, 
   Odf_Sender_position_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Sender_position_fixed (OSCTXT* pctxt, 
   Odf_Sender_position_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Sender_position_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_email_fixed                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_email_fixed (OSCTXT* pctxt, 
   Odf_Sender_email_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Sender_email_fixed (OSCTXT* pctxt, 
   Odf_Sender_email_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Sender_email_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_phone_private_fixed                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_phone_private_fixed (OSCTXT* pctxt, 
   Odf_Sender_phone_private_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Sender_phone_private_fixed (OSCTXT* pctxt, 
   Odf_Sender_phone_private_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Sender_phone_private_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_fax_fixed                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_fax_fixed (OSCTXT* pctxt, 
   Odf_Sender_fax_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Sender_fax_fixed (OSCTXT* pctxt, Odf_Sender_fax_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Sender_fax_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_company_fixed                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_company_fixed (OSCTXT* pctxt, 
   Odf_Sender_company_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Sender_company_fixed (OSCTXT* pctxt, 
   Odf_Sender_company_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Sender_company_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_phone_work_fixed                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_phone_work_fixed (OSCTXT* pctxt, 
   Odf_Sender_phone_work_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Sender_phone_work_fixed (OSCTXT* pctxt, 
   Odf_Sender_phone_work_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Sender_phone_work_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_street_fixed                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_street_fixed (OSCTXT* pctxt, 
   Odf_Sender_street_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Sender_street_fixed (OSCTXT* pctxt, 
   Odf_Sender_street_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Sender_street_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_city_fixed                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_city_fixed (OSCTXT* pctxt, 
   Odf_Sender_city_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Sender_city_fixed (OSCTXT* pctxt, Odf_Sender_city_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Sender_city_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_postal_code_fixed                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_postal_code_fixed (OSCTXT* pctxt, 
   Odf_Sender_postal_code_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Sender_postal_code_fixed (OSCTXT* pctxt, 
   Odf_Sender_postal_code_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Sender_postal_code_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_country_fixed                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_country_fixed (OSCTXT* pctxt, 
   Odf_Sender_country_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Sender_country_fixed (OSCTXT* pctxt, 
   Odf_Sender_country_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Sender_country_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_state_or_province_fixed                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_state_or_province_fixed (OSCTXT* pctxt, 
   Odf_Sender_state_or_province_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Sender_state_or_province_fixed (OSCTXT* pctxt, 
   Odf_Sender_state_or_province_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Sender_state_or_province_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Author_name_fixed                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Author_name_fixed (OSCTXT* pctxt, 
   Odf_Author_name_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Author_name_fixed (OSCTXT* pctxt, Odf_Author_name_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Author_name_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Author_initials_fixed                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Author_initials_fixed (OSCTXT* pctxt, 
   Odf_Author_initials_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Author_initials_fixed (OSCTXT* pctxt, 
   Odf_Author_initials_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Author_initials_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Chapter_display                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Chapter_display (OSCTXT* pctxt, 
   Odf_Chapter_display *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Chapter_display (OSCTXT* pctxt, Odf_Chapter_display* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Chapter_display_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  File_name_display                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_File_name_display (OSCTXT* pctxt, 
   Odf_File_name_display *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_File_name_display (OSCTXT* pctxt, Odf_File_name_display* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_File_name_display_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  File_name_fixed                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_File_name_fixed (OSCTXT* pctxt, 
   Odf_File_name_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_File_name_fixed (OSCTXT* pctxt, Odf_File_name_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_File_name_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Template_name_display                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Template_name_display (OSCTXT* pctxt, 
   Odf_Template_name_display *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Template_name_display (OSCTXT* pctxt, 
   Odf_Template_name_display* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Template_name_display_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Variable_set_value_type                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Variable_set_value_type (OSCTXT* pctxt, 
   Odf_Variable_set_value_type *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Variable_set_value_type (OSCTXT* pctxt, 
   Odf_Variable_set_value_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Variable_set_value_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Variable_set_display                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Variable_set_display (OSCTXT* pctxt, 
   Odf_Variable_set_display *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Variable_set_display (OSCTXT* pctxt, 
   Odf_Variable_set_display* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Variable_set_display_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Variable_get_display                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Variable_get_display (OSCTXT* pctxt, 
   Odf_Variable_get_display *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Variable_get_display (OSCTXT* pctxt, 
   Odf_Variable_get_display* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Variable_get_display_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Variable_input_value_type                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Variable_input_value_type (OSCTXT* pctxt, 
   Odf_Variable_input_value_type *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Variable_input_value_type (OSCTXT* pctxt, 
   Odf_Variable_input_value_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Variable_input_value_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Variable_input_display                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Variable_input_display (OSCTXT* pctxt, 
   Odf_Variable_input_display *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Variable_input_display (OSCTXT* pctxt, 
   Odf_Variable_input_display* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Variable_input_display_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  User_field_get_display                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_User_field_get_display (OSCTXT* pctxt, 
   Odf_User_field_get_display *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_User_field_get_display (OSCTXT* pctxt, 
   Odf_User_field_get_display* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_User_field_get_display_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Expression_value_type                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Expression_value_type (OSCTXT* pctxt, 
   Odf_Expression_value_type *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Expression_value_type (OSCTXT* pctxt, 
   Odf_Expression_value_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Expression_value_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Expression_display                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Expression_display (OSCTXT* pctxt, 
   Odf_Expression_display *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Expression_display (OSCTXT* pctxt, 
   Odf_Expression_display* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Expression_display_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Initial_creator_fixed                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Initial_creator_fixed (OSCTXT* pctxt, 
   Odf_Initial_creator_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Initial_creator_fixed (OSCTXT* pctxt, 
   Odf_Initial_creator_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Initial_creator_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Creation_date_fixed                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Creation_date_fixed (OSCTXT* pctxt, 
   Odf_Creation_date_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Creation_date_fixed (OSCTXT* pctxt, 
   Odf_Creation_date_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Creation_date_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Creation_time_fixed                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Creation_time_fixed (OSCTXT* pctxt, 
   Odf_Creation_time_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Creation_time_fixed (OSCTXT* pctxt, 
   Odf_Creation_time_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Creation_time_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Description_fixed                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Description_fixed (OSCTXT* pctxt, 
   Odf_Description_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Description_fixed (OSCTXT* pctxt, Odf_Description_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Description_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  User_defined_fixed                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_User_defined_fixed (OSCTXT* pctxt, 
   Odf_User_defined_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_User_defined_fixed (OSCTXT* pctxt, 
   Odf_User_defined_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_User_defined_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Print_time_fixed                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Print_time_fixed (OSCTXT* pctxt, 
   Odf_Print_time_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Print_time_fixed (OSCTXT* pctxt, Odf_Print_time_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Print_time_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Print_date_fixed                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Print_date_fixed (OSCTXT* pctxt, 
   Odf_Print_date_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Print_date_fixed (OSCTXT* pctxt, Odf_Print_date_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Print_date_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Printed_by_fixed                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Printed_by_fixed (OSCTXT* pctxt, 
   Odf_Printed_by_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Printed_by_fixed (OSCTXT* pctxt, Odf_Printed_by_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Printed_by_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Title_fixed                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Title_fixed (OSCTXT* pctxt, Odf_Title_fixed *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Title_fixed (OSCTXT* pctxt, Odf_Title_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Title_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Subject_fixed                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Subject_fixed (OSCTXT* pctxt, Odf_Subject_fixed *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Subject_fixed (OSCTXT* pctxt, Odf_Subject_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Subject_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Keywords_fixed                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Keywords_fixed (OSCTXT* pctxt, 
   Odf_Keywords_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Keywords_fixed (OSCTXT* pctxt, Odf_Keywords_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Keywords_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Editing_cycles_fixed                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Editing_cycles_fixed (OSCTXT* pctxt, 
   Odf_Editing_cycles_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Editing_cycles_fixed (OSCTXT* pctxt, 
   Odf_Editing_cycles_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Editing_cycles_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Editing_duration_fixed                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Editing_duration_fixed (OSCTXT* pctxt, 
   Odf_Editing_duration_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Editing_duration_fixed (OSCTXT* pctxt, 
   Odf_Editing_duration_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Editing_duration_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Modification_time_fixed                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Modification_time_fixed (OSCTXT* pctxt, 
   Odf_Modification_time_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Modification_time_fixed (OSCTXT* pctxt, 
   Odf_Modification_time_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Modification_time_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Modification_date_fixed                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Modification_date_fixed (OSCTXT* pctxt, 
   Odf_Modification_date_fixed *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Modification_date_fixed (OSCTXT* pctxt, 
   Odf_Modification_date_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Modification_date_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Creator_fixed                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Creator_fixed (OSCTXT* pctxt, Odf_Creator_fixed *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Creator_fixed (OSCTXT* pctxt, Odf_Creator_fixed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Creator_fixed_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_display_table_type                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Database_display_table_type (OSCTXT* pctxt, 
   Odf_Database_display_table_type *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Database_display_table_type (OSCTXT* pctxt, 
   Odf_Database_display_table_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Database_display_table_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_next_table_type                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Database_next_table_type (OSCTXT* pctxt, 
   Odf_Database_next_table_type *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Database_next_table_type (OSCTXT* pctxt, 
   Odf_Database_next_table_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Database_next_table_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_row_select_table_type                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Database_row_select_table_type (OSCTXT* pctxt, 
   Odf_Database_row_select_table_type *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Database_row_select_table_type (OSCTXT* pctxt, 
   Odf_Database_row_select_table_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Database_row_select_table_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_row_number_table_type                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Database_row_number_table_type (OSCTXT* pctxt, 
   Odf_Database_row_number_table_type *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Database_row_number_table_type (OSCTXT* pctxt, 
   Odf_Database_row_number_table_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Database_row_number_table_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_name_table_type                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Database_name_table_type (OSCTXT* pctxt, 
   Odf_Database_name_table_type *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Database_name_table_type (OSCTXT* pctxt, 
   Odf_Database_name_table_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Database_name_table_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Page_variable_set_active                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Page_variable_set_active (OSCTXT* pctxt, 
   Odf_Page_variable_set_active *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Page_variable_set_active (OSCTXT* pctxt, 
   Odf_Page_variable_set_active* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Page_variable_set_active_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Placeholder_placeholder_type                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Placeholder_placeholder_type (OSCTXT* pctxt, 
   Odf_Placeholder_placeholder_type *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Placeholder_placeholder_type (OSCTXT* pctxt, 
   Odf_Placeholder_placeholder_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Placeholder_placeholder_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Conditional_text_current_value                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Conditional_text_current_value (OSCTXT* pctxt, 
   Odf_Conditional_text_current_value *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Conditional_text_current_value (OSCTXT* pctxt, 
   Odf_Conditional_text_current_value* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Conditional_text_current_value_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Hidden_text_is_hidden                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Hidden_text_is_hidden (OSCTXT* pctxt, 
   Odf_Hidden_text_is_hidden *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Hidden_text_is_hidden (OSCTXT* pctxt, 
   Odf_Hidden_text_is_hidden* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Hidden_text_is_hidden_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Note_ref_note_class                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Note_ref_note_class (OSCTXT* pctxt, 
   Odf_Note_ref_note_class *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Note_ref_note_class (OSCTXT* pctxt, 
   Odf_Note_ref_note_class* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Note_ref_note_class_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Note_ref_reference_format                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Note_ref_reference_format (OSCTXT* pctxt, 
   Odf_Note_ref_reference_format *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Note_ref_reference_format (OSCTXT* pctxt, 
   Odf_Note_ref_reference_format* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Note_ref_reference_format_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sequence_ref_reference_format                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sequence_ref_reference_format (OSCTXT* pctxt, 
   Odf_Sequence_ref_reference_format *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Sequence_ref_reference_format (OSCTXT* pctxt, 
   Odf_Sequence_ref_reference_format* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Sequence_ref_reference_format_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Hidden_paragraph_is_hidden                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Hidden_paragraph_is_hidden (OSCTXT* pctxt, 
   Odf_Hidden_paragraph_is_hidden *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Hidden_paragraph_is_hidden (OSCTXT* pctxt, 
   Odf_Hidden_paragraph_is_hidden* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Hidden_paragraph_is_hidden_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Measure_kind                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Measure_kind (OSCTXT* pctxt, Odf_Measure_kind *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Measure_kind (OSCTXT* pctxt, Odf_Measure_kind* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Measure_kind_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_formula_display                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Table_formula_display (OSCTXT* pctxt, 
   Odf_Table_formula_display *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Table_formula_display (OSCTXT* pctxt, 
   Odf_Table_formula_display* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Table_formula_display_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alphabetical_index_mark_start_main_entry                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Alphabetical_index_mark_start_main_entry (OSCTXT* pctxt, 
   Odf_Alphabetical_index_mark_start_main_entry *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Alphabetical_index_mark_start_main_entry (OSCTXT* pctxt, 
   Odf_Alphabetical_index_mark_start_main_entry* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Alphabetical_index_mark_start_main_entry_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alphabetical_index_mark_main_entry                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Alphabetical_index_mark_main_entry (OSCTXT* pctxt, 
   Odf_Alphabetical_index_mark_main_entry *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Alphabetical_index_mark_main_entry (OSCTXT* pctxt, 
   Odf_Alphabetical_index_mark_main_entry* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Alphabetical_index_mark_main_entry_ToEnum (pctxt, strval, pvalue
      );
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Bibliography_mark_bibliography_type                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Bibliography_mark_bibliography_type (OSCTXT* pctxt, 
   Odf_Bibliography_mark_bibliography_type *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Bibliography_mark_bibliography_type (OSCTXT* pctxt, 
   Odf_Bibliography_mark_bibliography_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Bibliography_mark_bibliography_type_ToEnum (pctxt, strval, pvalue
      );
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Section_source_show                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Section_source_show (OSCTXT* pctxt, 
   Odf_Section_source_show *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Section_source_show (OSCTXT* pctxt, 
   Odf_Section_source_show* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Section_source_show_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_of_content_source_index_scope                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Table_of_content_source_index_scope (OSCTXT* pctxt, 
   Odf_Table_of_content_source_index_scope *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Table_of_content_source_index_scope (OSCTXT* pctxt, 
   Odf_Table_of_content_source_index_scope* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Table_of_content_source_index_scope_ToEnum (pctxt, strval, pvalue
      );
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_of_content_source_relative_tab_stop_position        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Table_of_content_source_relative_tab_stop_position (
   OSCTXT* pctxt, 
   Odf_Table_of_content_source_relative_tab_stop_position *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Table_of_content_source_relative_tab_stop_position 
   (OSCTXT* pctxt, 
   Odf_Table_of_content_source_relative_tab_stop_position* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Table_of_content_source_relative_tab_stop_position_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_of_content_source_use_index_marks                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Table_of_content_source_use_index_marks (OSCTXT* pctxt, 
   Odf_Table_of_content_source_use_index_marks *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Table_of_content_source_use_index_marks (OSCTXT* pctxt, 
   Odf_Table_of_content_source_use_index_marks* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Table_of_content_source_use_index_marks_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_of_content_source_use_index_source_styles           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Table_of_content_source_use_index_source_styles (
   OSCTXT* pctxt, Odf_Table_of_content_source_use_index_source_styles *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Table_of_content_source_use_index_source_styles (OSCTXT* pctxt, 
   Odf_Table_of_content_source_use_index_source_styles* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Table_of_content_source_use_index_source_styles_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_of_content_source_use_outline_level                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Table_of_content_source_use_outline_level (OSCTXT* pctxt, 
   Odf_Table_of_content_source_use_outline_level *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Table_of_content_source_use_outline_level (OSCTXT* pctxt, 
   Odf_Table_of_content_source_use_outline_level* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Table_of_content_source_use_outline_level_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Illustration_index_source_caption_sequence_format         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Illustration_index_source_caption_sequence_format (
   OSCTXT* pctxt, 
   Odf_Illustration_index_source_caption_sequence_format *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Illustration_index_source_caption_sequence_format 
   (OSCTXT* pctxt, 
   Odf_Illustration_index_source_caption_sequence_format* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Illustration_index_source_caption_sequence_format_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Illustration_index_source_index_scope                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Illustration_index_source_index_scope (OSCTXT* pctxt, 
   Odf_Illustration_index_source_index_scope *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Illustration_index_source_index_scope (OSCTXT* pctxt, 
   Odf_Illustration_index_source_index_scope* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Illustration_index_source_index_scope_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Illustration_index_source_relative_tab_stop_position      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Illustration_index_source_relative_tab_stop_position (
   OSCTXT* pctxt, 
   Odf_Illustration_index_source_relative_tab_stop_position *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Illustration_index_source_relative_tab_stop_position 
   (OSCTXT* pctxt, 
   Odf_Illustration_index_source_relative_tab_stop_position* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Illustration_index_source_relative_tab_stop_position_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Illustration_index_source_use_caption                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Illustration_index_source_use_caption (OSCTXT* pctxt, 
   Odf_Illustration_index_source_use_caption *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Illustration_index_source_use_caption (OSCTXT* pctxt, 
   Odf_Illustration_index_source_use_caption* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Illustration_index_source_use_caption_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_index_source_caption_sequence_format                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Table_index_source_caption_sequence_format (
   OSCTXT* pctxt, Odf_Table_index_source_caption_sequence_format *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Table_index_source_caption_sequence_format (OSCTXT* pctxt, 
   Odf_Table_index_source_caption_sequence_format* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Table_index_source_caption_sequence_format_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_index_source_index_scope                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Table_index_source_index_scope (OSCTXT* pctxt, 
   Odf_Table_index_source_index_scope *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Table_index_source_index_scope (OSCTXT* pctxt, 
   Odf_Table_index_source_index_scope* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Table_index_source_index_scope_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_index_source_relative_tab_stop_position             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Table_index_source_relative_tab_stop_position (
   OSCTXT* pctxt, Odf_Table_index_source_relative_tab_stop_position *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Table_index_source_relative_tab_stop_position (OSCTXT* pctxt, 
   Odf_Table_index_source_relative_tab_stop_position* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Table_index_source_relative_tab_stop_position_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_index_source_use_caption                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Table_index_source_use_caption (OSCTXT* pctxt, 
   Odf_Table_index_source_use_caption *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Table_index_source_use_caption (OSCTXT* pctxt, 
   Odf_Table_index_source_use_caption* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Table_index_source_use_caption_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Object_index_source_index_scope                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Object_index_source_index_scope (OSCTXT* pctxt, 
   Odf_Object_index_source_index_scope *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Object_index_source_index_scope (OSCTXT* pctxt, 
   Odf_Object_index_source_index_scope* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Object_index_source_index_scope_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Object_index_source_relative_tab_stop_position            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Object_index_source_relative_tab_stop_position (
   OSCTXT* pctxt, Odf_Object_index_source_relative_tab_stop_position *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Object_index_source_relative_tab_stop_position (OSCTXT* pctxt, 
   Odf_Object_index_source_relative_tab_stop_position* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Object_index_source_relative_tab_stop_position_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Object_index_source_use_chart_objects                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Object_index_source_use_chart_objects (OSCTXT* pctxt, 
   Odf_Object_index_source_use_chart_objects *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Object_index_source_use_chart_objects (OSCTXT* pctxt, 
   Odf_Object_index_source_use_chart_objects* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Object_index_source_use_chart_objects_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Object_index_source_use_draw_objects                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Object_index_source_use_draw_objects (OSCTXT* pctxt, 
   Odf_Object_index_source_use_draw_objects *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Object_index_source_use_draw_objects (OSCTXT* pctxt, 
   Odf_Object_index_source_use_draw_objects* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Object_index_source_use_draw_objects_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Object_index_source_use_math_objects                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Object_index_source_use_math_objects (OSCTXT* pctxt, 
   Odf_Object_index_source_use_math_objects *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Object_index_source_use_math_objects (OSCTXT* pctxt, 
   Odf_Object_index_source_use_math_objects* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Object_index_source_use_math_objects_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Object_index_source_use_other_objects                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Object_index_source_use_other_objects (OSCTXT* pctxt, 
   Odf_Object_index_source_use_other_objects *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Object_index_source_use_other_objects (OSCTXT* pctxt, 
   Odf_Object_index_source_use_other_objects* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Object_index_source_use_other_objects_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Object_index_source_use_spreadsheet_objects               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Object_index_source_use_spreadsheet_objects (
   OSCTXT* pctxt, Odf_Object_index_source_use_spreadsheet_objects *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Object_index_source_use_spreadsheet_objects (OSCTXT* pctxt, 
   Odf_Object_index_source_use_spreadsheet_objects* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Object_index_source_use_spreadsheet_objects_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  User_index_source_copy_outline_levels                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_User_index_source_copy_outline_levels (OSCTXT* pctxt, 
   Odf_User_index_source_copy_outline_levels *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_User_index_source_copy_outline_levels (OSCTXT* pctxt, 
   Odf_User_index_source_copy_outline_levels* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_User_index_source_copy_outline_levels_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  User_index_source_index_scope                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_User_index_source_index_scope (OSCTXT* pctxt, 
   Odf_User_index_source_index_scope *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_User_index_source_index_scope (OSCTXT* pctxt, 
   Odf_User_index_source_index_scope* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_User_index_source_index_scope_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  User_index_source_relative_tab_stop_position              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_User_index_source_relative_tab_stop_position (
   OSCTXT* pctxt, Odf_User_index_source_relative_tab_stop_position *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_User_index_source_relative_tab_stop_position (OSCTXT* pctxt, 
   Odf_User_index_source_relative_tab_stop_position* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_User_index_source_relative_tab_stop_position_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  User_index_source_use_floating_frames                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_User_index_source_use_floating_frames (OSCTXT* pctxt, 
   Odf_User_index_source_use_floating_frames *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_User_index_source_use_floating_frames (OSCTXT* pctxt, 
   Odf_User_index_source_use_floating_frames* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_User_index_source_use_floating_frames_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  User_index_source_use_graphics                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_User_index_source_use_graphics (OSCTXT* pctxt, 
   Odf_User_index_source_use_graphics *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_User_index_source_use_graphics (OSCTXT* pctxt, 
   Odf_User_index_source_use_graphics* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_User_index_source_use_graphics_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  User_index_source_use_index_marks                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_User_index_source_use_index_marks (OSCTXT* pctxt, 
   Odf_User_index_source_use_index_marks *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_User_index_source_use_index_marks (OSCTXT* pctxt, 
   Odf_User_index_source_use_index_marks* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_User_index_source_use_index_marks_ToEnum (pctxt, strval, pvalue
      );
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  User_index_source_use_objects                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_User_index_source_use_objects (OSCTXT* pctxt, 
   Odf_User_index_source_use_objects *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_User_index_source_use_objects (OSCTXT* pctxt, 
   Odf_User_index_source_use_objects* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_User_index_source_use_objects_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  User_index_source_use_tables                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_User_index_source_use_tables (OSCTXT* pctxt, 
   Odf_User_index_source_use_tables *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_User_index_source_use_tables (OSCTXT* pctxt, 
   Odf_User_index_source_use_tables* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_User_index_source_use_tables_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alphabetical_index_source_alphabetical_separators         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Alphabetical_index_source_alphabetical_separators (
   OSCTXT* pctxt, 
   Odf_Alphabetical_index_source_alphabetical_separators *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Alphabetical_index_source_alphabetical_separators 
   (OSCTXT* pctxt, 
   Odf_Alphabetical_index_source_alphabetical_separators* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Alphabetical_index_source_alphabetical_separators_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alphabetical_index_source_capitalize_entries              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Alphabetical_index_source_capitalize_entries (
   OSCTXT* pctxt, Odf_Alphabetical_index_source_capitalize_entries *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Alphabetical_index_source_capitalize_entries (OSCTXT* pctxt, 
   Odf_Alphabetical_index_source_capitalize_entries* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Alphabetical_index_source_capitalize_entries_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alphabetical_index_source_combine_entries                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Alphabetical_index_source_combine_entries (OSCTXT* pctxt, 
   Odf_Alphabetical_index_source_combine_entries *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Alphabetical_index_source_combine_entries (OSCTXT* pctxt, 
   Odf_Alphabetical_index_source_combine_entries* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Alphabetical_index_source_combine_entries_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alphabetical_index_source_combine_entries_with_dash       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Alphabetical_index_source_combine_entries_with_dash (
   OSCTXT* pctxt, 
   Odf_Alphabetical_index_source_combine_entries_with_dash *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Alphabetical_index_source_combine_entries_with_dash 
   (OSCTXT* pctxt, 
   Odf_Alphabetical_index_source_combine_entries_with_dash* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Alphabetical_index_source_combine_entries_with_dash_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alphabetical_index_source_combine_entries_with_pp         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Alphabetical_index_source_combine_entries_with_pp (
   OSCTXT* pctxt, 
   Odf_Alphabetical_index_source_combine_entries_with_pp *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Alphabetical_index_source_combine_entries_with_pp 
   (OSCTXT* pctxt, 
   Odf_Alphabetical_index_source_combine_entries_with_pp* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Alphabetical_index_source_combine_entries_with_pp_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alphabetical_index_source_comma_separated                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Alphabetical_index_source_comma_separated (OSCTXT* pctxt, 
   Odf_Alphabetical_index_source_comma_separated *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Alphabetical_index_source_comma_separated (OSCTXT* pctxt, 
   Odf_Alphabetical_index_source_comma_separated* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Alphabetical_index_source_comma_separated_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alphabetical_index_source_ignore_case                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Alphabetical_index_source_ignore_case (OSCTXT* pctxt, 
   Odf_Alphabetical_index_source_ignore_case *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Alphabetical_index_source_ignore_case (OSCTXT* pctxt, 
   Odf_Alphabetical_index_source_ignore_case* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Alphabetical_index_source_ignore_case_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alphabetical_index_source_index_scope                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Alphabetical_index_source_index_scope (OSCTXT* pctxt, 
   Odf_Alphabetical_index_source_index_scope *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Alphabetical_index_source_index_scope (OSCTXT* pctxt, 
   Odf_Alphabetical_index_source_index_scope* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Alphabetical_index_source_index_scope_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alphabetical_index_source_relative_tab_stop_position      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Alphabetical_index_source_relative_tab_stop_position (
   OSCTXT* pctxt, 
   Odf_Alphabetical_index_source_relative_tab_stop_position *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Alphabetical_index_source_relative_tab_stop_position 
   (OSCTXT* pctxt, 
   Odf_Alphabetical_index_source_relative_tab_stop_position* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Alphabetical_index_source_relative_tab_stop_position_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alphabetical_index_source_use_keys_as_entries             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Alphabetical_index_source_use_keys_as_entries (
   OSCTXT* pctxt, Odf_Alphabetical_index_source_use_keys_as_entries *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Alphabetical_index_source_use_keys_as_entries (OSCTXT* pctxt, 
   Odf_Alphabetical_index_source_use_keys_as_entries* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Alphabetical_index_source_use_keys_as_entries_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alphabetical_index_entry_template_outline_level           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Alphabetical_index_entry_template_outline_level (
   OSCTXT* pctxt, Odf_Alphabetical_index_entry_template_outline_level *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Alphabetical_index_entry_template_outline_level (OSCTXT* pctxt, 
   Odf_Alphabetical_index_entry_template_outline_level* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Alphabetical_index_entry_template_outline_level_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Bibliography_entry_template_bibliography_type             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Bibliography_entry_template_bibliography_type (
   OSCTXT* pctxt, Odf_Bibliography_entry_template_bibliography_type *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Bibliography_entry_template_bibliography_type (OSCTXT* pctxt, 
   Odf_Bibliography_entry_template_bibliography_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Bibliography_entry_template_bibliography_type_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_entry_chapter_display                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_entry_chapter_display (OSCTXT* pctxt, 
   Odf_Index_entry_chapter_display *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Index_entry_chapter_display (OSCTXT* pctxt, 
   Odf_Index_entry_chapter_display* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Index_entry_chapter_display_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_entry_bibliography_bibliography_data_field          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_entry_bibliography_bibliography_data_field (
   OSCTXT* pctxt, 
   Odf_Index_entry_bibliography_bibliography_data_field *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Index_entry_bibliography_bibliography_data_field 
   (OSCTXT* pctxt, 
   Odf_Index_entry_bibliography_bibliography_data_field* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Index_entry_bibliography_bibliography_data_field_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Element282_reference_format                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Element282_reference_format (OSCTXT* pctxt, 
   Odf_Element282_reference_format *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Element282_reference_format (OSCTXT* pctxt, 
   Odf_Element282_reference_format* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Element282_reference_format_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Element480_derivations_list_property_value_type           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Element480_derivations_list_property_value_type (
   OSCTXT* pctxt, Odf_Element480_derivations_list_property_value_type *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Odf_Element480_derivations_list_property_value_type (OSCTXT* pctxt, 
   Odf_Element480_derivations_list_property_value_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Odf_Element480_derivations_list_property_value_type_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  List_level_style_number_style_name                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_List_level_style_number_style_name (OSCTXT* pctxt, 
   Odf_List_level_style_number_style_name *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_List_level_style_number_style_name (OSCTXT* pctxt, 
   Odf_List_level_style_number_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  List_level_style_number                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_List_level_style_number (OSCTXT* pctxt, 
   Odf_List_level_style_number *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode num_format */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->num_format = rtxMemAllocType (pctxt, Ns8_Num_format);

            if (pvalue->num_format == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);
            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);

            stat = asn1D_Ns8_Num_format (pctxt, 
               (Ns8_Num_format*)pvalue->num_format, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.num_formatPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode num_letter_sync */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Num_letter_sync (pctxt, 
               (Ns8_Num_letter_sync*)&pvalue->num_letter_sync, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.num_letter_syncPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode num_prefix */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Num_prefix (pctxt, 
               (Ns8_Num_prefix*)&pvalue->num_prefix, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.num_prefixPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode num_suffix */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Num_suffix (pctxt, 
               (Ns8_Num_suffix*)&pvalue->num_suffix, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.num_suffixPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode display_levels */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->display_levels, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.display_levelsPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode level */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->level, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode start_value */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->start_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.start_valuePresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_List_level_style_number_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode list_level_properties */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->list_level_properties
                = rtxMemAllocType (pctxt, Ns8_List_level_properties);

            if (pvalue->list_level_properties == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_List_level_properties ((Ns8_List_level_properties*)pvalue->list_level_properties);
            asn1Init_Ns8_List_level_properties ((Ns8_List_level_properties*)pvalue->list_level_properties);

            stat = asn1D_Ns8_List_level_properties (pctxt, 
               (Ns8_List_level_properties*)pvalue->list_level_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.list_level_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode text_properties */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->text_properties
                = rtxMemAllocType (pctxt, Ns8_Text_properties);

            if (pvalue->text_properties == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Text_properties ((Ns8_Text_properties*)pvalue->text_properties);
            asn1Init_Ns8_Text_properties ((Ns8_Text_properties*)pvalue->text_properties);

            stat = asn1D_Ns8_Text_properties (pctxt, 
               (Ns8_Text_properties*)pvalue->text_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_List_level_style_number (OSCTXT* pctxt, 
   Odf_List_level_style_number* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("num-format"), 10}, 0 },
         { {OSUTF8("num-letter-sync"), 15}, 0 },
         { {OSUTF8("num-prefix"), 10}, 0 },
         { {OSUTF8("num-suffix"), 10}, 0 },
         { {OSUTF8("display-levels"), 14}, 0 },
         { {OSUTF8("level"), 5}, 0 },
         { {OSUTF8("start-value"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 8, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* num-format */
            pvalue->num_format = rtxMemAllocType (pctxt, Ns8_Num_format);

            if (pvalue->num_format == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);

            stat = XmlDec_Ns8_Num_format (pctxt, pvalue->num_format);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.num_formatPresent = TRUE;
            break;

         case 1: /* num-letter-sync */
            stat = XmlDec_Ns8_Num_letter_sync (pctxt, &pvalue->num_letter_sync
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.num_letter_syncPresent = TRUE;
            break;

         case 2: /* num-prefix */
            stat = XmlDec_Ns8_Num_prefix (pctxt, &pvalue->num_prefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.num_prefixPresent = TRUE;
            break;

         case 3: /* num-suffix */
            stat = XmlDec_Ns8_Num_suffix (pctxt, &pvalue->num_suffix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.num_suffixPresent = TRUE;
            break;

         case 4: /* display-levels */
            stat = rtXmlpDecUInt (pctxt, &pvalue->display_levels);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.display_levelsPresent = TRUE;
            break;

         case 5: /* level */
            stat = rtXmlpDecUInt (pctxt, &pvalue->level);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 6: /* start-value */
            stat = rtXmlpDecUInt (pctxt, &pvalue->start_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.start_valuePresent = TRUE;
            break;

         case 7: /* style-name */
            stat = XmlDec_Odf_List_level_style_number_style_name (pctxt, &
               pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_List_level_style_number");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_List_level_style_number");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("list-level-properties"), 21}, 0}, 0 },
      {{{OSUTF8("text-properties"), 15}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* list-level-properties */
         pvalue->list_level_properties
             = rtxMemAllocType (pctxt, Ns8_List_level_properties);

         if (pvalue->list_level_properties == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns8_List_level_properties ((Ns8_List_level_properties*)pvalue
            ->list_level_properties);

         stat = XmlDec_Ns8_List_level_properties (pctxt, pvalue->
            list_level_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.list_level_propertiesPresent = TRUE;
         break;
      }
      case 1: { /* text-properties */
         pvalue->text_properties
             = rtxMemAllocType (pctxt, Ns8_Text_properties);

         if (pvalue->text_properties == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns8_Text_properties ((Ns8_Text_properties*)pvalue->
            text_properties);

         stat = XmlDec_Ns8_Text_properties (pctxt, pvalue->text_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.text_propertiesPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  List_level_style_bullet_style_name                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_List_level_style_bullet_style_name (OSCTXT* pctxt, 
   Odf_List_level_style_bullet_style_name *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_List_level_style_bullet_style_name (OSCTXT* pctxt, 
   Odf_List_level_style_bullet_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  List_level_style_bullet                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_List_level_style_bullet (OSCTXT* pctxt, 
   Odf_List_level_style_bullet *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode num_prefix */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Num_prefix (pctxt, 
               (Ns8_Num_prefix*)&pvalue->num_prefix, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.num_prefixPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode num_suffix */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Num_suffix (pctxt, 
               (Ns8_Num_suffix*)&pvalue->num_suffix, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.num_suffixPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode bullet_char */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->bullet_char, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode bullet_relative_size */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->bullet_relative_size, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bullet_relative_sizePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode level */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->level, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_List_level_style_bullet_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode list_level_properties */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->list_level_properties
                = rtxMemAllocType (pctxt, Ns8_List_level_properties);

            if (pvalue->list_level_properties == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_List_level_properties ((Ns8_List_level_properties*)pvalue->list_level_properties);
            asn1Init_Ns8_List_level_properties ((Ns8_List_level_properties*)pvalue->list_level_properties);

            stat = asn1D_Ns8_List_level_properties (pctxt, 
               (Ns8_List_level_properties*)pvalue->list_level_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.list_level_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode text_properties */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->text_properties
                = rtxMemAllocType (pctxt, Ns8_Text_properties);

            if (pvalue->text_properties == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Text_properties ((Ns8_Text_properties*)pvalue->text_properties);
            asn1Init_Ns8_Text_properties ((Ns8_Text_properties*)pvalue->text_properties);

            stat = asn1D_Ns8_Text_properties (pctxt, 
               (Ns8_Text_properties*)pvalue->text_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_List_level_style_bullet (OSCTXT* pctxt, 
   Odf_List_level_style_bullet* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("num-prefix"), 10}, 0 },
         { {OSUTF8("num-suffix"), 10}, 0 },
         { {OSUTF8("bullet-char"), 11}, 0 },
         { {OSUTF8("bullet-relative-size"), 20}, 0 },
         { {OSUTF8("level"), 5}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 6, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* num-prefix */
            stat = XmlDec_Ns8_Num_prefix (pctxt, &pvalue->num_prefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.num_prefixPresent = TRUE;
            break;

         case 1: /* num-suffix */
            stat = XmlDec_Ns8_Num_suffix (pctxt, &pvalue->num_suffix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.num_suffixPresent = TRUE;
            break;

         case 2: /* bullet-char */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->bullet_char);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* bullet-relative-size */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->bullet_relative_size);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bullet_relative_sizePresent = TRUE;
            break;

         case 4: /* level */
            stat = rtXmlpDecUInt (pctxt, &pvalue->level);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* style-name */
            stat = XmlDec_Odf_List_level_style_bullet_style_name (pctxt, &
               pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_List_level_style_bullet");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_List_level_style_bullet");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("list-level-properties"), 21}, 0}, 0 },
      {{{OSUTF8("text-properties"), 15}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* list-level-properties */
         pvalue->list_level_properties
             = rtxMemAllocType (pctxt, Ns8_List_level_properties);

         if (pvalue->list_level_properties == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns8_List_level_properties ((Ns8_List_level_properties*)pvalue
            ->list_level_properties);

         stat = XmlDec_Ns8_List_level_properties (pctxt, pvalue->
            list_level_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.list_level_propertiesPresent = TRUE;
         break;
      }
      case 1: { /* text-properties */
         pvalue->text_properties
             = rtxMemAllocType (pctxt, Ns8_Text_properties);

         if (pvalue->text_properties == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns8_Text_properties ((Ns8_Text_properties*)pvalue->
            text_properties);

         stat = XmlDec_Ns8_Text_properties (pctxt, pvalue->text_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.text_propertiesPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  List_level_style_image                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_List_level_style_image (OSCTXT* pctxt, 
   Odf_List_level_style_image *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode actuate */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_List_level_style_image_actuate (pctxt, 
               &pvalue->actuate, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.actuatePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode href */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Href (pctxt, 
               &pvalue->href, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.hrefPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode show */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_List_level_style_image_show (pctxt, 
               &pvalue->show, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.showPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Type (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.typePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode level */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->level, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode binary_data */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Binary_data (pctxt, 
               (Ns13_Binary_data*)&pvalue->binary_data, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.binary_dataPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode list_level_properties */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->list_level_properties
                = rtxMemAllocType (pctxt, Ns8_List_level_properties);

            if (pvalue->list_level_properties == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_List_level_properties ((Ns8_List_level_properties*)pvalue->list_level_properties);
            asn1Init_Ns8_List_level_properties ((Ns8_List_level_properties*)pvalue->list_level_properties);

            stat = asn1D_Ns8_List_level_properties (pctxt, 
               (Ns8_List_level_properties*)pvalue->list_level_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.list_level_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_List_level_style_image (OSCTXT* pctxt, 
   Odf_List_level_style_image* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("actuate"), 7}, 0 },
         { {OSUTF8("href"), 4}, 0 },
         { {OSUTF8("show"), 4}, 0 },
         { {OSUTF8("type"), 4}, 0 },
         { {OSUTF8("level"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* actuate */
            stat = XmlDec_Odf_List_level_style_image_actuate (pctxt, &pvalue->
               actuate);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.actuatePresent = TRUE;
            break;

         case 1: /* href */
            stat = XmlDec_Xlink_Href (pctxt, &pvalue->href);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.hrefPresent = TRUE;
            break;

         case 2: /* show */
            stat = XmlDec_Odf_List_level_style_image_show (pctxt, &pvalue->show
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.showPresent = TRUE;
            break;

         case 3: /* type */
            stat = XmlDec_Xlink_Type (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.typePresent = TRUE;
            break;

         case 4: /* level */
            stat = rtXmlpDecUInt (pctxt, &pvalue->level);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_List_level_style_image");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_List_level_style_image");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("binary-data"), 11}, 0}, 0 },
      {{{OSUTF8("list-level-properties"), 21}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* binary-data */
         stat = XmlDec_Ns13_Binary_data (pctxt, &pvalue->binary_data);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.binary_dataPresent = TRUE;
         break;
      }
      case 1: { /* list-level-properties */
         pvalue->list_level_properties
             = rtxMemAllocType (pctxt, Ns8_List_level_properties);

         if (pvalue->list_level_properties == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns8_List_level_properties ((Ns8_List_level_properties*)pvalue
            ->list_level_properties);

         stat = XmlDec_Ns8_List_level_properties (pctxt, pvalue->
            list_level_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.list_level_propertiesPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  List_style_element                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_List_style_element (OSCTXT* pctxt, 
   Odf_List_style_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.list_level_style_number
             = rtxMemAllocType (pctxt, Odf_List_level_style_number);

         if (pvalue->u.list_level_style_number == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List_level_style_number (pvalue->u.list_level_style_number);
         stat = asn1D_Odf_List_level_style_number (pctxt, 
            pvalue->u.list_level_style_number, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.list_level_style_bullet
             = rtxMemAllocType (pctxt, Odf_List_level_style_bullet);

         if (pvalue->u.list_level_style_bullet == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List_level_style_bullet (pvalue->u.list_level_style_bullet);
         stat = asn1D_Odf_List_level_style_bullet (pctxt, 
            pvalue->u.list_level_style_bullet, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.list_level_style_image
             = rtxMemAllocType (pctxt, Odf_List_level_style_image);

         if (pvalue->u.list_level_style_image == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List_level_style_image (pvalue->u.list_level_style_image);
         stat = asn1D_Odf_List_level_style_image (pctxt, 
            pvalue->u.list_level_style_image, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_List_style_element (OSCTXT* pctxt, 
   Odf_List_style_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("list-level-style-number"), 23}, 0}, 0 },
      {{{OSUTF8("list-level-style-bullet"), 23}, 0}, 1 },
      {{{OSUTF8("list-level-style-image"), 22}, 0}, 2 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* list-level-style-number */
      pvalue->u.list_level_style_number
          = rtxMemAllocType (pctxt, Odf_List_level_style_number);

      if (pvalue->u.list_level_style_number == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List_level_style_number (pvalue->u.list_level_style_number
         );

      stat = XmlDec_Odf_List_level_style_number (pctxt, pvalue->
         u.list_level_style_number);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* list-level-style-bullet */
      pvalue->u.list_level_style_bullet
          = rtxMemAllocType (pctxt, Odf_List_level_style_bullet);

      if (pvalue->u.list_level_style_bullet == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List_level_style_bullet (pvalue->u.list_level_style_bullet
         );

      stat = XmlDec_Odf_List_level_style_bullet (pctxt, pvalue->
         u.list_level_style_bullet);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* list-level-style-image */
      pvalue->u.list_level_style_image
          = rtxMemAllocType (pctxt, Odf_List_level_style_image);

      if (pvalue->u.list_level_style_image == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List_level_style_image (pvalue->u.list_level_style_image);

      stat = XmlDec_Odf_List_level_style_image (pctxt, pvalue->
         u.list_level_style_image);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  List_style                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_List_style (OSCTXT* pctxt, Odf_List_style *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode display_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Display_name (pctxt, 
               (Ns3_Display_name*)&pvalue->display_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.display_namePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Name (pctxt, 
               (Ns8_Name*)&pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode consecutive_numbering */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_List_style_consecutive_numbering (pctxt, 
               &pvalue->consecutive_numbering, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.consecutive_numberingPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_List_style_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_List_style_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_List_style_element (pdata2);

                  stat = asn1D_Odf_List_style_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_List_style (OSCTXT* pctxt, Odf_List_style* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("display-name"), 12}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("consecutive-numbering"), 21}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* display-name */
            stat = XmlDec_Ns3_Display_name (pctxt, &pvalue->display_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.display_namePresent = TRUE;
            break;

         case 1: /* name */
            stat = XmlDec_Ns8_Name (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* consecutive-numbering */
            stat = XmlDec_Odf_List_style_consecutive_numbering (pctxt, &pvalue
               ->consecutive_numbering);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.consecutive_numberingPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_List_style");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_List_style");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("list-level-style-number"), 23}, 0}, 0 },
      {{{OSUTF8("list-level-style-bullet"), 23}, 0}, 0 },
      {{{OSUTF8("list-level-style-image"), 22}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_List_style_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_List_style_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_List_style_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Odf_List_style_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 3, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Outline_level_style_style_name                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Outline_level_style_style_name (OSCTXT* pctxt, 
   Odf_Outline_level_style_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Outline_level_style_style_name (OSCTXT* pctxt, 
   Odf_Outline_level_style_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Outline_level_style                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Outline_level_style (OSCTXT* pctxt, 
   Odf_Outline_level_style *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode num_format */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->num_format = rtxMemAllocType (pctxt, Ns8_Num_format);

            if (pvalue->num_format == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);
            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);

            stat = asn1D_Ns8_Num_format (pctxt, 
               (Ns8_Num_format*)pvalue->num_format, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.num_formatPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode num_letter_sync */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Num_letter_sync (pctxt, 
               (Ns8_Num_letter_sync*)&pvalue->num_letter_sync, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.num_letter_syncPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode num_prefix */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Num_prefix (pctxt, 
               (Ns8_Num_prefix*)&pvalue->num_prefix, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.num_prefixPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode num_suffix */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Num_suffix (pctxt, 
               (Ns8_Num_suffix*)&pvalue->num_suffix, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.num_suffixPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode display_levels */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->display_levels, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.display_levelsPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode level */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->level, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode start_value */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->start_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.start_valuePresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Outline_level_style_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode list_level_properties */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->list_level_properties
                = rtxMemAllocType (pctxt, Ns8_List_level_properties);

            if (pvalue->list_level_properties == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_List_level_properties ((Ns8_List_level_properties*)pvalue->list_level_properties);
            asn1Init_Ns8_List_level_properties ((Ns8_List_level_properties*)pvalue->list_level_properties);

            stat = asn1D_Ns8_List_level_properties (pctxt, 
               (Ns8_List_level_properties*)pvalue->list_level_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.list_level_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode text_properties */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->text_properties
                = rtxMemAllocType (pctxt, Ns8_Text_properties);

            if (pvalue->text_properties == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Text_properties ((Ns8_Text_properties*)pvalue->text_properties);
            asn1Init_Ns8_Text_properties ((Ns8_Text_properties*)pvalue->text_properties);

            stat = asn1D_Ns8_Text_properties (pctxt, 
               (Ns8_Text_properties*)pvalue->text_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Outline_level_style (OSCTXT* pctxt, 
   Odf_Outline_level_style* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("num-format"), 10}, 0 },
         { {OSUTF8("num-letter-sync"), 15}, 0 },
         { {OSUTF8("num-prefix"), 10}, 0 },
         { {OSUTF8("num-suffix"), 10}, 0 },
         { {OSUTF8("display-levels"), 14}, 0 },
         { {OSUTF8("level"), 5}, 0 },
         { {OSUTF8("start-value"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 8, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* num-format */
            pvalue->num_format = rtxMemAllocType (pctxt, Ns8_Num_format);

            if (pvalue->num_format == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);

            stat = XmlDec_Ns8_Num_format (pctxt, pvalue->num_format);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.num_formatPresent = TRUE;
            break;

         case 1: /* num-letter-sync */
            stat = XmlDec_Ns8_Num_letter_sync (pctxt, &pvalue->num_letter_sync
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.num_letter_syncPresent = TRUE;
            break;

         case 2: /* num-prefix */
            stat = XmlDec_Ns8_Num_prefix (pctxt, &pvalue->num_prefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.num_prefixPresent = TRUE;
            break;

         case 3: /* num-suffix */
            stat = XmlDec_Ns8_Num_suffix (pctxt, &pvalue->num_suffix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.num_suffixPresent = TRUE;
            break;

         case 4: /* display-levels */
            stat = rtXmlpDecUInt (pctxt, &pvalue->display_levels);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.display_levelsPresent = TRUE;
            break;

         case 5: /* level */
            stat = rtXmlpDecUInt (pctxt, &pvalue->level);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 6: /* start-value */
            stat = rtXmlpDecUInt (pctxt, &pvalue->start_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.start_valuePresent = TRUE;
            break;

         case 7: /* style-name */
            stat = XmlDec_Odf_Outline_level_style_style_name (pctxt, &pvalue->
               style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Outline_level_style");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Outline_level_style");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("list-level-properties"), 21}, 0}, 0 },
      {{{OSUTF8("text-properties"), 15}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* list-level-properties */
         pvalue->list_level_properties
             = rtxMemAllocType (pctxt, Ns8_List_level_properties);

         if (pvalue->list_level_properties == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns8_List_level_properties ((Ns8_List_level_properties*)pvalue
            ->list_level_properties);

         stat = XmlDec_Ns8_List_level_properties (pctxt, pvalue->
            list_level_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.list_level_propertiesPresent = TRUE;
         break;
      }
      case 1: { /* text-properties */
         pvalue->text_properties
             = rtxMemAllocType (pctxt, Ns8_Text_properties);

         if (pvalue->text_properties == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns8_Text_properties ((Ns8_Text_properties*)pvalue->
            text_properties);

         stat = XmlDec_Ns8_Text_properties (pctxt, pvalue->text_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.text_propertiesPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Outline_style                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Outline_style (OSCTXT* pctxt, Odf_Outline_style *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode outline_level_style_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Outline_level_style* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->outline_level_style_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Outline_level_style, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_Outline_level_style (pdata2);

                  stat = asn1D_Odf_Outline_level_style (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->outline_level_style_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Outline_style (OSCTXT* pctxt, Odf_Outline_style* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("outline-level-style"), 19}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_Outline_level_style* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_Outline_level_style);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Outline_level_style (pdata1);

            stat = XmlDec_Odf_Outline_level_style (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->outline_level_style_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Notes_configuration_citation_body_style_name              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Notes_configuration_citation_body_style_name (
   OSCTXT* pctxt, Odf_Notes_configuration_citation_body_style_name *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Notes_configuration_citation_body_style_name (OSCTXT* pctxt, 
   Odf_Notes_configuration_citation_body_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Notes_configuration_citation_style_name                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Notes_configuration_citation_style_name (OSCTXT* pctxt, 
   Odf_Notes_configuration_citation_style_name *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Notes_configuration_citation_style_name (OSCTXT* pctxt, 
   Odf_Notes_configuration_citation_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Notes_configuration_default_style_name                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Notes_configuration_default_style_name (OSCTXT* pctxt, 
   Odf_Notes_configuration_default_style_name *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Notes_configuration_default_style_name (OSCTXT* pctxt, 
   Odf_Notes_configuration_default_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Notes_configuration_master_page_name                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Notes_configuration_master_page_name (OSCTXT* pctxt, 
   Odf_Notes_configuration_master_page_name *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Notes_configuration_master_page_name (OSCTXT* pctxt, 
   Odf_Notes_configuration_master_page_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Notes_configuration_element                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Notes_configuration_element (OSCTXT* pctxt, 
   Odf_Notes_configuration_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = asn1D_Odf_Note_continuation_notice_forward (pctxt, 
            &pvalue->u.note_continuation_notice_forward, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = asn1D_Odf_Note_continuation_notice_backward (pctxt, 
            &pvalue->u.note_continuation_notice_backward, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Notes_configuration_element (OSCTXT* pctxt, 
   Odf_Notes_configuration_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("note-continuation-notice-forward"), 32}, 0}, 0 },
      {{{OSUTF8("note-continuation-notice-backward"), 33}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* note-continuation-notice-forward */
      stat = XmlDec_Odf_Note_continuation_notice_forward (pctxt, &pvalue->
         u.note_continuation_notice_forward);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* note-continuation-notice-backward */
      stat = XmlDec_Odf_Note_continuation_notice_backward (pctxt, &pvalue->
         u.note_continuation_notice_backward);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Notes_configuration                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Notes_configuration (OSCTXT* pctxt, 
   Odf_Notes_configuration *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode num_format */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->num_format = rtxMemAllocType (pctxt, Ns8_Num_format);

            if (pvalue->num_format == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);
            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);

            stat = asn1D_Ns8_Num_format (pctxt, 
               (Ns8_Num_format*)pvalue->num_format, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.num_formatPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode num_letter_sync */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Num_letter_sync (pctxt, 
               (Ns8_Num_letter_sync*)&pvalue->num_letter_sync, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.num_letter_syncPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode num_prefix */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Num_prefix (pctxt, 
               (Ns8_Num_prefix*)&pvalue->num_prefix, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.num_prefixPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode num_suffix */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Num_suffix (pctxt, 
               (Ns8_Num_suffix*)&pvalue->num_suffix, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.num_suffixPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode citation_body_style_name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Notes_configuration_citation_body_style_name (pctxt, 
               &pvalue->citation_body_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.citation_body_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode citation_style_name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Notes_configuration_citation_style_name (pctxt, 
               &pvalue->citation_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.citation_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode default_style_name */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Notes_configuration_default_style_name (pctxt, 
               &pvalue->default_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.default_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode footnotes_position */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Notes_configuration_footnotes_position (pctxt, 
               &pvalue->footnotes_position, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.footnotes_positionPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode master_page_name */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Notes_configuration_master_page_name (pctxt, 
               &pvalue->master_page_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.master_page_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode note_class */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Notes_configuration_note_class (pctxt, 
               &pvalue->note_class, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 10:
         /* decode start_numbering_at */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Notes_configuration_start_numbering_at (pctxt, 
               &pvalue->start_numbering_at, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.start_numbering_atPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode start_value */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->start_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.start_valuePresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Notes_configuration_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Notes_configuration_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_Notes_configuration_element (pdata2);

                  stat = asn1D_Odf_Notes_configuration_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_CONS|12):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Notes_configuration (OSCTXT* pctxt, 
   Odf_Notes_configuration* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("num-format"), 10}, 0 },
         { {OSUTF8("num-letter-sync"), 15}, 0 },
         { {OSUTF8("num-prefix"), 10}, 0 },
         { {OSUTF8("num-suffix"), 10}, 0 },
         { {OSUTF8("citation-body-style-name"), 24}, 0 },
         { {OSUTF8("citation-style-name"), 19}, 0 },
         { {OSUTF8("default-style-name"), 18}, 0 },
         { {OSUTF8("footnotes-position"), 18}, 0 },
         { {OSUTF8("master-page-name"), 16}, 0 },
         { {OSUTF8("note-class"), 10}, 0 },
         { {OSUTF8("start-numbering-at"), 18}, 0 },
         { {OSUTF8("start-value"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 12, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* num-format */
            pvalue->num_format = rtxMemAllocType (pctxt, Ns8_Num_format);

            if (pvalue->num_format == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);

            stat = XmlDec_Ns8_Num_format (pctxt, pvalue->num_format);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.num_formatPresent = TRUE;
            break;

         case 1: /* num-letter-sync */
            stat = XmlDec_Ns8_Num_letter_sync (pctxt, &pvalue->num_letter_sync
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.num_letter_syncPresent = TRUE;
            break;

         case 2: /* num-prefix */
            stat = XmlDec_Ns8_Num_prefix (pctxt, &pvalue->num_prefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.num_prefixPresent = TRUE;
            break;

         case 3: /* num-suffix */
            stat = XmlDec_Ns8_Num_suffix (pctxt, &pvalue->num_suffix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.num_suffixPresent = TRUE;
            break;

         case 4: /* citation-body-style-name */
            stat = XmlDec_Odf_Notes_configuration_citation_body_style_name 
               (pctxt, &pvalue->citation_body_style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.citation_body_style_namePresent = TRUE;
            break;

         case 5: /* citation-style-name */
            stat = XmlDec_Odf_Notes_configuration_citation_style_name (pctxt, &
               pvalue->citation_style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.citation_style_namePresent = TRUE;
            break;

         case 6: /* default-style-name */
            stat = XmlDec_Odf_Notes_configuration_default_style_name (pctxt, &
               pvalue->default_style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.default_style_namePresent = TRUE;
            break;

         case 7: /* footnotes-position */
            stat = XmlDec_Odf_Notes_configuration_footnotes_position (pctxt, &
               pvalue->footnotes_position);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.footnotes_positionPresent = TRUE;
            break;

         case 8: /* master-page-name */
            stat = XmlDec_Odf_Notes_configuration_master_page_name (pctxt, &
               pvalue->master_page_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.master_page_namePresent = TRUE;
            break;

         case 9: /* note-class */
            stat = XmlDec_Odf_Notes_configuration_note_class (pctxt, &pvalue->
               note_class);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 10: /* start-numbering-at */
            stat = XmlDec_Odf_Notes_configuration_start_numbering_at (pctxt, &
               pvalue->start_numbering_at);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.start_numbering_atPresent = TRUE;
            break;

         case 11: /* start-value */
            stat = rtXmlpDecUInt (pctxt, &pvalue->start_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.start_valuePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Notes_configuration");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Notes_configuration");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("note-continuation-notice-forward"), 32}, 0}, 0 },
      {{{OSUTF8("note-continuation-notice-backward"), 33}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_Notes_configuration_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_Notes_configuration_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Notes_configuration_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Odf_Notes_configuration_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 2, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sort_key                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sort_key (OSCTXT* pctxt, Odf_Sort_key *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode key */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Sort_key_key (pctxt, 
               &pvalue->key, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode sort_ascending */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Sort_key_sort_ascending (pctxt, 
               &pvalue->sort_ascending, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sort_ascendingPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Sort_key (OSCTXT* pctxt, Odf_Sort_key* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("key"), 3}, 0 },
         { {OSUTF8("sort-ascending"), 14}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* key */
            stat = XmlDec_Odf_Sort_key_key (pctxt, &pvalue->key);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* sort-ascending */
            stat = XmlDec_Odf_Sort_key_sort_ascending (pctxt, &pvalue->
               sort_ascending);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.sort_ascendingPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Sort_key");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Sort_key");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Bibliography_configuration                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Bibliography_configuration (OSCTXT* pctxt, 
   Odf_Bibliography_configuration *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode numbered_entries */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Bibliography_configuration_numbered_entries (pctxt, 
               &pvalue->numbered_entries, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.numbered_entriesPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode prefix */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->prefix, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.prefixPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode sort_algorithm */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->sort_algorithm, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sort_algorithmPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode sort_by_position */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Bibliography_configuration_sort_by_position (pctxt, 
               &pvalue->sort_by_position, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sort_by_positionPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode suffix */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->suffix, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.suffixPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode country */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns1_Country (pctxt, 
               &pvalue->country, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.countryPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns1_Language (pctxt, 
               &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode sort_key_list */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Sort_key* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->sort_key_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Sort_key, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_Sort_key (pdata2);

                  stat = asn1D_Odf_Sort_key (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->sort_key_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Bibliography_configuration (OSCTXT* pctxt, 
   Odf_Bibliography_configuration* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("numbered-entries"), 16}, 0 },
         { {OSUTF8("prefix"), 6}, 0 },
         { {OSUTF8("sort-algorithm"), 14}, 0 },
         { {OSUTF8("sort-by-position"), 16}, 0 },
         { {OSUTF8("suffix"), 6}, 0 },
         { {OSUTF8("country"), 7}, 0 },
         { {OSUTF8("language"), 8}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 7, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* numbered-entries */
            stat = XmlDec_Odf_Bibliography_configuration_numbered_entries 
               (pctxt, &pvalue->numbered_entries);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.numbered_entriesPresent = TRUE;
            break;

         case 1: /* prefix */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->prefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.prefixPresent = TRUE;
            break;

         case 2: /* sort-algorithm */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->sort_algorithm);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.sort_algorithmPresent = TRUE;
            break;

         case 3: /* sort-by-position */
            stat = XmlDec_Odf_Bibliography_configuration_sort_by_position 
               (pctxt, &pvalue->sort_by_position);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.sort_by_positionPresent = TRUE;
            break;

         case 4: /* suffix */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->suffix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.suffixPresent = TRUE;
            break;

         case 5: /* country */
            stat = XmlDec_Ns1_Country (pctxt, &pvalue->country);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.countryPresent = TRUE;
            break;

         case 6: /* language */
            stat = XmlDec_Ns1_Language (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Bibliography_configuration");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Bibliography_configuration");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("sort-key"), 8}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_Sort_key* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_Sort_key);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Sort_key (pdata1);

            stat = XmlDec_Odf_Sort_key (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->sort_key_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Linenumbering_configuration_style_name                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Linenumbering_configuration_style_name (OSCTXT* pctxt, 
   Odf_Linenumbering_configuration_style_name *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Linenumbering_configuration_style_name (OSCTXT* pctxt, 
   Odf_Linenumbering_configuration_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Linenumbering_separator                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Linenumbering_separator (OSCTXT* pctxt, 
   Odf_Linenumbering_separator *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode increment */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->increment, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.incrementPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Linenumbering_separator (OSCTXT* pctxt, 
   Odf_Linenumbering_separator* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("increment"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* increment */
            stat = rtXmlpDecUInt (pctxt, &pvalue->increment);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.incrementPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Linenumbering_separator");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Linenumbering_separator");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Linenumbering_configuration                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Linenumbering_configuration (OSCTXT* pctxt, 
   Odf_Linenumbering_configuration *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode num_format */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->num_format = rtxMemAllocType (pctxt, Ns8_Num_format);

            if (pvalue->num_format == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);
            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);

            stat = asn1D_Ns8_Num_format (pctxt, 
               (Ns8_Num_format*)pvalue->num_format, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.num_formatPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode num_letter_sync */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Num_letter_sync (pctxt, 
               (Ns8_Num_letter_sync*)&pvalue->num_letter_sync, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.num_letter_syncPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode count_empty_lines */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Linenumbering_configuration_count_empty_lines (pctxt, 
               &pvalue->count_empty_lines, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.count_empty_linesPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode count_in_text_boxes */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Linenumbering_configuration_count_in_text_boxes (pctxt, 
               &pvalue->count_in_text_boxes, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.count_in_text_boxesPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode increment */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->increment, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.incrementPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode number_lines */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Linenumbering_configuration_number_lines (pctxt, 
               &pvalue->number_lines, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.number_linesPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode number_position */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Linenumbering_configuration_number_position (pctxt, 
               &pvalue->number_position, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.number_positionPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode offset */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->offset, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.offsetPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode restart_on_page */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Linenumbering_configuration_restart_on_page (pctxt, 
               &pvalue->restart_on_page, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.restart_on_pagePresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Linenumbering_configuration_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 10:
         /* decode linenumbering_separator */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Linenumbering_separator (pctxt, 
               &pvalue->linenumbering_separator, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.linenumbering_separatorPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Linenumbering_configuration (OSCTXT* pctxt, 
   Odf_Linenumbering_configuration* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("num-format"), 10}, 0 },
         { {OSUTF8("num-letter-sync"), 15}, 0 },
         { {OSUTF8("count-empty-lines"), 17}, 0 },
         { {OSUTF8("count-in-text-boxes"), 19}, 0 },
         { {OSUTF8("increment"), 9}, 0 },
         { {OSUTF8("number-lines"), 12}, 0 },
         { {OSUTF8("number-position"), 15}, 0 },
         { {OSUTF8("offset"), 6}, 0 },
         { {OSUTF8("restart-on-page"), 15}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 10, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* num-format */
            pvalue->num_format = rtxMemAllocType (pctxt, Ns8_Num_format);

            if (pvalue->num_format == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);

            stat = XmlDec_Ns8_Num_format (pctxt, pvalue->num_format);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.num_formatPresent = TRUE;
            break;

         case 1: /* num-letter-sync */
            stat = XmlDec_Ns8_Num_letter_sync (pctxt, &pvalue->num_letter_sync
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.num_letter_syncPresent = TRUE;
            break;

         case 2: /* count-empty-lines */
            stat = XmlDec_Odf_Linenumbering_configuration_count_empty_lines 
               (pctxt, &pvalue->count_empty_lines);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.count_empty_linesPresent = TRUE;
            break;

         case 3: /* count-in-text-boxes */
            stat = XmlDec_Odf_Linenumbering_configuration_count_in_text_boxes 
               (pctxt, &pvalue->count_in_text_boxes);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.count_in_text_boxesPresent = TRUE;
            break;

         case 4: /* increment */
            stat = rtXmlpDecUInt (pctxt, &pvalue->increment);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.incrementPresent = TRUE;
            break;

         case 5: /* number-lines */
            stat = XmlDec_Odf_Linenumbering_configuration_number_lines (pctxt, 
               &pvalue->number_lines);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.number_linesPresent = TRUE;
            break;

         case 6: /* number-position */
            stat = XmlDec_Odf_Linenumbering_configuration_number_position 
               (pctxt, &pvalue->number_position);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.number_positionPresent = TRUE;
            break;

         case 7: /* offset */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->offset);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.offsetPresent = TRUE;
            break;

         case 8: /* restart-on-page */
            stat = XmlDec_Odf_Linenumbering_configuration_restart_on_page 
               (pctxt, &pvalue->restart_on_page);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.restart_on_pagePresent = TRUE;
            break;

         case 9: /* style-name */
            stat = XmlDec_Odf_Linenumbering_configuration_style_name (pctxt, &
               pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Linenumbering_configuration");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Linenumbering_configuration");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("linenumbering-separator"), 23}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* linenumbering-separator */
         stat = XmlDec_Odf_Linenumbering_separator (pctxt, &pvalue->
            linenumbering_separator);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.linenumbering_separatorPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  P_cond_style_name                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_P_cond_style_name (OSCTXT* pctxt, 
   Odf_P_cond_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_P_cond_style_name (OSCTXT* pctxt, Odf_P_cond_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  P_style_name                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_P_style_name (OSCTXT* pctxt, Odf_P_style_name *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_P_style_name (OSCTXT* pctxt, Odf_P_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  S                                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_S (OSCTXT* pctxt, Odf_S *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode c */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->c, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.cPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_S (OSCTXT* pctxt, Odf_S* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("c"), 1}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* c */
            stat = rtXmlpDecUInt (pctxt, &pvalue->c);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.cPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_S");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_S");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Tab                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Tab (OSCTXT* pctxt, Odf_Tab *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode tab_ref */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->tab_ref, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_refPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Tab (OSCTXT* pctxt, Odf_Tab* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("tab-ref"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* tab-ref */
            stat = rtXmlpDecUInt (pctxt, &pvalue->tab_ref);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_refPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Tab");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Tab");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Line_break                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Line_break (OSCTXT* pctxt, Odf_Line_break *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   if (tagging == ASN1EXPL && length == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Line_break (OSCTXT* pctxt, Odf_Line_break* pvalue)
{
   int stat = 0;

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Span_style_name                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Span_style_name (OSCTXT* pctxt, 
   Odf_Span_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Span_style_name (OSCTXT* pctxt, Odf_Span_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  A_style_name                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_A_style_name (OSCTXT* pctxt, Odf_A_style_name *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_A_style_name (OSCTXT* pctxt, Odf_A_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  A_visited_style_name                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_A_visited_style_name (OSCTXT* pctxt, 
   Odf_A_visited_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_A_visited_style_name (OSCTXT* pctxt, 
   Odf_A_visited_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Bookmark                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Bookmark (OSCTXT* pctxt, Odf_Bookmark *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Bookmark (OSCTXT* pctxt, Odf_Bookmark* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("name"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Bookmark");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Bookmark");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Bookmark_start                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Bookmark_start (OSCTXT* pctxt, 
   Odf_Bookmark_start *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Bookmark_start (OSCTXT* pctxt, Odf_Bookmark_start* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("name"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Bookmark_start");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Bookmark_start");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Bookmark_end                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Bookmark_end (OSCTXT* pctxt, Odf_Bookmark_end *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Bookmark_end (OSCTXT* pctxt, Odf_Bookmark_end* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("name"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Bookmark_end");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Bookmark_end");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reference_mark                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Reference_mark (OSCTXT* pctxt, 
   Odf_Reference_mark *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Reference_mark (OSCTXT* pctxt, Odf_Reference_mark* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("name"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Reference_mark");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Reference_mark");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reference_mark_start                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Reference_mark_start (OSCTXT* pctxt, 
   Odf_Reference_mark_start *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Reference_mark_start (OSCTXT* pctxt, 
   Odf_Reference_mark_start* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("name"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Reference_mark_start");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Reference_mark_start");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reference_mark_end                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Reference_mark_end (OSCTXT* pctxt, 
   Odf_Reference_mark_end *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Reference_mark_end (OSCTXT* pctxt, 
   Odf_Reference_mark_end* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("name"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Reference_mark_end");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Reference_mark_end");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Note_citation                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Note_citation (OSCTXT* pctxt, Odf_Note_citation *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode label */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->label, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.labelPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Note_citation (OSCTXT* pctxt, Odf_Note_citation* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("label"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* label */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->label);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.labelPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Note_citation");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Note_citation");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H_cond_style_name                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_H_cond_style_name (OSCTXT* pctxt, 
   Odf_H_cond_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_H_cond_style_name (OSCTXT* pctxt, Odf_H_cond_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H_style_name                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_H_style_name (OSCTXT* pctxt, Odf_H_style_name *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_H_style_name (OSCTXT* pctxt, Odf_H_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ruby_style_name                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Ruby_style_name (OSCTXT* pctxt, 
   Odf_Ruby_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Ruby_style_name (OSCTXT* pctxt, Odf_Ruby_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  List_style_name                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_List_style_name (OSCTXT* pctxt, 
   Odf_List_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_List_style_name (OSCTXT* pctxt, Odf_List_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  List_header_element                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_List_header_element (OSCTXT* pctxt, 
   Odf_List_header_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P ((Odf_P*)pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            (Odf_P*)pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

         if (pvalue->u.h == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_H ((Odf_H*)pvalue->u.h);
         stat = asn1D_Odf_H (pctxt, 
            (Odf_H*)pvalue->u.h, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List ((Odf_List*)pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            (Odf_List*)pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_List_header_element (OSCTXT* pctxt, 
   Odf_List_header_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("h"), 1}, 0}, 1 },
      {{{OSUTF8("list"), 4}, 0}, 2 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P ((Odf_P*)pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* h */
      pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

      if (pvalue->u.h == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_H ((Odf_H*)pvalue->u.h);

      stat = XmlDec_Odf_H (pctxt, pvalue->u.h);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List ((Odf_List*)pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  List_header                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_List_header (OSCTXT* pctxt, Odf_List_header *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode number */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Number (pctxt, 
               &pvalue->number, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.numberPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_List_header_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_List_header_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_List_header_element (pdata2);

                  stat = asn1D_Odf_List_header_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_List_header (OSCTXT* pctxt, Odf_List_header* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("number"), 6}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 1 },
      {{{OSUTF8("h"), 1}, 0}, 1 },
      {{{OSUTF8("list"), 4}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* number */
         stat = XmlDec_Odf_Number (pctxt, &pvalue->number);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.numberPresent = TRUE;
         break;
      }
      case 1: {
         Odf_List_header_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_List_header_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_List_header_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Odf_List_header_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 3, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  List_item_element                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_List_item_element (OSCTXT* pctxt, 
   Odf_List_item_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P ((Odf_P*)pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            (Odf_P*)pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

         if (pvalue->u.h == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_H ((Odf_H*)pvalue->u.h);
         stat = asn1D_Odf_H (pctxt, 
            (Odf_H*)pvalue->u.h, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List ((Odf_List*)pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            (Odf_List*)pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_List_item_element (OSCTXT* pctxt, Odf_List_item_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("h"), 1}, 0}, 1 },
      {{{OSUTF8("list"), 4}, 0}, 2 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P ((Odf_P*)pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* h */
      pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

      if (pvalue->u.h == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_H ((Odf_H*)pvalue->u.h);

      stat = XmlDec_Odf_H (pctxt, pvalue->u.h);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List ((Odf_List*)pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  List_item                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_List_item (OSCTXT* pctxt, Odf_List_item *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode start_value */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->start_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.start_valuePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode number */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Number (pctxt, 
               &pvalue->number, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.numberPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_List_item_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_List_item_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_List_item_element (pdata2);

                  stat = asn1D_Odf_List_item_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_List_item (OSCTXT* pctxt, Odf_List_item* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("start-value"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* start-value */
            stat = rtXmlpDecUInt (pctxt, &pvalue->start_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.start_valuePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_List_item");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_List_item");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("number"), 6}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 1 },
      {{{OSUTF8("h"), 1}, 0}, 1 },
      {{{OSUTF8("list"), 4}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* number */
         stat = XmlDec_Odf_Number (pctxt, &pvalue->number);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.numberPresent = TRUE;
         break;
      }
      case 1: {
         Odf_List_item_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_List_item_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_List_item_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Odf_List_item_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 3, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  List                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_List (OSCTXT* pctxt, Odf_List *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode continue_numbering */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_List_continue_numbering (pctxt, 
               &pvalue->continue_numbering, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.continue_numberingPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_List_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode list_header */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_List_header (pctxt, 
               &pvalue->list_header, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.list_headerPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode list_item_list */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_List_item* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->list_item_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_List_item, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_List_item (pdata2);

                  stat = asn1D_Odf_List_item (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->list_item_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_List (OSCTXT* pctxt, Odf_List* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("continue-numbering"), 18}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* continue-numbering */
            stat = XmlDec_Odf_List_continue_numbering (pctxt, &pvalue->
               continue_numbering);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.continue_numberingPresent = TRUE;
            break;

         case 1: /* style-name */
            stat = XmlDec_Odf_List_style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_List");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_List");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("list-header"), 11}, 0}, 0 },
      {{{OSUTF8("list-item"), 9}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* list-header */
         stat = XmlDec_Odf_List_header (pctxt, &pvalue->list_header);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.list_headerPresent = TRUE;
         break;
      }
      case 1: {
         Odf_List_item* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_List_item);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_List_item (pdata1);

            stat = XmlDec_Odf_List_item (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->list_item_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Change                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Change (OSCTXT* pctxt, Odf_Change *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode change_id */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->change_id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Change (OSCTXT* pctxt, Odf_Change* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("change-id"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* change-id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->change_id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Change");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Change");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Change_start                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Change_start (OSCTXT* pctxt, Odf_Change_start *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode change_id */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->change_id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Change_start (OSCTXT* pctxt, Odf_Change_start* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("change-id"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* change-id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->change_id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Change_start");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Change_start");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Change_end                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Change_end (OSCTXT* pctxt, Odf_Change_end *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode change_id */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->change_id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Change_end (OSCTXT* pctxt, Odf_Change_end* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("change-id"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* change-id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->change_id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Change_end");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Change_end");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  P                                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_P (OSCTXT* pctxt, Odf_P *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode class_names */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->class_names);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->class_names, pnode);
               }

            }
            if (stat == 0) {
               pvalue->m.class_namesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode cond_style_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_P_cond_style_name (pctxt, 
               &pvalue->cond_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.cond_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_P_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_P_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_P_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_P_element (pdata2);

                  stat = asn1D_Odf_P_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_P (OSCTXT* pctxt, Odf_P* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("cond-style-name"), 15}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* class-names */
            rtxDListInit (&pvalue->class_names);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_namesPresent = TRUE;
            break;

         case 1: /* cond-style-name */
            stat = XmlDec_Odf_P_cond_style_name (pctxt, &pvalue->
               cond_style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.cond_style_namePresent = TRUE;
            break;

         case 2: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 3: /* style-name */
            stat = XmlDec_Odf_P_style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_P");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_P");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("s"), 1}, 0}, 0 },
      {{{OSUTF8("tab"), 3}, 0}, 0 },
      {{{OSUTF8("line-break"), 10}, 0}, 0 },
      {{{OSUTF8("span"), 4}, 0}, 0 },
      {{{OSUTF8("a"), 1}, 0}, 0 },
      {{{OSUTF8("bookmark"), 8}, 0}, 0 },
      {{{OSUTF8("bookmark-start"), 14}, 0}, 0 },
      {{{OSUTF8("bookmark-end"), 12}, 0}, 0 },
      {{{OSUTF8("reference-mark"), 14}, 0}, 0 },
      {{{OSUTF8("reference-mark-start"), 20}, 0}, 0 },
      {{{OSUTF8("reference-mark-end"), 18}, 0}, 0 },
      {{{OSUTF8("note"), 4}, 0}, 0 },
      {{{OSUTF8("ruby"), 4}, 0}, 0 },
      {{{OSUTF8("annotation"), 10}, 0}, 0 },
      {{{OSUTF8("change"), 6}, 0}, 0 },
      {{{OSUTF8("change-start"), 12}, 0}, 0 },
      {{{OSUTF8("change-end"), 10}, 0}, 0 },
      {{{OSUTF8("rect"), 4}, 0}, 0 },
      {{{OSUTF8("line"), 4}, 0}, 0 },
      {{{OSUTF8("polyline"), 8}, 0}, 0 },
      {{{OSUTF8("polygon"), 7}, 0}, 0 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 0 },
      {{{OSUTF8("path"), 4}, 0}, 0 },
      {{{OSUTF8("circle"), 6}, 0}, 0 },
      {{{OSUTF8("ellipse"), 7}, 0}, 0 },
      {{{OSUTF8("g"), 1}, 0}, 0 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 0 },
      {{{OSUTF8("frame"), 5}, 0}, 0 },
      {{{OSUTF8("measure"), 7}, 0}, 0 },
      {{{OSUTF8("caption"), 7}, 0}, 0 },
      {{{OSUTF8("connector"), 9}, 0}, 0 },
      {{{OSUTF8("control"), 7}, 0}, 0 },
      {{{OSUTF8("scene"), 5}, 0}, 0 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 0 },
      {{{OSUTF8("date"), 4}, 0}, 0 },
      {{{OSUTF8("time"), 4}, 0}, 0 },
      {{{OSUTF8("page-number"), 11}, 0}, 0 },
      {{{OSUTF8("page-continuation"), 17}, 0}, 0 },
      {{{OSUTF8("sender-firstname"), 16}, 0}, 0 },
      {{{OSUTF8("sender-lastname"), 15}, 0}, 0 },
      {{{OSUTF8("sender-initials"), 15}, 0}, 0 },
      {{{OSUTF8("sender-title"), 12}, 0}, 0 },
      {{{OSUTF8("sender-position"), 15}, 0}, 0 },
      {{{OSUTF8("sender-email"), 12}, 0}, 0 },
      {{{OSUTF8("sender-phone-private"), 20}, 0}, 0 },
      {{{OSUTF8("sender-fax"), 10}, 0}, 0 },
      {{{OSUTF8("sender-company"), 14}, 0}, 0 },
      {{{OSUTF8("sender-phone-work"), 17}, 0}, 0 },
      {{{OSUTF8("sender-street"), 13}, 0}, 0 },
      {{{OSUTF8("sender-city"), 11}, 0}, 0 },
      {{{OSUTF8("sender-postal-code"), 18}, 0}, 0 },
      {{{OSUTF8("sender-country"), 14}, 0}, 0 },
      {{{OSUTF8("sender-state-or-province"), 24}, 0}, 0 },
      {{{OSUTF8("author-name"), 11}, 0}, 0 },
      {{{OSUTF8("author-initials"), 15}, 0}, 0 },
      {{{OSUTF8("chapter"), 7}, 0}, 0 },
      {{{OSUTF8("file-name"), 9}, 0}, 0 },
      {{{OSUTF8("template-name"), 13}, 0}, 0 },
      {{{OSUTF8("sheet-name"), 10}, 0}, 0 },
      {{{OSUTF8("variable-set"), 12}, 0}, 0 },
      {{{OSUTF8("variable-get"), 12}, 0}, 0 },
      {{{OSUTF8("variable-input"), 14}, 0}, 0 },
      {{{OSUTF8("user-field-get"), 14}, 0}, 0 },
      {{{OSUTF8("user-field-input"), 16}, 0}, 0 },
      {{{OSUTF8("sequence"), 8}, 0}, 0 },
      {{{OSUTF8("expression"), 10}, 0}, 0 },
      {{{OSUTF8("text-input"), 10}, 0}, 0 },
      {{{OSUTF8("initial-creator"), 15}, 0}, 0 },
      {{{OSUTF8("creation-date"), 13}, 0}, 0 },
      {{{OSUTF8("creation-time"), 13}, 0}, 0 },
      {{{OSUTF8("description"), 11}, 0}, 0 },
      {{{OSUTF8("user-defined"), 12}, 0}, 0 },
      {{{OSUTF8("print-time"), 10}, 0}, 0 },
      {{{OSUTF8("print-date"), 10}, 0}, 0 },
      {{{OSUTF8("printed-by"), 10}, 0}, 0 },
      {{{OSUTF8("title"), 5}, 0}, 0 },
      {{{OSUTF8("subject"), 7}, 0}, 0 },
      {{{OSUTF8("keywords"), 8}, 0}, 0 },
      {{{OSUTF8("editing-cycles"), 14}, 0}, 0 },
      {{{OSUTF8("editing-duration"), 16}, 0}, 0 },
      {{{OSUTF8("modification-time"), 17}, 0}, 0 },
      {{{OSUTF8("modification-date"), 17}, 0}, 0 },
      {{{OSUTF8("creator"), 7}, 0}, 0 },
      {{{OSUTF8("page-count"), 10}, 0}, 0 },
      {{{OSUTF8("paragraph-count"), 15}, 0}, 0 },
      {{{OSUTF8("word-count"), 10}, 0}, 0 },
      {{{OSUTF8("character-count"), 15}, 0}, 0 },
      {{{OSUTF8("table-count"), 11}, 0}, 0 },
      {{{OSUTF8("image-count"), 11}, 0}, 0 },
      {{{OSUTF8("object-count"), 12}, 0}, 0 },
      {{{OSUTF8("database-display"), 16}, 0}, 0 },
      {{{OSUTF8("database-next"), 13}, 0}, 0 },
      {{{OSUTF8("database-row-select"), 19}, 0}, 0 },
      {{{OSUTF8("database-row-number"), 19}, 0}, 0 },
      {{{OSUTF8("database-name"), 13}, 0}, 0 },
      {{{OSUTF8("page-variable-set"), 17}, 0}, 0 },
      {{{OSUTF8("page-variable-get"), 17}, 0}, 0 },
      {{{OSUTF8("placeholder"), 11}, 0}, 0 },
      {{{OSUTF8("conditional-text"), 16}, 0}, 0 },
      {{{OSUTF8("hidden-text"), 11}, 0}, 0 },
      {{{OSUTF8("reference-ref"), 13}, 0}, 0 },
      {{{OSUTF8("bookmark-ref"), 12}, 0}, 0 },
      {{{OSUTF8("note-ref"), 8}, 0}, 0 },
      {{{OSUTF8("sequence-ref"), 12}, 0}, 0 },
      {{{OSUTF8("script"), 6}, 0}, 0 },
      {{{OSUTF8("execute-macro"), 13}, 0}, 0 },
      {{{OSUTF8("hidden-paragraph"), 16}, 0}, 0 },
      {{{OSUTF8("dde-connection"), 14}, 0}, 0 },
      {{{OSUTF8("table-formula"), 13}, 0}, 0 },
      {{{OSUTF8("toc-mark-start"), 14}, 0}, 0 },
      {{{OSUTF8("toc-mark-end"), 12}, 0}, 0 },
      {{{OSUTF8("toc-mark"), 8}, 0}, 0 },
      {{{OSUTF8("user-index-mark-start"), 21}, 0}, 0 },
      {{{OSUTF8("user-index-mark-end"), 19}, 0}, 0 },
      {{{OSUTF8("user-index-mark"), 15}, 0}, 0 },
      {{{OSUTF8("alphabetical-index-mark-start"), 29}, 0}, 0 },
      {{{OSUTF8("alphabetical-index-mark-end"), 27}, 0}, 0 },
      {{{OSUTF8("alphabetical-index-mark"), 23}, 0}, 0 },
      {{{OSUTF8("bibliography-mark"), 17}, 0}, 0 },
      {{{OSUTF8("header"), 6}, 0}, 0 },
      {{{OSUTF8("footer"), 6}, 0}, 0 },
      {{{OSUTF8("date-time"), 9}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 122, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_P_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_P_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_P_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Odf_P_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 122, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Numbered_paragraph_style_name                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Numbered_paragraph_style_name (OSCTXT* pctxt, 
   Odf_Numbered_paragraph_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Numbered_paragraph_style_name (OSCTXT* pctxt, 
   Odf_Numbered_paragraph_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H                                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_H (OSCTXT* pctxt, Odf_H *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode class_names */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->class_names);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->class_names, pnode);
               }

            }
            if (stat == 0) {
               pvalue->m.class_namesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode cond_style_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_H_cond_style_name (pctxt, 
               &pvalue->cond_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.cond_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode is_list_header */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_H_is_list_header (pctxt, 
               &pvalue->is_list_header, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.is_list_headerPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode outline_level */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->outline_level, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode restart_numbering */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_H_restart_numbering (pctxt, 
               &pvalue->restart_numbering, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.restart_numberingPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode start_value */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->start_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.start_valuePresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_H_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode number */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Number (pctxt, 
               &pvalue->number, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.numberPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_H_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_H_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_H_element (pdata2);

                  stat = asn1D_Odf_H_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_H (OSCTXT* pctxt, Odf_H* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("cond-style-name"), 15}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("is-list-header"), 14}, 0 },
         { {OSUTF8("outline-level"), 13}, 0 },
         { {OSUTF8("restart-numbering"), 17}, 0 },
         { {OSUTF8("start-value"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 8, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* class-names */
            rtxDListInit (&pvalue->class_names);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_namesPresent = TRUE;
            break;

         case 1: /* cond-style-name */
            stat = XmlDec_Odf_H_cond_style_name (pctxt, &pvalue->
               cond_style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.cond_style_namePresent = TRUE;
            break;

         case 2: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 3: /* is-list-header */
            stat = XmlDec_Odf_H_is_list_header (pctxt, &pvalue->is_list_header
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.is_list_headerPresent = TRUE;
            break;

         case 4: /* outline-level */
            stat = rtXmlpDecUInt (pctxt, &pvalue->outline_level);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* restart-numbering */
            stat = XmlDec_Odf_H_restart_numbering (pctxt, &pvalue->
               restart_numbering);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.restart_numberingPresent = TRUE;
            break;

         case 6: /* start-value */
            stat = rtXmlpDecUInt (pctxt, &pvalue->start_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.start_valuePresent = TRUE;
            break;

         case 7: /* style-name */
            stat = XmlDec_Odf_H_style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_H");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_H");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("number"), 6}, 0}, 0 },
      {{{OSUTF8("s"), 1}, 0}, 1 },
      {{{OSUTF8("tab"), 3}, 0}, 1 },
      {{{OSUTF8("line-break"), 10}, 0}, 1 },
      {{{OSUTF8("span"), 4}, 0}, 1 },
      {{{OSUTF8("a"), 1}, 0}, 1 },
      {{{OSUTF8("bookmark"), 8}, 0}, 1 },
      {{{OSUTF8("bookmark-start"), 14}, 0}, 1 },
      {{{OSUTF8("bookmark-end"), 12}, 0}, 1 },
      {{{OSUTF8("reference-mark"), 14}, 0}, 1 },
      {{{OSUTF8("reference-mark-start"), 20}, 0}, 1 },
      {{{OSUTF8("reference-mark-end"), 18}, 0}, 1 },
      {{{OSUTF8("note"), 4}, 0}, 1 },
      {{{OSUTF8("ruby"), 4}, 0}, 1 },
      {{{OSUTF8("annotation"), 10}, 0}, 1 },
      {{{OSUTF8("change"), 6}, 0}, 1 },
      {{{OSUTF8("change-start"), 12}, 0}, 1 },
      {{{OSUTF8("change-end"), 10}, 0}, 1 },
      {{{OSUTF8("rect"), 4}, 0}, 1 },
      {{{OSUTF8("line"), 4}, 0}, 1 },
      {{{OSUTF8("polyline"), 8}, 0}, 1 },
      {{{OSUTF8("polygon"), 7}, 0}, 1 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 1 },
      {{{OSUTF8("path"), 4}, 0}, 1 },
      {{{OSUTF8("circle"), 6}, 0}, 1 },
      {{{OSUTF8("ellipse"), 7}, 0}, 1 },
      {{{OSUTF8("g"), 1}, 0}, 1 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 1 },
      {{{OSUTF8("frame"), 5}, 0}, 1 },
      {{{OSUTF8("measure"), 7}, 0}, 1 },
      {{{OSUTF8("caption"), 7}, 0}, 1 },
      {{{OSUTF8("connector"), 9}, 0}, 1 },
      {{{OSUTF8("control"), 7}, 0}, 1 },
      {{{OSUTF8("scene"), 5}, 0}, 1 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 1 },
      {{{OSUTF8("date"), 4}, 0}, 1 },
      {{{OSUTF8("time"), 4}, 0}, 1 },
      {{{OSUTF8("page-number"), 11}, 0}, 1 },
      {{{OSUTF8("page-continuation"), 17}, 0}, 1 },
      {{{OSUTF8("sender-firstname"), 16}, 0}, 1 },
      {{{OSUTF8("sender-lastname"), 15}, 0}, 1 },
      {{{OSUTF8("sender-initials"), 15}, 0}, 1 },
      {{{OSUTF8("sender-title"), 12}, 0}, 1 },
      {{{OSUTF8("sender-position"), 15}, 0}, 1 },
      {{{OSUTF8("sender-email"), 12}, 0}, 1 },
      {{{OSUTF8("sender-phone-private"), 20}, 0}, 1 },
      {{{OSUTF8("sender-fax"), 10}, 0}, 1 },
      {{{OSUTF8("sender-company"), 14}, 0}, 1 },
      {{{OSUTF8("sender-phone-work"), 17}, 0}, 1 },
      {{{OSUTF8("sender-street"), 13}, 0}, 1 },
      {{{OSUTF8("sender-city"), 11}, 0}, 1 },
      {{{OSUTF8("sender-postal-code"), 18}, 0}, 1 },
      {{{OSUTF8("sender-country"), 14}, 0}, 1 },
      {{{OSUTF8("sender-state-or-province"), 24}, 0}, 1 },
      {{{OSUTF8("author-name"), 11}, 0}, 1 },
      {{{OSUTF8("author-initials"), 15}, 0}, 1 },
      {{{OSUTF8("chapter"), 7}, 0}, 1 },
      {{{OSUTF8("file-name"), 9}, 0}, 1 },
      {{{OSUTF8("template-name"), 13}, 0}, 1 },
      {{{OSUTF8("sheet-name"), 10}, 0}, 1 },
      {{{OSUTF8("variable-set"), 12}, 0}, 1 },
      {{{OSUTF8("variable-get"), 12}, 0}, 1 },
      {{{OSUTF8("variable-input"), 14}, 0}, 1 },
      {{{OSUTF8("user-field-get"), 14}, 0}, 1 },
      {{{OSUTF8("user-field-input"), 16}, 0}, 1 },
      {{{OSUTF8("sequence"), 8}, 0}, 1 },
      {{{OSUTF8("expression"), 10}, 0}, 1 },
      {{{OSUTF8("text-input"), 10}, 0}, 1 },
      {{{OSUTF8("initial-creator"), 15}, 0}, 1 },
      {{{OSUTF8("creation-date"), 13}, 0}, 1 },
      {{{OSUTF8("creation-time"), 13}, 0}, 1 },
      {{{OSUTF8("description"), 11}, 0}, 1 },
      {{{OSUTF8("user-defined"), 12}, 0}, 1 },
      {{{OSUTF8("print-time"), 10}, 0}, 1 },
      {{{OSUTF8("print-date"), 10}, 0}, 1 },
      {{{OSUTF8("printed-by"), 10}, 0}, 1 },
      {{{OSUTF8("title"), 5}, 0}, 1 },
      {{{OSUTF8("subject"), 7}, 0}, 1 },
      {{{OSUTF8("keywords"), 8}, 0}, 1 },
      {{{OSUTF8("editing-cycles"), 14}, 0}, 1 },
      {{{OSUTF8("editing-duration"), 16}, 0}, 1 },
      {{{OSUTF8("modification-time"), 17}, 0}, 1 },
      {{{OSUTF8("modification-date"), 17}, 0}, 1 },
      {{{OSUTF8("creator"), 7}, 0}, 1 },
      {{{OSUTF8("page-count"), 10}, 0}, 1 },
      {{{OSUTF8("paragraph-count"), 15}, 0}, 1 },
      {{{OSUTF8("word-count"), 10}, 0}, 1 },
      {{{OSUTF8("character-count"), 15}, 0}, 1 },
      {{{OSUTF8("table-count"), 11}, 0}, 1 },
      {{{OSUTF8("image-count"), 11}, 0}, 1 },
      {{{OSUTF8("object-count"), 12}, 0}, 1 },
      {{{OSUTF8("database-display"), 16}, 0}, 1 },
      {{{OSUTF8("database-next"), 13}, 0}, 1 },
      {{{OSUTF8("database-row-select"), 19}, 0}, 1 },
      {{{OSUTF8("database-row-number"), 19}, 0}, 1 },
      {{{OSUTF8("database-name"), 13}, 0}, 1 },
      {{{OSUTF8("page-variable-set"), 17}, 0}, 1 },
      {{{OSUTF8("page-variable-get"), 17}, 0}, 1 },
      {{{OSUTF8("placeholder"), 11}, 0}, 1 },
      {{{OSUTF8("conditional-text"), 16}, 0}, 1 },
      {{{OSUTF8("hidden-text"), 11}, 0}, 1 },
      {{{OSUTF8("reference-ref"), 13}, 0}, 1 },
      {{{OSUTF8("bookmark-ref"), 12}, 0}, 1 },
      {{{OSUTF8("note-ref"), 8}, 0}, 1 },
      {{{OSUTF8("sequence-ref"), 12}, 0}, 1 },
      {{{OSUTF8("script"), 6}, 0}, 1 },
      {{{OSUTF8("execute-macro"), 13}, 0}, 1 },
      {{{OSUTF8("hidden-paragraph"), 16}, 0}, 1 },
      {{{OSUTF8("dde-connection"), 14}, 0}, 1 },
      {{{OSUTF8("table-formula"), 13}, 0}, 1 },
      {{{OSUTF8("toc-mark-start"), 14}, 0}, 1 },
      {{{OSUTF8("toc-mark-end"), 12}, 0}, 1 },
      {{{OSUTF8("toc-mark"), 8}, 0}, 1 },
      {{{OSUTF8("user-index-mark-start"), 21}, 0}, 1 },
      {{{OSUTF8("user-index-mark-end"), 19}, 0}, 1 },
      {{{OSUTF8("user-index-mark"), 15}, 0}, 1 },
      {{{OSUTF8("alphabetical-index-mark-start"), 29}, 0}, 1 },
      {{{OSUTF8("alphabetical-index-mark-end"), 27}, 0}, 1 },
      {{{OSUTF8("alphabetical-index-mark"), 23}, 0}, 1 },
      {{{OSUTF8("bibliography-mark"), 17}, 0}, 1 },
      {{{OSUTF8("header"), 6}, 0}, 1 },
      {{{OSUTF8("footer"), 6}, 0}, 1 },
      {{{OSUTF8("date-time"), 9}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 123, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* number */
         stat = XmlDec_Odf_Number (pctxt, &pvalue->number);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.numberPresent = TRUE;
         break;
      }
      case 1: {
         Odf_H_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_H_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_H_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Odf_H_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 122, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Numbered_paragraph_choice                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Numbered_paragraph_choice (OSCTXT* pctxt, 
   Odf_Numbered_paragraph_choice *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P (pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

         if (pvalue->u.h == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_H (pvalue->u.h);
         stat = asn1D_Odf_H (pctxt, 
            pvalue->u.h, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Numbered_paragraph_choice (OSCTXT* pctxt, 
   Odf_Numbered_paragraph_choice* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("h"), 1}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P (pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* h */
      pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

      if (pvalue->u.h == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_H (pvalue->u.h);

      stat = XmlDec_Odf_H (pctxt, pvalue->u.h);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Numbered_paragraph                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Numbered_paragraph (OSCTXT* pctxt, 
   Odf_Numbered_paragraph *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode continue_numbering */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Numbered_paragraph_continue_numbering (pctxt, 
               &pvalue->continue_numbering, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.continue_numberingPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode level */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->level, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.levelPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode start_value */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->start_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.start_valuePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Numbered_paragraph_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode number */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Number (pctxt, 
               &pvalue->number, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.numberPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Numbered_paragraph_choice (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Numbered_paragraph (OSCTXT* pctxt, 
   Odf_Numbered_paragraph* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("continue-numbering"), 18}, 0 },
         { {OSUTF8("level"), 5}, 0 },
         { {OSUTF8("start-value"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* continue-numbering */
            stat = XmlDec_Odf_Numbered_paragraph_continue_numbering (pctxt, &
               pvalue->continue_numbering);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.continue_numberingPresent = TRUE;
            break;

         case 1: /* level */
            stat = rtXmlpDecUInt (pctxt, &pvalue->level);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.levelPresent = TRUE;
            break;

         case 2: /* start-value */
            stat = rtXmlpDecUInt (pctxt, &pvalue->start_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.start_valuePresent = TRUE;
            break;

         case 3: /* style-name */
            stat = XmlDec_Odf_Numbered_paragraph_style_name (pctxt, &pvalue->
               style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Numbered_paragraph");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Numbered_paragraph");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("number"), 6}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 1 },
      {{{OSUTF8("h"), 1}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}, {3, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* number */
         stat = XmlDec_Odf_Number (pctxt, &pvalue->number);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.numberPresent = TRUE;
         break;
      }
      case 1: { /*  */
         stat = XmlDec_Odf_Numbered_paragraph_choice (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Section_style_name                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Section_style_name (OSCTXT* pctxt, 
   Odf_Section_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Section_style_name (OSCTXT* pctxt, 
   Odf_Section_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Section_source                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Section_source (OSCTXT* pctxt, 
   Odf_Section_source *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode href */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Href (pctxt, 
               &pvalue->href, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.hrefPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode show */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Section_source_show (pctxt, 
               &pvalue->show, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.showPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Type (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.typePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode filter_name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->filter_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.filter_namePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode section_name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->section_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.section_namePresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Section_source (OSCTXT* pctxt, Odf_Section_source* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("href"), 4}, 0 },
         { {OSUTF8("show"), 4}, 0 },
         { {OSUTF8("type"), 4}, 0 },
         { {OSUTF8("filter-name"), 11}, 0 },
         { {OSUTF8("section-name"), 12}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* href */
            stat = XmlDec_Xlink_Href (pctxt, &pvalue->href);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.hrefPresent = TRUE;
            break;

         case 1: /* show */
            stat = XmlDec_Odf_Section_source_show (pctxt, &pvalue->show);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.showPresent = TRUE;
            break;

         case 2: /* type */
            stat = XmlDec_Xlink_Type (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.typePresent = TRUE;
            break;

         case 3: /* filter-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->filter_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.filter_namePresent = TRUE;
            break;

         case 4: /* section-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->section_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.section_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Section_source");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Section_source");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Section_choice                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Section_choice (OSCTXT* pctxt, 
   Odf_Section_choice *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.section_source
             = rtxMemAllocType (pctxt, Odf_Section_source);

         if (pvalue->u.section_source == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Section_source (pvalue->u.section_source);
         stat = asn1D_Odf_Section_source (pctxt, 
            pvalue->u.section_source, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.dde_source = rtxMemAllocType (pctxt, Ns13_Dde_source);

         if (pvalue->u.dde_source == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Dde_source ((Ns13_Dde_source*)pvalue->u.dde_source);
         stat = asn1D_Ns13_Dde_source (pctxt, 
            (Ns13_Dde_source*)pvalue->u.dde_source, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Section_choice (OSCTXT* pctxt, Odf_Section_choice* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("section-source"), 14}, 0}, 0 },
      {{{OSUTF8("dde-source"), 10}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* section-source */
      pvalue->u.section_source = rtxMemAllocType (pctxt, Odf_Section_source);

      if (pvalue->u.section_source == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Section_source (pvalue->u.section_source);

      stat = XmlDec_Odf_Section_source (pctxt, pvalue->u.section_source);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* dde-source */
      pvalue->u.dde_source = rtxMemAllocType (pctxt, Ns13_Dde_source);

      if (pvalue->u.dde_source == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns13_Dde_source ((Ns13_Dde_source*)pvalue->u.dde_source);

      stat = XmlDec_Ns13_Dde_source (pctxt, pvalue->u.dde_source);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_of_content_style_name                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Table_of_content_style_name (OSCTXT* pctxt, 
   Odf_Table_of_content_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Table_of_content_style_name (OSCTXT* pctxt, 
   Odf_Table_of_content_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_title_template_style_name                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_title_template_style_name (OSCTXT* pctxt, 
   Odf_Index_title_template_style_name *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Index_title_template_style_name (OSCTXT* pctxt, 
   Odf_Index_title_template_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_title_template                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_title_template (OSCTXT* pctxt, 
   Odf_Index_title_template *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_title_template_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Index_title_template (OSCTXT* pctxt, 
   Odf_Index_title_template* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* style-name */
            stat = XmlDec_Odf_Index_title_template_style_name (pctxt, &pvalue->
               style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Index_title_template");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Index_title_template");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_of_content_entry_template_style_name                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Table_of_content_entry_template_style_name (
   OSCTXT* pctxt, Odf_Table_of_content_entry_template_style_name *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Table_of_content_entry_template_style_name (OSCTXT* pctxt, 
   Odf_Table_of_content_entry_template_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_entry_chapter_style_name                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_entry_chapter_style_name (OSCTXT* pctxt, 
   Odf_Index_entry_chapter_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Index_entry_chapter_style_name (OSCTXT* pctxt, 
   Odf_Index_entry_chapter_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_entry_chapter                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_entry_chapter (OSCTXT* pctxt, 
   Odf_Index_entry_chapter *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode display */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_entry_chapter_display (pctxt, 
               &pvalue->display, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.displayPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_entry_chapter_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Index_entry_chapter (OSCTXT* pctxt, 
   Odf_Index_entry_chapter* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("display"), 7}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* display */
            stat = XmlDec_Odf_Index_entry_chapter_display (pctxt, &pvalue->
               display);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.displayPresent = TRUE;
            break;

         case 1: /* style-name */
            stat = XmlDec_Odf_Index_entry_chapter_style_name (pctxt, &pvalue->
               style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Index_entry_chapter");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Index_entry_chapter");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_entry_page_number_style_name                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_entry_page_number_style_name (OSCTXT* pctxt, 
   Odf_Index_entry_page_number_style_name *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Index_entry_page_number_style_name (OSCTXT* pctxt, 
   Odf_Index_entry_page_number_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_entry_page_number                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_entry_page_number (OSCTXT* pctxt, 
   Odf_Index_entry_page_number *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_entry_page_number_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Index_entry_page_number (OSCTXT* pctxt, 
   Odf_Index_entry_page_number* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* style-name */
            stat = XmlDec_Odf_Index_entry_page_number_style_name (pctxt, &
               pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Index_entry_page_number");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Index_entry_page_number");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_entry_text_style_name                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_entry_text_style_name (OSCTXT* pctxt, 
   Odf_Index_entry_text_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Index_entry_text_style_name (OSCTXT* pctxt, 
   Odf_Index_entry_text_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_entry_text                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_entry_text (OSCTXT* pctxt, 
   Odf_Index_entry_text *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_entry_text_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Index_entry_text (OSCTXT* pctxt, Odf_Index_entry_text* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* style-name */
            stat = XmlDec_Odf_Index_entry_text_style_name (pctxt, &pvalue->
               style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Index_entry_text");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Index_entry_text");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_entry_span_style_name                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_entry_span_style_name (OSCTXT* pctxt, 
   Odf_Index_entry_span_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Index_entry_span_style_name (OSCTXT* pctxt, 
   Odf_Index_entry_span_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_entry_span                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_entry_span (OSCTXT* pctxt, 
   Odf_Index_entry_span *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_entry_span_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Index_entry_span (OSCTXT* pctxt, Odf_Index_entry_span* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* style-name */
            stat = XmlDec_Odf_Index_entry_span_style_name (pctxt, &pvalue->
               style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Index_entry_span");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Index_entry_span");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_entry_tab_stop_style_name                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_entry_tab_stop_style_name (OSCTXT* pctxt, 
   Odf_Index_entry_tab_stop_style_name *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Index_entry_tab_stop_style_name (OSCTXT* pctxt, 
   Odf_Index_entry_tab_stop_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_entry_tab_stop                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_entry_tab_stop (OSCTXT* pctxt, 
   Odf_Index_entry_tab_stop *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode leader_char */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Leader_char (pctxt, 
               (Ns8_Leader_char*)&pvalue->leader_char, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.leader_charPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode position */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Position (pctxt, 
               (Ns8_Position*)&pvalue->position, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.positionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Type (pctxt, 
               (Ns8_Type*)&pvalue->type, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_entry_tab_stop_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Index_entry_tab_stop (OSCTXT* pctxt, 
   Odf_Index_entry_tab_stop* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("leader-char"), 11}, 0 },
         { {OSUTF8("position"), 8}, 0 },
         { {OSUTF8("type"), 4}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* leader-char */
            stat = XmlDec_Ns8_Leader_char (pctxt, &pvalue->leader_char);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.leader_charPresent = TRUE;
            break;

         case 1: /* position */
            stat = XmlDec_Ns8_Position (pctxt, &pvalue->position);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.positionPresent = TRUE;
            break;

         case 2: /* type */
            stat = XmlDec_Ns8_Type (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* style-name */
            stat = XmlDec_Odf_Index_entry_tab_stop_style_name (pctxt, &pvalue->
               style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Index_entry_tab_stop");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Index_entry_tab_stop");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_entry_link_start_style_name                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_entry_link_start_style_name (OSCTXT* pctxt, 
   Odf_Index_entry_link_start_style_name *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Index_entry_link_start_style_name (OSCTXT* pctxt, 
   Odf_Index_entry_link_start_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_entry_link_start                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_entry_link_start (OSCTXT* pctxt, 
   Odf_Index_entry_link_start *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_entry_link_start_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Index_entry_link_start (OSCTXT* pctxt, 
   Odf_Index_entry_link_start* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* style-name */
            stat = XmlDec_Odf_Index_entry_link_start_style_name (pctxt, &pvalue
               ->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Index_entry_link_start");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Index_entry_link_start");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_entry_link_end_style_name                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_entry_link_end_style_name (OSCTXT* pctxt, 
   Odf_Index_entry_link_end_style_name *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Index_entry_link_end_style_name (OSCTXT* pctxt, 
   Odf_Index_entry_link_end_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_entry_link_end                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_entry_link_end (OSCTXT* pctxt, 
   Odf_Index_entry_link_end *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_entry_link_end_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Index_entry_link_end (OSCTXT* pctxt, 
   Odf_Index_entry_link_end* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* style-name */
            stat = XmlDec_Odf_Index_entry_link_end_style_name (pctxt, &pvalue->
               style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Index_entry_link_end");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Index_entry_link_end");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_of_content_entry_template_element                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Table_of_content_entry_template_element (OSCTXT* pctxt, 
   Odf_Table_of_content_entry_template_element *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.index_entry_chapter
             = rtxMemAllocType (pctxt, Odf_Index_entry_chapter);

         if (pvalue->u.index_entry_chapter == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_chapter (pvalue->u.index_entry_chapter);
         stat = asn1D_Odf_Index_entry_chapter (pctxt, 
            pvalue->u.index_entry_chapter, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.index_entry_page_number
             = rtxMemAllocType (pctxt, Odf_Index_entry_page_number);

         if (pvalue->u.index_entry_page_number == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_page_number (pvalue->u.index_entry_page_number);
         stat = asn1D_Odf_Index_entry_page_number (pctxt, 
            pvalue->u.index_entry_page_number, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.index_entry_text
             = rtxMemAllocType (pctxt, Odf_Index_entry_text);

         if (pvalue->u.index_entry_text == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_text (pvalue->u.index_entry_text);
         stat = asn1D_Odf_Index_entry_text (pctxt, 
            pvalue->u.index_entry_text, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.index_entry_span
             = rtxMemAllocType (pctxt, Odf_Index_entry_span);

         if (pvalue->u.index_entry_span == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_span (pvalue->u.index_entry_span);
         stat = asn1D_Odf_Index_entry_span (pctxt, 
            pvalue->u.index_entry_span, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.index_entry_tab_stop
             = rtxMemAllocType (pctxt, Odf_Index_entry_tab_stop);

         if (pvalue->u.index_entry_tab_stop == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_tab_stop (pvalue->u.index_entry_tab_stop);
         stat = asn1D_Odf_Index_entry_tab_stop (pctxt, 
            pvalue->u.index_entry_tab_stop, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.index_entry_link_start
             = rtxMemAllocType (pctxt, Odf_Index_entry_link_start);

         if (pvalue->u.index_entry_link_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_link_start (pvalue->u.index_entry_link_start);
         stat = asn1D_Odf_Index_entry_link_start (pctxt, 
            pvalue->u.index_entry_link_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.index_entry_link_end
             = rtxMemAllocType (pctxt, Odf_Index_entry_link_end);

         if (pvalue->u.index_entry_link_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_link_end (pvalue->u.index_entry_link_end);
         stat = asn1D_Odf_Index_entry_link_end (pctxt, 
            pvalue->u.index_entry_link_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Table_of_content_entry_template_element (OSCTXT* pctxt, 
   Odf_Table_of_content_entry_template_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("index-entry-chapter"), 19}, 0}, 0 },
      {{{OSUTF8("index-entry-page-number"), 23}, 0}, 1 },
      {{{OSUTF8("index-entry-text"), 16}, 0}, 2 },
      {{{OSUTF8("index-entry-span"), 16}, 0}, 3 },
      {{{OSUTF8("index-entry-tab-stop"), 20}, 0}, 4 },
      {{{OSUTF8("index-entry-link-start"), 22}, 0}, 5 },
      {{{OSUTF8("index-entry-link-end"), 20}, 0}, 6 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 7, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* index-entry-chapter */
      pvalue->u.index_entry_chapter
          = rtxMemAllocType (pctxt, Odf_Index_entry_chapter);

      if (pvalue->u.index_entry_chapter == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_chapter (pvalue->u.index_entry_chapter);

      stat = XmlDec_Odf_Index_entry_chapter (pctxt, pvalue->
         u.index_entry_chapter);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* index-entry-page-number */
      pvalue->u.index_entry_page_number
          = rtxMemAllocType (pctxt, Odf_Index_entry_page_number);

      if (pvalue->u.index_entry_page_number == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_page_number (pvalue->u.index_entry_page_number
         );

      stat = XmlDec_Odf_Index_entry_page_number (pctxt, pvalue->
         u.index_entry_page_number);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* index-entry-text */
      pvalue->u.index_entry_text
          = rtxMemAllocType (pctxt, Odf_Index_entry_text);

      if (pvalue->u.index_entry_text == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_text (pvalue->u.index_entry_text);

      stat = XmlDec_Odf_Index_entry_text (pctxt, pvalue->u.index_entry_text);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* index-entry-span */
      pvalue->u.index_entry_span
          = rtxMemAllocType (pctxt, Odf_Index_entry_span);

      if (pvalue->u.index_entry_span == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_span (pvalue->u.index_entry_span);

      stat = XmlDec_Odf_Index_entry_span (pctxt, pvalue->u.index_entry_span);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* index-entry-tab-stop */
      pvalue->u.index_entry_tab_stop
          = rtxMemAllocType (pctxt, Odf_Index_entry_tab_stop);

      if (pvalue->u.index_entry_tab_stop == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_tab_stop (pvalue->u.index_entry_tab_stop);

      stat = XmlDec_Odf_Index_entry_tab_stop (pctxt, pvalue->
         u.index_entry_tab_stop);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* index-entry-link-start */
      pvalue->u.index_entry_link_start
          = rtxMemAllocType (pctxt, Odf_Index_entry_link_start);

      if (pvalue->u.index_entry_link_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_link_start (pvalue->u.index_entry_link_start);

      stat = XmlDec_Odf_Index_entry_link_start (pctxt, pvalue->
         u.index_entry_link_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* index-entry-link-end */
      pvalue->u.index_entry_link_end
          = rtxMemAllocType (pctxt, Odf_Index_entry_link_end);

      if (pvalue->u.index_entry_link_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_link_end (pvalue->u.index_entry_link_end);

      stat = XmlDec_Odf_Index_entry_link_end (pctxt, pvalue->
         u.index_entry_link_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_of_content_entry_template                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Table_of_content_entry_template (OSCTXT* pctxt, 
   Odf_Table_of_content_entry_template *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode outline_level */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->outline_level, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Table_of_content_entry_template_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Table_of_content_entry_template_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Table_of_content_entry_template_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_Table_of_content_entry_template_element (pdata2);

                  stat = asn1D_Odf_Table_of_content_entry_template_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Table_of_content_entry_template (OSCTXT* pctxt, 
   Odf_Table_of_content_entry_template* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("outline-level"), 13}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* outline-level */
            stat = rtXmlpDecUInt (pctxt, &pvalue->outline_level);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* style-name */
            stat = XmlDec_Odf_Table_of_content_entry_template_style_name 
               (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Table_of_content_entry_template");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Table_of_content_entry_template");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("index-entry-chapter"), 19}, 0}, 0 },
      {{{OSUTF8("index-entry-page-number"), 23}, 0}, 0 },
      {{{OSUTF8("index-entry-text"), 16}, 0}, 0 },
      {{{OSUTF8("index-entry-span"), 16}, 0}, 0 },
      {{{OSUTF8("index-entry-tab-stop"), 20}, 0}, 0 },
      {{{OSUTF8("index-entry-link-start"), 22}, 0}, 0 },
      {{{OSUTF8("index-entry-link-end"), 20}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 7, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_Table_of_content_entry_template_element* pdata1;
         do {
            pdata1
                = rtxMemAllocType (pctxt, Odf_Table_of_content_entry_template_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Table_of_content_entry_template_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Odf_Table_of_content_entry_template_element (pctxt, 
               pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 7, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_source_style                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_source_style (OSCTXT* pctxt, 
   Odf_Index_source_style *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->style_name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Index_source_style (OSCTXT* pctxt, 
   Odf_Index_source_style* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* style-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Index_source_style");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Index_source_style");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_source_styles                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_source_styles (OSCTXT* pctxt, 
   Odf_Index_source_styles *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode outline_level */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->outline_level, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode index_source_style_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Index_source_style* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->index_source_style_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Index_source_style, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_Index_source_style (pdata2);

                  stat = asn1D_Odf_Index_source_style (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->index_source_style_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Index_source_styles (OSCTXT* pctxt, 
   Odf_Index_source_styles* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("outline-level"), 13}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* outline-level */
            stat = rtXmlpDecUInt (pctxt, &pvalue->outline_level);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Index_source_styles");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Index_source_styles");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("index-source-style"), 18}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_Index_source_style* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_Index_source_style);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Index_source_style (pdata1);

            stat = XmlDec_Odf_Index_source_style (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->index_source_style_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_of_content_source                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Table_of_content_source (OSCTXT* pctxt, 
   Odf_Table_of_content_source *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode index_scope */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Table_of_content_source_index_scope (pctxt, 
               &pvalue->index_scope, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.index_scopePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode outline_level */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->outline_level, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.outline_levelPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode relative_tab_stop_position */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Table_of_content_source_relative_tab_stop_position (pctxt, 
               &pvalue->relative_tab_stop_position, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.relative_tab_stop_positionPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode use_index_marks */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Table_of_content_source_use_index_marks (pctxt, 
               &pvalue->use_index_marks, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.use_index_marksPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode use_index_source_styles */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Table_of_content_source_use_index_source_styles (pctxt, 
               &pvalue->use_index_source_styles, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.use_index_source_stylesPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode use_outline_level */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Table_of_content_source_use_outline_level (pctxt, 
               &pvalue->use_outline_level, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.use_outline_levelPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode index_title_template */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_title_template (pctxt, 
               &pvalue->index_title_template, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.index_title_templatePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode table_of_content_entry_template_list */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Table_of_content_entry_template* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->table_of_content_entry_template_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Table_of_content_entry_template, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_Table_of_content_entry_template (pdata2);

                  stat = asn1D_Odf_Table_of_content_entry_template (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->table_of_content_entry_template_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 8:
         /* decode index_source_styles_list */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Index_source_styles* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->index_source_styles_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Index_source_styles, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_Index_source_styles (pdata2);

                  stat = asn1D_Odf_Index_source_styles (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->index_source_styles_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Table_of_content_source (OSCTXT* pctxt, 
   Odf_Table_of_content_source* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("index-scope"), 11}, 0 },
         { {OSUTF8("outline-level"), 13}, 0 },
         { {OSUTF8("relative-tab-stop-position"), 26}, 0 },
         { {OSUTF8("use-index-marks"), 15}, 0 },
         { {OSUTF8("use-index-source-styles"), 23}, 0 },
         { {OSUTF8("use-outline-level"), 17}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 6, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* index-scope */
            stat = XmlDec_Odf_Table_of_content_source_index_scope (pctxt, &
               pvalue->index_scope);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.index_scopePresent = TRUE;
            break;

         case 1: /* outline-level */
            stat = rtXmlpDecUInt (pctxt, &pvalue->outline_level);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.outline_levelPresent = TRUE;
            break;

         case 2: /* relative-tab-stop-position */
            stat = XmlDec_Odf_Table_of_content_source_relative_tab_stop_position 
               (pctxt, &pvalue->relative_tab_stop_position);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.relative_tab_stop_positionPresent = TRUE;
            break;

         case 3: /* use-index-marks */
            stat = XmlDec_Odf_Table_of_content_source_use_index_marks (pctxt, &
               pvalue->use_index_marks);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.use_index_marksPresent = TRUE;
            break;

         case 4: /* use-index-source-styles */
            stat = XmlDec_Odf_Table_of_content_source_use_index_source_styles 
               (pctxt, &pvalue->use_index_source_styles);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.use_index_source_stylesPresent = TRUE;
            break;

         case 5: /* use-outline-level */
            stat = XmlDec_Odf_Table_of_content_source_use_outline_level 
               (pctxt, &pvalue->use_outline_level);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.use_outline_levelPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Table_of_content_source");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Table_of_content_source");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("index-title-template"), 20}, 0}, 0 },
      {{{OSUTF8("table-of-content-entry-template"), 31}, 0}, 1 },
      {{{OSUTF8("index-source-styles"), 19}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* index-title-template */
         stat = XmlDec_Odf_Index_title_template (pctxt, &pvalue->
            index_title_template);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.index_title_templatePresent = TRUE;
         break;
      }
      case 1: {
         Odf_Table_of_content_entry_template* pdata1;
         do {
            pdata1
                = rtxMemAllocType (pctxt, Odf_Table_of_content_entry_template);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Table_of_content_entry_template (pdata1);

            stat = XmlDec_Odf_Table_of_content_entry_template (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->
               table_of_content_entry_template_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 2: {
         Odf_Index_source_styles* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_Index_source_styles);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Index_source_styles (pdata1);

            stat = XmlDec_Odf_Index_source_styles (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->index_source_styles_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 2, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Illustration_index_style_name                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Illustration_index_style_name (OSCTXT* pctxt, 
   Odf_Illustration_index_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Illustration_index_style_name (OSCTXT* pctxt, 
   Odf_Illustration_index_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Illustration_index_entry_template_style_name              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Illustration_index_entry_template_style_name (
   OSCTXT* pctxt, Odf_Illustration_index_entry_template_style_name *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Illustration_index_entry_template_style_name (OSCTXT* pctxt, 
   Odf_Illustration_index_entry_template_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Illustration_index_entry_template_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Illustration_index_entry_template_element (OSCTXT* pctxt, 
   Odf_Illustration_index_entry_template_element *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.index_entry_page_number
             = rtxMemAllocType (pctxt, Odf_Index_entry_page_number);

         if (pvalue->u.index_entry_page_number == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_page_number (pvalue->u.index_entry_page_number);
         stat = asn1D_Odf_Index_entry_page_number (pctxt, 
            pvalue->u.index_entry_page_number, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.index_entry_text
             = rtxMemAllocType (pctxt, Odf_Index_entry_text);

         if (pvalue->u.index_entry_text == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_text (pvalue->u.index_entry_text);
         stat = asn1D_Odf_Index_entry_text (pctxt, 
            pvalue->u.index_entry_text, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.index_entry_span
             = rtxMemAllocType (pctxt, Odf_Index_entry_span);

         if (pvalue->u.index_entry_span == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_span (pvalue->u.index_entry_span);
         stat = asn1D_Odf_Index_entry_span (pctxt, 
            pvalue->u.index_entry_span, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.index_entry_tab_stop
             = rtxMemAllocType (pctxt, Odf_Index_entry_tab_stop);

         if (pvalue->u.index_entry_tab_stop == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_tab_stop (pvalue->u.index_entry_tab_stop);
         stat = asn1D_Odf_Index_entry_tab_stop (pctxt, 
            pvalue->u.index_entry_tab_stop, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Illustration_index_entry_template_element (OSCTXT* pctxt, 
   Odf_Illustration_index_entry_template_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("index-entry-page-number"), 23}, 0}, 0 },
      {{{OSUTF8("index-entry-text"), 16}, 0}, 1 },
      {{{OSUTF8("index-entry-span"), 16}, 0}, 2 },
      {{{OSUTF8("index-entry-tab-stop"), 20}, 0}, 3 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 4, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* index-entry-page-number */
      pvalue->u.index_entry_page_number
          = rtxMemAllocType (pctxt, Odf_Index_entry_page_number);

      if (pvalue->u.index_entry_page_number == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_page_number (pvalue->u.index_entry_page_number
         );

      stat = XmlDec_Odf_Index_entry_page_number (pctxt, pvalue->
         u.index_entry_page_number);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* index-entry-text */
      pvalue->u.index_entry_text
          = rtxMemAllocType (pctxt, Odf_Index_entry_text);

      if (pvalue->u.index_entry_text == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_text (pvalue->u.index_entry_text);

      stat = XmlDec_Odf_Index_entry_text (pctxt, pvalue->u.index_entry_text);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* index-entry-span */
      pvalue->u.index_entry_span
          = rtxMemAllocType (pctxt, Odf_Index_entry_span);

      if (pvalue->u.index_entry_span == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_span (pvalue->u.index_entry_span);

      stat = XmlDec_Odf_Index_entry_span (pctxt, pvalue->u.index_entry_span);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* index-entry-tab-stop */
      pvalue->u.index_entry_tab_stop
          = rtxMemAllocType (pctxt, Odf_Index_entry_tab_stop);

      if (pvalue->u.index_entry_tab_stop == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_tab_stop (pvalue->u.index_entry_tab_stop);

      stat = XmlDec_Odf_Index_entry_tab_stop (pctxt, pvalue->
         u.index_entry_tab_stop);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Illustration_index_entry_template                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Illustration_index_entry_template (OSCTXT* pctxt, 
   Odf_Illustration_index_entry_template *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Illustration_index_entry_template_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Illustration_index_entry_template_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Illustration_index_entry_template_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_Illustration_index_entry_template_element (pdata2);

                  stat = asn1D_Odf_Illustration_index_entry_template_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Illustration_index_entry_template (OSCTXT* pctxt, 
   Odf_Illustration_index_entry_template* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* style-name */
            stat = XmlDec_Odf_Illustration_index_entry_template_style_name 
               (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Illustration_index_entry_template");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Illustration_index_entry_template");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("index-entry-page-number"), 23}, 0}, 0 },
      {{{OSUTF8("index-entry-text"), 16}, 0}, 0 },
      {{{OSUTF8("index-entry-span"), 16}, 0}, 0 },
      {{{OSUTF8("index-entry-tab-stop"), 20}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_Illustration_index_entry_template_element* pdata1;
         do {
            pdata1
                = rtxMemAllocType (pctxt, Odf_Illustration_index_entry_template_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Illustration_index_entry_template_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Odf_Illustration_index_entry_template_element 
               (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 4, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Illustration_index_source                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Illustration_index_source (OSCTXT* pctxt, 
   Odf_Illustration_index_source *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode caption_sequence_format */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Illustration_index_source_caption_sequence_format (pctxt, 
               &pvalue->caption_sequence_format, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.caption_sequence_formatPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode caption_sequence_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->caption_sequence_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.caption_sequence_namePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode index_scope */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Illustration_index_source_index_scope (pctxt, 
               &pvalue->index_scope, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.index_scopePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode relative_tab_stop_position */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Illustration_index_source_relative_tab_stop_position (pctxt, 
               &pvalue->relative_tab_stop_position, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.relative_tab_stop_positionPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode use_caption */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Illustration_index_source_use_caption (pctxt, 
               &pvalue->use_caption, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.use_captionPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode index_title_template */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_title_template (pctxt, 
               &pvalue->index_title_template, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.index_title_templatePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode illustration_index_entry_template */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Illustration_index_entry_template (pctxt, 
               &pvalue->illustration_index_entry_template, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.illustration_index_entry_templatePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Illustration_index_source (OSCTXT* pctxt, 
   Odf_Illustration_index_source* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("caption-sequence-format"), 23}, 0 },
         { {OSUTF8("caption-sequence-name"), 21}, 0 },
         { {OSUTF8("index-scope"), 11}, 0 },
         { {OSUTF8("relative-tab-stop-position"), 26}, 0 },
         { {OSUTF8("use-caption"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* caption-sequence-format */
            stat = XmlDec_Odf_Illustration_index_source_caption_sequence_format 
               (pctxt, &pvalue->caption_sequence_format);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.caption_sequence_formatPresent = TRUE;
            break;

         case 1: /* caption-sequence-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->caption_sequence_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.caption_sequence_namePresent = TRUE;
            break;

         case 2: /* index-scope */
            stat = XmlDec_Odf_Illustration_index_source_index_scope (pctxt, &
               pvalue->index_scope);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.index_scopePresent = TRUE;
            break;

         case 3: /* relative-tab-stop-position */
            stat = XmlDec_Odf_Illustration_index_source_relative_tab_stop_position 
               (pctxt, &pvalue->relative_tab_stop_position);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.relative_tab_stop_positionPresent = TRUE;
            break;

         case 4: /* use-caption */
            stat = XmlDec_Odf_Illustration_index_source_use_caption (pctxt, &
               pvalue->use_caption);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.use_captionPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Illustration_index_source");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Illustration_index_source");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("index-title-template"), 20}, 0}, 0 },
      {{{OSUTF8("illustration-index-entry-template"), 33}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* index-title-template */
         stat = XmlDec_Odf_Index_title_template (pctxt, &pvalue->
            index_title_template);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.index_title_templatePresent = TRUE;
         break;
      }
      case 1: { /* illustration-index-entry-template */
         stat = XmlDec_Odf_Illustration_index_entry_template (pctxt, &pvalue->
            illustration_index_entry_template);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.illustration_index_entry_templatePresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Illustration_index                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Illustration_index (OSCTXT* pctxt, 
   Odf_Illustration_index *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode protected_ */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Illustration_index_protected_ (pctxt, 
               &pvalue->protected_, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.protected_Present = TRUE;
            }
         }
         break;

      case 2:
         /* decode protection_key */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->protection_key, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.protection_keyPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Illustration_index_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode illustration_index_source */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Illustration_index_source (pctxt, 
               &pvalue->illustration_index_source, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode index_body */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_body (pctxt, 
               (Odf_Index_body*)&pvalue->index_body, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Illustration_index (OSCTXT* pctxt, 
   Odf_Illustration_index* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("protected"), 9}, 0 },
         { {OSUTF8("protection-key"), 14}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* protected */
            stat = XmlDec_Odf_Illustration_index_protected_ (pctxt, &pvalue->
               protected_);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.protected_Present = TRUE;
            break;

         case 2: /* protection-key */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->protection_key);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.protection_keyPresent = TRUE;
            break;

         case 3: /* style-name */
            stat = XmlDec_Odf_Illustration_index_style_name (pctxt, &pvalue->
               style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Illustration_index");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Illustration_index");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("illustration-index-source"), 25}, 0}, 0 },
      {{{OSUTF8("index-body"), 10}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 1, -1}, {2, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* illustration-index-source */
         stat = XmlDec_Odf_Illustration_index_source (pctxt, &pvalue->
            illustration_index_source);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* index-body */
         stat = XmlDec_Odf_Index_body (pctxt, &pvalue->index_body);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_index_style_name                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Table_index_style_name (OSCTXT* pctxt, 
   Odf_Table_index_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Table_index_style_name (OSCTXT* pctxt, 
   Odf_Table_index_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_index_entry_template_style_name                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Table_index_entry_template_style_name (OSCTXT* pctxt, 
   Odf_Table_index_entry_template_style_name *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Table_index_entry_template_style_name (OSCTXT* pctxt, 
   Odf_Table_index_entry_template_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_index_entry_template_element                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Table_index_entry_template_element (OSCTXT* pctxt, 
   Odf_Table_index_entry_template_element *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.index_entry_page_number
             = rtxMemAllocType (pctxt, Odf_Index_entry_page_number);

         if (pvalue->u.index_entry_page_number == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_page_number (pvalue->u.index_entry_page_number);
         stat = asn1D_Odf_Index_entry_page_number (pctxt, 
            pvalue->u.index_entry_page_number, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.index_entry_text
             = rtxMemAllocType (pctxt, Odf_Index_entry_text);

         if (pvalue->u.index_entry_text == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_text (pvalue->u.index_entry_text);
         stat = asn1D_Odf_Index_entry_text (pctxt, 
            pvalue->u.index_entry_text, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.index_entry_span
             = rtxMemAllocType (pctxt, Odf_Index_entry_span);

         if (pvalue->u.index_entry_span == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_span (pvalue->u.index_entry_span);
         stat = asn1D_Odf_Index_entry_span (pctxt, 
            pvalue->u.index_entry_span, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.index_entry_tab_stop
             = rtxMemAllocType (pctxt, Odf_Index_entry_tab_stop);

         if (pvalue->u.index_entry_tab_stop == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_tab_stop (pvalue->u.index_entry_tab_stop);
         stat = asn1D_Odf_Index_entry_tab_stop (pctxt, 
            pvalue->u.index_entry_tab_stop, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Table_index_entry_template_element (OSCTXT* pctxt, 
   Odf_Table_index_entry_template_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("index-entry-page-number"), 23}, 0}, 0 },
      {{{OSUTF8("index-entry-text"), 16}, 0}, 1 },
      {{{OSUTF8("index-entry-span"), 16}, 0}, 2 },
      {{{OSUTF8("index-entry-tab-stop"), 20}, 0}, 3 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 4, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* index-entry-page-number */
      pvalue->u.index_entry_page_number
          = rtxMemAllocType (pctxt, Odf_Index_entry_page_number);

      if (pvalue->u.index_entry_page_number == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_page_number (pvalue->u.index_entry_page_number
         );

      stat = XmlDec_Odf_Index_entry_page_number (pctxt, pvalue->
         u.index_entry_page_number);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* index-entry-text */
      pvalue->u.index_entry_text
          = rtxMemAllocType (pctxt, Odf_Index_entry_text);

      if (pvalue->u.index_entry_text == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_text (pvalue->u.index_entry_text);

      stat = XmlDec_Odf_Index_entry_text (pctxt, pvalue->u.index_entry_text);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* index-entry-span */
      pvalue->u.index_entry_span
          = rtxMemAllocType (pctxt, Odf_Index_entry_span);

      if (pvalue->u.index_entry_span == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_span (pvalue->u.index_entry_span);

      stat = XmlDec_Odf_Index_entry_span (pctxt, pvalue->u.index_entry_span);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* index-entry-tab-stop */
      pvalue->u.index_entry_tab_stop
          = rtxMemAllocType (pctxt, Odf_Index_entry_tab_stop);

      if (pvalue->u.index_entry_tab_stop == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_tab_stop (pvalue->u.index_entry_tab_stop);

      stat = XmlDec_Odf_Index_entry_tab_stop (pctxt, pvalue->
         u.index_entry_tab_stop);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_index_entry_template                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Table_index_entry_template (OSCTXT* pctxt, 
   Odf_Table_index_entry_template *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Table_index_entry_template_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Table_index_entry_template_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Table_index_entry_template_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_Table_index_entry_template_element (pdata2);

                  stat = asn1D_Odf_Table_index_entry_template_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Table_index_entry_template (OSCTXT* pctxt, 
   Odf_Table_index_entry_template* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* style-name */
            stat = XmlDec_Odf_Table_index_entry_template_style_name (pctxt, &
               pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Table_index_entry_template");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Table_index_entry_template");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("index-entry-page-number"), 23}, 0}, 0 },
      {{{OSUTF8("index-entry-text"), 16}, 0}, 0 },
      {{{OSUTF8("index-entry-span"), 16}, 0}, 0 },
      {{{OSUTF8("index-entry-tab-stop"), 20}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_Table_index_entry_template_element* pdata1;
         do {
            pdata1
                = rtxMemAllocType (pctxt, Odf_Table_index_entry_template_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Table_index_entry_template_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Odf_Table_index_entry_template_element (pctxt, pdata1
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 4, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_index_source                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Table_index_source (OSCTXT* pctxt, 
   Odf_Table_index_source *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode caption_sequence_format */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Table_index_source_caption_sequence_format (pctxt, 
               &pvalue->caption_sequence_format, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.caption_sequence_formatPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode caption_sequence_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->caption_sequence_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.caption_sequence_namePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode index_scope */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Table_index_source_index_scope (pctxt, 
               &pvalue->index_scope, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.index_scopePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode relative_tab_stop_position */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Table_index_source_relative_tab_stop_position (pctxt, 
               &pvalue->relative_tab_stop_position, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.relative_tab_stop_positionPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode use_caption */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Table_index_source_use_caption (pctxt, 
               &pvalue->use_caption, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.use_captionPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode index_title_template */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_title_template (pctxt, 
               &pvalue->index_title_template, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.index_title_templatePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode table_index_entry_template */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Table_index_entry_template (pctxt, 
               &pvalue->table_index_entry_template, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_index_entry_templatePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Table_index_source (OSCTXT* pctxt, 
   Odf_Table_index_source* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("caption-sequence-format"), 23}, 0 },
         { {OSUTF8("caption-sequence-name"), 21}, 0 },
         { {OSUTF8("index-scope"), 11}, 0 },
         { {OSUTF8("relative-tab-stop-position"), 26}, 0 },
         { {OSUTF8("use-caption"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* caption-sequence-format */
            stat = XmlDec_Odf_Table_index_source_caption_sequence_format 
               (pctxt, &pvalue->caption_sequence_format);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.caption_sequence_formatPresent = TRUE;
            break;

         case 1: /* caption-sequence-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->caption_sequence_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.caption_sequence_namePresent = TRUE;
            break;

         case 2: /* index-scope */
            stat = XmlDec_Odf_Table_index_source_index_scope (pctxt, &pvalue->
               index_scope);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.index_scopePresent = TRUE;
            break;

         case 3: /* relative-tab-stop-position */
            stat = XmlDec_Odf_Table_index_source_relative_tab_stop_position 
               (pctxt, &pvalue->relative_tab_stop_position);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.relative_tab_stop_positionPresent = TRUE;
            break;

         case 4: /* use-caption */
            stat = XmlDec_Odf_Table_index_source_use_caption (pctxt, &pvalue->
               use_caption);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.use_captionPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Table_index_source");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Table_index_source");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("index-title-template"), 20}, 0}, 0 },
      {{{OSUTF8("table-index-entry-template"), 26}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* index-title-template */
         stat = XmlDec_Odf_Index_title_template (pctxt, &pvalue->
            index_title_template);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.index_title_templatePresent = TRUE;
         break;
      }
      case 1: { /* table-index-entry-template */
         stat = XmlDec_Odf_Table_index_entry_template (pctxt, &pvalue->
            table_index_entry_template);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.table_index_entry_templatePresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_index                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Table_index (OSCTXT* pctxt, Odf_Table_index *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode protected_ */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Table_index_protected_ (pctxt, 
               &pvalue->protected_, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.protected_Present = TRUE;
            }
         }
         break;

      case 2:
         /* decode protection_key */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->protection_key, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.protection_keyPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Table_index_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode table_index_source */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Table_index_source (pctxt, 
               &pvalue->table_index_source, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode index_body */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_body (pctxt, 
               (Odf_Index_body*)&pvalue->index_body, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Table_index (OSCTXT* pctxt, Odf_Table_index* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("protected"), 9}, 0 },
         { {OSUTF8("protection-key"), 14}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* protected */
            stat = XmlDec_Odf_Table_index_protected_ (pctxt, &pvalue->
               protected_);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.protected_Present = TRUE;
            break;

         case 2: /* protection-key */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->protection_key);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.protection_keyPresent = TRUE;
            break;

         case 3: /* style-name */
            stat = XmlDec_Odf_Table_index_style_name (pctxt, &pvalue->
               style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Table_index");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Table_index");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("table-index-source"), 18}, 0}, 0 },
      {{{OSUTF8("index-body"), 10}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 1, -1}, {2, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* table-index-source */
         stat = XmlDec_Odf_Table_index_source (pctxt, &pvalue->
            table_index_source);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* index-body */
         stat = XmlDec_Odf_Index_body (pctxt, &pvalue->index_body);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Object_index_style_name                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Object_index_style_name (OSCTXT* pctxt, 
   Odf_Object_index_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Object_index_style_name (OSCTXT* pctxt, 
   Odf_Object_index_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Object_index_entry_template_style_name                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Object_index_entry_template_style_name (OSCTXT* pctxt, 
   Odf_Object_index_entry_template_style_name *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Object_index_entry_template_style_name (OSCTXT* pctxt, 
   Odf_Object_index_entry_template_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Object_index_entry_template_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Object_index_entry_template_element (OSCTXT* pctxt, 
   Odf_Object_index_entry_template_element *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.index_entry_page_number
             = rtxMemAllocType (pctxt, Odf_Index_entry_page_number);

         if (pvalue->u.index_entry_page_number == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_page_number (pvalue->u.index_entry_page_number);
         stat = asn1D_Odf_Index_entry_page_number (pctxt, 
            pvalue->u.index_entry_page_number, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.index_entry_text
             = rtxMemAllocType (pctxt, Odf_Index_entry_text);

         if (pvalue->u.index_entry_text == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_text (pvalue->u.index_entry_text);
         stat = asn1D_Odf_Index_entry_text (pctxt, 
            pvalue->u.index_entry_text, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.index_entry_span
             = rtxMemAllocType (pctxt, Odf_Index_entry_span);

         if (pvalue->u.index_entry_span == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_span (pvalue->u.index_entry_span);
         stat = asn1D_Odf_Index_entry_span (pctxt, 
            pvalue->u.index_entry_span, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.index_entry_tab_stop
             = rtxMemAllocType (pctxt, Odf_Index_entry_tab_stop);

         if (pvalue->u.index_entry_tab_stop == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_tab_stop (pvalue->u.index_entry_tab_stop);
         stat = asn1D_Odf_Index_entry_tab_stop (pctxt, 
            pvalue->u.index_entry_tab_stop, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Object_index_entry_template_element (OSCTXT* pctxt, 
   Odf_Object_index_entry_template_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("index-entry-page-number"), 23}, 0}, 0 },
      {{{OSUTF8("index-entry-text"), 16}, 0}, 1 },
      {{{OSUTF8("index-entry-span"), 16}, 0}, 2 },
      {{{OSUTF8("index-entry-tab-stop"), 20}, 0}, 3 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 4, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* index-entry-page-number */
      pvalue->u.index_entry_page_number
          = rtxMemAllocType (pctxt, Odf_Index_entry_page_number);

      if (pvalue->u.index_entry_page_number == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_page_number (pvalue->u.index_entry_page_number
         );

      stat = XmlDec_Odf_Index_entry_page_number (pctxt, pvalue->
         u.index_entry_page_number);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* index-entry-text */
      pvalue->u.index_entry_text
          = rtxMemAllocType (pctxt, Odf_Index_entry_text);

      if (pvalue->u.index_entry_text == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_text (pvalue->u.index_entry_text);

      stat = XmlDec_Odf_Index_entry_text (pctxt, pvalue->u.index_entry_text);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* index-entry-span */
      pvalue->u.index_entry_span
          = rtxMemAllocType (pctxt, Odf_Index_entry_span);

      if (pvalue->u.index_entry_span == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_span (pvalue->u.index_entry_span);

      stat = XmlDec_Odf_Index_entry_span (pctxt, pvalue->u.index_entry_span);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* index-entry-tab-stop */
      pvalue->u.index_entry_tab_stop
          = rtxMemAllocType (pctxt, Odf_Index_entry_tab_stop);

      if (pvalue->u.index_entry_tab_stop == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_tab_stop (pvalue->u.index_entry_tab_stop);

      stat = XmlDec_Odf_Index_entry_tab_stop (pctxt, pvalue->
         u.index_entry_tab_stop);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Object_index_entry_template                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Object_index_entry_template (OSCTXT* pctxt, 
   Odf_Object_index_entry_template *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Object_index_entry_template_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Object_index_entry_template_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Object_index_entry_template_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_Object_index_entry_template_element (pdata2);

                  stat = asn1D_Odf_Object_index_entry_template_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Object_index_entry_template (OSCTXT* pctxt, 
   Odf_Object_index_entry_template* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* style-name */
            stat = XmlDec_Odf_Object_index_entry_template_style_name (pctxt, &
               pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Object_index_entry_template");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Object_index_entry_template");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("index-entry-page-number"), 23}, 0}, 0 },
      {{{OSUTF8("index-entry-text"), 16}, 0}, 0 },
      {{{OSUTF8("index-entry-span"), 16}, 0}, 0 },
      {{{OSUTF8("index-entry-tab-stop"), 20}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_Object_index_entry_template_element* pdata1;
         do {
            pdata1
                = rtxMemAllocType (pctxt, Odf_Object_index_entry_template_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Object_index_entry_template_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Odf_Object_index_entry_template_element (pctxt, 
               pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 4, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Object_index_source                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Object_index_source (OSCTXT* pctxt, 
   Odf_Object_index_source *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode index_scope */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Object_index_source_index_scope (pctxt, 
               &pvalue->index_scope, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.index_scopePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode relative_tab_stop_position */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Object_index_source_relative_tab_stop_position (pctxt, 
               &pvalue->relative_tab_stop_position, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.relative_tab_stop_positionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode use_chart_objects */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Object_index_source_use_chart_objects (pctxt, 
               &pvalue->use_chart_objects, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.use_chart_objectsPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode use_draw_objects */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Object_index_source_use_draw_objects (pctxt, 
               &pvalue->use_draw_objects, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.use_draw_objectsPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode use_math_objects */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Object_index_source_use_math_objects (pctxt, 
               &pvalue->use_math_objects, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.use_math_objectsPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode use_other_objects */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Object_index_source_use_other_objects (pctxt, 
               &pvalue->use_other_objects, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.use_other_objectsPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode use_spreadsheet_objects */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Object_index_source_use_spreadsheet_objects (pctxt, 
               &pvalue->use_spreadsheet_objects, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.use_spreadsheet_objectsPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode index_title_template */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_title_template (pctxt, 
               &pvalue->index_title_template, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.index_title_templatePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode object_index_entry_template */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Object_index_entry_template (pctxt, 
               &pvalue->object_index_entry_template, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.object_index_entry_templatePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Object_index_source (OSCTXT* pctxt, 
   Odf_Object_index_source* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("index-scope"), 11}, 0 },
         { {OSUTF8("relative-tab-stop-position"), 26}, 0 },
         { {OSUTF8("use-chart-objects"), 17}, 0 },
         { {OSUTF8("use-draw-objects"), 16}, 0 },
         { {OSUTF8("use-math-objects"), 16}, 0 },
         { {OSUTF8("use-other-objects"), 17}, 0 },
         { {OSUTF8("use-spreadsheet-objects"), 23}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 7, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* index-scope */
            stat = XmlDec_Odf_Object_index_source_index_scope (pctxt, &pvalue->
               index_scope);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.index_scopePresent = TRUE;
            break;

         case 1: /* relative-tab-stop-position */
            stat = XmlDec_Odf_Object_index_source_relative_tab_stop_position 
               (pctxt, &pvalue->relative_tab_stop_position);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.relative_tab_stop_positionPresent = TRUE;
            break;

         case 2: /* use-chart-objects */
            stat = XmlDec_Odf_Object_index_source_use_chart_objects (pctxt, &
               pvalue->use_chart_objects);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.use_chart_objectsPresent = TRUE;
            break;

         case 3: /* use-draw-objects */
            stat = XmlDec_Odf_Object_index_source_use_draw_objects (pctxt, &
               pvalue->use_draw_objects);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.use_draw_objectsPresent = TRUE;
            break;

         case 4: /* use-math-objects */
            stat = XmlDec_Odf_Object_index_source_use_math_objects (pctxt, &
               pvalue->use_math_objects);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.use_math_objectsPresent = TRUE;
            break;

         case 5: /* use-other-objects */
            stat = XmlDec_Odf_Object_index_source_use_other_objects (pctxt, &
               pvalue->use_other_objects);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.use_other_objectsPresent = TRUE;
            break;

         case 6: /* use-spreadsheet-objects */
            stat = XmlDec_Odf_Object_index_source_use_spreadsheet_objects 
               (pctxt, &pvalue->use_spreadsheet_objects);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.use_spreadsheet_objectsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Object_index_source");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Object_index_source");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("index-title-template"), 20}, 0}, 0 },
      {{{OSUTF8("object-index-entry-template"), 27}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* index-title-template */
         stat = XmlDec_Odf_Index_title_template (pctxt, &pvalue->
            index_title_template);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.index_title_templatePresent = TRUE;
         break;
      }
      case 1: { /* object-index-entry-template */
         stat = XmlDec_Odf_Object_index_entry_template (pctxt, &pvalue->
            object_index_entry_template);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.object_index_entry_templatePresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Object_index                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Object_index (OSCTXT* pctxt, Odf_Object_index *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode protected_ */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Object_index_protected_ (pctxt, 
               &pvalue->protected_, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.protected_Present = TRUE;
            }
         }
         break;

      case 2:
         /* decode protection_key */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->protection_key, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.protection_keyPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Object_index_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode object_index_source */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Object_index_source (pctxt, 
               &pvalue->object_index_source, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode index_body */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_body (pctxt, 
               (Odf_Index_body*)&pvalue->index_body, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Object_index (OSCTXT* pctxt, Odf_Object_index* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("protected"), 9}, 0 },
         { {OSUTF8("protection-key"), 14}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* protected */
            stat = XmlDec_Odf_Object_index_protected_ (pctxt, &pvalue->
               protected_);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.protected_Present = TRUE;
            break;

         case 2: /* protection-key */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->protection_key);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.protection_keyPresent = TRUE;
            break;

         case 3: /* style-name */
            stat = XmlDec_Odf_Object_index_style_name (pctxt, &pvalue->
               style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Object_index");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Object_index");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("object-index-source"), 19}, 0}, 0 },
      {{{OSUTF8("index-body"), 10}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 1, -1}, {2, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* object-index-source */
         stat = XmlDec_Odf_Object_index_source (pctxt, &pvalue->
            object_index_source);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* index-body */
         stat = XmlDec_Odf_Index_body (pctxt, &pvalue->index_body);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  User_index_style_name                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_User_index_style_name (OSCTXT* pctxt, 
   Odf_User_index_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_User_index_style_name (OSCTXT* pctxt, 
   Odf_User_index_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  User_index_entry_template_style_name                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_User_index_entry_template_style_name (OSCTXT* pctxt, 
   Odf_User_index_entry_template_style_name *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_User_index_entry_template_style_name (OSCTXT* pctxt, 
   Odf_User_index_entry_template_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  User_index_entry_template_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_User_index_entry_template_element (OSCTXT* pctxt, 
   Odf_User_index_entry_template_element *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.index_entry_chapter
             = rtxMemAllocType (pctxt, Odf_Index_entry_chapter);

         if (pvalue->u.index_entry_chapter == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_chapter (pvalue->u.index_entry_chapter);
         stat = asn1D_Odf_Index_entry_chapter (pctxt, 
            pvalue->u.index_entry_chapter, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.index_entry_page_number
             = rtxMemAllocType (pctxt, Odf_Index_entry_page_number);

         if (pvalue->u.index_entry_page_number == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_page_number (pvalue->u.index_entry_page_number);
         stat = asn1D_Odf_Index_entry_page_number (pctxt, 
            pvalue->u.index_entry_page_number, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.index_entry_text
             = rtxMemAllocType (pctxt, Odf_Index_entry_text);

         if (pvalue->u.index_entry_text == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_text (pvalue->u.index_entry_text);
         stat = asn1D_Odf_Index_entry_text (pctxt, 
            pvalue->u.index_entry_text, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.index_entry_span
             = rtxMemAllocType (pctxt, Odf_Index_entry_span);

         if (pvalue->u.index_entry_span == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_span (pvalue->u.index_entry_span);
         stat = asn1D_Odf_Index_entry_span (pctxt, 
            pvalue->u.index_entry_span, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.index_entry_tab_stop
             = rtxMemAllocType (pctxt, Odf_Index_entry_tab_stop);

         if (pvalue->u.index_entry_tab_stop == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_tab_stop (pvalue->u.index_entry_tab_stop);
         stat = asn1D_Odf_Index_entry_tab_stop (pctxt, 
            pvalue->u.index_entry_tab_stop, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_User_index_entry_template_element (OSCTXT* pctxt, 
   Odf_User_index_entry_template_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("index-entry-chapter"), 19}, 0}, 0 },
      {{{OSUTF8("index-entry-page-number"), 23}, 0}, 1 },
      {{{OSUTF8("index-entry-text"), 16}, 0}, 2 },
      {{{OSUTF8("index-entry-span"), 16}, 0}, 3 },
      {{{OSUTF8("index-entry-tab-stop"), 20}, 0}, 4 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 5, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* index-entry-chapter */
      pvalue->u.index_entry_chapter
          = rtxMemAllocType (pctxt, Odf_Index_entry_chapter);

      if (pvalue->u.index_entry_chapter == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_chapter (pvalue->u.index_entry_chapter);

      stat = XmlDec_Odf_Index_entry_chapter (pctxt, pvalue->
         u.index_entry_chapter);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* index-entry-page-number */
      pvalue->u.index_entry_page_number
          = rtxMemAllocType (pctxt, Odf_Index_entry_page_number);

      if (pvalue->u.index_entry_page_number == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_page_number (pvalue->u.index_entry_page_number
         );

      stat = XmlDec_Odf_Index_entry_page_number (pctxt, pvalue->
         u.index_entry_page_number);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* index-entry-text */
      pvalue->u.index_entry_text
          = rtxMemAllocType (pctxt, Odf_Index_entry_text);

      if (pvalue->u.index_entry_text == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_text (pvalue->u.index_entry_text);

      stat = XmlDec_Odf_Index_entry_text (pctxt, pvalue->u.index_entry_text);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* index-entry-span */
      pvalue->u.index_entry_span
          = rtxMemAllocType (pctxt, Odf_Index_entry_span);

      if (pvalue->u.index_entry_span == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_span (pvalue->u.index_entry_span);

      stat = XmlDec_Odf_Index_entry_span (pctxt, pvalue->u.index_entry_span);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* index-entry-tab-stop */
      pvalue->u.index_entry_tab_stop
          = rtxMemAllocType (pctxt, Odf_Index_entry_tab_stop);

      if (pvalue->u.index_entry_tab_stop == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_tab_stop (pvalue->u.index_entry_tab_stop);

      stat = XmlDec_Odf_Index_entry_tab_stop (pctxt, pvalue->
         u.index_entry_tab_stop);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  User_index_entry_template                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_User_index_entry_template (OSCTXT* pctxt, 
   Odf_User_index_entry_template *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode outline_level */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->outline_level, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_User_index_entry_template_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_User_index_entry_template_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_User_index_entry_template_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_User_index_entry_template_element (pdata2);

                  stat = asn1D_Odf_User_index_entry_template_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_User_index_entry_template (OSCTXT* pctxt, 
   Odf_User_index_entry_template* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("outline-level"), 13}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* outline-level */
            stat = rtXmlpDecUInt (pctxt, &pvalue->outline_level);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* style-name */
            stat = XmlDec_Odf_User_index_entry_template_style_name (pctxt, &
               pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_User_index_entry_template");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_User_index_entry_template");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("index-entry-chapter"), 19}, 0}, 0 },
      {{{OSUTF8("index-entry-page-number"), 23}, 0}, 0 },
      {{{OSUTF8("index-entry-text"), 16}, 0}, 0 },
      {{{OSUTF8("index-entry-span"), 16}, 0}, 0 },
      {{{OSUTF8("index-entry-tab-stop"), 20}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 5, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_User_index_entry_template_element* pdata1;
         do {
            pdata1
                = rtxMemAllocType (pctxt, Odf_User_index_entry_template_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_User_index_entry_template_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Odf_User_index_entry_template_element (pctxt, pdata1
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 5, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  User_index_source                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_User_index_source (OSCTXT* pctxt, 
   Odf_User_index_source *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode copy_outline_levels */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_User_index_source_copy_outline_levels (pctxt, 
               &pvalue->copy_outline_levels, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.copy_outline_levelsPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode index_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->index_name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode index_scope */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_User_index_source_index_scope (pctxt, 
               &pvalue->index_scope, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.index_scopePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode relative_tab_stop_position */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_User_index_source_relative_tab_stop_position (pctxt, 
               &pvalue->relative_tab_stop_position, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.relative_tab_stop_positionPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode use_floating_frames */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_User_index_source_use_floating_frames (pctxt, 
               &pvalue->use_floating_frames, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.use_floating_framesPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode use_graphics */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_User_index_source_use_graphics (pctxt, 
               &pvalue->use_graphics, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.use_graphicsPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode use_index_marks */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_User_index_source_use_index_marks (pctxt, 
               &pvalue->use_index_marks, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.use_index_marksPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode use_objects */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_User_index_source_use_objects (pctxt, 
               &pvalue->use_objects, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.use_objectsPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode use_tables */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_User_index_source_use_tables (pctxt, 
               &pvalue->use_tables, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.use_tablesPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode index_title_template */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_title_template (pctxt, 
               &pvalue->index_title_template, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.index_title_templatePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 10:
         /* decode user_index_entry_template_list */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_User_index_entry_template* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->user_index_entry_template_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_User_index_entry_template, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_User_index_entry_template (pdata2);

                  stat = asn1D_Odf_User_index_entry_template (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->user_index_entry_template_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 11:
         /* decode index_source_styles_list */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Index_source_styles* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->index_source_styles_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Index_source_styles, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_Index_source_styles (pdata2);

                  stat = asn1D_Odf_Index_source_styles (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->index_source_styles_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_CONS|11):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_User_index_source (OSCTXT* pctxt, Odf_User_index_source* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("copy-outline-levels"), 19}, 0 },
         { {OSUTF8("index-name"), 10}, 0 },
         { {OSUTF8("index-scope"), 11}, 0 },
         { {OSUTF8("relative-tab-stop-position"), 26}, 0 },
         { {OSUTF8("use-floating-frames"), 19}, 0 },
         { {OSUTF8("use-graphics"), 12}, 0 },
         { {OSUTF8("use-index-marks"), 15}, 0 },
         { {OSUTF8("use-objects"), 11}, 0 },
         { {OSUTF8("use-tables"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 9, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* copy-outline-levels */
            stat = XmlDec_Odf_User_index_source_copy_outline_levels (pctxt, &
               pvalue->copy_outline_levels);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.copy_outline_levelsPresent = TRUE;
            break;

         case 1: /* index-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->index_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* index-scope */
            stat = XmlDec_Odf_User_index_source_index_scope (pctxt, &pvalue->
               index_scope);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.index_scopePresent = TRUE;
            break;

         case 3: /* relative-tab-stop-position */
            stat = XmlDec_Odf_User_index_source_relative_tab_stop_position 
               (pctxt, &pvalue->relative_tab_stop_position);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.relative_tab_stop_positionPresent = TRUE;
            break;

         case 4: /* use-floating-frames */
            stat = XmlDec_Odf_User_index_source_use_floating_frames (pctxt, &
               pvalue->use_floating_frames);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.use_floating_framesPresent = TRUE;
            break;

         case 5: /* use-graphics */
            stat = XmlDec_Odf_User_index_source_use_graphics (pctxt, &pvalue->
               use_graphics);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.use_graphicsPresent = TRUE;
            break;

         case 6: /* use-index-marks */
            stat = XmlDec_Odf_User_index_source_use_index_marks (pctxt, &pvalue
               ->use_index_marks);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.use_index_marksPresent = TRUE;
            break;

         case 7: /* use-objects */
            stat = XmlDec_Odf_User_index_source_use_objects (pctxt, &pvalue->
               use_objects);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.use_objectsPresent = TRUE;
            break;

         case 8: /* use-tables */
            stat = XmlDec_Odf_User_index_source_use_tables (pctxt, &pvalue->
               use_tables);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.use_tablesPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_User_index_source");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_User_index_source");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("index-title-template"), 20}, 0}, 0 },
      {{{OSUTF8("user-index-entry-template"), 25}, 0}, 1 },
      {{{OSUTF8("index-source-styles"), 19}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* index-title-template */
         stat = XmlDec_Odf_Index_title_template (pctxt, &pvalue->
            index_title_template);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.index_title_templatePresent = TRUE;
         break;
      }
      case 1: {
         Odf_User_index_entry_template* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_User_index_entry_template);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_User_index_entry_template (pdata1);

            stat = XmlDec_Odf_User_index_entry_template (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->user_index_entry_template_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 2: {
         Odf_Index_source_styles* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_Index_source_styles);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Index_source_styles (pdata1);

            stat = XmlDec_Odf_Index_source_styles (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->index_source_styles_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 2, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  User_index                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_User_index (OSCTXT* pctxt, Odf_User_index *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode protected_ */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_User_index_protected_ (pctxt, 
               &pvalue->protected_, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.protected_Present = TRUE;
            }
         }
         break;

      case 2:
         /* decode protection_key */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->protection_key, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.protection_keyPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_User_index_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode user_index_source */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_User_index_source (pctxt, 
               &pvalue->user_index_source, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode index_body */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_body (pctxt, 
               (Odf_Index_body*)&pvalue->index_body, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_User_index (OSCTXT* pctxt, Odf_User_index* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("protected"), 9}, 0 },
         { {OSUTF8("protection-key"), 14}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* protected */
            stat = XmlDec_Odf_User_index_protected_ (pctxt, &pvalue->protected_
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.protected_Present = TRUE;
            break;

         case 2: /* protection-key */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->protection_key);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.protection_keyPresent = TRUE;
            break;

         case 3: /* style-name */
            stat = XmlDec_Odf_User_index_style_name (pctxt, &pvalue->style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_User_index");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_User_index");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("user-index-source"), 17}, 0}, 0 },
      {{{OSUTF8("index-body"), 10}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 1, -1}, {2, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* user-index-source */
         stat = XmlDec_Odf_User_index_source (pctxt, &pvalue->user_index_source
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* index-body */
         stat = XmlDec_Odf_Index_body (pctxt, &pvalue->index_body);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alphabetical_index_style_name                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Alphabetical_index_style_name (OSCTXT* pctxt, 
   Odf_Alphabetical_index_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Alphabetical_index_style_name (OSCTXT* pctxt, 
   Odf_Alphabetical_index_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alphabetical_index_source_main_entry_style_name           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Alphabetical_index_source_main_entry_style_name (
   OSCTXT* pctxt, Odf_Alphabetical_index_source_main_entry_style_name *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Alphabetical_index_source_main_entry_style_name (OSCTXT* pctxt, 
   Odf_Alphabetical_index_source_main_entry_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alphabetical_index_entry_template_style_name              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Alphabetical_index_entry_template_style_name (
   OSCTXT* pctxt, Odf_Alphabetical_index_entry_template_style_name *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Alphabetical_index_entry_template_style_name (OSCTXT* pctxt, 
   Odf_Alphabetical_index_entry_template_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alphabetical_index_entry_template_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Alphabetical_index_entry_template_element (OSCTXT* pctxt, 
   Odf_Alphabetical_index_entry_template_element *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.index_entry_chapter
             = rtxMemAllocType (pctxt, Odf_Index_entry_chapter);

         if (pvalue->u.index_entry_chapter == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_chapter (pvalue->u.index_entry_chapter);
         stat = asn1D_Odf_Index_entry_chapter (pctxt, 
            pvalue->u.index_entry_chapter, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.index_entry_page_number
             = rtxMemAllocType (pctxt, Odf_Index_entry_page_number);

         if (pvalue->u.index_entry_page_number == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_page_number (pvalue->u.index_entry_page_number);
         stat = asn1D_Odf_Index_entry_page_number (pctxt, 
            pvalue->u.index_entry_page_number, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.index_entry_text
             = rtxMemAllocType (pctxt, Odf_Index_entry_text);

         if (pvalue->u.index_entry_text == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_text (pvalue->u.index_entry_text);
         stat = asn1D_Odf_Index_entry_text (pctxt, 
            pvalue->u.index_entry_text, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.index_entry_span
             = rtxMemAllocType (pctxt, Odf_Index_entry_span);

         if (pvalue->u.index_entry_span == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_span (pvalue->u.index_entry_span);
         stat = asn1D_Odf_Index_entry_span (pctxt, 
            pvalue->u.index_entry_span, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.index_entry_tab_stop
             = rtxMemAllocType (pctxt, Odf_Index_entry_tab_stop);

         if (pvalue->u.index_entry_tab_stop == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_tab_stop (pvalue->u.index_entry_tab_stop);
         stat = asn1D_Odf_Index_entry_tab_stop (pctxt, 
            pvalue->u.index_entry_tab_stop, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Alphabetical_index_entry_template_element (OSCTXT* pctxt, 
   Odf_Alphabetical_index_entry_template_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("index-entry-chapter"), 19}, 0}, 0 },
      {{{OSUTF8("index-entry-page-number"), 23}, 0}, 1 },
      {{{OSUTF8("index-entry-text"), 16}, 0}, 2 },
      {{{OSUTF8("index-entry-span"), 16}, 0}, 3 },
      {{{OSUTF8("index-entry-tab-stop"), 20}, 0}, 4 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 5, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* index-entry-chapter */
      pvalue->u.index_entry_chapter
          = rtxMemAllocType (pctxt, Odf_Index_entry_chapter);

      if (pvalue->u.index_entry_chapter == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_chapter (pvalue->u.index_entry_chapter);

      stat = XmlDec_Odf_Index_entry_chapter (pctxt, pvalue->
         u.index_entry_chapter);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* index-entry-page-number */
      pvalue->u.index_entry_page_number
          = rtxMemAllocType (pctxt, Odf_Index_entry_page_number);

      if (pvalue->u.index_entry_page_number == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_page_number (pvalue->u.index_entry_page_number
         );

      stat = XmlDec_Odf_Index_entry_page_number (pctxt, pvalue->
         u.index_entry_page_number);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* index-entry-text */
      pvalue->u.index_entry_text
          = rtxMemAllocType (pctxt, Odf_Index_entry_text);

      if (pvalue->u.index_entry_text == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_text (pvalue->u.index_entry_text);

      stat = XmlDec_Odf_Index_entry_text (pctxt, pvalue->u.index_entry_text);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* index-entry-span */
      pvalue->u.index_entry_span
          = rtxMemAllocType (pctxt, Odf_Index_entry_span);

      if (pvalue->u.index_entry_span == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_span (pvalue->u.index_entry_span);

      stat = XmlDec_Odf_Index_entry_span (pctxt, pvalue->u.index_entry_span);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* index-entry-tab-stop */
      pvalue->u.index_entry_tab_stop
          = rtxMemAllocType (pctxt, Odf_Index_entry_tab_stop);

      if (pvalue->u.index_entry_tab_stop == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_tab_stop (pvalue->u.index_entry_tab_stop);

      stat = XmlDec_Odf_Index_entry_tab_stop (pctxt, pvalue->
         u.index_entry_tab_stop);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alphabetical_index_entry_template                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Alphabetical_index_entry_template (OSCTXT* pctxt, 
   Odf_Alphabetical_index_entry_template *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode outline_level */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Alphabetical_index_entry_template_outline_level (pctxt, 
               &pvalue->outline_level, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Alphabetical_index_entry_template_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Alphabetical_index_entry_template_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Alphabetical_index_entry_template_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_Alphabetical_index_entry_template_element (pdata2);

                  stat = asn1D_Odf_Alphabetical_index_entry_template_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Alphabetical_index_entry_template (OSCTXT* pctxt, 
   Odf_Alphabetical_index_entry_template* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("outline-level"), 13}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* outline-level */
            stat = XmlDec_Odf_Alphabetical_index_entry_template_outline_level 
               (pctxt, &pvalue->outline_level);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* style-name */
            stat = XmlDec_Odf_Alphabetical_index_entry_template_style_name 
               (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Alphabetical_index_entry_template");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Alphabetical_index_entry_template");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("index-entry-chapter"), 19}, 0}, 0 },
      {{{OSUTF8("index-entry-page-number"), 23}, 0}, 0 },
      {{{OSUTF8("index-entry-text"), 16}, 0}, 0 },
      {{{OSUTF8("index-entry-span"), 16}, 0}, 0 },
      {{{OSUTF8("index-entry-tab-stop"), 20}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 5, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_Alphabetical_index_entry_template_element* pdata1;
         do {
            pdata1
                = rtxMemAllocType (pctxt, Odf_Alphabetical_index_entry_template_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Alphabetical_index_entry_template_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Odf_Alphabetical_index_entry_template_element 
               (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 5, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alphabetical_index_source                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Alphabetical_index_source (OSCTXT* pctxt, 
   Odf_Alphabetical_index_source *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode alphabetical_separators */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Alphabetical_index_source_alphabetical_separators (pctxt, 
               &pvalue->alphabetical_separators, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.alphabetical_separatorsPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode capitalize_entries */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Alphabetical_index_source_capitalize_entries (pctxt, 
               &pvalue->capitalize_entries, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.capitalize_entriesPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode combine_entries */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Alphabetical_index_source_combine_entries (pctxt, 
               &pvalue->combine_entries, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.combine_entriesPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode combine_entries_with_dash */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Alphabetical_index_source_combine_entries_with_dash (pctxt, 
               &pvalue->combine_entries_with_dash, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.combine_entries_with_dashPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode combine_entries_with_pp */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Alphabetical_index_source_combine_entries_with_pp (pctxt, 
               &pvalue->combine_entries_with_pp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.combine_entries_with_ppPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode comma_separated */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Alphabetical_index_source_comma_separated (pctxt, 
               &pvalue->comma_separated, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.comma_separatedPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode ignore_case */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Alphabetical_index_source_ignore_case (pctxt, 
               &pvalue->ignore_case, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.ignore_casePresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode index_scope */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Alphabetical_index_source_index_scope (pctxt, 
               &pvalue->index_scope, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.index_scopePresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode main_entry_style_name */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Alphabetical_index_source_main_entry_style_name (pctxt, 
               &pvalue->main_entry_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.main_entry_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode relative_tab_stop_position */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Alphabetical_index_source_relative_tab_stop_position (pctxt, 
               &pvalue->relative_tab_stop_position, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.relative_tab_stop_positionPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode sort_algorithm */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->sort_algorithm, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sort_algorithmPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode use_keys_as_entries */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Alphabetical_index_source_use_keys_as_entries (pctxt, 
               &pvalue->use_keys_as_entries, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.use_keys_as_entriesPresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode country */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns1_Country (pctxt, 
               &pvalue->country, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.countryPresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns1_Language (pctxt, 
               &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode index_title_template */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_title_template (pctxt, 
               &pvalue->index_title_template, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.index_title_templatePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 15:
         /* decode alphabetical_index_entry_template_list */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Alphabetical_index_entry_template* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->alphabetical_index_entry_template_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Alphabetical_index_entry_template, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_Alphabetical_index_entry_template (pdata2);

                  stat = asn1D_Odf_Alphabetical_index_entry_template (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->alphabetical_index_entry_template_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_CONS|15):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Alphabetical_index_source (OSCTXT* pctxt, 
   Odf_Alphabetical_index_source* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("alphabetical-separators"), 23}, 0 },
         { {OSUTF8("capitalize-entries"), 18}, 0 },
         { {OSUTF8("combine-entries"), 15}, 0 },
         { {OSUTF8("combine-entries-with-dash"), 25}, 0 },
         { {OSUTF8("combine-entries-with-pp"), 23}, 0 },
         { {OSUTF8("comma-separated"), 15}, 0 },
         { {OSUTF8("ignore-case"), 11}, 0 },
         { {OSUTF8("index-scope"), 11}, 0 },
         { {OSUTF8("main-entry-style-name"), 21}, 0 },
         { {OSUTF8("relative-tab-stop-position"), 26}, 0 },
         { {OSUTF8("sort-algorithm"), 14}, 0 },
         { {OSUTF8("use-keys-as-entries"), 19}, 0 },
         { {OSUTF8("country"), 7}, 0 },
         { {OSUTF8("language"), 8}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 14, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* alphabetical-separators */
            stat = XmlDec_Odf_Alphabetical_index_source_alphabetical_separators 
               (pctxt, &pvalue->alphabetical_separators);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.alphabetical_separatorsPresent = TRUE;
            break;

         case 1: /* capitalize-entries */
            stat = XmlDec_Odf_Alphabetical_index_source_capitalize_entries 
               (pctxt, &pvalue->capitalize_entries);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.capitalize_entriesPresent = TRUE;
            break;

         case 2: /* combine-entries */
            stat = XmlDec_Odf_Alphabetical_index_source_combine_entries 
               (pctxt, &pvalue->combine_entries);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.combine_entriesPresent = TRUE;
            break;

         case 3: /* combine-entries-with-dash */
            stat = XmlDec_Odf_Alphabetical_index_source_combine_entries_with_dash 
               (pctxt, &pvalue->combine_entries_with_dash);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.combine_entries_with_dashPresent = TRUE;
            break;

         case 4: /* combine-entries-with-pp */
            stat = XmlDec_Odf_Alphabetical_index_source_combine_entries_with_pp 
               (pctxt, &pvalue->combine_entries_with_pp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.combine_entries_with_ppPresent = TRUE;
            break;

         case 5: /* comma-separated */
            stat = XmlDec_Odf_Alphabetical_index_source_comma_separated 
               (pctxt, &pvalue->comma_separated);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.comma_separatedPresent = TRUE;
            break;

         case 6: /* ignore-case */
            stat = XmlDec_Odf_Alphabetical_index_source_ignore_case (pctxt, &
               pvalue->ignore_case);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.ignore_casePresent = TRUE;
            break;

         case 7: /* index-scope */
            stat = XmlDec_Odf_Alphabetical_index_source_index_scope (pctxt, &
               pvalue->index_scope);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.index_scopePresent = TRUE;
            break;

         case 8: /* main-entry-style-name */
            stat = XmlDec_Odf_Alphabetical_index_source_main_entry_style_name 
               (pctxt, &pvalue->main_entry_style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.main_entry_style_namePresent = TRUE;
            break;

         case 9: /* relative-tab-stop-position */
            stat = XmlDec_Odf_Alphabetical_index_source_relative_tab_stop_position 
               (pctxt, &pvalue->relative_tab_stop_position);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.relative_tab_stop_positionPresent = TRUE;
            break;

         case 10: /* sort-algorithm */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->sort_algorithm);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.sort_algorithmPresent = TRUE;
            break;

         case 11: /* use-keys-as-entries */
            stat = XmlDec_Odf_Alphabetical_index_source_use_keys_as_entries 
               (pctxt, &pvalue->use_keys_as_entries);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.use_keys_as_entriesPresent = TRUE;
            break;

         case 12: /* country */
            stat = XmlDec_Ns1_Country (pctxt, &pvalue->country);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.countryPresent = TRUE;
            break;

         case 13: /* language */
            stat = XmlDec_Ns1_Language (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Alphabetical_index_source");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Alphabetical_index_source");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("index-title-template"), 20}, 0}, 0 },
      {{{OSUTF8("alphabetical-index-entry-template"), 33}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* index-title-template */
         stat = XmlDec_Odf_Index_title_template (pctxt, &pvalue->
            index_title_template);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.index_title_templatePresent = TRUE;
         break;
      }
      case 1: {
         Odf_Alphabetical_index_entry_template* pdata1;
         do {
            pdata1
                = rtxMemAllocType (pctxt, Odf_Alphabetical_index_entry_template);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Alphabetical_index_entry_template (pdata1);

            stat = XmlDec_Odf_Alphabetical_index_entry_template (pctxt, pdata1
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->
               alphabetical_index_entry_template_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alphabetical_index                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Alphabetical_index (OSCTXT* pctxt, 
   Odf_Alphabetical_index *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode protected_ */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Alphabetical_index_protected_ (pctxt, 
               &pvalue->protected_, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.protected_Present = TRUE;
            }
         }
         break;

      case 2:
         /* decode protection_key */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->protection_key, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.protection_keyPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Alphabetical_index_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode alphabetical_index_source */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Alphabetical_index_source (pctxt, 
               &pvalue->alphabetical_index_source, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode index_body */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_body (pctxt, 
               (Odf_Index_body*)&pvalue->index_body, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Alphabetical_index (OSCTXT* pctxt, 
   Odf_Alphabetical_index* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("protected"), 9}, 0 },
         { {OSUTF8("protection-key"), 14}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* protected */
            stat = XmlDec_Odf_Alphabetical_index_protected_ (pctxt, &pvalue->
               protected_);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.protected_Present = TRUE;
            break;

         case 2: /* protection-key */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->protection_key);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.protection_keyPresent = TRUE;
            break;

         case 3: /* style-name */
            stat = XmlDec_Odf_Alphabetical_index_style_name (pctxt, &pvalue->
               style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Alphabetical_index");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Alphabetical_index");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("alphabetical-index-source"), 25}, 0}, 0 },
      {{{OSUTF8("index-body"), 10}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 1, -1}, {2, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* alphabetical-index-source */
         stat = XmlDec_Odf_Alphabetical_index_source (pctxt, &pvalue->
            alphabetical_index_source);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* index-body */
         stat = XmlDec_Odf_Index_body (pctxt, &pvalue->index_body);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Bibliography_style_name                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Bibliography_style_name (OSCTXT* pctxt, 
   Odf_Bibliography_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Bibliography_style_name (OSCTXT* pctxt, 
   Odf_Bibliography_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Bibliography_entry_template_style_name                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Bibliography_entry_template_style_name (OSCTXT* pctxt, 
   Odf_Bibliography_entry_template_style_name *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Bibliography_entry_template_style_name (OSCTXT* pctxt, 
   Odf_Bibliography_entry_template_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_entry_bibliography_style_name                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_entry_bibliography_style_name (OSCTXT* pctxt, 
   Odf_Index_entry_bibliography_style_name *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Index_entry_bibliography_style_name (OSCTXT* pctxt, 
   Odf_Index_entry_bibliography_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_entry_bibliography                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_entry_bibliography (OSCTXT* pctxt, 
   Odf_Index_entry_bibliography *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bibliography_data_field */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_entry_bibliography_bibliography_data_field (pctxt, 
               &pvalue->bibliography_data_field, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_entry_bibliography_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Index_entry_bibliography (OSCTXT* pctxt, 
   Odf_Index_entry_bibliography* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bibliography-data-field"), 23}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bibliography-data-field */
            stat = XmlDec_Odf_Index_entry_bibliography_bibliography_data_field 
               (pctxt, &pvalue->bibliography_data_field);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* style-name */
            stat = XmlDec_Odf_Index_entry_bibliography_style_name (pctxt, &
               pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Index_entry_bibliography");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Index_entry_bibliography");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Bibliography_entry_template_element                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Bibliography_entry_template_element (OSCTXT* pctxt, 
   Odf_Bibliography_entry_template_element *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.index_entry_span
             = rtxMemAllocType (pctxt, Odf_Index_entry_span);

         if (pvalue->u.index_entry_span == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_span (pvalue->u.index_entry_span);
         stat = asn1D_Odf_Index_entry_span (pctxt, 
            pvalue->u.index_entry_span, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.index_entry_tab_stop
             = rtxMemAllocType (pctxt, Odf_Index_entry_tab_stop);

         if (pvalue->u.index_entry_tab_stop == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_tab_stop (pvalue->u.index_entry_tab_stop);
         stat = asn1D_Odf_Index_entry_tab_stop (pctxt, 
            pvalue->u.index_entry_tab_stop, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.index_entry_bibliography
             = rtxMemAllocType (pctxt, Odf_Index_entry_bibliography);

         if (pvalue->u.index_entry_bibliography == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_entry_bibliography (pvalue->u.index_entry_bibliography);
         stat = asn1D_Odf_Index_entry_bibliography (pctxt, 
            pvalue->u.index_entry_bibliography, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Bibliography_entry_template_element (OSCTXT* pctxt, 
   Odf_Bibliography_entry_template_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("index-entry-span"), 16}, 0}, 0 },
      {{{OSUTF8("index-entry-tab-stop"), 20}, 0}, 1 },
      {{{OSUTF8("index-entry-bibliography"), 24}, 0}, 2 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* index-entry-span */
      pvalue->u.index_entry_span
          = rtxMemAllocType (pctxt, Odf_Index_entry_span);

      if (pvalue->u.index_entry_span == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_span (pvalue->u.index_entry_span);

      stat = XmlDec_Odf_Index_entry_span (pctxt, pvalue->u.index_entry_span);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* index-entry-tab-stop */
      pvalue->u.index_entry_tab_stop
          = rtxMemAllocType (pctxt, Odf_Index_entry_tab_stop);

      if (pvalue->u.index_entry_tab_stop == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_tab_stop (pvalue->u.index_entry_tab_stop);

      stat = XmlDec_Odf_Index_entry_tab_stop (pctxt, pvalue->
         u.index_entry_tab_stop);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* index-entry-bibliography */
      pvalue->u.index_entry_bibliography
          = rtxMemAllocType (pctxt, Odf_Index_entry_bibliography);

      if (pvalue->u.index_entry_bibliography == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_entry_bibliography (pvalue->u.index_entry_bibliography
         );

      stat = XmlDec_Odf_Index_entry_bibliography (pctxt, pvalue->
         u.index_entry_bibliography);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Bibliography_entry_template                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Bibliography_entry_template (OSCTXT* pctxt, 
   Odf_Bibliography_entry_template *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bibliography_type */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Bibliography_entry_template_bibliography_type (pctxt, 
               &pvalue->bibliography_type, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Bibliography_entry_template_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Bibliography_entry_template_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Bibliography_entry_template_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_Bibliography_entry_template_element (pdata2);

                  stat = asn1D_Odf_Bibliography_entry_template_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Bibliography_entry_template (OSCTXT* pctxt, 
   Odf_Bibliography_entry_template* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bibliography-type"), 17}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bibliography-type */
            stat = XmlDec_Odf_Bibliography_entry_template_bibliography_type 
               (pctxt, &pvalue->bibliography_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* style-name */
            stat = XmlDec_Odf_Bibliography_entry_template_style_name (pctxt, &
               pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Bibliography_entry_template");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Bibliography_entry_template");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("index-entry-span"), 16}, 0}, 0 },
      {{{OSUTF8("index-entry-tab-stop"), 20}, 0}, 0 },
      {{{OSUTF8("index-entry-bibliography"), 24}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_Bibliography_entry_template_element* pdata1;
         do {
            pdata1
                = rtxMemAllocType (pctxt, Odf_Bibliography_entry_template_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Bibliography_entry_template_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Odf_Bibliography_entry_template_element (pctxt, 
               pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 3, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Bibliography_source                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Bibliography_source (OSCTXT* pctxt, 
   Odf_Bibliography_source *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode index_title_template */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_title_template (pctxt, 
               &pvalue->index_title_template, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.index_title_templatePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode bibliography_entry_template_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Bibliography_entry_template* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->bibliography_entry_template_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Bibliography_entry_template, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_Bibliography_entry_template (pdata2);

                  stat = asn1D_Odf_Bibliography_entry_template (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->bibliography_entry_template_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Bibliography_source (OSCTXT* pctxt, 
   Odf_Bibliography_source* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("index-title-template"), 20}, 0}, 0 },
      {{{OSUTF8("bibliography-entry-template"), 27}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* index-title-template */
         stat = XmlDec_Odf_Index_title_template (pctxt, &pvalue->
            index_title_template);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.index_title_templatePresent = TRUE;
         break;
      }
      case 1: {
         Odf_Bibliography_entry_template* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_Bibliography_entry_template);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Bibliography_entry_template (pdata1);

            stat = XmlDec_Odf_Bibliography_entry_template (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->bibliography_entry_template_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Bibliography                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Bibliography (OSCTXT* pctxt, Odf_Bibliography *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode protected_ */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Bibliography_protected_ (pctxt, 
               &pvalue->protected_, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.protected_Present = TRUE;
            }
         }
         break;

      case 2:
         /* decode protection_key */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->protection_key, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.protection_keyPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Bibliography_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode bibliography_source */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Bibliography_source (pctxt, 
               &pvalue->bibliography_source, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode index_body */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_body (pctxt, 
               (Odf_Index_body*)&pvalue->index_body, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Bibliography (OSCTXT* pctxt, Odf_Bibliography* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("protected"), 9}, 0 },
         { {OSUTF8("protection-key"), 14}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* protected */
            stat = XmlDec_Odf_Bibliography_protected_ (pctxt, &pvalue->
               protected_);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.protected_Present = TRUE;
            break;

         case 2: /* protection-key */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->protection_key);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.protection_keyPresent = TRUE;
            break;

         case 3: /* style-name */
            stat = XmlDec_Odf_Bibliography_style_name (pctxt, &pvalue->
               style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Bibliography");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Bibliography");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("bibliography-source"), 19}, 0}, 0 },
      {{{OSUTF8("index-body"), 10}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 1, -1}, {2, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* bibliography-source */
         stat = XmlDec_Odf_Bibliography_source (pctxt, &pvalue->
            bibliography_source);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* index-body */
         stat = XmlDec_Odf_Index_body (pctxt, &pvalue->index_body);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_title_style_name                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_title_style_name (OSCTXT* pctxt, 
   Odf_Index_title_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Index_title_style_name (OSCTXT* pctxt, 
   Odf_Index_title_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_title_element                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_title_element (OSCTXT* pctxt, 
   Odf_Index_title_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

         if (pvalue->u.h == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_H (pvalue->u.h);
         stat = asn1D_Odf_H (pctxt, 
            pvalue->u.h, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P (pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List (pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.numbered_paragraph
             = rtxMemAllocType (pctxt, Odf_Numbered_paragraph);

         if (pvalue->u.numbered_paragraph == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Numbered_paragraph (pvalue->u.numbered_paragraph);
         stat = asn1D_Odf_Numbered_paragraph (pctxt, 
            pvalue->u.numbered_paragraph, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.table = rtxMemAllocType (pctxt, Table);

         if (pvalue->u.table == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table ((Table*)pvalue->u.table);
         stat = asn1D_Table (pctxt, 
            (Table*)pvalue->u.table, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.a = rtxMemAllocType (pctxt, Ns3_A);

         if (pvalue->u.a == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_A ((Ns3_A*)pvalue->u.a);
         stat = asn1D_Ns3_A (pctxt, 
            (Ns3_A*)pvalue->u.a, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.section = rtxMemAllocType (pctxt, Odf_Section);

         if (pvalue->u.section == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Section ((Odf_Section*)pvalue->u.section);
         stat = asn1D_Odf_Section (pctxt, 
            (Odf_Section*)pvalue->u.section, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.table_of_content
             = rtxMemAllocType (pctxt, Odf_Table_of_content);

         if (pvalue->u.table_of_content == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_of_content ((Odf_Table_of_content*)pvalue->u.table_of_content);
         stat = asn1D_Odf_Table_of_content (pctxt, 
            (Odf_Table_of_content*)pvalue->u.table_of_content, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.illustration_index
             = rtxMemAllocType (pctxt, Odf_Illustration_index);

         if (pvalue->u.illustration_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Illustration_index (pvalue->u.illustration_index);
         stat = asn1D_Odf_Illustration_index (pctxt, 
            pvalue->u.illustration_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.table_index = rtxMemAllocType (pctxt, Odf_Table_index);

         if (pvalue->u.table_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_index (pvalue->u.table_index);
         stat = asn1D_Odf_Table_index (pctxt, 
            pvalue->u.table_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.object_index = rtxMemAllocType (pctxt, Odf_Object_index);

         if (pvalue->u.object_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Object_index (pvalue->u.object_index);
         stat = asn1D_Odf_Object_index (pctxt, 
            pvalue->u.object_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.user_index = rtxMemAllocType (pctxt, Odf_User_index);

         if (pvalue->u.user_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index (pvalue->u.user_index);
         stat = asn1D_Odf_User_index (pctxt, 
            pvalue->u.user_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.alphabetical_index
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index);

         if (pvalue->u.alphabetical_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index (pvalue->u.alphabetical_index);
         stat = asn1D_Odf_Alphabetical_index (pctxt, 
            pvalue->u.alphabetical_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.bibliography = rtxMemAllocType (pctxt, Odf_Bibliography);

         if (pvalue->u.bibliography == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bibliography (pvalue->u.bibliography);
         stat = asn1D_Odf_Bibliography (pctxt, 
            pvalue->u.bibliography, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

         if (pvalue->u.rect == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);
         stat = asn1D_Ns3_Rect (pctxt, 
            (Ns3_Rect*)pvalue->u.rect, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

         if (pvalue->u.line == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);
         stat = asn1D_Ns3_Line (pctxt, 
            (Ns3_Line*)pvalue->u.line, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

         if (pvalue->u.polyline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);
         stat = asn1D_Ns3_Polyline (pctxt, 
            (Ns3_Polyline*)pvalue->u.polyline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      case (TM_CTXT|TM_CONS|17):
         pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

         if (pvalue->u.polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);
         stat = asn1D_Ns3_Polygon (pctxt, 
            (Ns3_Polygon*)pvalue->u.polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 18;
         break;

      case (TM_CTXT|TM_CONS|18):
         pvalue->u.regular_polygon
             = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

         if (pvalue->u.regular_polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->u.regular_polygon);
         stat = asn1D_Ns3_Regular_polygon (pctxt, 
            (Ns3_Regular_polygon*)pvalue->u.regular_polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 19;
         break;

      case (TM_CTXT|TM_CONS|19):
         pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

         if (pvalue->u.path == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);
         stat = asn1D_Ns3_Path (pctxt, 
            (Ns3_Path*)pvalue->u.path, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 20;
         break;

      case (TM_CTXT|TM_CONS|20):
         pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

         if (pvalue->u.circle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);
         stat = asn1D_Ns3_Circle (pctxt, 
            (Ns3_Circle*)pvalue->u.circle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 21;
         break;

      case (TM_CTXT|TM_CONS|21):
         pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

         if (pvalue->u.ellipse == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);
         stat = asn1D_Ns3_Ellipse (pctxt, 
            (Ns3_Ellipse*)pvalue->u.ellipse, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 22;
         break;

      case (TM_CTXT|TM_CONS|22):
         pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

         if (pvalue->u.g == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);
         stat = asn1D_Ns3_G (pctxt, 
            (Ns3_G*)pvalue->u.g, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 23;
         break;

      case (TM_CTXT|TM_CONS|23):
         pvalue->u.page_thumbnail
             = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

         if (pvalue->u.page_thumbnail == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->u.page_thumbnail);
         stat = asn1D_Ns3_Page_thumbnail (pctxt, 
            (Ns3_Page_thumbnail*)pvalue->u.page_thumbnail, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 24;
         break;

      case (TM_CTXT|TM_CONS|24):
         pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

         if (pvalue->u.frame == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);
         stat = asn1D_Ns3_Frame (pctxt, 
            (Ns3_Frame*)pvalue->u.frame, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 25;
         break;

      case (TM_CTXT|TM_CONS|25):
         pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

         if (pvalue->u.measure == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);
         stat = asn1D_Ns3_Measure (pctxt, 
            (Ns3_Measure*)pvalue->u.measure, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 26;
         break;

      case (TM_CTXT|TM_CONS|26):
         pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

         if (pvalue->u.caption == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);
         stat = asn1D_Ns3_Caption (pctxt, 
            (Ns3_Caption*)pvalue->u.caption, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 27;
         break;

      case (TM_CTXT|TM_CONS|27):
         pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

         if (pvalue->u.connector == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);
         stat = asn1D_Ns3_Connector (pctxt, 
            (Ns3_Connector*)pvalue->u.connector, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 28;
         break;

      case (TM_CTXT|TM_CONS|28):
         pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

         if (pvalue->u.control == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);
         stat = asn1D_Ns3_Control (pctxt, 
            (Ns3_Control*)pvalue->u.control, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 29;
         break;

      case (TM_CTXT|TM_CONS|29):
         pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

         if (pvalue->u.scene == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);
         stat = asn1D_Ns7_Scene (pctxt, 
            (Ns7_Scene*)pvalue->u.scene, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 30;
         break;

      case (TM_CTXT|TM_CONS|30):
         pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

         if (pvalue->u.custom_shape == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);
         stat = asn1D_Ns3_Custom_shape (pctxt, 
            (Ns3_Custom_shape*)pvalue->u.custom_shape, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 31;
         break;

      case (TM_CTXT|TM_CONS|31):
         pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

         if (pvalue->u.change == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change (pvalue->u.change);
         stat = asn1D_Odf_Change (pctxt, 
            pvalue->u.change, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 32;
         break;

      case (TM_CTXT|TM_CONS|32):
         pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

         if (pvalue->u.change_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_start (pvalue->u.change_start);
         stat = asn1D_Odf_Change_start (pctxt, 
            pvalue->u.change_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 33;
         break;

      case (TM_CTXT|TM_CONS|33):
         pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

         if (pvalue->u.change_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_end (pvalue->u.change_end);
         stat = asn1D_Odf_Change_end (pctxt, 
            pvalue->u.change_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 34;
         break;

      case (TM_CTXT|TM_CONS|34):
         pvalue->u.index_title = rtxMemAllocType (pctxt, Odf_Index_title);

         if (pvalue->u.index_title == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_title ((Odf_Index_title*)pvalue->u.index_title);
         stat = asn1D_Odf_Index_title (pctxt, 
            (Odf_Index_title*)pvalue->u.index_title, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 35;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Index_title_element (OSCTXT* pctxt, 
   Odf_Index_title_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("h"), 1}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 1 },
      {{{OSUTF8("list"), 4}, 0}, 2 },
      {{{OSUTF8("numbered-paragraph"), 18}, 0}, 3 },
      {{{OSUTF8("table"), 5}, 0}, 4 },
      {{{OSUTF8("a"), 1}, 0}, 5 },
      {{{OSUTF8("section"), 7}, 0}, 6 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 7 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 8 },
      {{{OSUTF8("table-index"), 11}, 0}, 9 },
      {{{OSUTF8("object-index"), 12}, 0}, 10 },
      {{{OSUTF8("user-index"), 10}, 0}, 11 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 12 },
      {{{OSUTF8("bibliography"), 12}, 0}, 13 },
      {{{OSUTF8("rect"), 4}, 0}, 14 },
      {{{OSUTF8("line"), 4}, 0}, 15 },
      {{{OSUTF8("polyline"), 8}, 0}, 16 },
      {{{OSUTF8("polygon"), 7}, 0}, 17 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 18 },
      {{{OSUTF8("path"), 4}, 0}, 19 },
      {{{OSUTF8("circle"), 6}, 0}, 20 },
      {{{OSUTF8("ellipse"), 7}, 0}, 21 },
      {{{OSUTF8("g"), 1}, 0}, 22 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 23 },
      {{{OSUTF8("frame"), 5}, 0}, 24 },
      {{{OSUTF8("measure"), 7}, 0}, 25 },
      {{{OSUTF8("caption"), 7}, 0}, 26 },
      {{{OSUTF8("connector"), 9}, 0}, 27 },
      {{{OSUTF8("control"), 7}, 0}, 28 },
      {{{OSUTF8("scene"), 5}, 0}, 29 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 30 },
      {{{OSUTF8("change"), 6}, 0}, 31 },
      {{{OSUTF8("change-start"), 12}, 0}, 32 },
      {{{OSUTF8("change-end"), 10}, 0}, 33 },
      {{{OSUTF8("index-title"), 11}, 0}, 34 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 35, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* h */
      pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

      if (pvalue->u.h == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_H (pvalue->u.h);

      stat = XmlDec_Odf_H (pctxt, pvalue->u.h);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P (pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List (pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* numbered-paragraph */
      pvalue->u.numbered_paragraph
          = rtxMemAllocType (pctxt, Odf_Numbered_paragraph);

      if (pvalue->u.numbered_paragraph == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Numbered_paragraph (pvalue->u.numbered_paragraph);

      stat = XmlDec_Odf_Numbered_paragraph (pctxt, pvalue->u.numbered_paragraph
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* table */
      pvalue->u.table = rtxMemAllocType (pctxt, Table);

      if (pvalue->u.table == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table ((Table*)pvalue->u.table);

      stat = XmlDec_Table (pctxt, pvalue->u.table);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* a */
      pvalue->u.a = rtxMemAllocType (pctxt, Ns3_A);

      if (pvalue->u.a == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_A ((Ns3_A*)pvalue->u.a);

      stat = XmlDec_Ns3_A (pctxt, pvalue->u.a);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* section */
      pvalue->u.section = rtxMemAllocType (pctxt, Odf_Section);

      if (pvalue->u.section == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Section ((Odf_Section*)pvalue->u.section);

      stat = XmlDec_Odf_Section (pctxt, pvalue->u.section);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* table-of-content */
      pvalue->u.table_of_content
          = rtxMemAllocType (pctxt, Odf_Table_of_content);

      if (pvalue->u.table_of_content == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_of_content ((Odf_Table_of_content*)pvalue->
         u.table_of_content);

      stat = XmlDec_Odf_Table_of_content (pctxt, pvalue->u.table_of_content);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* illustration-index */
      pvalue->u.illustration_index
          = rtxMemAllocType (pctxt, Odf_Illustration_index);

      if (pvalue->u.illustration_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Illustration_index (pvalue->u.illustration_index);

      stat = XmlDec_Odf_Illustration_index (pctxt, pvalue->u.illustration_index
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* table-index */
      pvalue->u.table_index = rtxMemAllocType (pctxt, Odf_Table_index);

      if (pvalue->u.table_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_index (pvalue->u.table_index);

      stat = XmlDec_Odf_Table_index (pctxt, pvalue->u.table_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* object-index */
      pvalue->u.object_index = rtxMemAllocType (pctxt, Odf_Object_index);

      if (pvalue->u.object_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Object_index (pvalue->u.object_index);

      stat = XmlDec_Odf_Object_index (pctxt, pvalue->u.object_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* user-index */
      pvalue->u.user_index = rtxMemAllocType (pctxt, Odf_User_index);

      if (pvalue->u.user_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index (pvalue->u.user_index);

      stat = XmlDec_Odf_User_index (pctxt, pvalue->u.user_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* alphabetical-index */
      pvalue->u.alphabetical_index
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index);

      if (pvalue->u.alphabetical_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index (pvalue->u.alphabetical_index);

      stat = XmlDec_Odf_Alphabetical_index (pctxt, pvalue->u.alphabetical_index
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* bibliography */
      pvalue->u.bibliography = rtxMemAllocType (pctxt, Odf_Bibliography);

      if (pvalue->u.bibliography == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bibliography (pvalue->u.bibliography);

      stat = XmlDec_Odf_Bibliography (pctxt, pvalue->u.bibliography);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* rect */
      pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

      if (pvalue->u.rect == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);

      stat = XmlDec_Ns3_Rect (pctxt, pvalue->u.rect);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* line */
      pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

      if (pvalue->u.line == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);

      stat = XmlDec_Ns3_Line (pctxt, pvalue->u.line);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* polyline */
      pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

      if (pvalue->u.polyline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);

      stat = XmlDec_Ns3_Polyline (pctxt, pvalue->u.polyline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 17: { /* polygon */
      pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

      if (pvalue->u.polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);

      stat = XmlDec_Ns3_Polygon (pctxt, pvalue->u.polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 18: { /* regular-polygon */
      pvalue->u.regular_polygon
          = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

      if (pvalue->u.regular_polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->
         u.regular_polygon);

      stat = XmlDec_Ns3_Regular_polygon (pctxt, pvalue->u.regular_polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 19: { /* path */
      pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

      if (pvalue->u.path == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);

      stat = XmlDec_Ns3_Path (pctxt, pvalue->u.path);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 20: { /* circle */
      pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

      if (pvalue->u.circle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);

      stat = XmlDec_Ns3_Circle (pctxt, pvalue->u.circle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 21: { /* ellipse */
      pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

      if (pvalue->u.ellipse == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);

      stat = XmlDec_Ns3_Ellipse (pctxt, pvalue->u.ellipse);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 22: { /* g */
      pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

      if (pvalue->u.g == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);

      stat = XmlDec_Ns3_G (pctxt, pvalue->u.g);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 23: { /* page-thumbnail */
      pvalue->u.page_thumbnail = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

      if (pvalue->u.page_thumbnail == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->
         u.page_thumbnail);

      stat = XmlDec_Ns3_Page_thumbnail (pctxt, pvalue->u.page_thumbnail);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 24: { /* frame */
      pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

      if (pvalue->u.frame == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);

      stat = XmlDec_Ns3_Frame (pctxt, pvalue->u.frame);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 25: { /* measure */
      pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

      if (pvalue->u.measure == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);

      stat = XmlDec_Ns3_Measure (pctxt, pvalue->u.measure);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 26: { /* caption */
      pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

      if (pvalue->u.caption == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);

      stat = XmlDec_Ns3_Caption (pctxt, pvalue->u.caption);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 27: { /* connector */
      pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

      if (pvalue->u.connector == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);

      stat = XmlDec_Ns3_Connector (pctxt, pvalue->u.connector);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 28: { /* control */
      pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

      if (pvalue->u.control == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);

      stat = XmlDec_Ns3_Control (pctxt, pvalue->u.control);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 29: { /* scene */
      pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

      if (pvalue->u.scene == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);

      stat = XmlDec_Ns7_Scene (pctxt, pvalue->u.scene);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 30: { /* custom-shape */
      pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

      if (pvalue->u.custom_shape == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);

      stat = XmlDec_Ns3_Custom_shape (pctxt, pvalue->u.custom_shape);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 31: { /* change */
      pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

      if (pvalue->u.change == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change (pvalue->u.change);

      stat = XmlDec_Odf_Change (pctxt, pvalue->u.change);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 32: { /* change-start */
      pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

      if (pvalue->u.change_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_start (pvalue->u.change_start);

      stat = XmlDec_Odf_Change_start (pctxt, pvalue->u.change_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 33: { /* change-end */
      pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

      if (pvalue->u.change_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_end (pvalue->u.change_end);

      stat = XmlDec_Odf_Change_end (pctxt, pvalue->u.change_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 34: { /* index-title */
      pvalue->u.index_title = rtxMemAllocType (pctxt, Odf_Index_title);

      if (pvalue->u.index_title == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_title ((Odf_Index_title*)pvalue->u.index_title);

      stat = XmlDec_Odf_Index_title (pctxt, pvalue->u.index_title);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_title                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_title (OSCTXT* pctxt, Odf_Index_title *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode protected_ */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_title_protected_ (pctxt, 
               &pvalue->protected_, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.protected_Present = TRUE;
            }
         }
         break;

      case 2:
         /* decode protection_key */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->protection_key, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.protection_keyPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_title_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Index_title_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Index_title_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_Index_title_element (pdata2);

                  stat = asn1D_Odf_Index_title_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Index_title (OSCTXT* pctxt, Odf_Index_title* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("protected"), 9}, 0 },
         { {OSUTF8("protection-key"), 14}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* protected */
            stat = XmlDec_Odf_Index_title_protected_ (pctxt, &pvalue->
               protected_);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.protected_Present = TRUE;
            break;

         case 2: /* protection-key */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->protection_key);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.protection_keyPresent = TRUE;
            break;

         case 3: /* style-name */
            stat = XmlDec_Odf_Index_title_style_name (pctxt, &pvalue->
               style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Index_title");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Index_title");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("h"), 1}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("list"), 4}, 0}, 0 },
      {{{OSUTF8("numbered-paragraph"), 18}, 0}, 0 },
      {{{OSUTF8("table"), 5}, 0}, 0 },
      {{{OSUTF8("a"), 1}, 0}, 0 },
      {{{OSUTF8("section"), 7}, 0}, 0 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 0 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 0 },
      {{{OSUTF8("table-index"), 11}, 0}, 0 },
      {{{OSUTF8("object-index"), 12}, 0}, 0 },
      {{{OSUTF8("user-index"), 10}, 0}, 0 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 0 },
      {{{OSUTF8("bibliography"), 12}, 0}, 0 },
      {{{OSUTF8("rect"), 4}, 0}, 0 },
      {{{OSUTF8("line"), 4}, 0}, 0 },
      {{{OSUTF8("polyline"), 8}, 0}, 0 },
      {{{OSUTF8("polygon"), 7}, 0}, 0 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 0 },
      {{{OSUTF8("path"), 4}, 0}, 0 },
      {{{OSUTF8("circle"), 6}, 0}, 0 },
      {{{OSUTF8("ellipse"), 7}, 0}, 0 },
      {{{OSUTF8("g"), 1}, 0}, 0 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 0 },
      {{{OSUTF8("frame"), 5}, 0}, 0 },
      {{{OSUTF8("measure"), 7}, 0}, 0 },
      {{{OSUTF8("caption"), 7}, 0}, 0 },
      {{{OSUTF8("connector"), 9}, 0}, 0 },
      {{{OSUTF8("control"), 7}, 0}, 0 },
      {{{OSUTF8("scene"), 5}, 0}, 0 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 0 },
      {{{OSUTF8("change"), 6}, 0}, 0 },
      {{{OSUTF8("change-start"), 12}, 0}, 0 },
      {{{OSUTF8("change-end"), 10}, 0}, 0 },
      {{{OSUTF8("index-title"), 11}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 35, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_Index_title_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_Index_title_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Index_title_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Odf_Index_title_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 35, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_body_element                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_body_element (OSCTXT* pctxt, 
   Odf_Index_body_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

         if (pvalue->u.h == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_H (pvalue->u.h);
         stat = asn1D_Odf_H (pctxt, 
            pvalue->u.h, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P (pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List (pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.numbered_paragraph
             = rtxMemAllocType (pctxt, Odf_Numbered_paragraph);

         if (pvalue->u.numbered_paragraph == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Numbered_paragraph (pvalue->u.numbered_paragraph);
         stat = asn1D_Odf_Numbered_paragraph (pctxt, 
            pvalue->u.numbered_paragraph, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.table = rtxMemAllocType (pctxt, Table);

         if (pvalue->u.table == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table ((Table*)pvalue->u.table);
         stat = asn1D_Table (pctxt, 
            (Table*)pvalue->u.table, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.a = rtxMemAllocType (pctxt, Ns3_A);

         if (pvalue->u.a == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_A ((Ns3_A*)pvalue->u.a);
         stat = asn1D_Ns3_A (pctxt, 
            (Ns3_A*)pvalue->u.a, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.section = rtxMemAllocType (pctxt, Odf_Section);

         if (pvalue->u.section == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Section ((Odf_Section*)pvalue->u.section);
         stat = asn1D_Odf_Section (pctxt, 
            (Odf_Section*)pvalue->u.section, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.table_of_content
             = rtxMemAllocType (pctxt, Odf_Table_of_content);

         if (pvalue->u.table_of_content == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_of_content ((Odf_Table_of_content*)pvalue->u.table_of_content);
         stat = asn1D_Odf_Table_of_content (pctxt, 
            (Odf_Table_of_content*)pvalue->u.table_of_content, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.illustration_index
             = rtxMemAllocType (pctxt, Odf_Illustration_index);

         if (pvalue->u.illustration_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Illustration_index (pvalue->u.illustration_index);
         stat = asn1D_Odf_Illustration_index (pctxt, 
            pvalue->u.illustration_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.table_index = rtxMemAllocType (pctxt, Odf_Table_index);

         if (pvalue->u.table_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_index (pvalue->u.table_index);
         stat = asn1D_Odf_Table_index (pctxt, 
            pvalue->u.table_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.object_index = rtxMemAllocType (pctxt, Odf_Object_index);

         if (pvalue->u.object_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Object_index (pvalue->u.object_index);
         stat = asn1D_Odf_Object_index (pctxt, 
            pvalue->u.object_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.user_index = rtxMemAllocType (pctxt, Odf_User_index);

         if (pvalue->u.user_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index (pvalue->u.user_index);
         stat = asn1D_Odf_User_index (pctxt, 
            pvalue->u.user_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.alphabetical_index
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index);

         if (pvalue->u.alphabetical_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index (pvalue->u.alphabetical_index);
         stat = asn1D_Odf_Alphabetical_index (pctxt, 
            pvalue->u.alphabetical_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.bibliography = rtxMemAllocType (pctxt, Odf_Bibliography);

         if (pvalue->u.bibliography == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bibliography (pvalue->u.bibliography);
         stat = asn1D_Odf_Bibliography (pctxt, 
            pvalue->u.bibliography, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

         if (pvalue->u.rect == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);
         stat = asn1D_Ns3_Rect (pctxt, 
            (Ns3_Rect*)pvalue->u.rect, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

         if (pvalue->u.line == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);
         stat = asn1D_Ns3_Line (pctxt, 
            (Ns3_Line*)pvalue->u.line, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

         if (pvalue->u.polyline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);
         stat = asn1D_Ns3_Polyline (pctxt, 
            (Ns3_Polyline*)pvalue->u.polyline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      case (TM_CTXT|TM_CONS|17):
         pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

         if (pvalue->u.polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);
         stat = asn1D_Ns3_Polygon (pctxt, 
            (Ns3_Polygon*)pvalue->u.polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 18;
         break;

      case (TM_CTXT|TM_CONS|18):
         pvalue->u.regular_polygon
             = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

         if (pvalue->u.regular_polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->u.regular_polygon);
         stat = asn1D_Ns3_Regular_polygon (pctxt, 
            (Ns3_Regular_polygon*)pvalue->u.regular_polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 19;
         break;

      case (TM_CTXT|TM_CONS|19):
         pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

         if (pvalue->u.path == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);
         stat = asn1D_Ns3_Path (pctxt, 
            (Ns3_Path*)pvalue->u.path, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 20;
         break;

      case (TM_CTXT|TM_CONS|20):
         pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

         if (pvalue->u.circle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);
         stat = asn1D_Ns3_Circle (pctxt, 
            (Ns3_Circle*)pvalue->u.circle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 21;
         break;

      case (TM_CTXT|TM_CONS|21):
         pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

         if (pvalue->u.ellipse == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);
         stat = asn1D_Ns3_Ellipse (pctxt, 
            (Ns3_Ellipse*)pvalue->u.ellipse, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 22;
         break;

      case (TM_CTXT|TM_CONS|22):
         pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

         if (pvalue->u.g == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);
         stat = asn1D_Ns3_G (pctxt, 
            (Ns3_G*)pvalue->u.g, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 23;
         break;

      case (TM_CTXT|TM_CONS|23):
         pvalue->u.page_thumbnail
             = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

         if (pvalue->u.page_thumbnail == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->u.page_thumbnail);
         stat = asn1D_Ns3_Page_thumbnail (pctxt, 
            (Ns3_Page_thumbnail*)pvalue->u.page_thumbnail, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 24;
         break;

      case (TM_CTXT|TM_CONS|24):
         pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

         if (pvalue->u.frame == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);
         stat = asn1D_Ns3_Frame (pctxt, 
            (Ns3_Frame*)pvalue->u.frame, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 25;
         break;

      case (TM_CTXT|TM_CONS|25):
         pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

         if (pvalue->u.measure == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);
         stat = asn1D_Ns3_Measure (pctxt, 
            (Ns3_Measure*)pvalue->u.measure, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 26;
         break;

      case (TM_CTXT|TM_CONS|26):
         pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

         if (pvalue->u.caption == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);
         stat = asn1D_Ns3_Caption (pctxt, 
            (Ns3_Caption*)pvalue->u.caption, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 27;
         break;

      case (TM_CTXT|TM_CONS|27):
         pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

         if (pvalue->u.connector == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);
         stat = asn1D_Ns3_Connector (pctxt, 
            (Ns3_Connector*)pvalue->u.connector, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 28;
         break;

      case (TM_CTXT|TM_CONS|28):
         pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

         if (pvalue->u.control == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);
         stat = asn1D_Ns3_Control (pctxt, 
            (Ns3_Control*)pvalue->u.control, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 29;
         break;

      case (TM_CTXT|TM_CONS|29):
         pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

         if (pvalue->u.scene == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);
         stat = asn1D_Ns7_Scene (pctxt, 
            (Ns7_Scene*)pvalue->u.scene, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 30;
         break;

      case (TM_CTXT|TM_CONS|30):
         pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

         if (pvalue->u.custom_shape == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);
         stat = asn1D_Ns3_Custom_shape (pctxt, 
            (Ns3_Custom_shape*)pvalue->u.custom_shape, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 31;
         break;

      case (TM_CTXT|TM_CONS|31):
         pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

         if (pvalue->u.change == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change (pvalue->u.change);
         stat = asn1D_Odf_Change (pctxt, 
            pvalue->u.change, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 32;
         break;

      case (TM_CTXT|TM_CONS|32):
         pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

         if (pvalue->u.change_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_start (pvalue->u.change_start);
         stat = asn1D_Odf_Change_start (pctxt, 
            pvalue->u.change_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 33;
         break;

      case (TM_CTXT|TM_CONS|33):
         pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

         if (pvalue->u.change_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_end (pvalue->u.change_end);
         stat = asn1D_Odf_Change_end (pctxt, 
            pvalue->u.change_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 34;
         break;

      case (TM_CTXT|TM_CONS|34):
         pvalue->u.index_title = rtxMemAllocType (pctxt, Odf_Index_title);

         if (pvalue->u.index_title == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_title (pvalue->u.index_title);
         stat = asn1D_Odf_Index_title (pctxt, 
            pvalue->u.index_title, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 35;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Index_body_element (OSCTXT* pctxt, 
   Odf_Index_body_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("h"), 1}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 1 },
      {{{OSUTF8("list"), 4}, 0}, 2 },
      {{{OSUTF8("numbered-paragraph"), 18}, 0}, 3 },
      {{{OSUTF8("table"), 5}, 0}, 4 },
      {{{OSUTF8("a"), 1}, 0}, 5 },
      {{{OSUTF8("section"), 7}, 0}, 6 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 7 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 8 },
      {{{OSUTF8("table-index"), 11}, 0}, 9 },
      {{{OSUTF8("object-index"), 12}, 0}, 10 },
      {{{OSUTF8("user-index"), 10}, 0}, 11 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 12 },
      {{{OSUTF8("bibliography"), 12}, 0}, 13 },
      {{{OSUTF8("rect"), 4}, 0}, 14 },
      {{{OSUTF8("line"), 4}, 0}, 15 },
      {{{OSUTF8("polyline"), 8}, 0}, 16 },
      {{{OSUTF8("polygon"), 7}, 0}, 17 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 18 },
      {{{OSUTF8("path"), 4}, 0}, 19 },
      {{{OSUTF8("circle"), 6}, 0}, 20 },
      {{{OSUTF8("ellipse"), 7}, 0}, 21 },
      {{{OSUTF8("g"), 1}, 0}, 22 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 23 },
      {{{OSUTF8("frame"), 5}, 0}, 24 },
      {{{OSUTF8("measure"), 7}, 0}, 25 },
      {{{OSUTF8("caption"), 7}, 0}, 26 },
      {{{OSUTF8("connector"), 9}, 0}, 27 },
      {{{OSUTF8("control"), 7}, 0}, 28 },
      {{{OSUTF8("scene"), 5}, 0}, 29 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 30 },
      {{{OSUTF8("change"), 6}, 0}, 31 },
      {{{OSUTF8("change-start"), 12}, 0}, 32 },
      {{{OSUTF8("change-end"), 10}, 0}, 33 },
      {{{OSUTF8("index-title"), 11}, 0}, 34 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 35, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* h */
      pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

      if (pvalue->u.h == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_H (pvalue->u.h);

      stat = XmlDec_Odf_H (pctxt, pvalue->u.h);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P (pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List (pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* numbered-paragraph */
      pvalue->u.numbered_paragraph
          = rtxMemAllocType (pctxt, Odf_Numbered_paragraph);

      if (pvalue->u.numbered_paragraph == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Numbered_paragraph (pvalue->u.numbered_paragraph);

      stat = XmlDec_Odf_Numbered_paragraph (pctxt, pvalue->u.numbered_paragraph
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* table */
      pvalue->u.table = rtxMemAllocType (pctxt, Table);

      if (pvalue->u.table == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table ((Table*)pvalue->u.table);

      stat = XmlDec_Table (pctxt, pvalue->u.table);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* a */
      pvalue->u.a = rtxMemAllocType (pctxt, Ns3_A);

      if (pvalue->u.a == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_A ((Ns3_A*)pvalue->u.a);

      stat = XmlDec_Ns3_A (pctxt, pvalue->u.a);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* section */
      pvalue->u.section = rtxMemAllocType (pctxt, Odf_Section);

      if (pvalue->u.section == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Section ((Odf_Section*)pvalue->u.section);

      stat = XmlDec_Odf_Section (pctxt, pvalue->u.section);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* table-of-content */
      pvalue->u.table_of_content
          = rtxMemAllocType (pctxt, Odf_Table_of_content);

      if (pvalue->u.table_of_content == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_of_content ((Odf_Table_of_content*)pvalue->
         u.table_of_content);

      stat = XmlDec_Odf_Table_of_content (pctxt, pvalue->u.table_of_content);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* illustration-index */
      pvalue->u.illustration_index
          = rtxMemAllocType (pctxt, Odf_Illustration_index);

      if (pvalue->u.illustration_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Illustration_index (pvalue->u.illustration_index);

      stat = XmlDec_Odf_Illustration_index (pctxt, pvalue->u.illustration_index
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* table-index */
      pvalue->u.table_index = rtxMemAllocType (pctxt, Odf_Table_index);

      if (pvalue->u.table_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_index (pvalue->u.table_index);

      stat = XmlDec_Odf_Table_index (pctxt, pvalue->u.table_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* object-index */
      pvalue->u.object_index = rtxMemAllocType (pctxt, Odf_Object_index);

      if (pvalue->u.object_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Object_index (pvalue->u.object_index);

      stat = XmlDec_Odf_Object_index (pctxt, pvalue->u.object_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* user-index */
      pvalue->u.user_index = rtxMemAllocType (pctxt, Odf_User_index);

      if (pvalue->u.user_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index (pvalue->u.user_index);

      stat = XmlDec_Odf_User_index (pctxt, pvalue->u.user_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* alphabetical-index */
      pvalue->u.alphabetical_index
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index);

      if (pvalue->u.alphabetical_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index (pvalue->u.alphabetical_index);

      stat = XmlDec_Odf_Alphabetical_index (pctxt, pvalue->u.alphabetical_index
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* bibliography */
      pvalue->u.bibliography = rtxMemAllocType (pctxt, Odf_Bibliography);

      if (pvalue->u.bibliography == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bibliography (pvalue->u.bibliography);

      stat = XmlDec_Odf_Bibliography (pctxt, pvalue->u.bibliography);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* rect */
      pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

      if (pvalue->u.rect == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);

      stat = XmlDec_Ns3_Rect (pctxt, pvalue->u.rect);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* line */
      pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

      if (pvalue->u.line == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);

      stat = XmlDec_Ns3_Line (pctxt, pvalue->u.line);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* polyline */
      pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

      if (pvalue->u.polyline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);

      stat = XmlDec_Ns3_Polyline (pctxt, pvalue->u.polyline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 17: { /* polygon */
      pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

      if (pvalue->u.polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);

      stat = XmlDec_Ns3_Polygon (pctxt, pvalue->u.polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 18: { /* regular-polygon */
      pvalue->u.regular_polygon
          = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

      if (pvalue->u.regular_polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->
         u.regular_polygon);

      stat = XmlDec_Ns3_Regular_polygon (pctxt, pvalue->u.regular_polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 19: { /* path */
      pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

      if (pvalue->u.path == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);

      stat = XmlDec_Ns3_Path (pctxt, pvalue->u.path);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 20: { /* circle */
      pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

      if (pvalue->u.circle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);

      stat = XmlDec_Ns3_Circle (pctxt, pvalue->u.circle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 21: { /* ellipse */
      pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

      if (pvalue->u.ellipse == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);

      stat = XmlDec_Ns3_Ellipse (pctxt, pvalue->u.ellipse);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 22: { /* g */
      pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

      if (pvalue->u.g == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);

      stat = XmlDec_Ns3_G (pctxt, pvalue->u.g);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 23: { /* page-thumbnail */
      pvalue->u.page_thumbnail = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

      if (pvalue->u.page_thumbnail == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->
         u.page_thumbnail);

      stat = XmlDec_Ns3_Page_thumbnail (pctxt, pvalue->u.page_thumbnail);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 24: { /* frame */
      pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

      if (pvalue->u.frame == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);

      stat = XmlDec_Ns3_Frame (pctxt, pvalue->u.frame);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 25: { /* measure */
      pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

      if (pvalue->u.measure == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);

      stat = XmlDec_Ns3_Measure (pctxt, pvalue->u.measure);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 26: { /* caption */
      pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

      if (pvalue->u.caption == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);

      stat = XmlDec_Ns3_Caption (pctxt, pvalue->u.caption);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 27: { /* connector */
      pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

      if (pvalue->u.connector == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);

      stat = XmlDec_Ns3_Connector (pctxt, pvalue->u.connector);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 28: { /* control */
      pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

      if (pvalue->u.control == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);

      stat = XmlDec_Ns3_Control (pctxt, pvalue->u.control);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 29: { /* scene */
      pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

      if (pvalue->u.scene == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);

      stat = XmlDec_Ns7_Scene (pctxt, pvalue->u.scene);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 30: { /* custom-shape */
      pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

      if (pvalue->u.custom_shape == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);

      stat = XmlDec_Ns3_Custom_shape (pctxt, pvalue->u.custom_shape);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 31: { /* change */
      pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

      if (pvalue->u.change == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change (pvalue->u.change);

      stat = XmlDec_Odf_Change (pctxt, pvalue->u.change);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 32: { /* change-start */
      pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

      if (pvalue->u.change_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_start (pvalue->u.change_start);

      stat = XmlDec_Odf_Change_start (pctxt, pvalue->u.change_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 33: { /* change-end */
      pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

      if (pvalue->u.change_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_end (pvalue->u.change_end);

      stat = XmlDec_Odf_Change_end (pctxt, pvalue->u.change_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 34: { /* index-title */
      pvalue->u.index_title = rtxMemAllocType (pctxt, Odf_Index_title);

      if (pvalue->u.index_title == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_title (pvalue->u.index_title);

      stat = XmlDec_Odf_Index_title (pctxt, pvalue->u.index_title);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Index_body                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Index_body (OSCTXT* pctxt, Odf_Index_body *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   Odf_Index_body_element* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (XD_PEEKTAG (pctxt, 0x30)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_UNIV|TM_CONS|16));

   if (XD_PEEKTAG (pctxt, 0xa0)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_CTXT|TM_CONS|0));

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      rtxDListAllocNodeAndData (pctxt, Odf_Index_body_element, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_body_element (pdata1);

      stat = asn1D_Odf_Index_body_element (pctxt, 
         pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

int XmlDec_Odf_Index_body (OSCTXT* pctxt, Odf_Index_body* pvalue)
{
   int stat = 0;

   { int elemID;
   Odf_Index_body_element* pdata1;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("h"), 1}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("list"), 4}, 0}, 0 },
      {{{OSUTF8("numbered-paragraph"), 18}, 0}, 0 },
      {{{OSUTF8("table"), 5}, 0}, 0 },
      {{{OSUTF8("a"), 1}, 0}, 0 },
      {{{OSUTF8("section"), 7}, 0}, 0 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 0 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 0 },
      {{{OSUTF8("table-index"), 11}, 0}, 0 },
      {{{OSUTF8("object-index"), 12}, 0}, 0 },
      {{{OSUTF8("user-index"), 10}, 0}, 0 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 0 },
      {{{OSUTF8("bibliography"), 12}, 0}, 0 },
      {{{OSUTF8("rect"), 4}, 0}, 0 },
      {{{OSUTF8("line"), 4}, 0}, 0 },
      {{{OSUTF8("polyline"), 8}, 0}, 0 },
      {{{OSUTF8("polygon"), 7}, 0}, 0 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 0 },
      {{{OSUTF8("path"), 4}, 0}, 0 },
      {{{OSUTF8("circle"), 6}, 0}, 0 },
      {{{OSUTF8("ellipse"), 7}, 0}, 0 },
      {{{OSUTF8("g"), 1}, 0}, 0 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 0 },
      {{{OSUTF8("frame"), 5}, 0}, 0 },
      {{{OSUTF8("measure"), 7}, 0}, 0 },
      {{{OSUTF8("caption"), 7}, 0}, 0 },
      {{{OSUTF8("connector"), 9}, 0}, 0 },
      {{{OSUTF8("control"), 7}, 0}, 0 },
      {{{OSUTF8("scene"), 5}, 0}, 0 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 0 },
      {{{OSUTF8("change"), 6}, 0}, 0 },
      {{{OSUTF8("change-start"), 12}, 0}, 0 },
      {{{OSUTF8("change-end"), 10}, 0}, 0 },
      {{{OSUTF8("index-title"), 11}, 0}, 0 }
   } ;

   rtxDListInit (pvalue);
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 35, -1, FALSE);
      if (elemID < 0 || elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0:
         rtXmlpMarkLastEventActive (pctxt);

         pdata1 = rtxMemAllocType (pctxt, Odf_Index_body_element);

         if (pdata1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_body_element (pdata1);

         stat = XmlDec_Odf_Index_body_element (pctxt, pdata1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         break;

      }
   }

   if (elemID == RTERR_UNEXPELEM || elemID == XML_OK_EOB) {
      stat = 0;
   }
   else return LOG_RTERR (pctxt, elemID);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_of_content                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Table_of_content (OSCTXT* pctxt, 
   Odf_Table_of_content *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode protected_ */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Table_of_content_protected_ (pctxt, 
               &pvalue->protected_, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.protected_Present = TRUE;
            }
         }
         break;

      case 2:
         /* decode protection_key */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->protection_key, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.protection_keyPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Table_of_content_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode table_of_content_source */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Table_of_content_source (pctxt, 
               &pvalue->table_of_content_source, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode index_body */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Index_body (pctxt, 
               &pvalue->index_body, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Table_of_content (OSCTXT* pctxt, Odf_Table_of_content* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("protected"), 9}, 0 },
         { {OSUTF8("protection-key"), 14}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* protected */
            stat = XmlDec_Odf_Table_of_content_protected_ (pctxt, &pvalue->
               protected_);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.protected_Present = TRUE;
            break;

         case 2: /* protection-key */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->protection_key);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.protection_keyPresent = TRUE;
            break;

         case 3: /* style-name */
            stat = XmlDec_Odf_Table_of_content_style_name (pctxt, &pvalue->
               style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Table_of_content");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Table_of_content");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("table-of-content-source"), 23}, 0}, 0 },
      {{{OSUTF8("index-body"), 10}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 1, -1}, {2, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* table-of-content-source */
         stat = XmlDec_Odf_Table_of_content_source (pctxt, &pvalue->
            table_of_content_source);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* index-body */
         stat = XmlDec_Odf_Index_body (pctxt, &pvalue->index_body);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Section_element                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Section_element (OSCTXT* pctxt, 
   Odf_Section_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

         if (pvalue->u.h == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_H (pvalue->u.h);
         stat = asn1D_Odf_H (pctxt, 
            pvalue->u.h, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P (pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List (pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.numbered_paragraph
             = rtxMemAllocType (pctxt, Odf_Numbered_paragraph);

         if (pvalue->u.numbered_paragraph == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Numbered_paragraph (pvalue->u.numbered_paragraph);
         stat = asn1D_Odf_Numbered_paragraph (pctxt, 
            pvalue->u.numbered_paragraph, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.table = rtxMemAllocType (pctxt, Table);

         if (pvalue->u.table == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table ((Table*)pvalue->u.table);
         stat = asn1D_Table (pctxt, 
            (Table*)pvalue->u.table, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.a = rtxMemAllocType (pctxt, Ns3_A);

         if (pvalue->u.a == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_A ((Ns3_A*)pvalue->u.a);
         stat = asn1D_Ns3_A (pctxt, 
            (Ns3_A*)pvalue->u.a, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.section = rtxMemAllocType (pctxt, Odf_Section);

         if (pvalue->u.section == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Section ((Odf_Section*)pvalue->u.section);
         stat = asn1D_Odf_Section (pctxt, 
            (Odf_Section*)pvalue->u.section, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.table_of_content
             = rtxMemAllocType (pctxt, Odf_Table_of_content);

         if (pvalue->u.table_of_content == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_of_content (pvalue->u.table_of_content);
         stat = asn1D_Odf_Table_of_content (pctxt, 
            pvalue->u.table_of_content, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.illustration_index
             = rtxMemAllocType (pctxt, Odf_Illustration_index);

         if (pvalue->u.illustration_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Illustration_index (pvalue->u.illustration_index);
         stat = asn1D_Odf_Illustration_index (pctxt, 
            pvalue->u.illustration_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.table_index = rtxMemAllocType (pctxt, Odf_Table_index);

         if (pvalue->u.table_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_index (pvalue->u.table_index);
         stat = asn1D_Odf_Table_index (pctxt, 
            pvalue->u.table_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.object_index = rtxMemAllocType (pctxt, Odf_Object_index);

         if (pvalue->u.object_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Object_index (pvalue->u.object_index);
         stat = asn1D_Odf_Object_index (pctxt, 
            pvalue->u.object_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.user_index = rtxMemAllocType (pctxt, Odf_User_index);

         if (pvalue->u.user_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index (pvalue->u.user_index);
         stat = asn1D_Odf_User_index (pctxt, 
            pvalue->u.user_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.alphabetical_index
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index);

         if (pvalue->u.alphabetical_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index (pvalue->u.alphabetical_index);
         stat = asn1D_Odf_Alphabetical_index (pctxt, 
            pvalue->u.alphabetical_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.bibliography = rtxMemAllocType (pctxt, Odf_Bibliography);

         if (pvalue->u.bibliography == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bibliography (pvalue->u.bibliography);
         stat = asn1D_Odf_Bibliography (pctxt, 
            pvalue->u.bibliography, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

         if (pvalue->u.rect == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);
         stat = asn1D_Ns3_Rect (pctxt, 
            (Ns3_Rect*)pvalue->u.rect, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

         if (pvalue->u.line == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);
         stat = asn1D_Ns3_Line (pctxt, 
            (Ns3_Line*)pvalue->u.line, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

         if (pvalue->u.polyline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);
         stat = asn1D_Ns3_Polyline (pctxt, 
            (Ns3_Polyline*)pvalue->u.polyline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      case (TM_CTXT|TM_CONS|17):
         pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

         if (pvalue->u.polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);
         stat = asn1D_Ns3_Polygon (pctxt, 
            (Ns3_Polygon*)pvalue->u.polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 18;
         break;

      case (TM_CTXT|TM_CONS|18):
         pvalue->u.regular_polygon
             = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

         if (pvalue->u.regular_polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->u.regular_polygon);
         stat = asn1D_Ns3_Regular_polygon (pctxt, 
            (Ns3_Regular_polygon*)pvalue->u.regular_polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 19;
         break;

      case (TM_CTXT|TM_CONS|19):
         pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

         if (pvalue->u.path == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);
         stat = asn1D_Ns3_Path (pctxt, 
            (Ns3_Path*)pvalue->u.path, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 20;
         break;

      case (TM_CTXT|TM_CONS|20):
         pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

         if (pvalue->u.circle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);
         stat = asn1D_Ns3_Circle (pctxt, 
            (Ns3_Circle*)pvalue->u.circle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 21;
         break;

      case (TM_CTXT|TM_CONS|21):
         pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

         if (pvalue->u.ellipse == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);
         stat = asn1D_Ns3_Ellipse (pctxt, 
            (Ns3_Ellipse*)pvalue->u.ellipse, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 22;
         break;

      case (TM_CTXT|TM_CONS|22):
         pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

         if (pvalue->u.g == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);
         stat = asn1D_Ns3_G (pctxt, 
            (Ns3_G*)pvalue->u.g, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 23;
         break;

      case (TM_CTXT|TM_CONS|23):
         pvalue->u.page_thumbnail
             = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

         if (pvalue->u.page_thumbnail == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->u.page_thumbnail);
         stat = asn1D_Ns3_Page_thumbnail (pctxt, 
            (Ns3_Page_thumbnail*)pvalue->u.page_thumbnail, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 24;
         break;

      case (TM_CTXT|TM_CONS|24):
         pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

         if (pvalue->u.frame == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);
         stat = asn1D_Ns3_Frame (pctxt, 
            (Ns3_Frame*)pvalue->u.frame, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 25;
         break;

      case (TM_CTXT|TM_CONS|25):
         pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

         if (pvalue->u.measure == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);
         stat = asn1D_Ns3_Measure (pctxt, 
            (Ns3_Measure*)pvalue->u.measure, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 26;
         break;

      case (TM_CTXT|TM_CONS|26):
         pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

         if (pvalue->u.caption == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);
         stat = asn1D_Ns3_Caption (pctxt, 
            (Ns3_Caption*)pvalue->u.caption, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 27;
         break;

      case (TM_CTXT|TM_CONS|27):
         pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

         if (pvalue->u.connector == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);
         stat = asn1D_Ns3_Connector (pctxt, 
            (Ns3_Connector*)pvalue->u.connector, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 28;
         break;

      case (TM_CTXT|TM_CONS|28):
         pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

         if (pvalue->u.control == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);
         stat = asn1D_Ns3_Control (pctxt, 
            (Ns3_Control*)pvalue->u.control, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 29;
         break;

      case (TM_CTXT|TM_CONS|29):
         pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

         if (pvalue->u.scene == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);
         stat = asn1D_Ns7_Scene (pctxt, 
            (Ns7_Scene*)pvalue->u.scene, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 30;
         break;

      case (TM_CTXT|TM_CONS|30):
         pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

         if (pvalue->u.custom_shape == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);
         stat = asn1D_Ns3_Custom_shape (pctxt, 
            (Ns3_Custom_shape*)pvalue->u.custom_shape, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 31;
         break;

      case (TM_CTXT|TM_CONS|31):
         pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

         if (pvalue->u.change == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change (pvalue->u.change);
         stat = asn1D_Odf_Change (pctxt, 
            pvalue->u.change, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 32;
         break;

      case (TM_CTXT|TM_CONS|32):
         pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

         if (pvalue->u.change_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_start (pvalue->u.change_start);
         stat = asn1D_Odf_Change_start (pctxt, 
            pvalue->u.change_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 33;
         break;

      case (TM_CTXT|TM_CONS|33):
         pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

         if (pvalue->u.change_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_end (pvalue->u.change_end);
         stat = asn1D_Odf_Change_end (pctxt, 
            pvalue->u.change_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 34;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Section_element (OSCTXT* pctxt, Odf_Section_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("h"), 1}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 1 },
      {{{OSUTF8("list"), 4}, 0}, 2 },
      {{{OSUTF8("numbered-paragraph"), 18}, 0}, 3 },
      {{{OSUTF8("table"), 5}, 0}, 4 },
      {{{OSUTF8("a"), 1}, 0}, 5 },
      {{{OSUTF8("section"), 7}, 0}, 6 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 7 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 8 },
      {{{OSUTF8("table-index"), 11}, 0}, 9 },
      {{{OSUTF8("object-index"), 12}, 0}, 10 },
      {{{OSUTF8("user-index"), 10}, 0}, 11 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 12 },
      {{{OSUTF8("bibliography"), 12}, 0}, 13 },
      {{{OSUTF8("rect"), 4}, 0}, 14 },
      {{{OSUTF8("line"), 4}, 0}, 15 },
      {{{OSUTF8("polyline"), 8}, 0}, 16 },
      {{{OSUTF8("polygon"), 7}, 0}, 17 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 18 },
      {{{OSUTF8("path"), 4}, 0}, 19 },
      {{{OSUTF8("circle"), 6}, 0}, 20 },
      {{{OSUTF8("ellipse"), 7}, 0}, 21 },
      {{{OSUTF8("g"), 1}, 0}, 22 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 23 },
      {{{OSUTF8("frame"), 5}, 0}, 24 },
      {{{OSUTF8("measure"), 7}, 0}, 25 },
      {{{OSUTF8("caption"), 7}, 0}, 26 },
      {{{OSUTF8("connector"), 9}, 0}, 27 },
      {{{OSUTF8("control"), 7}, 0}, 28 },
      {{{OSUTF8("scene"), 5}, 0}, 29 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 30 },
      {{{OSUTF8("change"), 6}, 0}, 31 },
      {{{OSUTF8("change-start"), 12}, 0}, 32 },
      {{{OSUTF8("change-end"), 10}, 0}, 33 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 34, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* h */
      pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

      if (pvalue->u.h == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_H (pvalue->u.h);

      stat = XmlDec_Odf_H (pctxt, pvalue->u.h);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P (pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List (pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* numbered-paragraph */
      pvalue->u.numbered_paragraph
          = rtxMemAllocType (pctxt, Odf_Numbered_paragraph);

      if (pvalue->u.numbered_paragraph == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Numbered_paragraph (pvalue->u.numbered_paragraph);

      stat = XmlDec_Odf_Numbered_paragraph (pctxt, pvalue->u.numbered_paragraph
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* table */
      pvalue->u.table = rtxMemAllocType (pctxt, Table);

      if (pvalue->u.table == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table ((Table*)pvalue->u.table);

      stat = XmlDec_Table (pctxt, pvalue->u.table);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* a */
      pvalue->u.a = rtxMemAllocType (pctxt, Ns3_A);

      if (pvalue->u.a == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_A ((Ns3_A*)pvalue->u.a);

      stat = XmlDec_Ns3_A (pctxt, pvalue->u.a);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* section */
      pvalue->u.section = rtxMemAllocType (pctxt, Odf_Section);

      if (pvalue->u.section == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Section ((Odf_Section*)pvalue->u.section);

      stat = XmlDec_Odf_Section (pctxt, pvalue->u.section);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* table-of-content */
      pvalue->u.table_of_content
          = rtxMemAllocType (pctxt, Odf_Table_of_content);

      if (pvalue->u.table_of_content == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_of_content (pvalue->u.table_of_content);

      stat = XmlDec_Odf_Table_of_content (pctxt, pvalue->u.table_of_content);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* illustration-index */
      pvalue->u.illustration_index
          = rtxMemAllocType (pctxt, Odf_Illustration_index);

      if (pvalue->u.illustration_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Illustration_index (pvalue->u.illustration_index);

      stat = XmlDec_Odf_Illustration_index (pctxt, pvalue->u.illustration_index
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* table-index */
      pvalue->u.table_index = rtxMemAllocType (pctxt, Odf_Table_index);

      if (pvalue->u.table_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_index (pvalue->u.table_index);

      stat = XmlDec_Odf_Table_index (pctxt, pvalue->u.table_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* object-index */
      pvalue->u.object_index = rtxMemAllocType (pctxt, Odf_Object_index);

      if (pvalue->u.object_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Object_index (pvalue->u.object_index);

      stat = XmlDec_Odf_Object_index (pctxt, pvalue->u.object_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* user-index */
      pvalue->u.user_index = rtxMemAllocType (pctxt, Odf_User_index);

      if (pvalue->u.user_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index (pvalue->u.user_index);

      stat = XmlDec_Odf_User_index (pctxt, pvalue->u.user_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* alphabetical-index */
      pvalue->u.alphabetical_index
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index);

      if (pvalue->u.alphabetical_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index (pvalue->u.alphabetical_index);

      stat = XmlDec_Odf_Alphabetical_index (pctxt, pvalue->u.alphabetical_index
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* bibliography */
      pvalue->u.bibliography = rtxMemAllocType (pctxt, Odf_Bibliography);

      if (pvalue->u.bibliography == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bibliography (pvalue->u.bibliography);

      stat = XmlDec_Odf_Bibliography (pctxt, pvalue->u.bibliography);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* rect */
      pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

      if (pvalue->u.rect == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);

      stat = XmlDec_Ns3_Rect (pctxt, pvalue->u.rect);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* line */
      pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

      if (pvalue->u.line == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);

      stat = XmlDec_Ns3_Line (pctxt, pvalue->u.line);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* polyline */
      pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

      if (pvalue->u.polyline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);

      stat = XmlDec_Ns3_Polyline (pctxt, pvalue->u.polyline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 17: { /* polygon */
      pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

      if (pvalue->u.polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);

      stat = XmlDec_Ns3_Polygon (pctxt, pvalue->u.polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 18: { /* regular-polygon */
      pvalue->u.regular_polygon
          = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

      if (pvalue->u.regular_polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->
         u.regular_polygon);

      stat = XmlDec_Ns3_Regular_polygon (pctxt, pvalue->u.regular_polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 19: { /* path */
      pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

      if (pvalue->u.path == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);

      stat = XmlDec_Ns3_Path (pctxt, pvalue->u.path);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 20: { /* circle */
      pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

      if (pvalue->u.circle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);

      stat = XmlDec_Ns3_Circle (pctxt, pvalue->u.circle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 21: { /* ellipse */
      pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

      if (pvalue->u.ellipse == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);

      stat = XmlDec_Ns3_Ellipse (pctxt, pvalue->u.ellipse);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 22: { /* g */
      pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

      if (pvalue->u.g == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);

      stat = XmlDec_Ns3_G (pctxt, pvalue->u.g);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 23: { /* page-thumbnail */
      pvalue->u.page_thumbnail = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

      if (pvalue->u.page_thumbnail == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->
         u.page_thumbnail);

      stat = XmlDec_Ns3_Page_thumbnail (pctxt, pvalue->u.page_thumbnail);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 24: { /* frame */
      pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

      if (pvalue->u.frame == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);

      stat = XmlDec_Ns3_Frame (pctxt, pvalue->u.frame);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 25: { /* measure */
      pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

      if (pvalue->u.measure == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);

      stat = XmlDec_Ns3_Measure (pctxt, pvalue->u.measure);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 26: { /* caption */
      pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

      if (pvalue->u.caption == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);

      stat = XmlDec_Ns3_Caption (pctxt, pvalue->u.caption);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 27: { /* connector */
      pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

      if (pvalue->u.connector == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);

      stat = XmlDec_Ns3_Connector (pctxt, pvalue->u.connector);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 28: { /* control */
      pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

      if (pvalue->u.control == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);

      stat = XmlDec_Ns3_Control (pctxt, pvalue->u.control);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 29: { /* scene */
      pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

      if (pvalue->u.scene == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);

      stat = XmlDec_Ns7_Scene (pctxt, pvalue->u.scene);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 30: { /* custom-shape */
      pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

      if (pvalue->u.custom_shape == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);

      stat = XmlDec_Ns3_Custom_shape (pctxt, pvalue->u.custom_shape);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 31: { /* change */
      pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

      if (pvalue->u.change == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change (pvalue->u.change);

      stat = XmlDec_Odf_Change (pctxt, pvalue->u.change);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 32: { /* change-start */
      pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

      if (pvalue->u.change_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_start (pvalue->u.change_start);

      stat = XmlDec_Odf_Change_start (pctxt, pvalue->u.change_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 33: { /* change-end */
      pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

      if (pvalue->u.change_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_end (pvalue->u.change_end);

      stat = XmlDec_Odf_Change_end (pctxt, pvalue->u.change_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Section                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Section (OSCTXT* pctxt, Odf_Section *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode condition */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->condition, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.conditionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode display */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Section_display (pctxt, 
               &pvalue->display, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.displayPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode protected_ */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Section_protected_ (pctxt, 
               &pvalue->protected_, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.protected_Present = TRUE;
            }
         }
         break;

      case 4:
         /* decode protection_key */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->protection_key, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.protection_keyPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Section_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Section_choice (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choicePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode choice_1_list */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Section_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_1_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Section_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_Section_element (pdata2);

                  stat = asn1D_Odf_Section_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_1_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Section (OSCTXT* pctxt, Odf_Section* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("condition"), 9}, 0 },
         { {OSUTF8("display"), 7}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("protected"), 9}, 0 },
         { {OSUTF8("protection-key"), 14}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 6, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* condition */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->condition);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.conditionPresent = TRUE;
            break;

         case 1: /* display */
            stat = XmlDec_Odf_Section_display (pctxt, &pvalue->display);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.displayPresent = TRUE;
            break;

         case 2: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* protected */
            stat = XmlDec_Odf_Section_protected_ (pctxt, &pvalue->protected_);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.protected_Present = TRUE;
            break;

         case 4: /* protection-key */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->protection_key);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.protection_keyPresent = TRUE;
            break;

         case 5: /* style-name */
            stat = XmlDec_Odf_Section_style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Section");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Section");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("section-source"), 14}, 0}, 0 },
      {{{OSUTF8("dde-source"), 10}, 0}, 0 },
      {{{OSUTF8("h"), 1}, 0}, 1 },
      {{{OSUTF8("p"), 1}, 0}, 1 },
      {{{OSUTF8("list"), 4}, 0}, 1 },
      {{{OSUTF8("numbered-paragraph"), 18}, 0}, 1 },
      {{{OSUTF8("table"), 5}, 0}, 1 },
      {{{OSUTF8("a"), 1}, 0}, 1 },
      {{{OSUTF8("section"), 7}, 0}, 1 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 1 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 1 },
      {{{OSUTF8("table-index"), 11}, 0}, 1 },
      {{{OSUTF8("object-index"), 12}, 0}, 1 },
      {{{OSUTF8("user-index"), 10}, 0}, 1 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 1 },
      {{{OSUTF8("bibliography"), 12}, 0}, 1 },
      {{{OSUTF8("rect"), 4}, 0}, 1 },
      {{{OSUTF8("line"), 4}, 0}, 1 },
      {{{OSUTF8("polyline"), 8}, 0}, 1 },
      {{{OSUTF8("polygon"), 7}, 0}, 1 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 1 },
      {{{OSUTF8("path"), 4}, 0}, 1 },
      {{{OSUTF8("circle"), 6}, 0}, 1 },
      {{{OSUTF8("ellipse"), 7}, 0}, 1 },
      {{{OSUTF8("g"), 1}, 0}, 1 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 1 },
      {{{OSUTF8("frame"), 5}, 0}, 1 },
      {{{OSUTF8("measure"), 7}, 0}, 1 },
      {{{OSUTF8("caption"), 7}, 0}, 1 },
      {{{OSUTF8("connector"), 9}, 0}, 1 },
      {{{OSUTF8("control"), 7}, 0}, 1 },
      {{{OSUTF8("scene"), 5}, 0}, 1 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 1 },
      {{{OSUTF8("change"), 6}, 0}, 1 },
      {{{OSUTF8("change-start"), 12}, 0}, 1 },
      {{{OSUTF8("change-end"), 10}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 36, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /*  */
         stat = XmlDec_Odf_Section_choice (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choicePresent = TRUE;
         break;
      }
      case 1: {
         Odf_Section_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_Section_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Section_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Odf_Section_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_1_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 2, 34, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Variable_decl                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Variable_decl (OSCTXT* pctxt, Odf_Variable_decl *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode value_type */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Variable_decl_value_type (pctxt, 
               &pvalue->value_type, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Variable_decl (OSCTXT* pctxt, Odf_Variable_decl* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("value-type"), 10}, 0 },
         { {OSUTF8("name"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* value-type */
            stat = XmlDec_Odf_Variable_decl_value_type (pctxt, &pvalue->
               value_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Variable_decl");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Variable_decl");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Variable_decls                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Variable_decls (OSCTXT* pctxt, 
   Odf_Variable_decls *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode variable_decl_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Variable_decl* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->variable_decl_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Variable_decl, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_Variable_decl (pdata2);

                  stat = asn1D_Odf_Variable_decl (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->variable_decl_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Variable_decls (OSCTXT* pctxt, Odf_Variable_decls* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("variable-decl"), 13}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_Variable_decl* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_Variable_decl);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Variable_decl (pdata1);

            stat = XmlDec_Odf_Variable_decl (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->variable_decl_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sequence_decl                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sequence_decl (OSCTXT* pctxt, Odf_Sequence_decl *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode display_outline_level */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->display_outline_level, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode separation_character */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->separation_character, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.separation_characterPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Sequence_decl (OSCTXT* pctxt, Odf_Sequence_decl* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("display-outline-level"), 21}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("separation-character"), 20}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* display-outline-level */
            stat = rtXmlpDecUInt (pctxt, &pvalue->display_outline_level);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* separation-character */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->separation_character);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.separation_characterPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Sequence_decl");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Sequence_decl");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sequence_decls                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sequence_decls (OSCTXT* pctxt, 
   Odf_Sequence_decls *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode sequence_decl_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Sequence_decl* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->sequence_decl_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Sequence_decl, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_Sequence_decl (pdata2);

                  stat = asn1D_Odf_Sequence_decl (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->sequence_decl_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Sequence_decls (OSCTXT* pctxt, Odf_Sequence_decls* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("sequence-decl"), 13}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_Sequence_decl* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_Sequence_decl);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Sequence_decl (pdata1);

            stat = XmlDec_Odf_Sequence_decl (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->sequence_decl_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  User_field_decl                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_User_field_decl (OSCTXT* pctxt, 
   Odf_User_field_decl *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode boolean_value */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Boolean_value (pctxt, 
               (Ns13_Boolean_value*)&pvalue->boolean_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.boolean_valuePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode currency */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Currency (pctxt, 
               (Ns13_Currency*)&pvalue->currency, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.currencyPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode date_value */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->date_value = rtxMemAllocType (pctxt, Ns13_Date_value);

            if (pvalue->date_value == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);
            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);

            stat = asn1D_Ns13_Date_value (pctxt, 
               (Ns13_Date_value*)pvalue->date_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.date_valuePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode string_value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_String_value (pctxt, 
               (Ns13_String_value*)&pvalue->string_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.string_valuePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode time_value */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Time_value (pctxt, 
               (Ns13_Time_value*)&pvalue->time_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.time_valuePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Value (pctxt, 
               (Ns13_Value*)&pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode value_type */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_User_field_decl_value_type (pctxt, 
               &pvalue->value_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.value_typePresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode formula */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->formula, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.formulaPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_User_field_decl (OSCTXT* pctxt, Odf_User_field_decl* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("boolean-value"), 13}, 0 },
         { {OSUTF8("currency"), 8}, 0 },
         { {OSUTF8("date-value"), 10}, 0 },
         { {OSUTF8("string-value"), 12}, 0 },
         { {OSUTF8("time-value"), 10}, 0 },
         { {OSUTF8("value"), 5}, 0 },
         { {OSUTF8("value-type"), 10}, 0 },
         { {OSUTF8("formula"), 7}, 0 },
         { {OSUTF8("name"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 9, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* boolean-value */
            stat = XmlDec_Ns13_Boolean_value (pctxt, &pvalue->boolean_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.boolean_valuePresent = TRUE;
            break;

         case 1: /* currency */
            stat = XmlDec_Ns13_Currency (pctxt, &pvalue->currency);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.currencyPresent = TRUE;
            break;

         case 2: /* date-value */
            pvalue->date_value = rtxMemAllocType (pctxt, Ns13_Date_value);

            if (pvalue->date_value == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);

            stat = XmlDec_Ns13_Date_value (pctxt, pvalue->date_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.date_valuePresent = TRUE;
            break;

         case 3: /* string-value */
            stat = XmlDec_Ns13_String_value (pctxt, &pvalue->string_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.string_valuePresent = TRUE;
            break;

         case 4: /* time-value */
            stat = XmlDec_Ns13_Time_value (pctxt, &pvalue->time_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.time_valuePresent = TRUE;
            break;

         case 5: /* value */
            stat = XmlDec_Ns13_Value (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         case 6: /* value-type */
            stat = XmlDec_Odf_User_field_decl_value_type (pctxt, &pvalue->
               value_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.value_typePresent = TRUE;
            break;

         case 7: /* formula */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->formula);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.formulaPresent = TRUE;
            break;

         case 8: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_User_field_decl");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_User_field_decl");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  User_field_decls                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_User_field_decls (OSCTXT* pctxt, 
   Odf_User_field_decls *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode user_field_decl_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_User_field_decl* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->user_field_decl_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_User_field_decl, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_User_field_decl (pdata2);

                  stat = asn1D_Odf_User_field_decl (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->user_field_decl_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_User_field_decls (OSCTXT* pctxt, Odf_User_field_decls* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("user-field-decl"), 15}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_User_field_decl* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_User_field_decl);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_User_field_decl (pdata1);

            stat = XmlDec_Odf_User_field_decl (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->user_field_decl_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Dde_connection_decl                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Dde_connection_decl (OSCTXT* pctxt, 
   Odf_Dde_connection_decl *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode automatic_update */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Automatic_update (pctxt, 
               (Ns13_Automatic_update*)&pvalue->automatic_update, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.automatic_updatePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode dde_application */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Dde_application (pctxt, 
               (Ns13_Dde_application*)&pvalue->dde_application, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode dde_item */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Dde_item (pctxt, 
               (Ns13_Dde_item*)&pvalue->dde_item, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode dde_topic */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Dde_topic (pctxt, 
               (Ns13_Dde_topic*)&pvalue->dde_topic, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Name (pctxt, 
               (Ns13_Name*)&pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 4) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Dde_connection_decl (OSCTXT* pctxt, 
   Odf_Dde_connection_decl* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("automatic-update"), 16}, 0 },
         { {OSUTF8("dde-application"), 15}, 0 },
         { {OSUTF8("dde-item"), 8}, 0 },
         { {OSUTF8("dde-topic"), 9}, 0 },
         { {OSUTF8("name"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* automatic-update */
            stat = XmlDec_Ns13_Automatic_update (pctxt, &pvalue->
               automatic_update);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.automatic_updatePresent = TRUE;
            break;

         case 1: /* dde-application */
            stat = XmlDec_Ns13_Dde_application (pctxt, &pvalue->dde_application
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* dde-item */
            stat = XmlDec_Ns13_Dde_item (pctxt, &pvalue->dde_item);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* dde-topic */
            stat = XmlDec_Ns13_Dde_topic (pctxt, &pvalue->dde_topic);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* name */
            stat = XmlDec_Ns13_Name (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Dde_connection_decl");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Dde_connection_decl");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Dde_connection_decls                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Dde_connection_decls (OSCTXT* pctxt, 
   Odf_Dde_connection_decls *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode dde_connection_decl_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Dde_connection_decl* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->dde_connection_decl_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Dde_connection_decl, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_Dde_connection_decl (pdata2);

                  stat = asn1D_Odf_Dde_connection_decl (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->dde_connection_decl_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Dde_connection_decls (OSCTXT* pctxt, 
   Odf_Dde_connection_decls* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("dde-connection-decl"), 19}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_Dde_connection_decl* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_Dde_connection_decl);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Dde_connection_decl (pdata1);

            stat = XmlDec_Odf_Dde_connection_decl (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->dde_connection_decl_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alphabetical_index_auto_mark_file                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Alphabetical_index_auto_mark_file (OSCTXT* pctxt, 
   Odf_Alphabetical_index_auto_mark_file *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode href */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Href (pctxt, 
               &pvalue->href, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Type (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.typePresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Alphabetical_index_auto_mark_file (OSCTXT* pctxt, 
   Odf_Alphabetical_index_auto_mark_file* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("href"), 4}, 0 },
         { {OSUTF8("type"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* href */
            stat = XmlDec_Xlink_Href (pctxt, &pvalue->href);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* type */
            stat = XmlDec_Xlink_Type (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.typePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Alphabetical_index_auto_mark_file");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Alphabetical_index_auto_mark_file");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Tracked_changes                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Tracked_changes (OSCTXT* pctxt, 
   Odf_Tracked_changes *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode track_changes */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Tracked_changes_track_changes (pctxt, 
               &pvalue->track_changes, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.track_changesPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode changed_region_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Changed_region* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->changed_region_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Changed_region, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_Changed_region (pdata2);

                  stat = asn1D_Odf_Changed_region (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->changed_region_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Tracked_changes (OSCTXT* pctxt, Odf_Tracked_changes* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("track-changes"), 13}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* track-changes */
            stat = XmlDec_Odf_Tracked_changes_track_changes (pctxt, &pvalue->
               track_changes);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.track_changesPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Tracked_changes");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Tracked_changes");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("changed-region"), 14}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_Changed_region* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_Changed_region);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Changed_region (pdata1);

            stat = XmlDec_Odf_Changed_region (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->changed_region_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Page_master_page_name                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Page_master_page_name (OSCTXT* pctxt, 
   Odf_Page_master_page_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Page_master_page_name (OSCTXT* pctxt, 
   Odf_Page_master_page_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Page                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Page (OSCTXT* pctxt, Odf_Page *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode master_page_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Page_master_page_name (pctxt, 
               &pvalue->master_page_name, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Page (OSCTXT* pctxt, Odf_Page* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("master-page-name"), 16}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* master-page-name */
            stat = XmlDec_Odf_Page_master_page_name (pctxt, &pvalue->
               master_page_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Page");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Page");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Page_sequence                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Page_sequence (OSCTXT* pctxt, Odf_Page_sequence *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode page_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Page* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->page_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Page, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_Page (pdata2);

                  stat = asn1D_Odf_Page (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->page_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Page_sequence (OSCTXT* pctxt, Odf_Page_sequence* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("page"), 4}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_Page* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_Page);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Page (pdata1);

            stat = XmlDec_Odf_Page (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->page_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Date_date_value                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Date_date_value (OSCTXT* pctxt, 
   Odf_Date_date_value *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_charstr (pctxt, &pvalue->u.alt, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|26), length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_charstr (pctxt, &pvalue->u.alt_1, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|26), length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Date_date_value (OSCTXT* pctxt, Odf_Date_date_value* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = (const char*)pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = (const char*)pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Date                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Date (OSCTXT* pctxt, Odf_Date *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode data_style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);
            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);

            stat = asn1D_Ns8_Data_style_name (pctxt, 
               (Ns8_Data_style_name*)pvalue->data_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode date_adjust */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->date_adjust, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.date_adjustPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode date_value */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Date_date_value (pctxt, 
               &pvalue->date_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.date_valuePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Date_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Date (OSCTXT* pctxt, Odf_Date* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("data-style-name"), 15}, 0 },
         { {OSUTF8("date-adjust"), 11}, 0 },
         { {OSUTF8("date-value"), 10}, 0 },
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* data-style-name */
            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->
               data_style_name);

            stat = XmlDec_Ns8_Data_style_name (pctxt, pvalue->data_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_style_namePresent = TRUE;
            break;

         case 1: /* date-adjust */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->date_adjust);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.date_adjustPresent = TRUE;
            break;

         case 2: /* date-value */
            stat = XmlDec_Odf_Date_date_value (pctxt, &pvalue->date_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.date_valuePresent = TRUE;
            break;

         case 3: /* fixed */
            stat = XmlDec_Odf_Date_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Date");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Date");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Time_time_value                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Time_time_value (OSCTXT* pctxt, 
   Odf_Time_time_value *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_charstr (pctxt, &pvalue->u.alt, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|26), length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_charstr (pctxt, &pvalue->u.alt_1, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|26), length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Time_time_value (OSCTXT* pctxt, Odf_Time_time_value* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = (const char*)pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = (const char*)pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Time                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Time (OSCTXT* pctxt, Odf_Time *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode data_style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);
            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);

            stat = asn1D_Ns8_Data_style_name (pctxt, 
               (Ns8_Data_style_name*)pvalue->data_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Time_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode time_adjust */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->time_adjust, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.time_adjustPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode time_value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Time_time_value (pctxt, 
               &pvalue->time_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.time_valuePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Time (OSCTXT* pctxt, Odf_Time* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("data-style-name"), 15}, 0 },
         { {OSUTF8("fixed"), 5}, 0 },
         { {OSUTF8("time-adjust"), 11}, 0 },
         { {OSUTF8("time-value"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* data-style-name */
            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->
               data_style_name);

            stat = XmlDec_Ns8_Data_style_name (pctxt, pvalue->data_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_style_namePresent = TRUE;
            break;

         case 1: /* fixed */
            stat = XmlDec_Odf_Time_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         case 2: /* time-adjust */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->time_adjust);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.time_adjustPresent = TRUE;
            break;

         case 3: /* time-value */
            stat = XmlDec_Odf_Time_time_value (pctxt, &pvalue->time_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.time_valuePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Time");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Time");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Page_number                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Page_number (OSCTXT* pctxt, Odf_Page_number *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode num_format */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->num_format = rtxMemAllocType (pctxt, Ns8_Num_format);

            if (pvalue->num_format == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);
            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);

            stat = asn1D_Ns8_Num_format (pctxt, 
               (Ns8_Num_format*)pvalue->num_format, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.num_formatPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode num_letter_sync */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Num_letter_sync (pctxt, 
               (Ns8_Num_letter_sync*)&pvalue->num_letter_sync, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.num_letter_syncPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Page_number_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode page_adjust */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->page_adjust, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.page_adjustPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode select_page */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Page_number_select_page (pctxt, 
               &pvalue->select_page, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.select_pagePresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Page_number (OSCTXT* pctxt, Odf_Page_number* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("num-format"), 10}, 0 },
         { {OSUTF8("num-letter-sync"), 15}, 0 },
         { {OSUTF8("fixed"), 5}, 0 },
         { {OSUTF8("page-adjust"), 11}, 0 },
         { {OSUTF8("select-page"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* num-format */
            pvalue->num_format = rtxMemAllocType (pctxt, Ns8_Num_format);

            if (pvalue->num_format == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);

            stat = XmlDec_Ns8_Num_format (pctxt, pvalue->num_format);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.num_formatPresent = TRUE;
            break;

         case 1: /* num-letter-sync */
            stat = XmlDec_Ns8_Num_letter_sync (pctxt, &pvalue->num_letter_sync
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.num_letter_syncPresent = TRUE;
            break;

         case 2: /* fixed */
            stat = XmlDec_Odf_Page_number_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         case 3: /* page-adjust */
            stat = rtXmlpDecInt (pctxt, &pvalue->page_adjust);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.page_adjustPresent = TRUE;
            break;

         case 4: /* select-page */
            stat = XmlDec_Odf_Page_number_select_page (pctxt, &pvalue->
               select_page);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.select_pagePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Page_number");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Page_number");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Page_continuation                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Page_continuation (OSCTXT* pctxt, 
   Odf_Page_continuation *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode select_page */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Page_continuation_select_page (pctxt, 
               &pvalue->select_page, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode string_value */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->string_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.string_valuePresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Page_continuation (OSCTXT* pctxt, Odf_Page_continuation* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("select-page"), 11}, 0 },
         { {OSUTF8("string-value"), 12}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* select-page */
            stat = XmlDec_Odf_Page_continuation_select_page (pctxt, &pvalue->
               select_page);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* string-value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->string_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.string_valuePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Page_continuation");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Page_continuation");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_firstname                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_firstname (OSCTXT* pctxt, 
   Odf_Sender_firstname *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Sender_firstname_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Sender_firstname (OSCTXT* pctxt, Odf_Sender_firstname* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* fixed */
            stat = XmlDec_Odf_Sender_firstname_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Sender_firstname");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Sender_firstname");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_lastname                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_lastname (OSCTXT* pctxt, 
   Odf_Sender_lastname *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Sender_lastname_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Sender_lastname (OSCTXT* pctxt, Odf_Sender_lastname* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* fixed */
            stat = XmlDec_Odf_Sender_lastname_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Sender_lastname");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Sender_lastname");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_initials                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_initials (OSCTXT* pctxt, 
   Odf_Sender_initials *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Sender_initials_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Sender_initials (OSCTXT* pctxt, Odf_Sender_initials* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* fixed */
            stat = XmlDec_Odf_Sender_initials_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Sender_initials");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Sender_initials");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_title                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_title (OSCTXT* pctxt, Odf_Sender_title *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Sender_title_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Sender_title (OSCTXT* pctxt, Odf_Sender_title* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* fixed */
            stat = XmlDec_Odf_Sender_title_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Sender_title");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Sender_title");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_position                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_position (OSCTXT* pctxt, 
   Odf_Sender_position *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Sender_position_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Sender_position (OSCTXT* pctxt, Odf_Sender_position* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* fixed */
            stat = XmlDec_Odf_Sender_position_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Sender_position");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Sender_position");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_email                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_email (OSCTXT* pctxt, Odf_Sender_email *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Sender_email_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Sender_email (OSCTXT* pctxt, Odf_Sender_email* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* fixed */
            stat = XmlDec_Odf_Sender_email_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Sender_email");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Sender_email");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_phone_private                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_phone_private (OSCTXT* pctxt, 
   Odf_Sender_phone_private *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Sender_phone_private_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Sender_phone_private (OSCTXT* pctxt, 
   Odf_Sender_phone_private* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* fixed */
            stat = XmlDec_Odf_Sender_phone_private_fixed (pctxt, &pvalue->fixed
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Sender_phone_private");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Sender_phone_private");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_fax                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_fax (OSCTXT* pctxt, Odf_Sender_fax *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Sender_fax_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Sender_fax (OSCTXT* pctxt, Odf_Sender_fax* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* fixed */
            stat = XmlDec_Odf_Sender_fax_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Sender_fax");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Sender_fax");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_company                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_company (OSCTXT* pctxt, 
   Odf_Sender_company *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Sender_company_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Sender_company (OSCTXT* pctxt, Odf_Sender_company* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* fixed */
            stat = XmlDec_Odf_Sender_company_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Sender_company");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Sender_company");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_phone_work                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_phone_work (OSCTXT* pctxt, 
   Odf_Sender_phone_work *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Sender_phone_work_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Sender_phone_work (OSCTXT* pctxt, Odf_Sender_phone_work* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* fixed */
            stat = XmlDec_Odf_Sender_phone_work_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Sender_phone_work");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Sender_phone_work");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_street                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_street (OSCTXT* pctxt, Odf_Sender_street *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Sender_street_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Sender_street (OSCTXT* pctxt, Odf_Sender_street* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* fixed */
            stat = XmlDec_Odf_Sender_street_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Sender_street");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Sender_street");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_city                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_city (OSCTXT* pctxt, Odf_Sender_city *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Sender_city_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Sender_city (OSCTXT* pctxt, Odf_Sender_city* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* fixed */
            stat = XmlDec_Odf_Sender_city_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Sender_city");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Sender_city");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_postal_code                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_postal_code (OSCTXT* pctxt, 
   Odf_Sender_postal_code *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Sender_postal_code_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Sender_postal_code (OSCTXT* pctxt, 
   Odf_Sender_postal_code* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* fixed */
            stat = XmlDec_Odf_Sender_postal_code_fixed (pctxt, &pvalue->fixed
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Sender_postal_code");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Sender_postal_code");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_country                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_country (OSCTXT* pctxt, 
   Odf_Sender_country *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Sender_country_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Sender_country (OSCTXT* pctxt, Odf_Sender_country* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* fixed */
            stat = XmlDec_Odf_Sender_country_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Sender_country");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Sender_country");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sender_state_or_province                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sender_state_or_province (OSCTXT* pctxt, 
   Odf_Sender_state_or_province *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Sender_state_or_province_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Sender_state_or_province (OSCTXT* pctxt, 
   Odf_Sender_state_or_province* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* fixed */
            stat = XmlDec_Odf_Sender_state_or_province_fixed (pctxt, &pvalue->
               fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Sender_state_or_province");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Sender_state_or_province");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Author_name                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Author_name (OSCTXT* pctxt, Odf_Author_name *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Author_name_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Author_name (OSCTXT* pctxt, Odf_Author_name* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* fixed */
            stat = XmlDec_Odf_Author_name_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Author_name");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Author_name");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Author_initials                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Author_initials (OSCTXT* pctxt, 
   Odf_Author_initials *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Author_initials_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Author_initials (OSCTXT* pctxt, Odf_Author_initials* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* fixed */
            stat = XmlDec_Odf_Author_initials_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Author_initials");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Author_initials");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Chapter                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Chapter (OSCTXT* pctxt, Odf_Chapter *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode display */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Chapter_display (pctxt, 
               &pvalue->display, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode outline_level */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->outline_level, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Chapter (OSCTXT* pctxt, Odf_Chapter* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("display"), 7}, 0 },
         { {OSUTF8("outline-level"), 13}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* display */
            stat = XmlDec_Odf_Chapter_display (pctxt, &pvalue->display);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* outline-level */
            stat = rtXmlpDecUInt (pctxt, &pvalue->outline_level);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Chapter");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Chapter");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  File_name                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_File_name (OSCTXT* pctxt, Odf_File_name *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode display */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_File_name_display (pctxt, 
               &pvalue->display, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.displayPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_File_name_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_File_name (OSCTXT* pctxt, Odf_File_name* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("display"), 7}, 0 },
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* display */
            stat = XmlDec_Odf_File_name_display (pctxt, &pvalue->display);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.displayPresent = TRUE;
            break;

         case 1: /* fixed */
            stat = XmlDec_Odf_File_name_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_File_name");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_File_name");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Template_name                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Template_name (OSCTXT* pctxt, Odf_Template_name *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode display */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Template_name_display (pctxt, 
               &pvalue->display, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.displayPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Template_name (OSCTXT* pctxt, Odf_Template_name* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("display"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* display */
            stat = XmlDec_Odf_Template_name_display (pctxt, &pvalue->display);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.displayPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Template_name");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Template_name");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Variable_set                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Variable_set (OSCTXT* pctxt, Odf_Variable_set *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode boolean_value */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Boolean_value (pctxt, 
               (Ns13_Boolean_value*)&pvalue->boolean_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.boolean_valuePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode currency */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Currency (pctxt, 
               (Ns13_Currency*)&pvalue->currency, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.currencyPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode date_value */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->date_value = rtxMemAllocType (pctxt, Ns13_Date_value);

            if (pvalue->date_value == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);
            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);

            stat = asn1D_Ns13_Date_value (pctxt, 
               (Ns13_Date_value*)pvalue->date_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.date_valuePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode string_value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_String_value (pctxt, 
               (Ns13_String_value*)&pvalue->string_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.string_valuePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode time_value */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Time_value (pctxt, 
               (Ns13_Time_value*)&pvalue->time_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.time_valuePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Value (pctxt, 
               (Ns13_Value*)&pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode value_type */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Variable_set_value_type (pctxt, 
               &pvalue->value_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.value_typePresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode data_style_name */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);
            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);

            stat = asn1D_Ns8_Data_style_name (pctxt, 
               (Ns8_Data_style_name*)pvalue->data_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode display */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Variable_set_display (pctxt, 
               &pvalue->display, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.displayPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode formula */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->formula, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.formulaPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|10):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Variable_set (OSCTXT* pctxt, Odf_Variable_set* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("boolean-value"), 13}, 0 },
         { {OSUTF8("currency"), 8}, 0 },
         { {OSUTF8("date-value"), 10}, 0 },
         { {OSUTF8("string-value"), 12}, 0 },
         { {OSUTF8("time-value"), 10}, 0 },
         { {OSUTF8("value"), 5}, 0 },
         { {OSUTF8("value-type"), 10}, 0 },
         { {OSUTF8("data-style-name"), 15}, 0 },
         { {OSUTF8("display"), 7}, 0 },
         { {OSUTF8("formula"), 7}, 0 },
         { {OSUTF8("name"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 11, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* boolean-value */
            stat = XmlDec_Ns13_Boolean_value (pctxt, &pvalue->boolean_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.boolean_valuePresent = TRUE;
            break;

         case 1: /* currency */
            stat = XmlDec_Ns13_Currency (pctxt, &pvalue->currency);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.currencyPresent = TRUE;
            break;

         case 2: /* date-value */
            pvalue->date_value = rtxMemAllocType (pctxt, Ns13_Date_value);

            if (pvalue->date_value == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);

            stat = XmlDec_Ns13_Date_value (pctxt, pvalue->date_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.date_valuePresent = TRUE;
            break;

         case 3: /* string-value */
            stat = XmlDec_Ns13_String_value (pctxt, &pvalue->string_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.string_valuePresent = TRUE;
            break;

         case 4: /* time-value */
            stat = XmlDec_Ns13_Time_value (pctxt, &pvalue->time_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.time_valuePresent = TRUE;
            break;

         case 5: /* value */
            stat = XmlDec_Ns13_Value (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         case 6: /* value-type */
            stat = XmlDec_Odf_Variable_set_value_type (pctxt, &pvalue->
               value_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.value_typePresent = TRUE;
            break;

         case 7: /* data-style-name */
            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->
               data_style_name);

            stat = XmlDec_Ns8_Data_style_name (pctxt, pvalue->data_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_style_namePresent = TRUE;
            break;

         case 8: /* display */
            stat = XmlDec_Odf_Variable_set_display (pctxt, &pvalue->display);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.displayPresent = TRUE;
            break;

         case 9: /* formula */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->formula);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.formulaPresent = TRUE;
            break;

         case 10: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Variable_set");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Variable_set");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Variable_get                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Variable_get (OSCTXT* pctxt, Odf_Variable_get *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode data_style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);
            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);

            stat = asn1D_Ns8_Data_style_name (pctxt, 
               (Ns8_Data_style_name*)pvalue->data_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode display */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Variable_get_display (pctxt, 
               &pvalue->display, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.displayPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Variable_get (OSCTXT* pctxt, Odf_Variable_get* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("data-style-name"), 15}, 0 },
         { {OSUTF8("display"), 7}, 0 },
         { {OSUTF8("name"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* data-style-name */
            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->
               data_style_name);

            stat = XmlDec_Ns8_Data_style_name (pctxt, pvalue->data_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_style_namePresent = TRUE;
            break;

         case 1: /* display */
            stat = XmlDec_Odf_Variable_get_display (pctxt, &pvalue->display);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.displayPresent = TRUE;
            break;

         case 2: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Variable_get");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Variable_get");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Variable_input                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Variable_input (OSCTXT* pctxt, 
   Odf_Variable_input *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode value_type */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Variable_input_value_type (pctxt, 
               &pvalue->value_type, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode data_style_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);
            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);

            stat = asn1D_Ns8_Data_style_name (pctxt, 
               (Ns8_Data_style_name*)pvalue->data_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode display */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Variable_input_display (pctxt, 
               &pvalue->display, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.displayPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Variable_input (OSCTXT* pctxt, Odf_Variable_input* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("value-type"), 10}, 0 },
         { {OSUTF8("data-style-name"), 15}, 0 },
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("display"), 7}, 0 },
         { {OSUTF8("name"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* value-type */
            stat = XmlDec_Odf_Variable_input_value_type (pctxt, &pvalue->
               value_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* data-style-name */
            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->
               data_style_name);

            stat = XmlDec_Ns8_Data_style_name (pctxt, pvalue->data_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_style_namePresent = TRUE;
            break;

         case 2: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 3: /* display */
            stat = XmlDec_Odf_Variable_input_display (pctxt, &pvalue->display
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.displayPresent = TRUE;
            break;

         case 4: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Variable_input");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Variable_input");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  User_field_get                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_User_field_get (OSCTXT* pctxt, 
   Odf_User_field_get *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode data_style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);
            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);

            stat = asn1D_Ns8_Data_style_name (pctxt, 
               (Ns8_Data_style_name*)pvalue->data_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode display */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_User_field_get_display (pctxt, 
               &pvalue->display, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.displayPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_User_field_get (OSCTXT* pctxt, Odf_User_field_get* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("data-style-name"), 15}, 0 },
         { {OSUTF8("display"), 7}, 0 },
         { {OSUTF8("name"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* data-style-name */
            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->
               data_style_name);

            stat = XmlDec_Ns8_Data_style_name (pctxt, pvalue->data_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_style_namePresent = TRUE;
            break;

         case 1: /* display */
            stat = XmlDec_Odf_User_field_get_display (pctxt, &pvalue->display
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.displayPresent = TRUE;
            break;

         case 2: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_User_field_get");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_User_field_get");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  User_field_input                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_User_field_input (OSCTXT* pctxt, 
   Odf_User_field_input *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode data_style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);
            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);

            stat = asn1D_Ns8_Data_style_name (pctxt, 
               (Ns8_Data_style_name*)pvalue->data_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_User_field_input (OSCTXT* pctxt, Odf_User_field_input* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("data-style-name"), 15}, 0 },
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("name"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* data-style-name */
            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->
               data_style_name);

            stat = XmlDec_Ns8_Data_style_name (pctxt, pvalue->data_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_style_namePresent = TRUE;
            break;

         case 1: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 2: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_User_field_input");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_User_field_input");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sequence                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sequence (OSCTXT* pctxt, Odf_Sequence *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode num_format */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->num_format = rtxMemAllocType (pctxt, Ns8_Num_format);

            if (pvalue->num_format == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);
            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);

            stat = asn1D_Ns8_Num_format (pctxt, 
               (Ns8_Num_format*)pvalue->num_format, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.num_formatPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode num_letter_sync */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Num_letter_sync (pctxt, 
               (Ns8_Num_letter_sync*)&pvalue->num_letter_sync, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.num_letter_syncPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode formula */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->formula, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.formulaPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode ref_name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->ref_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.ref_namePresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Sequence (OSCTXT* pctxt, Odf_Sequence* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("num-format"), 10}, 0 },
         { {OSUTF8("num-letter-sync"), 15}, 0 },
         { {OSUTF8("formula"), 7}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("ref-name"), 8}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* num-format */
            pvalue->num_format = rtxMemAllocType (pctxt, Ns8_Num_format);

            if (pvalue->num_format == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);

            stat = XmlDec_Ns8_Num_format (pctxt, pvalue->num_format);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.num_formatPresent = TRUE;
            break;

         case 1: /* num-letter-sync */
            stat = XmlDec_Ns8_Num_letter_sync (pctxt, &pvalue->num_letter_sync
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.num_letter_syncPresent = TRUE;
            break;

         case 2: /* formula */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->formula);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.formulaPresent = TRUE;
            break;

         case 3: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* ref-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->ref_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.ref_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Sequence");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Sequence");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Expression                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Expression (OSCTXT* pctxt, Odf_Expression *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode boolean_value */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Boolean_value (pctxt, 
               (Ns13_Boolean_value*)&pvalue->boolean_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.boolean_valuePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode currency */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Currency (pctxt, 
               (Ns13_Currency*)&pvalue->currency, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.currencyPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode date_value */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->date_value = rtxMemAllocType (pctxt, Ns13_Date_value);

            if (pvalue->date_value == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);
            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);

            stat = asn1D_Ns13_Date_value (pctxt, 
               (Ns13_Date_value*)pvalue->date_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.date_valuePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode string_value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_String_value (pctxt, 
               (Ns13_String_value*)&pvalue->string_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.string_valuePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode time_value */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Time_value (pctxt, 
               (Ns13_Time_value*)&pvalue->time_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.time_valuePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Value (pctxt, 
               (Ns13_Value*)&pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode value_type */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Expression_value_type (pctxt, 
               &pvalue->value_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.value_typePresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode data_style_name */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);
            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);

            stat = asn1D_Ns8_Data_style_name (pctxt, 
               (Ns8_Data_style_name*)pvalue->data_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode display */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Expression_display (pctxt, 
               &pvalue->display, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.displayPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode formula */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->formula, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.formulaPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Expression (OSCTXT* pctxt, Odf_Expression* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("boolean-value"), 13}, 0 },
         { {OSUTF8("currency"), 8}, 0 },
         { {OSUTF8("date-value"), 10}, 0 },
         { {OSUTF8("string-value"), 12}, 0 },
         { {OSUTF8("time-value"), 10}, 0 },
         { {OSUTF8("value"), 5}, 0 },
         { {OSUTF8("value-type"), 10}, 0 },
         { {OSUTF8("data-style-name"), 15}, 0 },
         { {OSUTF8("display"), 7}, 0 },
         { {OSUTF8("formula"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 10, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* boolean-value */
            stat = XmlDec_Ns13_Boolean_value (pctxt, &pvalue->boolean_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.boolean_valuePresent = TRUE;
            break;

         case 1: /* currency */
            stat = XmlDec_Ns13_Currency (pctxt, &pvalue->currency);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.currencyPresent = TRUE;
            break;

         case 2: /* date-value */
            pvalue->date_value = rtxMemAllocType (pctxt, Ns13_Date_value);

            if (pvalue->date_value == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);

            stat = XmlDec_Ns13_Date_value (pctxt, pvalue->date_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.date_valuePresent = TRUE;
            break;

         case 3: /* string-value */
            stat = XmlDec_Ns13_String_value (pctxt, &pvalue->string_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.string_valuePresent = TRUE;
            break;

         case 4: /* time-value */
            stat = XmlDec_Ns13_Time_value (pctxt, &pvalue->time_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.time_valuePresent = TRUE;
            break;

         case 5: /* value */
            stat = XmlDec_Ns13_Value (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         case 6: /* value-type */
            stat = XmlDec_Odf_Expression_value_type (pctxt, &pvalue->value_type
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.value_typePresent = TRUE;
            break;

         case 7: /* data-style-name */
            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->
               data_style_name);

            stat = XmlDec_Ns8_Data_style_name (pctxt, pvalue->data_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_style_namePresent = TRUE;
            break;

         case 8: /* display */
            stat = XmlDec_Odf_Expression_display (pctxt, &pvalue->display);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.displayPresent = TRUE;
            break;

         case 9: /* formula */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->formula);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.formulaPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Expression");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Expression");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Text_input                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Text_input (OSCTXT* pctxt, Odf_Text_input *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Text_input (OSCTXT* pctxt, Odf_Text_input* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Text_input");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Text_input");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Initial_creator                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Initial_creator (OSCTXT* pctxt, 
   Odf_Initial_creator *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Initial_creator_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Initial_creator (OSCTXT* pctxt, Odf_Initial_creator* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* fixed */
            stat = XmlDec_Odf_Initial_creator_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Initial_creator");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Initial_creator");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Creation_date_date_value                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Creation_date_date_value (OSCTXT* pctxt, 
   Odf_Creation_date_date_value *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_charstr (pctxt, &pvalue->u.alt, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|26), length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_charstr (pctxt, &pvalue->u.alt_1, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|26), length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Creation_date_date_value (OSCTXT* pctxt, 
   Odf_Creation_date_date_value* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = (const char*)pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = (const char*)pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Creation_date                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Creation_date (OSCTXT* pctxt, Odf_Creation_date *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode data_style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);
            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);

            stat = asn1D_Ns8_Data_style_name (pctxt, 
               (Ns8_Data_style_name*)pvalue->data_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode date_value */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Creation_date_date_value (pctxt, 
               &pvalue->date_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.date_valuePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Creation_date_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Creation_date (OSCTXT* pctxt, Odf_Creation_date* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("data-style-name"), 15}, 0 },
         { {OSUTF8("date-value"), 10}, 0 },
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* data-style-name */
            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->
               data_style_name);

            stat = XmlDec_Ns8_Data_style_name (pctxt, pvalue->data_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_style_namePresent = TRUE;
            break;

         case 1: /* date-value */
            stat = XmlDec_Odf_Creation_date_date_value (pctxt, &pvalue->
               date_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.date_valuePresent = TRUE;
            break;

         case 2: /* fixed */
            stat = XmlDec_Odf_Creation_date_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Creation_date");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Creation_date");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Creation_time_time_value                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Creation_time_time_value (OSCTXT* pctxt, 
   Odf_Creation_time_time_value *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_charstr (pctxt, &pvalue->u.alt, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|26), length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_charstr (pctxt, &pvalue->u.alt_1, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|26), length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Creation_time_time_value (OSCTXT* pctxt, 
   Odf_Creation_time_time_value* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = (const char*)pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = (const char*)pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Creation_time                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Creation_time (OSCTXT* pctxt, Odf_Creation_time *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode data_style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);
            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);

            stat = asn1D_Ns8_Data_style_name (pctxt, 
               (Ns8_Data_style_name*)pvalue->data_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Creation_time_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode time_value */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Creation_time_time_value (pctxt, 
               &pvalue->time_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.time_valuePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Creation_time (OSCTXT* pctxt, Odf_Creation_time* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("data-style-name"), 15}, 0 },
         { {OSUTF8("fixed"), 5}, 0 },
         { {OSUTF8("time-value"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* data-style-name */
            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->
               data_style_name);

            stat = XmlDec_Ns8_Data_style_name (pctxt, pvalue->data_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_style_namePresent = TRUE;
            break;

         case 1: /* fixed */
            stat = XmlDec_Odf_Creation_time_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         case 2: /* time-value */
            stat = XmlDec_Odf_Creation_time_time_value (pctxt, &pvalue->
               time_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.time_valuePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Creation_time");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Creation_time");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Description                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Description (OSCTXT* pctxt, Odf_Description *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Description_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Description (OSCTXT* pctxt, Odf_Description* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* fixed */
            stat = XmlDec_Odf_Description_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Description");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Description");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  User_defined                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_User_defined (OSCTXT* pctxt, Odf_User_defined *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode boolean_value */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Boolean_value (pctxt, 
               (Ns13_Boolean_value*)&pvalue->boolean_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.boolean_valuePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode date_value */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->date_value = rtxMemAllocType (pctxt, Ns13_Date_value);

            if (pvalue->date_value == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);
            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);

            stat = asn1D_Ns13_Date_value (pctxt, 
               (Ns13_Date_value*)pvalue->date_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.date_valuePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode string_value */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_String_value (pctxt, 
               (Ns13_String_value*)&pvalue->string_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.string_valuePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode time_value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Time_value (pctxt, 
               (Ns13_Time_value*)&pvalue->time_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.time_valuePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Value (pctxt, 
               (Ns13_Value*)&pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode data_style_name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);
            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);

            stat = asn1D_Ns8_Data_style_name (pctxt, 
               (Ns8_Data_style_name*)pvalue->data_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_User_defined_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_User_defined (OSCTXT* pctxt, Odf_User_defined* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("boolean-value"), 13}, 0 },
         { {OSUTF8("date-value"), 10}, 0 },
         { {OSUTF8("string-value"), 12}, 0 },
         { {OSUTF8("time-value"), 10}, 0 },
         { {OSUTF8("value"), 5}, 0 },
         { {OSUTF8("data-style-name"), 15}, 0 },
         { {OSUTF8("fixed"), 5}, 0 },
         { {OSUTF8("name"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 8, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* boolean-value */
            stat = XmlDec_Ns13_Boolean_value (pctxt, &pvalue->boolean_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.boolean_valuePresent = TRUE;
            break;

         case 1: /* date-value */
            pvalue->date_value = rtxMemAllocType (pctxt, Ns13_Date_value);

            if (pvalue->date_value == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);

            stat = XmlDec_Ns13_Date_value (pctxt, pvalue->date_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.date_valuePresent = TRUE;
            break;

         case 2: /* string-value */
            stat = XmlDec_Ns13_String_value (pctxt, &pvalue->string_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.string_valuePresent = TRUE;
            break;

         case 3: /* time-value */
            stat = XmlDec_Ns13_Time_value (pctxt, &pvalue->time_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.time_valuePresent = TRUE;
            break;

         case 4: /* value */
            stat = XmlDec_Ns13_Value (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         case 5: /* data-style-name */
            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->
               data_style_name);

            stat = XmlDec_Ns8_Data_style_name (pctxt, pvalue->data_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_style_namePresent = TRUE;
            break;

         case 6: /* fixed */
            stat = XmlDec_Odf_User_defined_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         case 7: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_User_defined");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_User_defined");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Print_time                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Print_time (OSCTXT* pctxt, Odf_Print_time *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode data_style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);
            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);

            stat = asn1D_Ns8_Data_style_name (pctxt, 
               (Ns8_Data_style_name*)pvalue->data_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Print_time_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode time_value */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->time_value, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
               pvalue->m.time_valuePresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Print_time (OSCTXT* pctxt, Odf_Print_time* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("data-style-name"), 15}, 0 },
         { {OSUTF8("fixed"), 5}, 0 },
         { {OSUTF8("time-value"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* data-style-name */
            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->
               data_style_name);

            stat = XmlDec_Ns8_Data_style_name (pctxt, pvalue->data_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_style_namePresent = TRUE;
            break;

         case 1: /* fixed */
            stat = XmlDec_Odf_Print_time_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         case 2: /* time-value */
            stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->
               time_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.time_valuePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Print_time");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Print_time");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Print_date                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Print_date (OSCTXT* pctxt, Odf_Print_date *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode data_style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);
            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);

            stat = asn1D_Ns8_Data_style_name (pctxt, 
               (Ns8_Data_style_name*)pvalue->data_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode date_value */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->date_value, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
               pvalue->m.date_valuePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Print_date_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Print_date (OSCTXT* pctxt, Odf_Print_date* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("data-style-name"), 15}, 0 },
         { {OSUTF8("date-value"), 10}, 0 },
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* data-style-name */
            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->
               data_style_name);

            stat = XmlDec_Ns8_Data_style_name (pctxt, pvalue->data_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_style_namePresent = TRUE;
            break;

         case 1: /* date-value */
            stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->
               date_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.date_valuePresent = TRUE;
            break;

         case 2: /* fixed */
            stat = XmlDec_Odf_Print_date_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Print_date");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Print_date");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Printed_by                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Printed_by (OSCTXT* pctxt, Odf_Printed_by *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Printed_by_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Printed_by (OSCTXT* pctxt, Odf_Printed_by* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* fixed */
            stat = XmlDec_Odf_Printed_by_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Printed_by");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Printed_by");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Title                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Title (OSCTXT* pctxt, Odf_Title *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Title_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Title (OSCTXT* pctxt, Odf_Title* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* fixed */
            stat = XmlDec_Odf_Title_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Title");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Title");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Subject                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Subject (OSCTXT* pctxt, Odf_Subject *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Subject_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Subject (OSCTXT* pctxt, Odf_Subject* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* fixed */
            stat = XmlDec_Odf_Subject_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Subject");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Subject");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Keywords                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Keywords (OSCTXT* pctxt, Odf_Keywords *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Keywords_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Keywords (OSCTXT* pctxt, Odf_Keywords* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* fixed */
            stat = XmlDec_Odf_Keywords_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Keywords");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Keywords");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Editing_cycles                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Editing_cycles (OSCTXT* pctxt, 
   Odf_Editing_cycles *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Editing_cycles_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Editing_cycles (OSCTXT* pctxt, Odf_Editing_cycles* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* fixed */
            stat = XmlDec_Odf_Editing_cycles_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Editing_cycles");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Editing_cycles");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Editing_duration                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Editing_duration (OSCTXT* pctxt, 
   Odf_Editing_duration *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode data_style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);
            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);

            stat = asn1D_Ns8_Data_style_name (pctxt, 
               (Ns8_Data_style_name*)pvalue->data_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode duration */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->duration, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.durationPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Editing_duration_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Editing_duration (OSCTXT* pctxt, Odf_Editing_duration* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("data-style-name"), 15}, 0 },
         { {OSUTF8("duration"), 8}, 0 },
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* data-style-name */
            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->
               data_style_name);

            stat = XmlDec_Ns8_Data_style_name (pctxt, pvalue->data_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_style_namePresent = TRUE;
            break;

         case 1: /* duration */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->duration);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.durationPresent = TRUE;
            break;

         case 2: /* fixed */
            stat = XmlDec_Odf_Editing_duration_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Editing_duration");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Editing_duration");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Modification_time                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Modification_time (OSCTXT* pctxt, 
   Odf_Modification_time *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode data_style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);
            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);

            stat = asn1D_Ns8_Data_style_name (pctxt, 
               (Ns8_Data_style_name*)pvalue->data_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Modification_time_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode time_value */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->time_value, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
               pvalue->m.time_valuePresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Modification_time (OSCTXT* pctxt, Odf_Modification_time* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("data-style-name"), 15}, 0 },
         { {OSUTF8("fixed"), 5}, 0 },
         { {OSUTF8("time-value"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* data-style-name */
            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->
               data_style_name);

            stat = XmlDec_Ns8_Data_style_name (pctxt, pvalue->data_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_style_namePresent = TRUE;
            break;

         case 1: /* fixed */
            stat = XmlDec_Odf_Modification_time_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         case 2: /* time-value */
            stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->
               time_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.time_valuePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Modification_time");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Modification_time");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Modification_date                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Modification_date (OSCTXT* pctxt, 
   Odf_Modification_date *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode data_style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);
            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);

            stat = asn1D_Ns8_Data_style_name (pctxt, 
               (Ns8_Data_style_name*)pvalue->data_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode date_value */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->date_value, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
               pvalue->m.date_valuePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Modification_date_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Modification_date (OSCTXT* pctxt, Odf_Modification_date* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("data-style-name"), 15}, 0 },
         { {OSUTF8("date-value"), 10}, 0 },
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* data-style-name */
            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->
               data_style_name);

            stat = XmlDec_Ns8_Data_style_name (pctxt, pvalue->data_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_style_namePresent = TRUE;
            break;

         case 1: /* date-value */
            stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->
               date_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.date_valuePresent = TRUE;
            break;

         case 2: /* fixed */
            stat = XmlDec_Odf_Modification_date_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Modification_date");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Modification_date");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Creator                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Creator (OSCTXT* pctxt, Odf_Creator *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode fixed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Creator_fixed (pctxt, 
               &pvalue->fixed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fixedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Creator (OSCTXT* pctxt, Odf_Creator* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("fixed"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* fixed */
            stat = XmlDec_Odf_Creator_fixed (pctxt, &pvalue->fixed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fixedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Creator");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Creator");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Element271_group                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Element271_group (OSCTXT* pctxt, 
   Odf_Element271_group *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         stat = asn1D_Odf_Page_count (pctxt, 
            &pvalue->u.page_count, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         stat = asn1D_Odf_Paragraph_count (pctxt, 
            &pvalue->u.paragraph_count, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         stat = asn1D_Odf_Word_count (pctxt, 
            &pvalue->u.word_count, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         stat = asn1D_Odf_Character_count (pctxt, 
            &pvalue->u.character_count, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         stat = asn1D_Odf_Table_count (pctxt, 
            &pvalue->u.table_count, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         stat = asn1D_Odf_Image_count (pctxt, 
            &pvalue->u.image_count, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         stat = asn1D_Odf_Object_count (pctxt, 
            &pvalue->u.object_count, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Element271_group (OSCTXT* pctxt, Odf_Element271_group* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("page-count"), 10}, 0}, 0 },
      {{{OSUTF8("paragraph-count"), 15}, 0}, 1 },
      {{{OSUTF8("word-count"), 10}, 0}, 2 },
      {{{OSUTF8("character-count"), 15}, 0}, 3 },
      {{{OSUTF8("table-count"), 11}, 0}, 4 },
      {{{OSUTF8("image-count"), 11}, 0}, 5 },
      {{{OSUTF8("object-count"), 12}, 0}, 6 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 7, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* page-count */
      stat = XmlDec_Odf_Page_count (pctxt, &pvalue->u.page_count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* paragraph-count */
      stat = XmlDec_Odf_Paragraph_count (pctxt, &pvalue->u.paragraph_count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* word-count */
      stat = XmlDec_Odf_Word_count (pctxt, &pvalue->u.word_count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* character-count */
      stat = XmlDec_Odf_Character_count (pctxt, &pvalue->u.character_count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* table-count */
      stat = XmlDec_Odf_Table_count (pctxt, &pvalue->u.table_count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* image-count */
      stat = XmlDec_Odf_Image_count (pctxt, &pvalue->u.image_count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* object-count */
      stat = XmlDec_Odf_Object_count (pctxt, &pvalue->u.object_count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_display                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Database_display (OSCTXT* pctxt, 
   Odf_Database_display *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode data_style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);
            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);

            stat = asn1D_Ns8_Data_style_name (pctxt, 
               (Ns8_Data_style_name*)pvalue->data_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode column_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->column_name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode database_name */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->database_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.database_namePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode table_name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->table_name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode table_type */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Database_display_table_type (pctxt, 
               &pvalue->table_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_typePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode connection_resource */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->connection_resource
                = rtxMemAllocType (pctxt, Connection_resource);

            if (pvalue->connection_resource == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Connection_resource ((Connection_resource*)pvalue->connection_resource);
            asn1Init_Connection_resource ((Connection_resource*)pvalue->connection_resource);

            stat = asn1D_Connection_resource (pctxt, 
               (Connection_resource*)pvalue->connection_resource, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.connection_resourcePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Database_display (OSCTXT* pctxt, Odf_Database_display* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("data-style-name"), 15}, 0 },
         { {OSUTF8("column-name"), 11}, 0 },
         { {OSUTF8("database-name"), 13}, 0 },
         { {OSUTF8("table-name"), 10}, 0 },
         { {OSUTF8("table-type"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* data-style-name */
            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->
               data_style_name);

            stat = XmlDec_Ns8_Data_style_name (pctxt, pvalue->data_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_style_namePresent = TRUE;
            break;

         case 1: /* column-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->column_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* database-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->database_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.database_namePresent = TRUE;
            break;

         case 3: /* table-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->table_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* table-type */
            stat = XmlDec_Odf_Database_display_table_type (pctxt, &pvalue->
               table_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.table_typePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Database_display");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Database_display");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("connection-resource"), 19}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* connection-resource */
         pvalue->connection_resource
             = rtxMemAllocType (pctxt, Connection_resource);

         if (pvalue->connection_resource == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Connection_resource ((Connection_resource*)pvalue->
            connection_resource);

         stat = XmlDec_Connection_resource (pctxt, pvalue->connection_resource
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.connection_resourcePresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_next                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Database_next (OSCTXT* pctxt, Odf_Database_next *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode condition */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->condition, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.conditionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode database_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->database_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.database_namePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode table_name */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->table_name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode table_type */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Database_next_table_type (pctxt, 
               &pvalue->table_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_typePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode connection_resource */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->connection_resource
                = rtxMemAllocType (pctxt, Connection_resource);

            if (pvalue->connection_resource == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Connection_resource ((Connection_resource*)pvalue->connection_resource);
            asn1Init_Connection_resource ((Connection_resource*)pvalue->connection_resource);

            stat = asn1D_Connection_resource (pctxt, 
               (Connection_resource*)pvalue->connection_resource, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.connection_resourcePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Database_next (OSCTXT* pctxt, Odf_Database_next* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("condition"), 9}, 0 },
         { {OSUTF8("database-name"), 13}, 0 },
         { {OSUTF8("table-name"), 10}, 0 },
         { {OSUTF8("table-type"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* condition */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->condition);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.conditionPresent = TRUE;
            break;

         case 1: /* database-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->database_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.database_namePresent = TRUE;
            break;

         case 2: /* table-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->table_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* table-type */
            stat = XmlDec_Odf_Database_next_table_type (pctxt, &pvalue->
               table_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.table_typePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Database_next");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Database_next");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("connection-resource"), 19}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* connection-resource */
         pvalue->connection_resource
             = rtxMemAllocType (pctxt, Connection_resource);

         if (pvalue->connection_resource == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Connection_resource ((Connection_resource*)pvalue->
            connection_resource);

         stat = XmlDec_Connection_resource (pctxt, pvalue->connection_resource
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.connection_resourcePresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_row_select                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Database_row_select (OSCTXT* pctxt, 
   Odf_Database_row_select *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode condition */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->condition, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.conditionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode database_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->database_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.database_namePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode row_number */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->row_number, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.row_numberPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode table_name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->table_name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode table_type */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Database_row_select_table_type (pctxt, 
               &pvalue->table_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_typePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode connection_resource */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->connection_resource
                = rtxMemAllocType (pctxt, Connection_resource);

            if (pvalue->connection_resource == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Connection_resource ((Connection_resource*)pvalue->connection_resource);
            asn1Init_Connection_resource ((Connection_resource*)pvalue->connection_resource);

            stat = asn1D_Connection_resource (pctxt, 
               (Connection_resource*)pvalue->connection_resource, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.connection_resourcePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Database_row_select (OSCTXT* pctxt, 
   Odf_Database_row_select* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("condition"), 9}, 0 },
         { {OSUTF8("database-name"), 13}, 0 },
         { {OSUTF8("row-number"), 10}, 0 },
         { {OSUTF8("table-name"), 10}, 0 },
         { {OSUTF8("table-type"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* condition */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->condition);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.conditionPresent = TRUE;
            break;

         case 1: /* database-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->database_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.database_namePresent = TRUE;
            break;

         case 2: /* row-number */
            stat = rtXmlpDecUInt (pctxt, &pvalue->row_number);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.row_numberPresent = TRUE;
            break;

         case 3: /* table-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->table_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* table-type */
            stat = XmlDec_Odf_Database_row_select_table_type (pctxt, &pvalue->
               table_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.table_typePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Database_row_select");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Database_row_select");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("connection-resource"), 19}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* connection-resource */
         pvalue->connection_resource
             = rtxMemAllocType (pctxt, Connection_resource);

         if (pvalue->connection_resource == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Connection_resource ((Connection_resource*)pvalue->
            connection_resource);

         stat = XmlDec_Connection_resource (pctxt, pvalue->connection_resource
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.connection_resourcePresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_row_number                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Database_row_number (OSCTXT* pctxt, 
   Odf_Database_row_number *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode num_format */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->num_format = rtxMemAllocType (pctxt, Ns8_Num_format);

            if (pvalue->num_format == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);
            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);

            stat = asn1D_Ns8_Num_format (pctxt, 
               (Ns8_Num_format*)pvalue->num_format, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.num_formatPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode num_letter_sync */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Num_letter_sync (pctxt, 
               (Ns8_Num_letter_sync*)&pvalue->num_letter_sync, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.num_letter_syncPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode database_name */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->database_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.database_namePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode table_name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->table_name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode table_type */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Database_row_number_table_type (pctxt, 
               &pvalue->table_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_typePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode connection_resource */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->connection_resource
                = rtxMemAllocType (pctxt, Connection_resource);

            if (pvalue->connection_resource == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Connection_resource ((Connection_resource*)pvalue->connection_resource);
            asn1Init_Connection_resource ((Connection_resource*)pvalue->connection_resource);

            stat = asn1D_Connection_resource (pctxt, 
               (Connection_resource*)pvalue->connection_resource, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.connection_resourcePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Database_row_number (OSCTXT* pctxt, 
   Odf_Database_row_number* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("num-format"), 10}, 0 },
         { {OSUTF8("num-letter-sync"), 15}, 0 },
         { {OSUTF8("database-name"), 13}, 0 },
         { {OSUTF8("table-name"), 10}, 0 },
         { {OSUTF8("table-type"), 10}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 6, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* num-format */
            pvalue->num_format = rtxMemAllocType (pctxt, Ns8_Num_format);

            if (pvalue->num_format == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);

            stat = XmlDec_Ns8_Num_format (pctxt, pvalue->num_format);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.num_formatPresent = TRUE;
            break;

         case 1: /* num-letter-sync */
            stat = XmlDec_Ns8_Num_letter_sync (pctxt, &pvalue->num_letter_sync
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.num_letter_syncPresent = TRUE;
            break;

         case 2: /* database-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->database_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.database_namePresent = TRUE;
            break;

         case 3: /* table-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->table_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* table-type */
            stat = XmlDec_Odf_Database_row_number_table_type (pctxt, &pvalue->
               table_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.table_typePresent = TRUE;
            break;

         case 5: /* value */
            stat = rtXmlpDecUInt (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Database_row_number");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Database_row_number");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("connection-resource"), 19}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* connection-resource */
         pvalue->connection_resource
             = rtxMemAllocType (pctxt, Connection_resource);

         if (pvalue->connection_resource == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Connection_resource ((Connection_resource*)pvalue->
            connection_resource);

         stat = XmlDec_Connection_resource (pctxt, pvalue->connection_resource
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.connection_resourcePresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_name                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Database_name (OSCTXT* pctxt, Odf_Database_name *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode database_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->database_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.database_namePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode table_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->table_name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode table_type */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Database_name_table_type (pctxt, 
               &pvalue->table_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_typePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode connection_resource */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->connection_resource
                = rtxMemAllocType (pctxt, Connection_resource);

            if (pvalue->connection_resource == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Connection_resource ((Connection_resource*)pvalue->connection_resource);
            asn1Init_Connection_resource ((Connection_resource*)pvalue->connection_resource);

            stat = asn1D_Connection_resource (pctxt, 
               (Connection_resource*)pvalue->connection_resource, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.connection_resourcePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Database_name (OSCTXT* pctxt, Odf_Database_name* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("database-name"), 13}, 0 },
         { {OSUTF8("table-name"), 10}, 0 },
         { {OSUTF8("table-type"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* database-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->database_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.database_namePresent = TRUE;
            break;

         case 1: /* table-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->table_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* table-type */
            stat = XmlDec_Odf_Database_name_table_type (pctxt, &pvalue->
               table_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.table_typePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Database_name");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Database_name");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("connection-resource"), 19}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* connection-resource */
         pvalue->connection_resource
             = rtxMemAllocType (pctxt, Connection_resource);

         if (pvalue->connection_resource == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Connection_resource ((Connection_resource*)pvalue->
            connection_resource);

         stat = XmlDec_Connection_resource (pctxt, pvalue->connection_resource
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.connection_resourcePresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Page_variable_set                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Page_variable_set (OSCTXT* pctxt, 
   Odf_Page_variable_set *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode active */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Page_variable_set_active (pctxt, 
               &pvalue->active, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.activePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode page_adjust */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->page_adjust, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.page_adjustPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Page_variable_set (OSCTXT* pctxt, Odf_Page_variable_set* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("active"), 6}, 0 },
         { {OSUTF8("page-adjust"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* active */
            stat = XmlDec_Odf_Page_variable_set_active (pctxt, &pvalue->active
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.activePresent = TRUE;
            break;

         case 1: /* page-adjust */
            stat = rtXmlpDecInt (pctxt, &pvalue->page_adjust);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.page_adjustPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Page_variable_set");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Page_variable_set");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Page_variable_get                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Page_variable_get (OSCTXT* pctxt, 
   Odf_Page_variable_get *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode num_format */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->num_format = rtxMemAllocType (pctxt, Ns8_Num_format);

            if (pvalue->num_format == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);
            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);

            stat = asn1D_Ns8_Num_format (pctxt, 
               (Ns8_Num_format*)pvalue->num_format, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.num_formatPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode num_letter_sync */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Num_letter_sync (pctxt, 
               (Ns8_Num_letter_sync*)&pvalue->num_letter_sync, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.num_letter_syncPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Page_variable_get (OSCTXT* pctxt, Odf_Page_variable_get* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("num-format"), 10}, 0 },
         { {OSUTF8("num-letter-sync"), 15}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* num-format */
            pvalue->num_format = rtxMemAllocType (pctxt, Ns8_Num_format);

            if (pvalue->num_format == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);

            stat = XmlDec_Ns8_Num_format (pctxt, pvalue->num_format);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.num_formatPresent = TRUE;
            break;

         case 1: /* num-letter-sync */
            stat = XmlDec_Ns8_Num_letter_sync (pctxt, &pvalue->num_letter_sync
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.num_letter_syncPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Page_variable_get");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Page_variable_get");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Placeholder                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Placeholder (OSCTXT* pctxt, Odf_Placeholder *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode placeholder_type */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Placeholder_placeholder_type (pctxt, 
               &pvalue->placeholder_type, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Placeholder (OSCTXT* pctxt, Odf_Placeholder* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("placeholder-type"), 16}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* placeholder-type */
            stat = XmlDec_Odf_Placeholder_placeholder_type (pctxt, &pvalue->
               placeholder_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Placeholder");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Placeholder");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Conditional_text                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Conditional_text (OSCTXT* pctxt, 
   Odf_Conditional_text *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode condition */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->condition, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode current_value */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Conditional_text_current_value (pctxt, 
               &pvalue->current_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.current_valuePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode string_value_if_false */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->string_value_if_false, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode string_value_if_true */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->string_value_if_true, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Conditional_text (OSCTXT* pctxt, Odf_Conditional_text* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("condition"), 9}, 0 },
         { {OSUTF8("current-value"), 13}, 0 },
         { {OSUTF8("string-value-if-false"), 21}, 0 },
         { {OSUTF8("string-value-if-true"), 20}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* condition */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->condition);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* current-value */
            stat = XmlDec_Odf_Conditional_text_current_value (pctxt, &pvalue->
               current_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.current_valuePresent = TRUE;
            break;

         case 2: /* string-value-if-false */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->string_value_if_false
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* string-value-if-true */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->string_value_if_true);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Conditional_text");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Conditional_text");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Hidden_text                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Hidden_text (OSCTXT* pctxt, Odf_Hidden_text *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode condition */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->condition, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode is_hidden */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Hidden_text_is_hidden (pctxt, 
               &pvalue->is_hidden, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.is_hiddenPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode string_value */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->string_value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Hidden_text (OSCTXT* pctxt, Odf_Hidden_text* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("condition"), 9}, 0 },
         { {OSUTF8("is-hidden"), 9}, 0 },
         { {OSUTF8("string-value"), 12}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* condition */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->condition);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* is-hidden */
            stat = XmlDec_Odf_Hidden_text_is_hidden (pctxt, &pvalue->is_hidden
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.is_hiddenPresent = TRUE;
            break;

         case 2: /* string-value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->string_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Hidden_text");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Hidden_text");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Element282_group                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Element282_group (OSCTXT* pctxt, 
   Odf_Element282_group *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         stat = asn1D_Odf_Reference_ref (pctxt, 
            &pvalue->u.reference_ref, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         stat = asn1D_Odf_Bookmark_ref (pctxt, 
            &pvalue->u.bookmark_ref, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Element282_group (OSCTXT* pctxt, Odf_Element282_group* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("reference-ref"), 13}, 0}, 0 },
      {{{OSUTF8("bookmark-ref"), 12}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* reference-ref */
      stat = XmlDec_Odf_Reference_ref (pctxt, &pvalue->u.reference_ref);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* bookmark-ref */
      stat = XmlDec_Odf_Bookmark_ref (pctxt, &pvalue->u.bookmark_ref);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Note_ref                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Note_ref (OSCTXT* pctxt, Odf_Note_ref *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode note_class */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Note_ref_note_class (pctxt, 
               &pvalue->note_class, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode ref_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->ref_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.ref_namePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode reference_format */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Note_ref_reference_format (pctxt, 
               &pvalue->reference_format, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.reference_formatPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Note_ref (OSCTXT* pctxt, Odf_Note_ref* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("note-class"), 10}, 0 },
         { {OSUTF8("ref-name"), 8}, 0 },
         { {OSUTF8("reference-format"), 16}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* note-class */
            stat = XmlDec_Odf_Note_ref_note_class (pctxt, &pvalue->note_class
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* ref-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->ref_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.ref_namePresent = TRUE;
            break;

         case 2: /* reference-format */
            stat = XmlDec_Odf_Note_ref_reference_format (pctxt, &pvalue->
               reference_format);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.reference_formatPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Note_ref");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Note_ref");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Sequence_ref                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Sequence_ref (OSCTXT* pctxt, Odf_Sequence_ref *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode ref_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->ref_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.ref_namePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode reference_format */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Sequence_ref_reference_format (pctxt, 
               &pvalue->reference_format, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.reference_formatPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Sequence_ref (OSCTXT* pctxt, Odf_Sequence_ref* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("ref-name"), 8}, 0 },
         { {OSUTF8("reference-format"), 16}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* ref-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->ref_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.ref_namePresent = TRUE;
            break;

         case 1: /* reference-format */
            stat = XmlDec_Odf_Sequence_ref_reference_format (pctxt, &pvalue->
               reference_format);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.reference_formatPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Sequence_ref");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Sequence_ref");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Script                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Script (OSCTXT* pctxt, Odf_Script *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode href */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Href (pctxt, 
               &pvalue->href, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.hrefPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Type (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.typePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns6_Language (pctxt, 
               &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Script (OSCTXT* pctxt, Odf_Script* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("href"), 4}, 0 },
         { {OSUTF8("type"), 4}, 0 },
         { {OSUTF8("language"), 8}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* href */
            stat = XmlDec_Xlink_Href (pctxt, &pvalue->href);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.hrefPresent = TRUE;
            break;

         case 1: /* type */
            stat = XmlDec_Xlink_Type (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.typePresent = TRUE;
            break;

         case 2: /* language */
            stat = XmlDec_Ns6_Language (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Script");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Script");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Execute_macro                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Execute_macro (OSCTXT* pctxt, Odf_Execute_macro *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Execute_macro (OSCTXT* pctxt, Odf_Execute_macro* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("name"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Execute_macro");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Execute_macro");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("event-listeners"), 15}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Hidden_paragraph                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Hidden_paragraph (OSCTXT* pctxt, 
   Odf_Hidden_paragraph *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode condition */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->condition, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode is_hidden */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Hidden_paragraph_is_hidden (pctxt, 
               &pvalue->is_hidden, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.is_hiddenPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Hidden_paragraph (OSCTXT* pctxt, Odf_Hidden_paragraph* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("condition"), 9}, 0 },
         { {OSUTF8("is-hidden"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* condition */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->condition);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* is-hidden */
            stat = XmlDec_Odf_Hidden_paragraph_is_hidden (pctxt, &pvalue->
               is_hidden);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.is_hiddenPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Hidden_paragraph");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Hidden_paragraph");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Dde_connection                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Dde_connection (OSCTXT* pctxt, 
   Odf_Dde_connection *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode connection_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->connection_name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Dde_connection (OSCTXT* pctxt, Odf_Dde_connection* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("connection-name"), 15}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* connection-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->connection_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Dde_connection");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Dde_connection");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Measure                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Measure (OSCTXT* pctxt, Odf_Measure *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode kind */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Measure_kind (pctxt, 
               &pvalue->kind, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Measure (OSCTXT* pctxt, Odf_Measure* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("kind"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* kind */
            stat = XmlDec_Odf_Measure_kind (pctxt, &pvalue->kind);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Measure");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Measure");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_formula                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Table_formula (OSCTXT* pctxt, Odf_Table_formula *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode data_style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);
            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->data_style_name);

            stat = asn1D_Ns8_Data_style_name (pctxt, 
               (Ns8_Data_style_name*)pvalue->data_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode display */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Table_formula_display (pctxt, 
               &pvalue->display, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.displayPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode formula */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->formula, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.formulaPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Table_formula (OSCTXT* pctxt, Odf_Table_formula* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("data-style-name"), 15}, 0 },
         { {OSUTF8("display"), 7}, 0 },
         { {OSUTF8("formula"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* data-style-name */
            pvalue->data_style_name
                = rtxMemAllocType (pctxt, Ns8_Data_style_name);

            if (pvalue->data_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Data_style_name ((Ns8_Data_style_name*)pvalue->
               data_style_name);

            stat = XmlDec_Ns8_Data_style_name (pctxt, pvalue->data_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_style_namePresent = TRUE;
            break;

         case 1: /* display */
            stat = XmlDec_Odf_Table_formula_display (pctxt, &pvalue->display);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.displayPresent = TRUE;
            break;

         case 2: /* formula */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->formula);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.formulaPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Table_formula");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Table_formula");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Toc_mark_start                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Toc_mark_start (OSCTXT* pctxt, 
   Odf_Toc_mark_start *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode outline_level */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->outline_level, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.outline_levelPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Toc_mark_start (OSCTXT* pctxt, Odf_Toc_mark_start* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("outline-level"), 13}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* outline-level */
            stat = rtXmlpDecUInt (pctxt, &pvalue->outline_level);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.outline_levelPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Toc_mark_start");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Toc_mark_start");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Toc_mark_end                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Toc_mark_end (OSCTXT* pctxt, Odf_Toc_mark_end *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Toc_mark_end (OSCTXT* pctxt, Odf_Toc_mark_end* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("id"), 2}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Toc_mark_end");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Toc_mark_end");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Toc_mark                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Toc_mark (OSCTXT* pctxt, Odf_Toc_mark *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode outline_level */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->outline_level, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.outline_levelPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode string_value */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->string_value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Toc_mark (OSCTXT* pctxt, Odf_Toc_mark* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("outline-level"), 13}, 0 },
         { {OSUTF8("string-value"), 12}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* outline-level */
            stat = rtXmlpDecUInt (pctxt, &pvalue->outline_level);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.outline_levelPresent = TRUE;
            break;

         case 1: /* string-value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->string_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Toc_mark");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Toc_mark");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  User_index_mark_start                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_User_index_mark_start (OSCTXT* pctxt, 
   Odf_User_index_mark_start *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode index_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->index_name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode outline_level */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->outline_level, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.outline_levelPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_User_index_mark_start (OSCTXT* pctxt, 
   Odf_User_index_mark_start* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("index-name"), 10}, 0 },
         { {OSUTF8("outline-level"), 13}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* index-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->index_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* outline-level */
            stat = rtXmlpDecUInt (pctxt, &pvalue->outline_level);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.outline_levelPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_User_index_mark_start");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_User_index_mark_start");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  User_index_mark_end                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_User_index_mark_end (OSCTXT* pctxt, 
   Odf_User_index_mark_end *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode outline_level */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->outline_level, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.outline_levelPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_User_index_mark_end (OSCTXT* pctxt, 
   Odf_User_index_mark_end* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("outline-level"), 13}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* outline-level */
            stat = rtXmlpDecUInt (pctxt, &pvalue->outline_level);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.outline_levelPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_User_index_mark_end");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_User_index_mark_end");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  User_index_mark                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_User_index_mark (OSCTXT* pctxt, 
   Odf_User_index_mark *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode index_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->index_name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode outline_level */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->outline_level, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.outline_levelPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode string_value */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->string_value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_User_index_mark (OSCTXT* pctxt, Odf_User_index_mark* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("index-name"), 10}, 0 },
         { {OSUTF8("outline-level"), 13}, 0 },
         { {OSUTF8("string-value"), 12}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* index-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->index_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* outline-level */
            stat = rtXmlpDecUInt (pctxt, &pvalue->outline_level);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.outline_levelPresent = TRUE;
            break;

         case 2: /* string-value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->string_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_User_index_mark");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_User_index_mark");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alphabetical_index_mark_start                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Alphabetical_index_mark_start (OSCTXT* pctxt, 
   Odf_Alphabetical_index_mark_start *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode key1 */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->key1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.key1Present = TRUE;
            }
         }
         break;

      case 2:
         /* decode key1_phonetic */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->key1_phonetic, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.key1_phoneticPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode key2 */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->key2, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.key2Present = TRUE;
            }
         }
         break;

      case 4:
         /* decode key2_phonetic */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->key2_phonetic, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.key2_phoneticPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode main_entry */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Alphabetical_index_mark_start_main_entry (pctxt, 
               &pvalue->main_entry, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.main_entryPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode string_value_phonetic */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->string_value_phonetic, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.string_value_phoneticPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Alphabetical_index_mark_start (OSCTXT* pctxt, 
   Odf_Alphabetical_index_mark_start* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("key1"), 4}, 0 },
         { {OSUTF8("key1-phonetic"), 13}, 0 },
         { {OSUTF8("key2"), 4}, 0 },
         { {OSUTF8("key2-phonetic"), 13}, 0 },
         { {OSUTF8("main-entry"), 10}, 0 },
         { {OSUTF8("string-value-phonetic"), 21}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 7, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* key1 */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->key1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.key1Present = TRUE;
            break;

         case 2: /* key1-phonetic */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->key1_phonetic);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.key1_phoneticPresent = TRUE;
            break;

         case 3: /* key2 */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->key2);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.key2Present = TRUE;
            break;

         case 4: /* key2-phonetic */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->key2_phonetic);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.key2_phoneticPresent = TRUE;
            break;

         case 5: /* main-entry */
            stat = XmlDec_Odf_Alphabetical_index_mark_start_main_entry (pctxt, 
               &pvalue->main_entry);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.main_entryPresent = TRUE;
            break;

         case 6: /* string-value-phonetic */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->string_value_phonetic
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.string_value_phoneticPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Alphabetical_index_mark_start");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Alphabetical_index_mark_start");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alphabetical_index_mark_end                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Alphabetical_index_mark_end (OSCTXT* pctxt, 
   Odf_Alphabetical_index_mark_end *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Alphabetical_index_mark_end (OSCTXT* pctxt, 
   Odf_Alphabetical_index_mark_end* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("id"), 2}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Alphabetical_index_mark_end");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Alphabetical_index_mark_end");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alphabetical_index_mark                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Alphabetical_index_mark (OSCTXT* pctxt, 
   Odf_Alphabetical_index_mark *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode key1 */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->key1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.key1Present = TRUE;
            }
         }
         break;

      case 1:
         /* decode key1_phonetic */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->key1_phonetic, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.key1_phoneticPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode key2 */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->key2, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.key2Present = TRUE;
            }
         }
         break;

      case 3:
         /* decode key2_phonetic */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->key2_phonetic, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.key2_phoneticPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode main_entry */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Alphabetical_index_mark_main_entry (pctxt, 
               &pvalue->main_entry, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.main_entryPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode string_value */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->string_value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode string_value_phonetic */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->string_value_phonetic, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.string_value_phoneticPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Alphabetical_index_mark (OSCTXT* pctxt, 
   Odf_Alphabetical_index_mark* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("key1"), 4}, 0 },
         { {OSUTF8("key1-phonetic"), 13}, 0 },
         { {OSUTF8("key2"), 4}, 0 },
         { {OSUTF8("key2-phonetic"), 13}, 0 },
         { {OSUTF8("main-entry"), 10}, 0 },
         { {OSUTF8("string-value"), 12}, 0 },
         { {OSUTF8("string-value-phonetic"), 21}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 7, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* key1 */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->key1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.key1Present = TRUE;
            break;

         case 1: /* key1-phonetic */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->key1_phonetic);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.key1_phoneticPresent = TRUE;
            break;

         case 2: /* key2 */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->key2);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.key2Present = TRUE;
            break;

         case 3: /* key2-phonetic */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->key2_phonetic);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.key2_phoneticPresent = TRUE;
            break;

         case 4: /* main-entry */
            stat = XmlDec_Odf_Alphabetical_index_mark_main_entry (pctxt, &
               pvalue->main_entry);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.main_entryPresent = TRUE;
            break;

         case 5: /* string-value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->string_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 6: /* string-value-phonetic */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->string_value_phonetic
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.string_value_phoneticPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Alphabetical_index_mark");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Alphabetical_index_mark");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Bibliography_mark                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Bibliography_mark (OSCTXT* pctxt, 
   Odf_Bibliography_mark *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode address */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.addressPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode annote */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->annote, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.annotePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode author */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->author, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.authorPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode bibliography_type */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Bibliography_mark_bibliography_type (pctxt, 
               &pvalue->bibliography_type, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode booktitle */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->booktitle, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.booktitlePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode chapter */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->chapter, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.chapterPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode custom1 */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->custom1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.custom1Present = TRUE;
            }
         }
         break;

      case 7:
         /* decode custom2 */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->custom2, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.custom2Present = TRUE;
            }
         }
         break;

      case 8:
         /* decode custom3 */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->custom3, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.custom3Present = TRUE;
            }
         }
         break;

      case 9:
         /* decode custom4 */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->custom4, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.custom4Present = TRUE;
            }
         }
         break;

      case 10:
         /* decode custom5 */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->custom5, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.custom5Present = TRUE;
            }
         }
         break;

      case 11:
         /* decode edition */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->edition, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.editionPresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode editor */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->editor, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.editorPresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode howpublished */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->howpublished, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.howpublishedPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode identifier */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->identifier, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.identifierPresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode institution */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->institution, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.institutionPresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode isbn */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->isbn, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.isbnPresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode issn */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->issn, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.issnPresent = TRUE;
            }
         }
         break;

      case 18:
         /* decode journal */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->journal, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.journalPresent = TRUE;
            }
         }
         break;

      case 19:
         /* decode month */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->month, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.monthPresent = TRUE;
            }
         }
         break;

      case 20:
         /* decode note */
         if (XD_PEEKTAG (pctxt, 0x94)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->note, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.notePresent = TRUE;
            }
         }
         break;

      case 21:
         /* decode number */
         if (XD_PEEKTAG (pctxt, 0x95)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->number, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.numberPresent = TRUE;
            }
         }
         break;

      case 22:
         /* decode organizations */
         if (XD_PEEKTAG (pctxt, 0x96)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->organizations, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.organizationsPresent = TRUE;
            }
         }
         break;

      case 23:
         /* decode pages */
         if (XD_PEEKTAG (pctxt, 0x97)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->pages, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.pagesPresent = TRUE;
            }
         }
         break;

      case 24:
         /* decode publisher */
         if (XD_PEEKTAG (pctxt, 0x98)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->publisher, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.publisherPresent = TRUE;
            }
         }
         break;

      case 25:
         /* decode report_type */
         if (XD_PEEKTAG (pctxt, 0x99)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->report_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.report_typePresent = TRUE;
            }
         }
         break;

      case 26:
         /* decode school */
         if (XD_PEEKTAG (pctxt, 0x9a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->school, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.schoolPresent = TRUE;
            }
         }
         break;

      case 27:
         /* decode series */
         if (XD_PEEKTAG (pctxt, 0x9b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->series, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.seriesPresent = TRUE;
            }
         }
         break;

      case 28:
         /* decode title */
         if (XD_PEEKTAG (pctxt, 0x9c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->title, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.titlePresent = TRUE;
            }
         }
         break;

      case 29:
         /* decode url */
         if (XD_PEEKTAG (pctxt, 0x9d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->url, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.urlPresent = TRUE;
            }
         }
         break;

      case 30:
         /* decode volume */
         if (XD_PEEKTAG (pctxt, 0x9e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->volume, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.volumePresent = TRUE;
            }
         }
         break;

      case 31:
         /* decode year */
         if ((stat = xd_match (pctxt, TM_CTXT|TM_PRIM|31, &length, XM_ADVANCE)) == 0) {
            stat = xd_utf8str (pctxt, &pvalue->year, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.yearPresent = TRUE;
            }
         }
         else if (stat == RTERR_IDNOTFOU) {
            stat = rtxErrReset (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_PRIM|17):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_PRIM|18):
         case (TM_CTXT|TM_CONS|18):
         case (TM_CTXT|TM_PRIM|19):
         case (TM_CTXT|TM_CONS|19):
         case (TM_CTXT|TM_PRIM|20):
         case (TM_CTXT|TM_CONS|20):
         case (TM_CTXT|TM_PRIM|21):
         case (TM_CTXT|TM_CONS|21):
         case (TM_CTXT|TM_PRIM|22):
         case (TM_CTXT|TM_CONS|22):
         case (TM_CTXT|TM_PRIM|23):
         case (TM_CTXT|TM_CONS|23):
         case (TM_CTXT|TM_PRIM|24):
         case (TM_CTXT|TM_CONS|24):
         case (TM_CTXT|TM_PRIM|25):
         case (TM_CTXT|TM_CONS|25):
         case (TM_CTXT|TM_PRIM|26):
         case (TM_CTXT|TM_CONS|26):
         case (TM_CTXT|TM_PRIM|27):
         case (TM_CTXT|TM_CONS|27):
         case (TM_CTXT|TM_PRIM|28):
         case (TM_CTXT|TM_CONS|28):
         case (TM_CTXT|TM_PRIM|29):
         case (TM_CTXT|TM_CONS|29):
         case (TM_CTXT|TM_PRIM|30):
         case (TM_CTXT|TM_CONS|30):
         case (TM_CTXT|TM_PRIM|31):
         case (TM_CTXT|TM_CONS|31):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Bibliography_mark (OSCTXT* pctxt, Odf_Bibliography_mark* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("address"), 7}, 0 },
         { {OSUTF8("annote"), 6}, 0 },
         { {OSUTF8("author"), 6}, 0 },
         { {OSUTF8("bibliography-type"), 17}, 0 },
         { {OSUTF8("booktitle"), 9}, 0 },
         { {OSUTF8("chapter"), 7}, 0 },
         { {OSUTF8("custom1"), 7}, 0 },
         { {OSUTF8("custom2"), 7}, 0 },
         { {OSUTF8("custom3"), 7}, 0 },
         { {OSUTF8("custom4"), 7}, 0 },
         { {OSUTF8("custom5"), 7}, 0 },
         { {OSUTF8("edition"), 7}, 0 },
         { {OSUTF8("editor"), 6}, 0 },
         { {OSUTF8("howpublished"), 12}, 0 },
         { {OSUTF8("identifier"), 10}, 0 },
         { {OSUTF8("institution"), 11}, 0 },
         { {OSUTF8("isbn"), 4}, 0 },
         { {OSUTF8("issn"), 4}, 0 },
         { {OSUTF8("journal"), 7}, 0 },
         { {OSUTF8("month"), 5}, 0 },
         { {OSUTF8("note"), 4}, 0 },
         { {OSUTF8("number"), 6}, 0 },
         { {OSUTF8("organizations"), 13}, 0 },
         { {OSUTF8("pages"), 5}, 0 },
         { {OSUTF8("publisher"), 9}, 0 },
         { {OSUTF8("report-type"), 11}, 0 },
         { {OSUTF8("school"), 6}, 0 },
         { {OSUTF8("series"), 6}, 0 },
         { {OSUTF8("title"), 5}, 0 },
         { {OSUTF8("url"), 3}, 0 },
         { {OSUTF8("volume"), 6}, 0 },
         { {OSUTF8("year"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 32, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* address */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.addressPresent = TRUE;
            break;

         case 1: /* annote */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->annote);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.annotePresent = TRUE;
            break;

         case 2: /* author */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->author);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.authorPresent = TRUE;
            break;

         case 3: /* bibliography-type */
            stat = XmlDec_Odf_Bibliography_mark_bibliography_type (pctxt, &
               pvalue->bibliography_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* booktitle */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->booktitle);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.booktitlePresent = TRUE;
            break;

         case 5: /* chapter */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->chapter);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.chapterPresent = TRUE;
            break;

         case 6: /* custom1 */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->custom1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.custom1Present = TRUE;
            break;

         case 7: /* custom2 */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->custom2);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.custom2Present = TRUE;
            break;

         case 8: /* custom3 */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->custom3);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.custom3Present = TRUE;
            break;

         case 9: /* custom4 */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->custom4);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.custom4Present = TRUE;
            break;

         case 10: /* custom5 */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->custom5);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.custom5Present = TRUE;
            break;

         case 11: /* edition */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->edition);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.editionPresent = TRUE;
            break;

         case 12: /* editor */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->editor);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.editorPresent = TRUE;
            break;

         case 13: /* howpublished */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->howpublished);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.howpublishedPresent = TRUE;
            break;

         case 14: /* identifier */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->identifier);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.identifierPresent = TRUE;
            break;

         case 15: /* institution */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->institution);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.institutionPresent = TRUE;
            break;

         case 16: /* isbn */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->isbn);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.isbnPresent = TRUE;
            break;

         case 17: /* issn */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->issn);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.issnPresent = TRUE;
            break;

         case 18: /* journal */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->journal);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.journalPresent = TRUE;
            break;

         case 19: /* month */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->month);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.monthPresent = TRUE;
            break;

         case 20: /* note */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->note);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.notePresent = TRUE;
            break;

         case 21: /* number */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->number);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.numberPresent = TRUE;
            break;

         case 22: /* organizations */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->organizations);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.organizationsPresent = TRUE;
            break;

         case 23: /* pages */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->pages);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.pagesPresent = TRUE;
            break;

         case 24: /* publisher */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->publisher);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.publisherPresent = TRUE;
            break;

         case 25: /* report-type */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->report_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.report_typePresent = TRUE;
            break;

         case 26: /* school */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->school);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.schoolPresent = TRUE;
            break;

         case 27: /* series */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->series);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.seriesPresent = TRUE;
            break;

         case 28: /* title */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->title);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.titlePresent = TRUE;
            break;

         case 29: /* url */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->url);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.urlPresent = TRUE;
            break;

         case 30: /* volume */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->volume);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.volumePresent = TRUE;
            break;

         case 31: /* year */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->year);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.yearPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Bibliography_mark");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Bibliography_mark");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ruby_base_element                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Ruby_base_element (OSCTXT* pctxt, 
   Odf_Ruby_base_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.s = rtxMemAllocType (pctxt, Odf_S);

         if (pvalue->u.s == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_S (pvalue->u.s);
         stat = asn1D_Odf_S (pctxt, 
            pvalue->u.s, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.tab = rtxMemAllocType (pctxt, Odf_Tab);

         if (pvalue->u.tab == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Tab (pvalue->u.tab);
         stat = asn1D_Odf_Tab (pctxt, 
            pvalue->u.tab, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.line_break = rtxMemAllocType (pctxt, Odf_Line_break);

         if (pvalue->u.line_break == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Line_break (pvalue->u.line_break);
         stat = asn1D_Odf_Line_break (pctxt, 
            pvalue->u.line_break, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.span = rtxMemAllocType (pctxt, Odf_Span);

         if (pvalue->u.span == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Span ((Odf_Span*)pvalue->u.span);
         stat = asn1D_Odf_Span (pctxt, 
            (Odf_Span*)pvalue->u.span, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.a = rtxMemAllocType (pctxt, Odf_A);

         if (pvalue->u.a == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_A ((Odf_A*)pvalue->u.a);
         stat = asn1D_Odf_A (pctxt, 
            (Odf_A*)pvalue->u.a, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.bookmark = rtxMemAllocType (pctxt, Odf_Bookmark);

         if (pvalue->u.bookmark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bookmark (pvalue->u.bookmark);
         stat = asn1D_Odf_Bookmark (pctxt, 
            pvalue->u.bookmark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.bookmark_start
             = rtxMemAllocType (pctxt, Odf_Bookmark_start);

         if (pvalue->u.bookmark_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bookmark_start (pvalue->u.bookmark_start);
         stat = asn1D_Odf_Bookmark_start (pctxt, 
            pvalue->u.bookmark_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.bookmark_end = rtxMemAllocType (pctxt, Odf_Bookmark_end);

         if (pvalue->u.bookmark_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bookmark_end (pvalue->u.bookmark_end);
         stat = asn1D_Odf_Bookmark_end (pctxt, 
            pvalue->u.bookmark_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.reference_mark
             = rtxMemAllocType (pctxt, Odf_Reference_mark);

         if (pvalue->u.reference_mark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Reference_mark (pvalue->u.reference_mark);
         stat = asn1D_Odf_Reference_mark (pctxt, 
            pvalue->u.reference_mark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.reference_mark_start
             = rtxMemAllocType (pctxt, Odf_Reference_mark_start);

         if (pvalue->u.reference_mark_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Reference_mark_start (pvalue->u.reference_mark_start);
         stat = asn1D_Odf_Reference_mark_start (pctxt, 
            pvalue->u.reference_mark_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.reference_mark_end
             = rtxMemAllocType (pctxt, Odf_Reference_mark_end);

         if (pvalue->u.reference_mark_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Reference_mark_end (pvalue->u.reference_mark_end);
         stat = asn1D_Odf_Reference_mark_end (pctxt, 
            pvalue->u.reference_mark_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.note = rtxMemAllocType (pctxt, Odf_Note);

         if (pvalue->u.note == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Note ((Odf_Note*)pvalue->u.note);
         stat = asn1D_Odf_Note (pctxt, 
            (Odf_Note*)pvalue->u.note, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.ruby = rtxMemAllocType (pctxt, Odf_Ruby);

         if (pvalue->u.ruby == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Ruby ((Odf_Ruby*)pvalue->u.ruby);
         stat = asn1D_Odf_Ruby (pctxt, 
            (Odf_Ruby*)pvalue->u.ruby, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.annotation = rtxMemAllocType (pctxt, Ns13_Annotation);

         if (pvalue->u.annotation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Annotation ((Ns13_Annotation*)pvalue->u.annotation);
         stat = asn1D_Ns13_Annotation (pctxt, 
            (Ns13_Annotation*)pvalue->u.annotation, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

         if (pvalue->u.change == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change (pvalue->u.change);
         stat = asn1D_Odf_Change (pctxt, 
            pvalue->u.change, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

         if (pvalue->u.change_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_start (pvalue->u.change_start);
         stat = asn1D_Odf_Change_start (pctxt, 
            pvalue->u.change_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

         if (pvalue->u.change_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_end (pvalue->u.change_end);
         stat = asn1D_Odf_Change_end (pctxt, 
            pvalue->u.change_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      case (TM_CTXT|TM_CONS|17):
         pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

         if (pvalue->u.rect == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);
         stat = asn1D_Ns3_Rect (pctxt, 
            (Ns3_Rect*)pvalue->u.rect, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 18;
         break;

      case (TM_CTXT|TM_CONS|18):
         pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

         if (pvalue->u.line == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);
         stat = asn1D_Ns3_Line (pctxt, 
            (Ns3_Line*)pvalue->u.line, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 19;
         break;

      case (TM_CTXT|TM_CONS|19):
         pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

         if (pvalue->u.polyline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);
         stat = asn1D_Ns3_Polyline (pctxt, 
            (Ns3_Polyline*)pvalue->u.polyline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 20;
         break;

      case (TM_CTXT|TM_CONS|20):
         pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

         if (pvalue->u.polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);
         stat = asn1D_Ns3_Polygon (pctxt, 
            (Ns3_Polygon*)pvalue->u.polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 21;
         break;

      case (TM_CTXT|TM_CONS|21):
         pvalue->u.regular_polygon
             = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

         if (pvalue->u.regular_polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->u.regular_polygon);
         stat = asn1D_Ns3_Regular_polygon (pctxt, 
            (Ns3_Regular_polygon*)pvalue->u.regular_polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 22;
         break;

      case (TM_CTXT|TM_CONS|22):
         pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

         if (pvalue->u.path == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);
         stat = asn1D_Ns3_Path (pctxt, 
            (Ns3_Path*)pvalue->u.path, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 23;
         break;

      case (TM_CTXT|TM_CONS|23):
         pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

         if (pvalue->u.circle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);
         stat = asn1D_Ns3_Circle (pctxt, 
            (Ns3_Circle*)pvalue->u.circle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 24;
         break;

      case (TM_CTXT|TM_CONS|24):
         pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

         if (pvalue->u.ellipse == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);
         stat = asn1D_Ns3_Ellipse (pctxt, 
            (Ns3_Ellipse*)pvalue->u.ellipse, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 25;
         break;

      case (TM_CTXT|TM_CONS|25):
         pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

         if (pvalue->u.g == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);
         stat = asn1D_Ns3_G (pctxt, 
            (Ns3_G*)pvalue->u.g, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 26;
         break;

      case (TM_CTXT|TM_CONS|26):
         pvalue->u.page_thumbnail
             = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

         if (pvalue->u.page_thumbnail == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->u.page_thumbnail);
         stat = asn1D_Ns3_Page_thumbnail (pctxt, 
            (Ns3_Page_thumbnail*)pvalue->u.page_thumbnail, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 27;
         break;

      case (TM_CTXT|TM_CONS|27):
         pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

         if (pvalue->u.frame == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);
         stat = asn1D_Ns3_Frame (pctxt, 
            (Ns3_Frame*)pvalue->u.frame, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 28;
         break;

      case (TM_CTXT|TM_CONS|28):
         pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

         if (pvalue->u.measure == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);
         stat = asn1D_Ns3_Measure (pctxt, 
            (Ns3_Measure*)pvalue->u.measure, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 29;
         break;

      case (TM_CTXT|TM_CONS|29):
         pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

         if (pvalue->u.caption == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);
         stat = asn1D_Ns3_Caption (pctxt, 
            (Ns3_Caption*)pvalue->u.caption, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 30;
         break;

      case (TM_CTXT|TM_CONS|30):
         pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

         if (pvalue->u.connector == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);
         stat = asn1D_Ns3_Connector (pctxt, 
            (Ns3_Connector*)pvalue->u.connector, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 31;
         break;

      case (TM_CTXT|TM_CONS|31):
         pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

         if (pvalue->u.control == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);
         stat = asn1D_Ns3_Control (pctxt, 
            (Ns3_Control*)pvalue->u.control, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 32;
         break;

      case (TM_CTXT|TM_CONS|32):
         pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

         if (pvalue->u.scene == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);
         stat = asn1D_Ns7_Scene (pctxt, 
            (Ns7_Scene*)pvalue->u.scene, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 33;
         break;

      case (TM_CTXT|TM_CONS|33):
         pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

         if (pvalue->u.custom_shape == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);
         stat = asn1D_Ns3_Custom_shape (pctxt, 
            (Ns3_Custom_shape*)pvalue->u.custom_shape, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 34;
         break;

      case (TM_CTXT|TM_CONS|34):
         pvalue->u.a_1 = rtxMemAllocType (pctxt, Ns3_A);

         if (pvalue->u.a_1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_A ((Ns3_A*)pvalue->u.a_1);
         stat = asn1D_Ns3_A (pctxt, 
            (Ns3_A*)pvalue->u.a_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 35;
         break;

      case (TM_CTXT|TM_CONS|35):
         pvalue->u.date = rtxMemAllocType (pctxt, Odf_Date);

         if (pvalue->u.date == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Date (pvalue->u.date);
         stat = asn1D_Odf_Date (pctxt, 
            pvalue->u.date, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 36;
         break;

      case (TM_CTXT|TM_CONS|36):
         pvalue->u.time_ = rtxMemAllocType (pctxt, Odf_Time);

         if (pvalue->u.time_ == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Time (pvalue->u.time_);
         stat = asn1D_Odf_Time (pctxt, 
            pvalue->u.time_, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 37;
         break;

      case (TM_CTXT|TM_CONS|37):
         pvalue->u.page_number = rtxMemAllocType (pctxt, Odf_Page_number);

         if (pvalue->u.page_number == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Page_number (pvalue->u.page_number);
         stat = asn1D_Odf_Page_number (pctxt, 
            pvalue->u.page_number, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 38;
         break;

      case (TM_CTXT|TM_CONS|38):
         pvalue->u.page_continuation
             = rtxMemAllocType (pctxt, Odf_Page_continuation);

         if (pvalue->u.page_continuation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Page_continuation (pvalue->u.page_continuation);
         stat = asn1D_Odf_Page_continuation (pctxt, 
            pvalue->u.page_continuation, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 39;
         break;

      case (TM_CTXT|TM_CONS|39):
         pvalue->u.sender_firstname
             = rtxMemAllocType (pctxt, Odf_Sender_firstname);

         if (pvalue->u.sender_firstname == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_firstname (pvalue->u.sender_firstname);
         stat = asn1D_Odf_Sender_firstname (pctxt, 
            pvalue->u.sender_firstname, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 40;
         break;

      case (TM_CTXT|TM_CONS|40):
         pvalue->u.sender_lastname
             = rtxMemAllocType (pctxt, Odf_Sender_lastname);

         if (pvalue->u.sender_lastname == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_lastname (pvalue->u.sender_lastname);
         stat = asn1D_Odf_Sender_lastname (pctxt, 
            pvalue->u.sender_lastname, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 41;
         break;

      case (TM_CTXT|TM_CONS|41):
         pvalue->u.sender_initials
             = rtxMemAllocType (pctxt, Odf_Sender_initials);

         if (pvalue->u.sender_initials == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_initials (pvalue->u.sender_initials);
         stat = asn1D_Odf_Sender_initials (pctxt, 
            pvalue->u.sender_initials, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 42;
         break;

      case (TM_CTXT|TM_CONS|42):
         pvalue->u.sender_title = rtxMemAllocType (pctxt, Odf_Sender_title);

         if (pvalue->u.sender_title == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_title (pvalue->u.sender_title);
         stat = asn1D_Odf_Sender_title (pctxt, 
            pvalue->u.sender_title, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 43;
         break;

      case (TM_CTXT|TM_CONS|43):
         pvalue->u.sender_position
             = rtxMemAllocType (pctxt, Odf_Sender_position);

         if (pvalue->u.sender_position == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_position (pvalue->u.sender_position);
         stat = asn1D_Odf_Sender_position (pctxt, 
            pvalue->u.sender_position, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 44;
         break;

      case (TM_CTXT|TM_CONS|44):
         pvalue->u.sender_email = rtxMemAllocType (pctxt, Odf_Sender_email);

         if (pvalue->u.sender_email == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_email (pvalue->u.sender_email);
         stat = asn1D_Odf_Sender_email (pctxt, 
            pvalue->u.sender_email, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 45;
         break;

      case (TM_CTXT|TM_CONS|45):
         pvalue->u.sender_phone_private
             = rtxMemAllocType (pctxt, Odf_Sender_phone_private);

         if (pvalue->u.sender_phone_private == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_phone_private (pvalue->u.sender_phone_private);
         stat = asn1D_Odf_Sender_phone_private (pctxt, 
            pvalue->u.sender_phone_private, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 46;
         break;

      case (TM_CTXT|TM_CONS|46):
         pvalue->u.sender_fax = rtxMemAllocType (pctxt, Odf_Sender_fax);

         if (pvalue->u.sender_fax == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_fax (pvalue->u.sender_fax);
         stat = asn1D_Odf_Sender_fax (pctxt, 
            pvalue->u.sender_fax, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 47;
         break;

      case (TM_CTXT|TM_CONS|47):
         pvalue->u.sender_company
             = rtxMemAllocType (pctxt, Odf_Sender_company);

         if (pvalue->u.sender_company == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_company (pvalue->u.sender_company);
         stat = asn1D_Odf_Sender_company (pctxt, 
            pvalue->u.sender_company, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 48;
         break;

      case (TM_CTXT|TM_CONS|48):
         pvalue->u.sender_phone_work
             = rtxMemAllocType (pctxt, Odf_Sender_phone_work);

         if (pvalue->u.sender_phone_work == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_phone_work (pvalue->u.sender_phone_work);
         stat = asn1D_Odf_Sender_phone_work (pctxt, 
            pvalue->u.sender_phone_work, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 49;
         break;

      case (TM_CTXT|TM_CONS|49):
         pvalue->u.sender_street = rtxMemAllocType (pctxt, Odf_Sender_street);

         if (pvalue->u.sender_street == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_street (pvalue->u.sender_street);
         stat = asn1D_Odf_Sender_street (pctxt, 
            pvalue->u.sender_street, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 50;
         break;

      case (TM_CTXT|TM_CONS|50):
         pvalue->u.sender_city = rtxMemAllocType (pctxt, Odf_Sender_city);

         if (pvalue->u.sender_city == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_city (pvalue->u.sender_city);
         stat = asn1D_Odf_Sender_city (pctxt, 
            pvalue->u.sender_city, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 51;
         break;

      case (TM_CTXT|TM_CONS|51):
         pvalue->u.sender_postal_code
             = rtxMemAllocType (pctxt, Odf_Sender_postal_code);

         if (pvalue->u.sender_postal_code == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_postal_code (pvalue->u.sender_postal_code);
         stat = asn1D_Odf_Sender_postal_code (pctxt, 
            pvalue->u.sender_postal_code, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 52;
         break;

      case (TM_CTXT|TM_CONS|52):
         pvalue->u.sender_country
             = rtxMemAllocType (pctxt, Odf_Sender_country);

         if (pvalue->u.sender_country == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_country (pvalue->u.sender_country);
         stat = asn1D_Odf_Sender_country (pctxt, 
            pvalue->u.sender_country, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 53;
         break;

      case (TM_CTXT|TM_CONS|53):
         pvalue->u.sender_state_or_province
             = rtxMemAllocType (pctxt, Odf_Sender_state_or_province);

         if (pvalue->u.sender_state_or_province == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_state_or_province (pvalue->u.sender_state_or_province);
         stat = asn1D_Odf_Sender_state_or_province (pctxt, 
            pvalue->u.sender_state_or_province, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 54;
         break;

      case (TM_CTXT|TM_CONS|54):
         pvalue->u.author_name = rtxMemAllocType (pctxt, Odf_Author_name);

         if (pvalue->u.author_name == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Author_name (pvalue->u.author_name);
         stat = asn1D_Odf_Author_name (pctxt, 
            pvalue->u.author_name, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 55;
         break;

      case (TM_CTXT|TM_CONS|55):
         pvalue->u.author_initials
             = rtxMemAllocType (pctxt, Odf_Author_initials);

         if (pvalue->u.author_initials == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Author_initials (pvalue->u.author_initials);
         stat = asn1D_Odf_Author_initials (pctxt, 
            pvalue->u.author_initials, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 56;
         break;

      case (TM_CTXT|TM_CONS|56):
         pvalue->u.chapter = rtxMemAllocType (pctxt, Odf_Chapter);

         if (pvalue->u.chapter == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Chapter (pvalue->u.chapter);
         stat = asn1D_Odf_Chapter (pctxt, 
            pvalue->u.chapter, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 57;
         break;

      case (TM_CTXT|TM_CONS|57):
         pvalue->u.file_name = rtxMemAllocType (pctxt, Odf_File_name);

         if (pvalue->u.file_name == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_File_name (pvalue->u.file_name);
         stat = asn1D_Odf_File_name (pctxt, 
            pvalue->u.file_name, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 58;
         break;

      case (TM_CTXT|TM_CONS|58):
         pvalue->u.template_name = rtxMemAllocType (pctxt, Odf_Template_name);

         if (pvalue->u.template_name == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Template_name (pvalue->u.template_name);
         stat = asn1D_Odf_Template_name (pctxt, 
            pvalue->u.template_name, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 59;
         break;

      case (TM_CTXT|TM_PRIM|59):
      case (TM_CTXT|TM_CONS|59):
         stat = asn1D_Odf_Sheet_name (pctxt, 
            &pvalue->u.sheet_name, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 60;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_CONS|60):
         pvalue->u.variable_set = rtxMemAllocType (pctxt, Odf_Variable_set);

         if (pvalue->u.variable_set == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Variable_set (pvalue->u.variable_set);
         stat = asn1D_Odf_Variable_set (pctxt, 
            pvalue->u.variable_set, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 61;
         break;

      case (TM_CTXT|TM_CONS|61):
         pvalue->u.variable_get = rtxMemAllocType (pctxt, Odf_Variable_get);

         if (pvalue->u.variable_get == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Variable_get (pvalue->u.variable_get);
         stat = asn1D_Odf_Variable_get (pctxt, 
            pvalue->u.variable_get, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 62;
         break;

      case (TM_CTXT|TM_CONS|62):
         pvalue->u.variable_input
             = rtxMemAllocType (pctxt, Odf_Variable_input);

         if (pvalue->u.variable_input == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Variable_input (pvalue->u.variable_input);
         stat = asn1D_Odf_Variable_input (pctxt, 
            pvalue->u.variable_input, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 63;
         break;

      case (TM_CTXT|TM_CONS|63):
         pvalue->u.user_field_get
             = rtxMemAllocType (pctxt, Odf_User_field_get);

         if (pvalue->u.user_field_get == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_field_get (pvalue->u.user_field_get);
         stat = asn1D_Odf_User_field_get (pctxt, 
            pvalue->u.user_field_get, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 64;
         break;

      case (TM_CTXT|TM_CONS|64):
         pvalue->u.user_field_input
             = rtxMemAllocType (pctxt, Odf_User_field_input);

         if (pvalue->u.user_field_input == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_field_input (pvalue->u.user_field_input);
         stat = asn1D_Odf_User_field_input (pctxt, 
            pvalue->u.user_field_input, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 65;
         break;

      case (TM_CTXT|TM_CONS|65):
         pvalue->u.sequence = rtxMemAllocType (pctxt, Odf_Sequence);

         if (pvalue->u.sequence == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sequence (pvalue->u.sequence);
         stat = asn1D_Odf_Sequence (pctxt, 
            pvalue->u.sequence, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 66;
         break;

      case (TM_CTXT|TM_CONS|66):
         pvalue->u.expression = rtxMemAllocType (pctxt, Odf_Expression);

         if (pvalue->u.expression == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Expression (pvalue->u.expression);
         stat = asn1D_Odf_Expression (pctxt, 
            pvalue->u.expression, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 67;
         break;

      case (TM_CTXT|TM_CONS|67):
         pvalue->u.text_input = rtxMemAllocType (pctxt, Odf_Text_input);

         if (pvalue->u.text_input == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Text_input (pvalue->u.text_input);
         stat = asn1D_Odf_Text_input (pctxt, 
            pvalue->u.text_input, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 68;
         break;

      case (TM_CTXT|TM_CONS|68):
         pvalue->u.initial_creator
             = rtxMemAllocType (pctxt, Odf_Initial_creator);

         if (pvalue->u.initial_creator == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Initial_creator (pvalue->u.initial_creator);
         stat = asn1D_Odf_Initial_creator (pctxt, 
            pvalue->u.initial_creator, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 69;
         break;

      case (TM_CTXT|TM_CONS|69):
         pvalue->u.creation_date = rtxMemAllocType (pctxt, Odf_Creation_date);

         if (pvalue->u.creation_date == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Creation_date (pvalue->u.creation_date);
         stat = asn1D_Odf_Creation_date (pctxt, 
            pvalue->u.creation_date, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 70;
         break;

      case (TM_CTXT|TM_CONS|70):
         pvalue->u.creation_time = rtxMemAllocType (pctxt, Odf_Creation_time);

         if (pvalue->u.creation_time == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Creation_time (pvalue->u.creation_time);
         stat = asn1D_Odf_Creation_time (pctxt, 
            pvalue->u.creation_time, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 71;
         break;

      case (TM_CTXT|TM_CONS|71):
         pvalue->u.description = rtxMemAllocType (pctxt, Odf_Description);

         if (pvalue->u.description == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Description (pvalue->u.description);
         stat = asn1D_Odf_Description (pctxt, 
            pvalue->u.description, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 72;
         break;

      case (TM_CTXT|TM_CONS|72):
         pvalue->u.user_defined = rtxMemAllocType (pctxt, Odf_User_defined);

         if (pvalue->u.user_defined == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_defined (pvalue->u.user_defined);
         stat = asn1D_Odf_User_defined (pctxt, 
            pvalue->u.user_defined, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 73;
         break;

      case (TM_CTXT|TM_CONS|73):
         pvalue->u.print_time = rtxMemAllocType (pctxt, Odf_Print_time);

         if (pvalue->u.print_time == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Print_time (pvalue->u.print_time);
         stat = asn1D_Odf_Print_time (pctxt, 
            pvalue->u.print_time, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 74;
         break;

      case (TM_CTXT|TM_CONS|74):
         pvalue->u.print_date = rtxMemAllocType (pctxt, Odf_Print_date);

         if (pvalue->u.print_date == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Print_date (pvalue->u.print_date);
         stat = asn1D_Odf_Print_date (pctxt, 
            pvalue->u.print_date, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 75;
         break;

      case (TM_CTXT|TM_CONS|75):
         pvalue->u.printed_by = rtxMemAllocType (pctxt, Odf_Printed_by);

         if (pvalue->u.printed_by == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Printed_by (pvalue->u.printed_by);
         stat = asn1D_Odf_Printed_by (pctxt, 
            pvalue->u.printed_by, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 76;
         break;

      case (TM_CTXT|TM_CONS|76):
         pvalue->u.title = rtxMemAllocType (pctxt, Odf_Title);

         if (pvalue->u.title == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Title (pvalue->u.title);
         stat = asn1D_Odf_Title (pctxt, 
            pvalue->u.title, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 77;
         break;

      case (TM_CTXT|TM_CONS|77):
         pvalue->u.subject = rtxMemAllocType (pctxt, Odf_Subject);

         if (pvalue->u.subject == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Subject (pvalue->u.subject);
         stat = asn1D_Odf_Subject (pctxt, 
            pvalue->u.subject, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 78;
         break;

      case (TM_CTXT|TM_CONS|78):
         pvalue->u.keywords = rtxMemAllocType (pctxt, Odf_Keywords);

         if (pvalue->u.keywords == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Keywords (pvalue->u.keywords);
         stat = asn1D_Odf_Keywords (pctxt, 
            pvalue->u.keywords, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 79;
         break;

      case (TM_CTXT|TM_CONS|79):
         pvalue->u.editing_cycles
             = rtxMemAllocType (pctxt, Odf_Editing_cycles);

         if (pvalue->u.editing_cycles == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Editing_cycles (pvalue->u.editing_cycles);
         stat = asn1D_Odf_Editing_cycles (pctxt, 
            pvalue->u.editing_cycles, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 80;
         break;

      case (TM_CTXT|TM_CONS|80):
         pvalue->u.editing_duration
             = rtxMemAllocType (pctxt, Odf_Editing_duration);

         if (pvalue->u.editing_duration == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Editing_duration (pvalue->u.editing_duration);
         stat = asn1D_Odf_Editing_duration (pctxt, 
            pvalue->u.editing_duration, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 81;
         break;

      case (TM_CTXT|TM_CONS|81):
         pvalue->u.modification_time
             = rtxMemAllocType (pctxt, Odf_Modification_time);

         if (pvalue->u.modification_time == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Modification_time (pvalue->u.modification_time);
         stat = asn1D_Odf_Modification_time (pctxt, 
            pvalue->u.modification_time, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 82;
         break;

      case (TM_CTXT|TM_CONS|82):
         pvalue->u.modification_date
             = rtxMemAllocType (pctxt, Odf_Modification_date);

         if (pvalue->u.modification_date == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Modification_date (pvalue->u.modification_date);
         stat = asn1D_Odf_Modification_date (pctxt, 
            pvalue->u.modification_date, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 83;
         break;

      case (TM_CTXT|TM_CONS|83):
         pvalue->u.creator = rtxMemAllocType (pctxt, Odf_Creator);

         if (pvalue->u.creator == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Creator (pvalue->u.creator);
         stat = asn1D_Odf_Creator (pctxt, 
            pvalue->u.creator, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 84;
         break;

      case (TM_CTXT|TM_CONS|84):
         pvalue->u.element271 = rtxMemAllocType (pctxt, Odf_Element271_group);

         if (pvalue->u.element271 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Element271_group (pvalue->u.element271);
         stat = asn1D_Odf_Element271_group (pctxt, 
            pvalue->u.element271, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 85;
         break;

      case (TM_CTXT|TM_CONS|85):
         pvalue->u.database_display
             = rtxMemAllocType (pctxt, Odf_Database_display);

         if (pvalue->u.database_display == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Database_display (pvalue->u.database_display);
         stat = asn1D_Odf_Database_display (pctxt, 
            pvalue->u.database_display, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 86;
         break;

      case (TM_CTXT|TM_CONS|86):
         pvalue->u.database_next = rtxMemAllocType (pctxt, Odf_Database_next);

         if (pvalue->u.database_next == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Database_next (pvalue->u.database_next);
         stat = asn1D_Odf_Database_next (pctxt, 
            pvalue->u.database_next, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 87;
         break;

      case (TM_CTXT|TM_CONS|87):
         pvalue->u.database_row_select
             = rtxMemAllocType (pctxt, Odf_Database_row_select);

         if (pvalue->u.database_row_select == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Database_row_select (pvalue->u.database_row_select);
         stat = asn1D_Odf_Database_row_select (pctxt, 
            pvalue->u.database_row_select, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 88;
         break;

      case (TM_CTXT|TM_CONS|88):
         pvalue->u.database_row_number
             = rtxMemAllocType (pctxt, Odf_Database_row_number);

         if (pvalue->u.database_row_number == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Database_row_number (pvalue->u.database_row_number);
         stat = asn1D_Odf_Database_row_number (pctxt, 
            pvalue->u.database_row_number, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 89;
         break;

      case (TM_CTXT|TM_CONS|89):
         pvalue->u.database_name = rtxMemAllocType (pctxt, Odf_Database_name);

         if (pvalue->u.database_name == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Database_name (pvalue->u.database_name);
         stat = asn1D_Odf_Database_name (pctxt, 
            pvalue->u.database_name, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 90;
         break;

      case (TM_CTXT|TM_CONS|90):
         pvalue->u.page_variable_set
             = rtxMemAllocType (pctxt, Odf_Page_variable_set);

         if (pvalue->u.page_variable_set == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Page_variable_set (pvalue->u.page_variable_set);
         stat = asn1D_Odf_Page_variable_set (pctxt, 
            pvalue->u.page_variable_set, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 91;
         break;

      case (TM_CTXT|TM_CONS|91):
         pvalue->u.page_variable_get
             = rtxMemAllocType (pctxt, Odf_Page_variable_get);

         if (pvalue->u.page_variable_get == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Page_variable_get (pvalue->u.page_variable_get);
         stat = asn1D_Odf_Page_variable_get (pctxt, 
            pvalue->u.page_variable_get, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 92;
         break;

      case (TM_CTXT|TM_CONS|92):
         pvalue->u.placeholder = rtxMemAllocType (pctxt, Odf_Placeholder);

         if (pvalue->u.placeholder == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Placeholder (pvalue->u.placeholder);
         stat = asn1D_Odf_Placeholder (pctxt, 
            pvalue->u.placeholder, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 93;
         break;

      case (TM_CTXT|TM_CONS|93):
         pvalue->u.conditional_text
             = rtxMemAllocType (pctxt, Odf_Conditional_text);

         if (pvalue->u.conditional_text == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Conditional_text (pvalue->u.conditional_text);
         stat = asn1D_Odf_Conditional_text (pctxt, 
            pvalue->u.conditional_text, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 94;
         break;

      case (TM_CTXT|TM_CONS|94):
         pvalue->u.hidden_text = rtxMemAllocType (pctxt, Odf_Hidden_text);

         if (pvalue->u.hidden_text == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Hidden_text (pvalue->u.hidden_text);
         stat = asn1D_Odf_Hidden_text (pctxt, 
            pvalue->u.hidden_text, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 95;
         break;

      case (TM_CTXT|TM_CONS|95):
         pvalue->u.element282 = rtxMemAllocType (pctxt, Odf_Element282_group);

         if (pvalue->u.element282 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Element282_group (pvalue->u.element282);
         stat = asn1D_Odf_Element282_group (pctxt, 
            pvalue->u.element282, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 96;
         break;

      case (TM_CTXT|TM_CONS|96):
         pvalue->u.note_ref = rtxMemAllocType (pctxt, Odf_Note_ref);

         if (pvalue->u.note_ref == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Note_ref (pvalue->u.note_ref);
         stat = asn1D_Odf_Note_ref (pctxt, 
            pvalue->u.note_ref, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 97;
         break;

      case (TM_CTXT|TM_CONS|97):
         pvalue->u.sequence_ref = rtxMemAllocType (pctxt, Odf_Sequence_ref);

         if (pvalue->u.sequence_ref == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sequence_ref (pvalue->u.sequence_ref);
         stat = asn1D_Odf_Sequence_ref (pctxt, 
            pvalue->u.sequence_ref, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 98;
         break;

      case (TM_CTXT|TM_CONS|98):
         pvalue->u.script = rtxMemAllocType (pctxt, Odf_Script);

         if (pvalue->u.script == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Script (pvalue->u.script);
         stat = asn1D_Odf_Script (pctxt, 
            pvalue->u.script, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 99;
         break;

      case (TM_CTXT|TM_CONS|99):
         pvalue->u.execute_macro = rtxMemAllocType (pctxt, Odf_Execute_macro);

         if (pvalue->u.execute_macro == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Execute_macro (pvalue->u.execute_macro);
         stat = asn1D_Odf_Execute_macro (pctxt, 
            pvalue->u.execute_macro, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 100;
         break;

      case (TM_CTXT|TM_CONS|100):
         pvalue->u.hidden_paragraph
             = rtxMemAllocType (pctxt, Odf_Hidden_paragraph);

         if (pvalue->u.hidden_paragraph == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Hidden_paragraph (pvalue->u.hidden_paragraph);
         stat = asn1D_Odf_Hidden_paragraph (pctxt, 
            pvalue->u.hidden_paragraph, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 101;
         break;

      case (TM_CTXT|TM_CONS|101):
         pvalue->u.dde_connection
             = rtxMemAllocType (pctxt, Odf_Dde_connection);

         if (pvalue->u.dde_connection == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Dde_connection (pvalue->u.dde_connection);
         stat = asn1D_Odf_Dde_connection (pctxt, 
            pvalue->u.dde_connection, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 102;
         break;

      case (TM_CTXT|TM_CONS|102):
         pvalue->u.measure_1 = rtxMemAllocType (pctxt, Odf_Measure);

         if (pvalue->u.measure_1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Measure (pvalue->u.measure_1);
         stat = asn1D_Odf_Measure (pctxt, 
            pvalue->u.measure_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 103;
         break;

      case (TM_CTXT|TM_CONS|103):
         pvalue->u.table_formula = rtxMemAllocType (pctxt, Odf_Table_formula);

         if (pvalue->u.table_formula == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_formula (pvalue->u.table_formula);
         stat = asn1D_Odf_Table_formula (pctxt, 
            pvalue->u.table_formula, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 104;
         break;

      case (TM_CTXT|TM_CONS|104):
         pvalue->u.toc_mark_start
             = rtxMemAllocType (pctxt, Odf_Toc_mark_start);

         if (pvalue->u.toc_mark_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Toc_mark_start (pvalue->u.toc_mark_start);
         stat = asn1D_Odf_Toc_mark_start (pctxt, 
            pvalue->u.toc_mark_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 105;
         break;

      case (TM_CTXT|TM_CONS|105):
         pvalue->u.toc_mark_end = rtxMemAllocType (pctxt, Odf_Toc_mark_end);

         if (pvalue->u.toc_mark_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Toc_mark_end (pvalue->u.toc_mark_end);
         stat = asn1D_Odf_Toc_mark_end (pctxt, 
            pvalue->u.toc_mark_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 106;
         break;

      case (TM_CTXT|TM_CONS|106):
         pvalue->u.toc_mark = rtxMemAllocType (pctxt, Odf_Toc_mark);

         if (pvalue->u.toc_mark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Toc_mark (pvalue->u.toc_mark);
         stat = asn1D_Odf_Toc_mark (pctxt, 
            pvalue->u.toc_mark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 107;
         break;

      case (TM_CTXT|TM_CONS|107):
         pvalue->u.user_index_mark_start
             = rtxMemAllocType (pctxt, Odf_User_index_mark_start);

         if (pvalue->u.user_index_mark_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index_mark_start (pvalue->u.user_index_mark_start);
         stat = asn1D_Odf_User_index_mark_start (pctxt, 
            pvalue->u.user_index_mark_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 108;
         break;

      case (TM_CTXT|TM_CONS|108):
         pvalue->u.user_index_mark_end
             = rtxMemAllocType (pctxt, Odf_User_index_mark_end);

         if (pvalue->u.user_index_mark_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index_mark_end (pvalue->u.user_index_mark_end);
         stat = asn1D_Odf_User_index_mark_end (pctxt, 
            pvalue->u.user_index_mark_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 109;
         break;

      case (TM_CTXT|TM_CONS|109):
         pvalue->u.user_index_mark
             = rtxMemAllocType (pctxt, Odf_User_index_mark);

         if (pvalue->u.user_index_mark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index_mark (pvalue->u.user_index_mark);
         stat = asn1D_Odf_User_index_mark (pctxt, 
            pvalue->u.user_index_mark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 110;
         break;

      case (TM_CTXT|TM_CONS|110):
         pvalue->u.alphabetical_index_mark_start
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark_start);

         if (pvalue->u.alphabetical_index_mark_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index_mark_start (pvalue->u.alphabetical_index_mark_start);
         stat = asn1D_Odf_Alphabetical_index_mark_start (pctxt, 
            pvalue->u.alphabetical_index_mark_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 111;
         break;

      case (TM_CTXT|TM_CONS|111):
         pvalue->u.alphabetical_index_mark_end
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark_end);

         if (pvalue->u.alphabetical_index_mark_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index_mark_end (pvalue->u.alphabetical_index_mark_end);
         stat = asn1D_Odf_Alphabetical_index_mark_end (pctxt, 
            pvalue->u.alphabetical_index_mark_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 112;
         break;

      case (TM_CTXT|TM_CONS|112):
         pvalue->u.alphabetical_index_mark
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark);

         if (pvalue->u.alphabetical_index_mark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index_mark (pvalue->u.alphabetical_index_mark);
         stat = asn1D_Odf_Alphabetical_index_mark (pctxt, 
            pvalue->u.alphabetical_index_mark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 113;
         break;

      case (TM_CTXT|TM_CONS|113):
         pvalue->u.bibliography_mark
             = rtxMemAllocType (pctxt, Odf_Bibliography_mark);

         if (pvalue->u.bibliography_mark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bibliography_mark (pvalue->u.bibliography_mark);
         stat = asn1D_Odf_Bibliography_mark (pctxt, 
            pvalue->u.bibliography_mark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 114;
         break;

      case (TM_CTXT|TM_CONS|114):
         pvalue->u.header = rtxMemAllocType (pctxt, Ns10_Header);

         if (pvalue->u.header == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns10_Header ((Ns10_Header*)pvalue->u.header);
         stat = asn1D_Ns10_Header (pctxt, 
            (Ns10_Header*)pvalue->u.header, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 115;
         break;

      case (TM_CTXT|TM_CONS|115):
         pvalue->u.footer = rtxMemAllocType (pctxt, Ns10_Footer);

         if (pvalue->u.footer == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns10_Footer ((Ns10_Footer*)pvalue->u.footer);
         stat = asn1D_Ns10_Footer (pctxt, 
            (Ns10_Footer*)pvalue->u.footer, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 116;
         break;

      case (TM_CTXT|TM_CONS|116):
         pvalue->u.date_time = rtxMemAllocType (pctxt, Ns10_Date_time);

         if (pvalue->u.date_time == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns10_Date_time ((Ns10_Date_time*)pvalue->u.date_time);
         stat = asn1D_Ns10_Date_time (pctxt, 
            (Ns10_Date_time*)pvalue->u.date_time, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 117;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Ruby_base_element (OSCTXT* pctxt, Odf_Ruby_base_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("s"), 1}, 0}, 0 },
      {{{OSUTF8("tab"), 3}, 0}, 1 },
      {{{OSUTF8("line-break"), 10}, 0}, 2 },
      {{{OSUTF8("span"), 4}, 0}, 3 },
      {{{OSUTF8("a"), 1}, 0}, 4 },
      {{{OSUTF8("bookmark"), 8}, 0}, 5 },
      {{{OSUTF8("bookmark-start"), 14}, 0}, 6 },
      {{{OSUTF8("bookmark-end"), 12}, 0}, 7 },
      {{{OSUTF8("reference-mark"), 14}, 0}, 8 },
      {{{OSUTF8("reference-mark-start"), 20}, 0}, 9 },
      {{{OSUTF8("reference-mark-end"), 18}, 0}, 10 },
      {{{OSUTF8("note"), 4}, 0}, 11 },
      {{{OSUTF8("ruby"), 4}, 0}, 12 },
      {{{OSUTF8("annotation"), 10}, 0}, 13 },
      {{{OSUTF8("change"), 6}, 0}, 14 },
      {{{OSUTF8("change-start"), 12}, 0}, 15 },
      {{{OSUTF8("change-end"), 10}, 0}, 16 },
      {{{OSUTF8("rect"), 4}, 0}, 17 },
      {{{OSUTF8("line"), 4}, 0}, 18 },
      {{{OSUTF8("polyline"), 8}, 0}, 19 },
      {{{OSUTF8("polygon"), 7}, 0}, 20 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 21 },
      {{{OSUTF8("path"), 4}, 0}, 22 },
      {{{OSUTF8("circle"), 6}, 0}, 23 },
      {{{OSUTF8("ellipse"), 7}, 0}, 24 },
      {{{OSUTF8("g"), 1}, 0}, 25 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 26 },
      {{{OSUTF8("frame"), 5}, 0}, 27 },
      {{{OSUTF8("measure"), 7}, 0}, 28 },
      {{{OSUTF8("caption"), 7}, 0}, 29 },
      {{{OSUTF8("connector"), 9}, 0}, 30 },
      {{{OSUTF8("control"), 7}, 0}, 31 },
      {{{OSUTF8("scene"), 5}, 0}, 32 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 33 },
      {{{OSUTF8("a"), 1}, 0}, 34 },
      {{{OSUTF8("date"), 4}, 0}, 35 },
      {{{OSUTF8("time"), 4}, 0}, 36 },
      {{{OSUTF8("page-number"), 11}, 0}, 37 },
      {{{OSUTF8("page-continuation"), 17}, 0}, 38 },
      {{{OSUTF8("sender-firstname"), 16}, 0}, 39 },
      {{{OSUTF8("sender-lastname"), 15}, 0}, 40 },
      {{{OSUTF8("sender-initials"), 15}, 0}, 41 },
      {{{OSUTF8("sender-title"), 12}, 0}, 42 },
      {{{OSUTF8("sender-position"), 15}, 0}, 43 },
      {{{OSUTF8("sender-email"), 12}, 0}, 44 },
      {{{OSUTF8("sender-phone-private"), 20}, 0}, 45 },
      {{{OSUTF8("sender-fax"), 10}, 0}, 46 },
      {{{OSUTF8("sender-company"), 14}, 0}, 47 },
      {{{OSUTF8("sender-phone-work"), 17}, 0}, 48 },
      {{{OSUTF8("sender-street"), 13}, 0}, 49 },
      {{{OSUTF8("sender-city"), 11}, 0}, 50 },
      {{{OSUTF8("sender-postal-code"), 18}, 0}, 51 },
      {{{OSUTF8("sender-country"), 14}, 0}, 52 },
      {{{OSUTF8("sender-state-or-province"), 24}, 0}, 53 },
      {{{OSUTF8("author-name"), 11}, 0}, 54 },
      {{{OSUTF8("author-initials"), 15}, 0}, 55 },
      {{{OSUTF8("chapter"), 7}, 0}, 56 },
      {{{OSUTF8("file-name"), 9}, 0}, 57 },
      {{{OSUTF8("template-name"), 13}, 0}, 58 },
      {{{OSUTF8("sheet-name"), 10}, 0}, 59 },
      {{{OSUTF8("variable-set"), 12}, 0}, 60 },
      {{{OSUTF8("variable-get"), 12}, 0}, 61 },
      {{{OSUTF8("variable-input"), 14}, 0}, 62 },
      {{{OSUTF8("user-field-get"), 14}, 0}, 63 },
      {{{OSUTF8("user-field-input"), 16}, 0}, 64 },
      {{{OSUTF8("sequence"), 8}, 0}, 65 },
      {{{OSUTF8("expression"), 10}, 0}, 66 },
      {{{OSUTF8("text-input"), 10}, 0}, 67 },
      {{{OSUTF8("initial-creator"), 15}, 0}, 68 },
      {{{OSUTF8("creation-date"), 13}, 0}, 69 },
      {{{OSUTF8("creation-time"), 13}, 0}, 70 },
      {{{OSUTF8("description"), 11}, 0}, 71 },
      {{{OSUTF8("user-defined"), 12}, 0}, 72 },
      {{{OSUTF8("print-time"), 10}, 0}, 73 },
      {{{OSUTF8("print-date"), 10}, 0}, 74 },
      {{{OSUTF8("printed-by"), 10}, 0}, 75 },
      {{{OSUTF8("title"), 5}, 0}, 76 },
      {{{OSUTF8("subject"), 7}, 0}, 77 },
      {{{OSUTF8("keywords"), 8}, 0}, 78 },
      {{{OSUTF8("editing-cycles"), 14}, 0}, 79 },
      {{{OSUTF8("editing-duration"), 16}, 0}, 80 },
      {{{OSUTF8("modification-time"), 17}, 0}, 81 },
      {{{OSUTF8("modification-date"), 17}, 0}, 82 },
      {{{OSUTF8("creator"), 7}, 0}, 83 },
      {{{OSUTF8("page-count"), 10}, 0}, 84 },
      {{{OSUTF8("paragraph-count"), 15}, 0}, 84 },
      {{{OSUTF8("word-count"), 10}, 0}, 84 },
      {{{OSUTF8("character-count"), 15}, 0}, 84 },
      {{{OSUTF8("table-count"), 11}, 0}, 84 },
      {{{OSUTF8("image-count"), 11}, 0}, 84 },
      {{{OSUTF8("object-count"), 12}, 0}, 84 },
      {{{OSUTF8("database-display"), 16}, 0}, 85 },
      {{{OSUTF8("database-next"), 13}, 0}, 86 },
      {{{OSUTF8("database-row-select"), 19}, 0}, 87 },
      {{{OSUTF8("database-row-number"), 19}, 0}, 88 },
      {{{OSUTF8("database-name"), 13}, 0}, 89 },
      {{{OSUTF8("page-variable-set"), 17}, 0}, 90 },
      {{{OSUTF8("page-variable-get"), 17}, 0}, 91 },
      {{{OSUTF8("placeholder"), 11}, 0}, 92 },
      {{{OSUTF8("conditional-text"), 16}, 0}, 93 },
      {{{OSUTF8("hidden-text"), 11}, 0}, 94 },
      {{{OSUTF8("reference-ref"), 13}, 0}, 95 },
      {{{OSUTF8("bookmark-ref"), 12}, 0}, 95 },
      {{{OSUTF8("note-ref"), 8}, 0}, 96 },
      {{{OSUTF8("sequence-ref"), 12}, 0}, 97 },
      {{{OSUTF8("script"), 6}, 0}, 98 },
      {{{OSUTF8("execute-macro"), 13}, 0}, 99 },
      {{{OSUTF8("hidden-paragraph"), 16}, 0}, 100 },
      {{{OSUTF8("dde-connection"), 14}, 0}, 101 },
      {{{OSUTF8("measure"), 7}, 0}, 102 },
      {{{OSUTF8("table-formula"), 13}, 0}, 103 },
      {{{OSUTF8("toc-mark-start"), 14}, 0}, 104 },
      {{{OSUTF8("toc-mark-end"), 12}, 0}, 105 },
      {{{OSUTF8("toc-mark"), 8}, 0}, 106 },
      {{{OSUTF8("user-index-mark-start"), 21}, 0}, 107 },
      {{{OSUTF8("user-index-mark-end"), 19}, 0}, 108 },
      {{{OSUTF8("user-index-mark"), 15}, 0}, 109 },
      {{{OSUTF8("alphabetical-index-mark-start"), 29}, 0}, 110 },
      {{{OSUTF8("alphabetical-index-mark-end"), 27}, 0}, 111 },
      {{{OSUTF8("alphabetical-index-mark"), 23}, 0}, 112 },
      {{{OSUTF8("bibliography-mark"), 17}, 0}, 113 },
      {{{OSUTF8("header"), 6}, 0}, 114 },
      {{{OSUTF8("footer"), 6}, 0}, 115 },
      {{{OSUTF8("date-time"), 9}, 0}, 116 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 124, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* s */
      pvalue->u.s = rtxMemAllocType (pctxt, Odf_S);

      if (pvalue->u.s == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_S (pvalue->u.s);

      stat = XmlDec_Odf_S (pctxt, pvalue->u.s);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* tab */
      pvalue->u.tab = rtxMemAllocType (pctxt, Odf_Tab);

      if (pvalue->u.tab == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Tab (pvalue->u.tab);

      stat = XmlDec_Odf_Tab (pctxt, pvalue->u.tab);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* line-break */
      pvalue->u.line_break = rtxMemAllocType (pctxt, Odf_Line_break);

      if (pvalue->u.line_break == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Line_break (pvalue->u.line_break);

      stat = XmlDec_Odf_Line_break (pctxt, pvalue->u.line_break);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* span */
      pvalue->u.span = rtxMemAllocType (pctxt, Odf_Span);

      if (pvalue->u.span == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Span ((Odf_Span*)pvalue->u.span);

      stat = XmlDec_Odf_Span (pctxt, pvalue->u.span);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* a */
      pvalue->u.a = rtxMemAllocType (pctxt, Odf_A);

      if (pvalue->u.a == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_A ((Odf_A*)pvalue->u.a);

      stat = XmlDec_Odf_A (pctxt, pvalue->u.a);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* bookmark */
      pvalue->u.bookmark = rtxMemAllocType (pctxt, Odf_Bookmark);

      if (pvalue->u.bookmark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bookmark (pvalue->u.bookmark);

      stat = XmlDec_Odf_Bookmark (pctxt, pvalue->u.bookmark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* bookmark-start */
      pvalue->u.bookmark_start = rtxMemAllocType (pctxt, Odf_Bookmark_start);

      if (pvalue->u.bookmark_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bookmark_start (pvalue->u.bookmark_start);

      stat = XmlDec_Odf_Bookmark_start (pctxt, pvalue->u.bookmark_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* bookmark-end */
      pvalue->u.bookmark_end = rtxMemAllocType (pctxt, Odf_Bookmark_end);

      if (pvalue->u.bookmark_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bookmark_end (pvalue->u.bookmark_end);

      stat = XmlDec_Odf_Bookmark_end (pctxt, pvalue->u.bookmark_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* reference-mark */
      pvalue->u.reference_mark = rtxMemAllocType (pctxt, Odf_Reference_mark);

      if (pvalue->u.reference_mark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Reference_mark (pvalue->u.reference_mark);

      stat = XmlDec_Odf_Reference_mark (pctxt, pvalue->u.reference_mark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* reference-mark-start */
      pvalue->u.reference_mark_start
          = rtxMemAllocType (pctxt, Odf_Reference_mark_start);

      if (pvalue->u.reference_mark_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Reference_mark_start (pvalue->u.reference_mark_start);

      stat = XmlDec_Odf_Reference_mark_start (pctxt, pvalue->
         u.reference_mark_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* reference-mark-end */
      pvalue->u.reference_mark_end
          = rtxMemAllocType (pctxt, Odf_Reference_mark_end);

      if (pvalue->u.reference_mark_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Reference_mark_end (pvalue->u.reference_mark_end);

      stat = XmlDec_Odf_Reference_mark_end (pctxt, pvalue->u.reference_mark_end
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* note */
      pvalue->u.note = rtxMemAllocType (pctxt, Odf_Note);

      if (pvalue->u.note == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Note ((Odf_Note*)pvalue->u.note);

      stat = XmlDec_Odf_Note (pctxt, pvalue->u.note);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* ruby */
      pvalue->u.ruby = rtxMemAllocType (pctxt, Odf_Ruby);

      if (pvalue->u.ruby == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Ruby ((Odf_Ruby*)pvalue->u.ruby);

      stat = XmlDec_Odf_Ruby (pctxt, pvalue->u.ruby);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* annotation */
      pvalue->u.annotation = rtxMemAllocType (pctxt, Ns13_Annotation);

      if (pvalue->u.annotation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns13_Annotation ((Ns13_Annotation*)pvalue->u.annotation);

      stat = XmlDec_Ns13_Annotation (pctxt, pvalue->u.annotation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* change */
      pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

      if (pvalue->u.change == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change (pvalue->u.change);

      stat = XmlDec_Odf_Change (pctxt, pvalue->u.change);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* change-start */
      pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

      if (pvalue->u.change_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_start (pvalue->u.change_start);

      stat = XmlDec_Odf_Change_start (pctxt, pvalue->u.change_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* change-end */
      pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

      if (pvalue->u.change_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_end (pvalue->u.change_end);

      stat = XmlDec_Odf_Change_end (pctxt, pvalue->u.change_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 17: { /* rect */
      pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

      if (pvalue->u.rect == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);

      stat = XmlDec_Ns3_Rect (pctxt, pvalue->u.rect);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 18: { /* line */
      pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

      if (pvalue->u.line == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);

      stat = XmlDec_Ns3_Line (pctxt, pvalue->u.line);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 19: { /* polyline */
      pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

      if (pvalue->u.polyline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);

      stat = XmlDec_Ns3_Polyline (pctxt, pvalue->u.polyline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 20: { /* polygon */
      pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

      if (pvalue->u.polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);

      stat = XmlDec_Ns3_Polygon (pctxt, pvalue->u.polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 21: { /* regular-polygon */
      pvalue->u.regular_polygon
          = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

      if (pvalue->u.regular_polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->
         u.regular_polygon);

      stat = XmlDec_Ns3_Regular_polygon (pctxt, pvalue->u.regular_polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 22: { /* path */
      pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

      if (pvalue->u.path == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);

      stat = XmlDec_Ns3_Path (pctxt, pvalue->u.path);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 23: { /* circle */
      pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

      if (pvalue->u.circle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);

      stat = XmlDec_Ns3_Circle (pctxt, pvalue->u.circle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 24: { /* ellipse */
      pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

      if (pvalue->u.ellipse == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);

      stat = XmlDec_Ns3_Ellipse (pctxt, pvalue->u.ellipse);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 25: { /* g */
      pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

      if (pvalue->u.g == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);

      stat = XmlDec_Ns3_G (pctxt, pvalue->u.g);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 26: { /* page-thumbnail */
      pvalue->u.page_thumbnail = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

      if (pvalue->u.page_thumbnail == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->
         u.page_thumbnail);

      stat = XmlDec_Ns3_Page_thumbnail (pctxt, pvalue->u.page_thumbnail);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 27: { /* frame */
      pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

      if (pvalue->u.frame == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);

      stat = XmlDec_Ns3_Frame (pctxt, pvalue->u.frame);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 28: { /* measure */
      pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

      if (pvalue->u.measure == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);

      stat = XmlDec_Ns3_Measure (pctxt, pvalue->u.measure);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 29: { /* caption */
      pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

      if (pvalue->u.caption == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);

      stat = XmlDec_Ns3_Caption (pctxt, pvalue->u.caption);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 30: { /* connector */
      pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

      if (pvalue->u.connector == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);

      stat = XmlDec_Ns3_Connector (pctxt, pvalue->u.connector);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 31: { /* control */
      pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

      if (pvalue->u.control == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);

      stat = XmlDec_Ns3_Control (pctxt, pvalue->u.control);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 32: { /* scene */
      pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

      if (pvalue->u.scene == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);

      stat = XmlDec_Ns7_Scene (pctxt, pvalue->u.scene);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 33: { /* custom-shape */
      pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

      if (pvalue->u.custom_shape == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);

      stat = XmlDec_Ns3_Custom_shape (pctxt, pvalue->u.custom_shape);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 34: { /* a */
      pvalue->u.a_1 = rtxMemAllocType (pctxt, Ns3_A);

      if (pvalue->u.a_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_A ((Ns3_A*)pvalue->u.a_1);

      stat = XmlDec_Ns3_A (pctxt, pvalue->u.a_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 35: { /* date */
      pvalue->u.date = rtxMemAllocType (pctxt, Odf_Date);

      if (pvalue->u.date == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Date (pvalue->u.date);

      stat = XmlDec_Odf_Date (pctxt, pvalue->u.date);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 36: { /* time */
      pvalue->u.time_ = rtxMemAllocType (pctxt, Odf_Time);

      if (pvalue->u.time_ == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Time (pvalue->u.time_);

      stat = XmlDec_Odf_Time (pctxt, pvalue->u.time_);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 37: { /* page-number */
      pvalue->u.page_number = rtxMemAllocType (pctxt, Odf_Page_number);

      if (pvalue->u.page_number == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Page_number (pvalue->u.page_number);

      stat = XmlDec_Odf_Page_number (pctxt, pvalue->u.page_number);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 38: { /* page-continuation */
      pvalue->u.page_continuation
          = rtxMemAllocType (pctxt, Odf_Page_continuation);

      if (pvalue->u.page_continuation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Page_continuation (pvalue->u.page_continuation);

      stat = XmlDec_Odf_Page_continuation (pctxt, pvalue->u.page_continuation
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 39: { /* sender-firstname */
      pvalue->u.sender_firstname
          = rtxMemAllocType (pctxt, Odf_Sender_firstname);

      if (pvalue->u.sender_firstname == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_firstname (pvalue->u.sender_firstname);

      stat = XmlDec_Odf_Sender_firstname (pctxt, pvalue->u.sender_firstname);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 40: { /* sender-lastname */
      pvalue->u.sender_lastname
          = rtxMemAllocType (pctxt, Odf_Sender_lastname);

      if (pvalue->u.sender_lastname == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_lastname (pvalue->u.sender_lastname);

      stat = XmlDec_Odf_Sender_lastname (pctxt, pvalue->u.sender_lastname);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 41: { /* sender-initials */
      pvalue->u.sender_initials
          = rtxMemAllocType (pctxt, Odf_Sender_initials);

      if (pvalue->u.sender_initials == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_initials (pvalue->u.sender_initials);

      stat = XmlDec_Odf_Sender_initials (pctxt, pvalue->u.sender_initials);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 42: { /* sender-title */
      pvalue->u.sender_title = rtxMemAllocType (pctxt, Odf_Sender_title);

      if (pvalue->u.sender_title == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_title (pvalue->u.sender_title);

      stat = XmlDec_Odf_Sender_title (pctxt, pvalue->u.sender_title);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 43: { /* sender-position */
      pvalue->u.sender_position
          = rtxMemAllocType (pctxt, Odf_Sender_position);

      if (pvalue->u.sender_position == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_position (pvalue->u.sender_position);

      stat = XmlDec_Odf_Sender_position (pctxt, pvalue->u.sender_position);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 44: { /* sender-email */
      pvalue->u.sender_email = rtxMemAllocType (pctxt, Odf_Sender_email);

      if (pvalue->u.sender_email == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_email (pvalue->u.sender_email);

      stat = XmlDec_Odf_Sender_email (pctxt, pvalue->u.sender_email);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 45: { /* sender-phone-private */
      pvalue->u.sender_phone_private
          = rtxMemAllocType (pctxt, Odf_Sender_phone_private);

      if (pvalue->u.sender_phone_private == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_phone_private (pvalue->u.sender_phone_private);

      stat = XmlDec_Odf_Sender_phone_private (pctxt, pvalue->
         u.sender_phone_private);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 46: { /* sender-fax */
      pvalue->u.sender_fax = rtxMemAllocType (pctxt, Odf_Sender_fax);

      if (pvalue->u.sender_fax == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_fax (pvalue->u.sender_fax);

      stat = XmlDec_Odf_Sender_fax (pctxt, pvalue->u.sender_fax);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 47: { /* sender-company */
      pvalue->u.sender_company = rtxMemAllocType (pctxt, Odf_Sender_company);

      if (pvalue->u.sender_company == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_company (pvalue->u.sender_company);

      stat = XmlDec_Odf_Sender_company (pctxt, pvalue->u.sender_company);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 48: { /* sender-phone-work */
      pvalue->u.sender_phone_work
          = rtxMemAllocType (pctxt, Odf_Sender_phone_work);

      if (pvalue->u.sender_phone_work == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_phone_work (pvalue->u.sender_phone_work);

      stat = XmlDec_Odf_Sender_phone_work (pctxt, pvalue->u.sender_phone_work
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 49: { /* sender-street */
      pvalue->u.sender_street = rtxMemAllocType (pctxt, Odf_Sender_street);

      if (pvalue->u.sender_street == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_street (pvalue->u.sender_street);

      stat = XmlDec_Odf_Sender_street (pctxt, pvalue->u.sender_street);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 50: { /* sender-city */
      pvalue->u.sender_city = rtxMemAllocType (pctxt, Odf_Sender_city);

      if (pvalue->u.sender_city == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_city (pvalue->u.sender_city);

      stat = XmlDec_Odf_Sender_city (pctxt, pvalue->u.sender_city);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 51: { /* sender-postal-code */
      pvalue->u.sender_postal_code
          = rtxMemAllocType (pctxt, Odf_Sender_postal_code);

      if (pvalue->u.sender_postal_code == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_postal_code (pvalue->u.sender_postal_code);

      stat = XmlDec_Odf_Sender_postal_code (pctxt, pvalue->u.sender_postal_code
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 52: { /* sender-country */
      pvalue->u.sender_country = rtxMemAllocType (pctxt, Odf_Sender_country);

      if (pvalue->u.sender_country == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_country (pvalue->u.sender_country);

      stat = XmlDec_Odf_Sender_country (pctxt, pvalue->u.sender_country);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 53: { /* sender-state-or-province */
      pvalue->u.sender_state_or_province
          = rtxMemAllocType (pctxt, Odf_Sender_state_or_province);

      if (pvalue->u.sender_state_or_province == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_state_or_province (pvalue->u.sender_state_or_province
         );

      stat = XmlDec_Odf_Sender_state_or_province (pctxt, pvalue->
         u.sender_state_or_province);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 54: { /* author-name */
      pvalue->u.author_name = rtxMemAllocType (pctxt, Odf_Author_name);

      if (pvalue->u.author_name == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Author_name (pvalue->u.author_name);

      stat = XmlDec_Odf_Author_name (pctxt, pvalue->u.author_name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 55: { /* author-initials */
      pvalue->u.author_initials
          = rtxMemAllocType (pctxt, Odf_Author_initials);

      if (pvalue->u.author_initials == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Author_initials (pvalue->u.author_initials);

      stat = XmlDec_Odf_Author_initials (pctxt, pvalue->u.author_initials);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 56: { /* chapter */
      pvalue->u.chapter = rtxMemAllocType (pctxt, Odf_Chapter);

      if (pvalue->u.chapter == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Chapter (pvalue->u.chapter);

      stat = XmlDec_Odf_Chapter (pctxt, pvalue->u.chapter);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 57: { /* file-name */
      pvalue->u.file_name = rtxMemAllocType (pctxt, Odf_File_name);

      if (pvalue->u.file_name == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_File_name (pvalue->u.file_name);

      stat = XmlDec_Odf_File_name (pctxt, pvalue->u.file_name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 58: { /* template-name */
      pvalue->u.template_name = rtxMemAllocType (pctxt, Odf_Template_name);

      if (pvalue->u.template_name == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Template_name (pvalue->u.template_name);

      stat = XmlDec_Odf_Template_name (pctxt, pvalue->u.template_name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 59: { /* sheet-name */
      stat = XmlDec_Odf_Sheet_name (pctxt, &pvalue->u.sheet_name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 60: { /* variable-set */
      pvalue->u.variable_set = rtxMemAllocType (pctxt, Odf_Variable_set);

      if (pvalue->u.variable_set == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Variable_set (pvalue->u.variable_set);

      stat = XmlDec_Odf_Variable_set (pctxt, pvalue->u.variable_set);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 61: { /* variable-get */
      pvalue->u.variable_get = rtxMemAllocType (pctxt, Odf_Variable_get);

      if (pvalue->u.variable_get == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Variable_get (pvalue->u.variable_get);

      stat = XmlDec_Odf_Variable_get (pctxt, pvalue->u.variable_get);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 62: { /* variable-input */
      pvalue->u.variable_input = rtxMemAllocType (pctxt, Odf_Variable_input);

      if (pvalue->u.variable_input == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Variable_input (pvalue->u.variable_input);

      stat = XmlDec_Odf_Variable_input (pctxt, pvalue->u.variable_input);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 63: { /* user-field-get */
      pvalue->u.user_field_get = rtxMemAllocType (pctxt, Odf_User_field_get);

      if (pvalue->u.user_field_get == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_field_get (pvalue->u.user_field_get);

      stat = XmlDec_Odf_User_field_get (pctxt, pvalue->u.user_field_get);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 64: { /* user-field-input */
      pvalue->u.user_field_input
          = rtxMemAllocType (pctxt, Odf_User_field_input);

      if (pvalue->u.user_field_input == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_field_input (pvalue->u.user_field_input);

      stat = XmlDec_Odf_User_field_input (pctxt, pvalue->u.user_field_input);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 65: { /* sequence */
      pvalue->u.sequence = rtxMemAllocType (pctxt, Odf_Sequence);

      if (pvalue->u.sequence == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sequence (pvalue->u.sequence);

      stat = XmlDec_Odf_Sequence (pctxt, pvalue->u.sequence);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 66: { /* expression */
      pvalue->u.expression = rtxMemAllocType (pctxt, Odf_Expression);

      if (pvalue->u.expression == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Expression (pvalue->u.expression);

      stat = XmlDec_Odf_Expression (pctxt, pvalue->u.expression);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 67: { /* text-input */
      pvalue->u.text_input = rtxMemAllocType (pctxt, Odf_Text_input);

      if (pvalue->u.text_input == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Text_input (pvalue->u.text_input);

      stat = XmlDec_Odf_Text_input (pctxt, pvalue->u.text_input);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 68: { /* initial-creator */
      pvalue->u.initial_creator
          = rtxMemAllocType (pctxt, Odf_Initial_creator);

      if (pvalue->u.initial_creator == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Initial_creator (pvalue->u.initial_creator);

      stat = XmlDec_Odf_Initial_creator (pctxt, pvalue->u.initial_creator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 69: { /* creation-date */
      pvalue->u.creation_date = rtxMemAllocType (pctxt, Odf_Creation_date);

      if (pvalue->u.creation_date == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Creation_date (pvalue->u.creation_date);

      stat = XmlDec_Odf_Creation_date (pctxt, pvalue->u.creation_date);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 70: { /* creation-time */
      pvalue->u.creation_time = rtxMemAllocType (pctxt, Odf_Creation_time);

      if (pvalue->u.creation_time == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Creation_time (pvalue->u.creation_time);

      stat = XmlDec_Odf_Creation_time (pctxt, pvalue->u.creation_time);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 71: { /* description */
      pvalue->u.description = rtxMemAllocType (pctxt, Odf_Description);

      if (pvalue->u.description == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Description (pvalue->u.description);

      stat = XmlDec_Odf_Description (pctxt, pvalue->u.description);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 72: { /* user-defined */
      pvalue->u.user_defined = rtxMemAllocType (pctxt, Odf_User_defined);

      if (pvalue->u.user_defined == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_defined (pvalue->u.user_defined);

      stat = XmlDec_Odf_User_defined (pctxt, pvalue->u.user_defined);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 73: { /* print-time */
      pvalue->u.print_time = rtxMemAllocType (pctxt, Odf_Print_time);

      if (pvalue->u.print_time == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Print_time (pvalue->u.print_time);

      stat = XmlDec_Odf_Print_time (pctxt, pvalue->u.print_time);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 74: { /* print-date */
      pvalue->u.print_date = rtxMemAllocType (pctxt, Odf_Print_date);

      if (pvalue->u.print_date == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Print_date (pvalue->u.print_date);

      stat = XmlDec_Odf_Print_date (pctxt, pvalue->u.print_date);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 75: { /* printed-by */
      pvalue->u.printed_by = rtxMemAllocType (pctxt, Odf_Printed_by);

      if (pvalue->u.printed_by == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Printed_by (pvalue->u.printed_by);

      stat = XmlDec_Odf_Printed_by (pctxt, pvalue->u.printed_by);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 76: { /* title */
      pvalue->u.title = rtxMemAllocType (pctxt, Odf_Title);

      if (pvalue->u.title == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Title (pvalue->u.title);

      stat = XmlDec_Odf_Title (pctxt, pvalue->u.title);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 77: { /* subject */
      pvalue->u.subject = rtxMemAllocType (pctxt, Odf_Subject);

      if (pvalue->u.subject == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Subject (pvalue->u.subject);

      stat = XmlDec_Odf_Subject (pctxt, pvalue->u.subject);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 78: { /* keywords */
      pvalue->u.keywords = rtxMemAllocType (pctxt, Odf_Keywords);

      if (pvalue->u.keywords == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Keywords (pvalue->u.keywords);

      stat = XmlDec_Odf_Keywords (pctxt, pvalue->u.keywords);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 79: { /* editing-cycles */
      pvalue->u.editing_cycles = rtxMemAllocType (pctxt, Odf_Editing_cycles);

      if (pvalue->u.editing_cycles == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Editing_cycles (pvalue->u.editing_cycles);

      stat = XmlDec_Odf_Editing_cycles (pctxt, pvalue->u.editing_cycles);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 80: { /* editing-duration */
      pvalue->u.editing_duration
          = rtxMemAllocType (pctxt, Odf_Editing_duration);

      if (pvalue->u.editing_duration == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Editing_duration (pvalue->u.editing_duration);

      stat = XmlDec_Odf_Editing_duration (pctxt, pvalue->u.editing_duration);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 81: { /* modification-time */
      pvalue->u.modification_time
          = rtxMemAllocType (pctxt, Odf_Modification_time);

      if (pvalue->u.modification_time == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Modification_time (pvalue->u.modification_time);

      stat = XmlDec_Odf_Modification_time (pctxt, pvalue->u.modification_time
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 82: { /* modification-date */
      pvalue->u.modification_date
          = rtxMemAllocType (pctxt, Odf_Modification_date);

      if (pvalue->u.modification_date == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Modification_date (pvalue->u.modification_date);

      stat = XmlDec_Odf_Modification_date (pctxt, pvalue->u.modification_date
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 83: { /* creator */
      pvalue->u.creator = rtxMemAllocType (pctxt, Odf_Creator);

      if (pvalue->u.creator == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Creator (pvalue->u.creator);

      stat = XmlDec_Odf_Creator (pctxt, pvalue->u.creator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 84: { /*  */
      pvalue->u.element271 = rtxMemAllocType (pctxt, Odf_Element271_group);

      if (pvalue->u.element271 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Element271_group (pvalue->u.element271);

      stat = XmlDec_Odf_Element271_group (pctxt, pvalue->u.element271);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 85: { /* database-display */
      pvalue->u.database_display
          = rtxMemAllocType (pctxt, Odf_Database_display);

      if (pvalue->u.database_display == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Database_display (pvalue->u.database_display);

      stat = XmlDec_Odf_Database_display (pctxt, pvalue->u.database_display);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 86: { /* database-next */
      pvalue->u.database_next = rtxMemAllocType (pctxt, Odf_Database_next);

      if (pvalue->u.database_next == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Database_next (pvalue->u.database_next);

      stat = XmlDec_Odf_Database_next (pctxt, pvalue->u.database_next);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 87: { /* database-row-select */
      pvalue->u.database_row_select
          = rtxMemAllocType (pctxt, Odf_Database_row_select);

      if (pvalue->u.database_row_select == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Database_row_select (pvalue->u.database_row_select);

      stat = XmlDec_Odf_Database_row_select (pctxt, pvalue->
         u.database_row_select);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 88: { /* database-row-number */
      pvalue->u.database_row_number
          = rtxMemAllocType (pctxt, Odf_Database_row_number);

      if (pvalue->u.database_row_number == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Database_row_number (pvalue->u.database_row_number);

      stat = XmlDec_Odf_Database_row_number (pctxt, pvalue->
         u.database_row_number);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 89: { /* database-name */
      pvalue->u.database_name = rtxMemAllocType (pctxt, Odf_Database_name);

      if (pvalue->u.database_name == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Database_name (pvalue->u.database_name);

      stat = XmlDec_Odf_Database_name (pctxt, pvalue->u.database_name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 90: { /* page-variable-set */
      pvalue->u.page_variable_set
          = rtxMemAllocType (pctxt, Odf_Page_variable_set);

      if (pvalue->u.page_variable_set == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Page_variable_set (pvalue->u.page_variable_set);

      stat = XmlDec_Odf_Page_variable_set (pctxt, pvalue->u.page_variable_set
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 91: { /* page-variable-get */
      pvalue->u.page_variable_get
          = rtxMemAllocType (pctxt, Odf_Page_variable_get);

      if (pvalue->u.page_variable_get == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Page_variable_get (pvalue->u.page_variable_get);

      stat = XmlDec_Odf_Page_variable_get (pctxt, pvalue->u.page_variable_get
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 92: { /* placeholder */
      pvalue->u.placeholder = rtxMemAllocType (pctxt, Odf_Placeholder);

      if (pvalue->u.placeholder == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Placeholder (pvalue->u.placeholder);

      stat = XmlDec_Odf_Placeholder (pctxt, pvalue->u.placeholder);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 93: { /* conditional-text */
      pvalue->u.conditional_text
          = rtxMemAllocType (pctxt, Odf_Conditional_text);

      if (pvalue->u.conditional_text == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Conditional_text (pvalue->u.conditional_text);

      stat = XmlDec_Odf_Conditional_text (pctxt, pvalue->u.conditional_text);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 94: { /* hidden-text */
      pvalue->u.hidden_text = rtxMemAllocType (pctxt, Odf_Hidden_text);

      if (pvalue->u.hidden_text == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Hidden_text (pvalue->u.hidden_text);

      stat = XmlDec_Odf_Hidden_text (pctxt, pvalue->u.hidden_text);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 95: { /*  */
      pvalue->u.element282 = rtxMemAllocType (pctxt, Odf_Element282_group);

      if (pvalue->u.element282 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Element282_group (pvalue->u.element282);

      stat = XmlDec_Odf_Element282_group (pctxt, pvalue->u.element282);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 96: { /* note-ref */
      pvalue->u.note_ref = rtxMemAllocType (pctxt, Odf_Note_ref);

      if (pvalue->u.note_ref == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Note_ref (pvalue->u.note_ref);

      stat = XmlDec_Odf_Note_ref (pctxt, pvalue->u.note_ref);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 97: { /* sequence-ref */
      pvalue->u.sequence_ref = rtxMemAllocType (pctxt, Odf_Sequence_ref);

      if (pvalue->u.sequence_ref == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sequence_ref (pvalue->u.sequence_ref);

      stat = XmlDec_Odf_Sequence_ref (pctxt, pvalue->u.sequence_ref);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 98: { /* script */
      pvalue->u.script = rtxMemAllocType (pctxt, Odf_Script);

      if (pvalue->u.script == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Script (pvalue->u.script);

      stat = XmlDec_Odf_Script (pctxt, pvalue->u.script);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 99: { /* execute-macro */
      pvalue->u.execute_macro = rtxMemAllocType (pctxt, Odf_Execute_macro);

      if (pvalue->u.execute_macro == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Execute_macro (pvalue->u.execute_macro);

      stat = XmlDec_Odf_Execute_macro (pctxt, pvalue->u.execute_macro);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 100: { /* hidden-paragraph */
      pvalue->u.hidden_paragraph
          = rtxMemAllocType (pctxt, Odf_Hidden_paragraph);

      if (pvalue->u.hidden_paragraph == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Hidden_paragraph (pvalue->u.hidden_paragraph);

      stat = XmlDec_Odf_Hidden_paragraph (pctxt, pvalue->u.hidden_paragraph);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 101: { /* dde-connection */
      pvalue->u.dde_connection = rtxMemAllocType (pctxt, Odf_Dde_connection);

      if (pvalue->u.dde_connection == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Dde_connection (pvalue->u.dde_connection);

      stat = XmlDec_Odf_Dde_connection (pctxt, pvalue->u.dde_connection);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 102: { /* measure */
      pvalue->u.measure_1 = rtxMemAllocType (pctxt, Odf_Measure);

      if (pvalue->u.measure_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Measure (pvalue->u.measure_1);

      stat = XmlDec_Odf_Measure (pctxt, pvalue->u.measure_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 103: { /* table-formula */
      pvalue->u.table_formula = rtxMemAllocType (pctxt, Odf_Table_formula);

      if (pvalue->u.table_formula == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_formula (pvalue->u.table_formula);

      stat = XmlDec_Odf_Table_formula (pctxt, pvalue->u.table_formula);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 104: { /* toc-mark-start */
      pvalue->u.toc_mark_start = rtxMemAllocType (pctxt, Odf_Toc_mark_start);

      if (pvalue->u.toc_mark_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Toc_mark_start (pvalue->u.toc_mark_start);

      stat = XmlDec_Odf_Toc_mark_start (pctxt, pvalue->u.toc_mark_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 105: { /* toc-mark-end */
      pvalue->u.toc_mark_end = rtxMemAllocType (pctxt, Odf_Toc_mark_end);

      if (pvalue->u.toc_mark_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Toc_mark_end (pvalue->u.toc_mark_end);

      stat = XmlDec_Odf_Toc_mark_end (pctxt, pvalue->u.toc_mark_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 106: { /* toc-mark */
      pvalue->u.toc_mark = rtxMemAllocType (pctxt, Odf_Toc_mark);

      if (pvalue->u.toc_mark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Toc_mark (pvalue->u.toc_mark);

      stat = XmlDec_Odf_Toc_mark (pctxt, pvalue->u.toc_mark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 107: { /* user-index-mark-start */
      pvalue->u.user_index_mark_start
          = rtxMemAllocType (pctxt, Odf_User_index_mark_start);

      if (pvalue->u.user_index_mark_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index_mark_start (pvalue->u.user_index_mark_start);

      stat = XmlDec_Odf_User_index_mark_start (pctxt, pvalue->
         u.user_index_mark_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 108: { /* user-index-mark-end */
      pvalue->u.user_index_mark_end
          = rtxMemAllocType (pctxt, Odf_User_index_mark_end);

      if (pvalue->u.user_index_mark_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index_mark_end (pvalue->u.user_index_mark_end);

      stat = XmlDec_Odf_User_index_mark_end (pctxt, pvalue->
         u.user_index_mark_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 109: { /* user-index-mark */
      pvalue->u.user_index_mark
          = rtxMemAllocType (pctxt, Odf_User_index_mark);

      if (pvalue->u.user_index_mark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index_mark (pvalue->u.user_index_mark);

      stat = XmlDec_Odf_User_index_mark (pctxt, pvalue->u.user_index_mark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 110: { /* alphabetical-index-mark-start */
      pvalue->u.alphabetical_index_mark_start
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark_start);

      if (pvalue->u.alphabetical_index_mark_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index_mark_start (pvalue->
         u.alphabetical_index_mark_start);

      stat = XmlDec_Odf_Alphabetical_index_mark_start (pctxt, pvalue->
         u.alphabetical_index_mark_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 111: { /* alphabetical-index-mark-end */
      pvalue->u.alphabetical_index_mark_end
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark_end);

      if (pvalue->u.alphabetical_index_mark_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index_mark_end (pvalue->
         u.alphabetical_index_mark_end);

      stat = XmlDec_Odf_Alphabetical_index_mark_end (pctxt, pvalue->
         u.alphabetical_index_mark_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 112: { /* alphabetical-index-mark */
      pvalue->u.alphabetical_index_mark
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark);

      if (pvalue->u.alphabetical_index_mark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index_mark (pvalue->u.alphabetical_index_mark
         );

      stat = XmlDec_Odf_Alphabetical_index_mark (pctxt, pvalue->
         u.alphabetical_index_mark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 113: { /* bibliography-mark */
      pvalue->u.bibliography_mark
          = rtxMemAllocType (pctxt, Odf_Bibliography_mark);

      if (pvalue->u.bibliography_mark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bibliography_mark (pvalue->u.bibliography_mark);

      stat = XmlDec_Odf_Bibliography_mark (pctxt, pvalue->u.bibliography_mark
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 114: { /* header */
      pvalue->u.header = rtxMemAllocType (pctxt, Ns10_Header);

      if (pvalue->u.header == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns10_Header ((Ns10_Header*)pvalue->u.header);

      stat = XmlDec_Ns10_Header (pctxt, pvalue->u.header);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 115: { /* footer */
      pvalue->u.footer = rtxMemAllocType (pctxt, Ns10_Footer);

      if (pvalue->u.footer == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns10_Footer ((Ns10_Footer*)pvalue->u.footer);

      stat = XmlDec_Ns10_Footer (pctxt, pvalue->u.footer);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 116: { /* date-time */
      pvalue->u.date_time = rtxMemAllocType (pctxt, Ns10_Date_time);

      if (pvalue->u.date_time == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns10_Date_time ((Ns10_Date_time*)pvalue->u.date_time);

      stat = XmlDec_Ns10_Date_time (pctxt, pvalue->u.date_time);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ruby_base                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Ruby_base (OSCTXT* pctxt, Odf_Ruby_base *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   Odf_Ruby_base_element* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (XD_PEEKTAG (pctxt, 0x30)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_UNIV|TM_CONS|16));

   if (XD_PEEKTAG (pctxt, 0xa0)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_CTXT|TM_CONS|0));

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      if (pvalue->count >= 1) return LOG_RTERR (pctxt, RTERR_SEQOVFLW);

      rtxDListAllocNodeAndData (pctxt, Odf_Ruby_base_element, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Ruby_base_element (pdata1);

      stat = asn1D_Odf_Ruby_base_element (pctxt, 
         pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

int XmlDec_Odf_Ruby_base (OSCTXT* pctxt, Odf_Ruby_base* pvalue)
{
   int stat = 0;

   { int elemID;
   Odf_Ruby_base_element* pdata1;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("s"), 1}, 0}, 0 },
      {{{OSUTF8("tab"), 3}, 0}, 0 },
      {{{OSUTF8("line-break"), 10}, 0}, 0 },
      {{{OSUTF8("span"), 4}, 0}, 0 },
      {{{OSUTF8("a"), 1}, 0}, 0 },
      {{{OSUTF8("bookmark"), 8}, 0}, 0 },
      {{{OSUTF8("bookmark-start"), 14}, 0}, 0 },
      {{{OSUTF8("bookmark-end"), 12}, 0}, 0 },
      {{{OSUTF8("reference-mark"), 14}, 0}, 0 },
      {{{OSUTF8("reference-mark-start"), 20}, 0}, 0 },
      {{{OSUTF8("reference-mark-end"), 18}, 0}, 0 },
      {{{OSUTF8("note"), 4}, 0}, 0 },
      {{{OSUTF8("ruby"), 4}, 0}, 0 },
      {{{OSUTF8("annotation"), 10}, 0}, 0 },
      {{{OSUTF8("change"), 6}, 0}, 0 },
      {{{OSUTF8("change-start"), 12}, 0}, 0 },
      {{{OSUTF8("change-end"), 10}, 0}, 0 },
      {{{OSUTF8("rect"), 4}, 0}, 0 },
      {{{OSUTF8("line"), 4}, 0}, 0 },
      {{{OSUTF8("polyline"), 8}, 0}, 0 },
      {{{OSUTF8("polygon"), 7}, 0}, 0 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 0 },
      {{{OSUTF8("path"), 4}, 0}, 0 },
      {{{OSUTF8("circle"), 6}, 0}, 0 },
      {{{OSUTF8("ellipse"), 7}, 0}, 0 },
      {{{OSUTF8("g"), 1}, 0}, 0 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 0 },
      {{{OSUTF8("frame"), 5}, 0}, 0 },
      {{{OSUTF8("measure"), 7}, 0}, 0 },
      {{{OSUTF8("caption"), 7}, 0}, 0 },
      {{{OSUTF8("connector"), 9}, 0}, 0 },
      {{{OSUTF8("control"), 7}, 0}, 0 },
      {{{OSUTF8("scene"), 5}, 0}, 0 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 0 },
      {{{OSUTF8("date"), 4}, 0}, 0 },
      {{{OSUTF8("time"), 4}, 0}, 0 },
      {{{OSUTF8("page-number"), 11}, 0}, 0 },
      {{{OSUTF8("page-continuation"), 17}, 0}, 0 },
      {{{OSUTF8("sender-firstname"), 16}, 0}, 0 },
      {{{OSUTF8("sender-lastname"), 15}, 0}, 0 },
      {{{OSUTF8("sender-initials"), 15}, 0}, 0 },
      {{{OSUTF8("sender-title"), 12}, 0}, 0 },
      {{{OSUTF8("sender-position"), 15}, 0}, 0 },
      {{{OSUTF8("sender-email"), 12}, 0}, 0 },
      {{{OSUTF8("sender-phone-private"), 20}, 0}, 0 },
      {{{OSUTF8("sender-fax"), 10}, 0}, 0 },
      {{{OSUTF8("sender-company"), 14}, 0}, 0 },
      {{{OSUTF8("sender-phone-work"), 17}, 0}, 0 },
      {{{OSUTF8("sender-street"), 13}, 0}, 0 },
      {{{OSUTF8("sender-city"), 11}, 0}, 0 },
      {{{OSUTF8("sender-postal-code"), 18}, 0}, 0 },
      {{{OSUTF8("sender-country"), 14}, 0}, 0 },
      {{{OSUTF8("sender-state-or-province"), 24}, 0}, 0 },
      {{{OSUTF8("author-name"), 11}, 0}, 0 },
      {{{OSUTF8("author-initials"), 15}, 0}, 0 },
      {{{OSUTF8("chapter"), 7}, 0}, 0 },
      {{{OSUTF8("file-name"), 9}, 0}, 0 },
      {{{OSUTF8("template-name"), 13}, 0}, 0 },
      {{{OSUTF8("sheet-name"), 10}, 0}, 0 },
      {{{OSUTF8("variable-set"), 12}, 0}, 0 },
      {{{OSUTF8("variable-get"), 12}, 0}, 0 },
      {{{OSUTF8("variable-input"), 14}, 0}, 0 },
      {{{OSUTF8("user-field-get"), 14}, 0}, 0 },
      {{{OSUTF8("user-field-input"), 16}, 0}, 0 },
      {{{OSUTF8("sequence"), 8}, 0}, 0 },
      {{{OSUTF8("expression"), 10}, 0}, 0 },
      {{{OSUTF8("text-input"), 10}, 0}, 0 },
      {{{OSUTF8("initial-creator"), 15}, 0}, 0 },
      {{{OSUTF8("creation-date"), 13}, 0}, 0 },
      {{{OSUTF8("creation-time"), 13}, 0}, 0 },
      {{{OSUTF8("description"), 11}, 0}, 0 },
      {{{OSUTF8("user-defined"), 12}, 0}, 0 },
      {{{OSUTF8("print-time"), 10}, 0}, 0 },
      {{{OSUTF8("print-date"), 10}, 0}, 0 },
      {{{OSUTF8("printed-by"), 10}, 0}, 0 },
      {{{OSUTF8("title"), 5}, 0}, 0 },
      {{{OSUTF8("subject"), 7}, 0}, 0 },
      {{{OSUTF8("keywords"), 8}, 0}, 0 },
      {{{OSUTF8("editing-cycles"), 14}, 0}, 0 },
      {{{OSUTF8("editing-duration"), 16}, 0}, 0 },
      {{{OSUTF8("modification-time"), 17}, 0}, 0 },
      {{{OSUTF8("modification-date"), 17}, 0}, 0 },
      {{{OSUTF8("creator"), 7}, 0}, 0 },
      {{{OSUTF8("page-count"), 10}, 0}, 0 },
      {{{OSUTF8("paragraph-count"), 15}, 0}, 0 },
      {{{OSUTF8("word-count"), 10}, 0}, 0 },
      {{{OSUTF8("character-count"), 15}, 0}, 0 },
      {{{OSUTF8("table-count"), 11}, 0}, 0 },
      {{{OSUTF8("image-count"), 11}, 0}, 0 },
      {{{OSUTF8("object-count"), 12}, 0}, 0 },
      {{{OSUTF8("database-display"), 16}, 0}, 0 },
      {{{OSUTF8("database-next"), 13}, 0}, 0 },
      {{{OSUTF8("database-row-select"), 19}, 0}, 0 },
      {{{OSUTF8("database-row-number"), 19}, 0}, 0 },
      {{{OSUTF8("database-name"), 13}, 0}, 0 },
      {{{OSUTF8("page-variable-set"), 17}, 0}, 0 },
      {{{OSUTF8("page-variable-get"), 17}, 0}, 0 },
      {{{OSUTF8("placeholder"), 11}, 0}, 0 },
      {{{OSUTF8("conditional-text"), 16}, 0}, 0 },
      {{{OSUTF8("hidden-text"), 11}, 0}, 0 },
      {{{OSUTF8("reference-ref"), 13}, 0}, 0 },
      {{{OSUTF8("bookmark-ref"), 12}, 0}, 0 },
      {{{OSUTF8("note-ref"), 8}, 0}, 0 },
      {{{OSUTF8("sequence-ref"), 12}, 0}, 0 },
      {{{OSUTF8("script"), 6}, 0}, 0 },
      {{{OSUTF8("execute-macro"), 13}, 0}, 0 },
      {{{OSUTF8("hidden-paragraph"), 16}, 0}, 0 },
      {{{OSUTF8("dde-connection"), 14}, 0}, 0 },
      {{{OSUTF8("table-formula"), 13}, 0}, 0 },
      {{{OSUTF8("toc-mark-start"), 14}, 0}, 0 },
      {{{OSUTF8("toc-mark-end"), 12}, 0}, 0 },
      {{{OSUTF8("toc-mark"), 8}, 0}, 0 },
      {{{OSUTF8("user-index-mark-start"), 21}, 0}, 0 },
      {{{OSUTF8("user-index-mark-end"), 19}, 0}, 0 },
      {{{OSUTF8("user-index-mark"), 15}, 0}, 0 },
      {{{OSUTF8("alphabetical-index-mark-start"), 29}, 0}, 0 },
      {{{OSUTF8("alphabetical-index-mark-end"), 27}, 0}, 0 },
      {{{OSUTF8("alphabetical-index-mark"), 23}, 0}, 0 },
      {{{OSUTF8("bibliography-mark"), 17}, 0}, 0 },
      {{{OSUTF8("header"), 6}, 0}, 0 },
      {{{OSUTF8("footer"), 6}, 0}, 0 },
      {{{OSUTF8("date-time"), 9}, 0}, 0 }
   } ;

   rtxDListInit (pvalue);
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 122, -1, FALSE);
      if (elemID < 0 || elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0:
         rtXmlpMarkLastEventActive (pctxt);

         pdata1 = rtxMemAllocType (pctxt, Odf_Ruby_base_element);

         if (pdata1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Ruby_base_element (pdata1);

         stat = XmlDec_Odf_Ruby_base_element (pctxt, pdata1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         break;

      }
   }

   if (elemID == RTERR_UNEXPELEM || elemID == XML_OK_EOB) {
      stat = 0;
   }
   else return LOG_RTERR (pctxt, elemID);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ruby_text_style_name                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Ruby_text_style_name (OSCTXT* pctxt, 
   Odf_Ruby_text_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Ruby_text_style_name (OSCTXT* pctxt, 
   Odf_Ruby_text_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ruby_text                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Ruby_text (OSCTXT* pctxt, Odf_Ruby_text *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Ruby_text_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Ruby_text (OSCTXT* pctxt, Odf_Ruby_text* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* style-name */
            stat = XmlDec_Odf_Ruby_text_style_name (pctxt, &pvalue->style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Ruby_text");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Ruby_text");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ruby                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Ruby (OSCTXT* pctxt, Odf_Ruby *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Ruby_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode ruby_base */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Ruby_base (pctxt, 
               &pvalue->ruby_base, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode ruby_text */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Ruby_text (pctxt, 
               &pvalue->ruby_text, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Ruby (OSCTXT* pctxt, Odf_Ruby* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* style-name */
            stat = XmlDec_Odf_Ruby_style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Ruby");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Ruby");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("ruby-base"), 9}, 0}, 0 },
      {{{OSUTF8("ruby-text"), 9}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 1, -1}, {2, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* ruby-base */
         stat = XmlDec_Odf_Ruby_base (pctxt, &pvalue->ruby_base);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* ruby-text */
         stat = XmlDec_Odf_Ruby_text (pctxt, &pvalue->ruby_text);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H_element                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_H_element (OSCTXT* pctxt, Odf_H_element *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.s = rtxMemAllocType (pctxt, Odf_S);

         if (pvalue->u.s == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_S (pvalue->u.s);
         stat = asn1D_Odf_S (pctxt, 
            pvalue->u.s, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.tab = rtxMemAllocType (pctxt, Odf_Tab);

         if (pvalue->u.tab == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Tab (pvalue->u.tab);
         stat = asn1D_Odf_Tab (pctxt, 
            pvalue->u.tab, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.line_break = rtxMemAllocType (pctxt, Odf_Line_break);

         if (pvalue->u.line_break == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Line_break (pvalue->u.line_break);
         stat = asn1D_Odf_Line_break (pctxt, 
            pvalue->u.line_break, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.span = rtxMemAllocType (pctxt, Odf_Span);

         if (pvalue->u.span == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Span ((Odf_Span*)pvalue->u.span);
         stat = asn1D_Odf_Span (pctxt, 
            (Odf_Span*)pvalue->u.span, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.a = rtxMemAllocType (pctxt, Odf_A);

         if (pvalue->u.a == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_A ((Odf_A*)pvalue->u.a);
         stat = asn1D_Odf_A (pctxt, 
            (Odf_A*)pvalue->u.a, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.bookmark = rtxMemAllocType (pctxt, Odf_Bookmark);

         if (pvalue->u.bookmark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bookmark (pvalue->u.bookmark);
         stat = asn1D_Odf_Bookmark (pctxt, 
            pvalue->u.bookmark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.bookmark_start
             = rtxMemAllocType (pctxt, Odf_Bookmark_start);

         if (pvalue->u.bookmark_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bookmark_start (pvalue->u.bookmark_start);
         stat = asn1D_Odf_Bookmark_start (pctxt, 
            pvalue->u.bookmark_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.bookmark_end = rtxMemAllocType (pctxt, Odf_Bookmark_end);

         if (pvalue->u.bookmark_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bookmark_end (pvalue->u.bookmark_end);
         stat = asn1D_Odf_Bookmark_end (pctxt, 
            pvalue->u.bookmark_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.reference_mark
             = rtxMemAllocType (pctxt, Odf_Reference_mark);

         if (pvalue->u.reference_mark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Reference_mark (pvalue->u.reference_mark);
         stat = asn1D_Odf_Reference_mark (pctxt, 
            pvalue->u.reference_mark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.reference_mark_start
             = rtxMemAllocType (pctxt, Odf_Reference_mark_start);

         if (pvalue->u.reference_mark_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Reference_mark_start (pvalue->u.reference_mark_start);
         stat = asn1D_Odf_Reference_mark_start (pctxt, 
            pvalue->u.reference_mark_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.reference_mark_end
             = rtxMemAllocType (pctxt, Odf_Reference_mark_end);

         if (pvalue->u.reference_mark_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Reference_mark_end (pvalue->u.reference_mark_end);
         stat = asn1D_Odf_Reference_mark_end (pctxt, 
            pvalue->u.reference_mark_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.note = rtxMemAllocType (pctxt, Odf_Note);

         if (pvalue->u.note == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Note ((Odf_Note*)pvalue->u.note);
         stat = asn1D_Odf_Note (pctxt, 
            (Odf_Note*)pvalue->u.note, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.ruby = rtxMemAllocType (pctxt, Odf_Ruby);

         if (pvalue->u.ruby == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Ruby (pvalue->u.ruby);
         stat = asn1D_Odf_Ruby (pctxt, 
            pvalue->u.ruby, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.annotation = rtxMemAllocType (pctxt, Ns13_Annotation);

         if (pvalue->u.annotation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Annotation ((Ns13_Annotation*)pvalue->u.annotation);
         stat = asn1D_Ns13_Annotation (pctxt, 
            (Ns13_Annotation*)pvalue->u.annotation, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

         if (pvalue->u.change == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change (pvalue->u.change);
         stat = asn1D_Odf_Change (pctxt, 
            pvalue->u.change, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

         if (pvalue->u.change_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_start (pvalue->u.change_start);
         stat = asn1D_Odf_Change_start (pctxt, 
            pvalue->u.change_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

         if (pvalue->u.change_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_end (pvalue->u.change_end);
         stat = asn1D_Odf_Change_end (pctxt, 
            pvalue->u.change_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      case (TM_CTXT|TM_CONS|17):
         pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

         if (pvalue->u.rect == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);
         stat = asn1D_Ns3_Rect (pctxt, 
            (Ns3_Rect*)pvalue->u.rect, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 18;
         break;

      case (TM_CTXT|TM_CONS|18):
         pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

         if (pvalue->u.line == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);
         stat = asn1D_Ns3_Line (pctxt, 
            (Ns3_Line*)pvalue->u.line, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 19;
         break;

      case (TM_CTXT|TM_CONS|19):
         pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

         if (pvalue->u.polyline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);
         stat = asn1D_Ns3_Polyline (pctxt, 
            (Ns3_Polyline*)pvalue->u.polyline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 20;
         break;

      case (TM_CTXT|TM_CONS|20):
         pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

         if (pvalue->u.polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);
         stat = asn1D_Ns3_Polygon (pctxt, 
            (Ns3_Polygon*)pvalue->u.polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 21;
         break;

      case (TM_CTXT|TM_CONS|21):
         pvalue->u.regular_polygon
             = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

         if (pvalue->u.regular_polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->u.regular_polygon);
         stat = asn1D_Ns3_Regular_polygon (pctxt, 
            (Ns3_Regular_polygon*)pvalue->u.regular_polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 22;
         break;

      case (TM_CTXT|TM_CONS|22):
         pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

         if (pvalue->u.path == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);
         stat = asn1D_Ns3_Path (pctxt, 
            (Ns3_Path*)pvalue->u.path, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 23;
         break;

      case (TM_CTXT|TM_CONS|23):
         pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

         if (pvalue->u.circle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);
         stat = asn1D_Ns3_Circle (pctxt, 
            (Ns3_Circle*)pvalue->u.circle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 24;
         break;

      case (TM_CTXT|TM_CONS|24):
         pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

         if (pvalue->u.ellipse == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);
         stat = asn1D_Ns3_Ellipse (pctxt, 
            (Ns3_Ellipse*)pvalue->u.ellipse, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 25;
         break;

      case (TM_CTXT|TM_CONS|25):
         pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

         if (pvalue->u.g == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);
         stat = asn1D_Ns3_G (pctxt, 
            (Ns3_G*)pvalue->u.g, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 26;
         break;

      case (TM_CTXT|TM_CONS|26):
         pvalue->u.page_thumbnail
             = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

         if (pvalue->u.page_thumbnail == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->u.page_thumbnail);
         stat = asn1D_Ns3_Page_thumbnail (pctxt, 
            (Ns3_Page_thumbnail*)pvalue->u.page_thumbnail, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 27;
         break;

      case (TM_CTXT|TM_CONS|27):
         pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

         if (pvalue->u.frame == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);
         stat = asn1D_Ns3_Frame (pctxt, 
            (Ns3_Frame*)pvalue->u.frame, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 28;
         break;

      case (TM_CTXT|TM_CONS|28):
         pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

         if (pvalue->u.measure == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);
         stat = asn1D_Ns3_Measure (pctxt, 
            (Ns3_Measure*)pvalue->u.measure, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 29;
         break;

      case (TM_CTXT|TM_CONS|29):
         pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

         if (pvalue->u.caption == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);
         stat = asn1D_Ns3_Caption (pctxt, 
            (Ns3_Caption*)pvalue->u.caption, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 30;
         break;

      case (TM_CTXT|TM_CONS|30):
         pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

         if (pvalue->u.connector == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);
         stat = asn1D_Ns3_Connector (pctxt, 
            (Ns3_Connector*)pvalue->u.connector, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 31;
         break;

      case (TM_CTXT|TM_CONS|31):
         pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

         if (pvalue->u.control == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);
         stat = asn1D_Ns3_Control (pctxt, 
            (Ns3_Control*)pvalue->u.control, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 32;
         break;

      case (TM_CTXT|TM_CONS|32):
         pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

         if (pvalue->u.scene == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);
         stat = asn1D_Ns7_Scene (pctxt, 
            (Ns7_Scene*)pvalue->u.scene, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 33;
         break;

      case (TM_CTXT|TM_CONS|33):
         pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

         if (pvalue->u.custom_shape == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);
         stat = asn1D_Ns3_Custom_shape (pctxt, 
            (Ns3_Custom_shape*)pvalue->u.custom_shape, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 34;
         break;

      case (TM_CTXT|TM_CONS|34):
         pvalue->u.a_1 = rtxMemAllocType (pctxt, Ns3_A);

         if (pvalue->u.a_1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_A ((Ns3_A*)pvalue->u.a_1);
         stat = asn1D_Ns3_A (pctxt, 
            (Ns3_A*)pvalue->u.a_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 35;
         break;

      case (TM_CTXT|TM_CONS|35):
         pvalue->u.date = rtxMemAllocType (pctxt, Odf_Date);

         if (pvalue->u.date == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Date (pvalue->u.date);
         stat = asn1D_Odf_Date (pctxt, 
            pvalue->u.date, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 36;
         break;

      case (TM_CTXT|TM_CONS|36):
         pvalue->u.time_ = rtxMemAllocType (pctxt, Odf_Time);

         if (pvalue->u.time_ == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Time (pvalue->u.time_);
         stat = asn1D_Odf_Time (pctxt, 
            pvalue->u.time_, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 37;
         break;

      case (TM_CTXT|TM_CONS|37):
         pvalue->u.page_number = rtxMemAllocType (pctxt, Odf_Page_number);

         if (pvalue->u.page_number == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Page_number (pvalue->u.page_number);
         stat = asn1D_Odf_Page_number (pctxt, 
            pvalue->u.page_number, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 38;
         break;

      case (TM_CTXT|TM_CONS|38):
         pvalue->u.page_continuation
             = rtxMemAllocType (pctxt, Odf_Page_continuation);

         if (pvalue->u.page_continuation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Page_continuation (pvalue->u.page_continuation);
         stat = asn1D_Odf_Page_continuation (pctxt, 
            pvalue->u.page_continuation, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 39;
         break;

      case (TM_CTXT|TM_CONS|39):
         pvalue->u.sender_firstname
             = rtxMemAllocType (pctxt, Odf_Sender_firstname);

         if (pvalue->u.sender_firstname == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_firstname (pvalue->u.sender_firstname);
         stat = asn1D_Odf_Sender_firstname (pctxt, 
            pvalue->u.sender_firstname, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 40;
         break;

      case (TM_CTXT|TM_CONS|40):
         pvalue->u.sender_lastname
             = rtxMemAllocType (pctxt, Odf_Sender_lastname);

         if (pvalue->u.sender_lastname == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_lastname (pvalue->u.sender_lastname);
         stat = asn1D_Odf_Sender_lastname (pctxt, 
            pvalue->u.sender_lastname, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 41;
         break;

      case (TM_CTXT|TM_CONS|41):
         pvalue->u.sender_initials
             = rtxMemAllocType (pctxt, Odf_Sender_initials);

         if (pvalue->u.sender_initials == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_initials (pvalue->u.sender_initials);
         stat = asn1D_Odf_Sender_initials (pctxt, 
            pvalue->u.sender_initials, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 42;
         break;

      case (TM_CTXT|TM_CONS|42):
         pvalue->u.sender_title = rtxMemAllocType (pctxt, Odf_Sender_title);

         if (pvalue->u.sender_title == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_title (pvalue->u.sender_title);
         stat = asn1D_Odf_Sender_title (pctxt, 
            pvalue->u.sender_title, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 43;
         break;

      case (TM_CTXT|TM_CONS|43):
         pvalue->u.sender_position
             = rtxMemAllocType (pctxt, Odf_Sender_position);

         if (pvalue->u.sender_position == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_position (pvalue->u.sender_position);
         stat = asn1D_Odf_Sender_position (pctxt, 
            pvalue->u.sender_position, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 44;
         break;

      case (TM_CTXT|TM_CONS|44):
         pvalue->u.sender_email = rtxMemAllocType (pctxt, Odf_Sender_email);

         if (pvalue->u.sender_email == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_email (pvalue->u.sender_email);
         stat = asn1D_Odf_Sender_email (pctxt, 
            pvalue->u.sender_email, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 45;
         break;

      case (TM_CTXT|TM_CONS|45):
         pvalue->u.sender_phone_private
             = rtxMemAllocType (pctxt, Odf_Sender_phone_private);

         if (pvalue->u.sender_phone_private == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_phone_private (pvalue->u.sender_phone_private);
         stat = asn1D_Odf_Sender_phone_private (pctxt, 
            pvalue->u.sender_phone_private, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 46;
         break;

      case (TM_CTXT|TM_CONS|46):
         pvalue->u.sender_fax = rtxMemAllocType (pctxt, Odf_Sender_fax);

         if (pvalue->u.sender_fax == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_fax (pvalue->u.sender_fax);
         stat = asn1D_Odf_Sender_fax (pctxt, 
            pvalue->u.sender_fax, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 47;
         break;

      case (TM_CTXT|TM_CONS|47):
         pvalue->u.sender_company
             = rtxMemAllocType (pctxt, Odf_Sender_company);

         if (pvalue->u.sender_company == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_company (pvalue->u.sender_company);
         stat = asn1D_Odf_Sender_company (pctxt, 
            pvalue->u.sender_company, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 48;
         break;

      case (TM_CTXT|TM_CONS|48):
         pvalue->u.sender_phone_work
             = rtxMemAllocType (pctxt, Odf_Sender_phone_work);

         if (pvalue->u.sender_phone_work == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_phone_work (pvalue->u.sender_phone_work);
         stat = asn1D_Odf_Sender_phone_work (pctxt, 
            pvalue->u.sender_phone_work, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 49;
         break;

      case (TM_CTXT|TM_CONS|49):
         pvalue->u.sender_street = rtxMemAllocType (pctxt, Odf_Sender_street);

         if (pvalue->u.sender_street == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_street (pvalue->u.sender_street);
         stat = asn1D_Odf_Sender_street (pctxt, 
            pvalue->u.sender_street, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 50;
         break;

      case (TM_CTXT|TM_CONS|50):
         pvalue->u.sender_city = rtxMemAllocType (pctxt, Odf_Sender_city);

         if (pvalue->u.sender_city == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_city (pvalue->u.sender_city);
         stat = asn1D_Odf_Sender_city (pctxt, 
            pvalue->u.sender_city, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 51;
         break;

      case (TM_CTXT|TM_CONS|51):
         pvalue->u.sender_postal_code
             = rtxMemAllocType (pctxt, Odf_Sender_postal_code);

         if (pvalue->u.sender_postal_code == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_postal_code (pvalue->u.sender_postal_code);
         stat = asn1D_Odf_Sender_postal_code (pctxt, 
            pvalue->u.sender_postal_code, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 52;
         break;

      case (TM_CTXT|TM_CONS|52):
         pvalue->u.sender_country
             = rtxMemAllocType (pctxt, Odf_Sender_country);

         if (pvalue->u.sender_country == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_country (pvalue->u.sender_country);
         stat = asn1D_Odf_Sender_country (pctxt, 
            pvalue->u.sender_country, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 53;
         break;

      case (TM_CTXT|TM_CONS|53):
         pvalue->u.sender_state_or_province
             = rtxMemAllocType (pctxt, Odf_Sender_state_or_province);

         if (pvalue->u.sender_state_or_province == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_state_or_province (pvalue->u.sender_state_or_province);
         stat = asn1D_Odf_Sender_state_or_province (pctxt, 
            pvalue->u.sender_state_or_province, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 54;
         break;

      case (TM_CTXT|TM_CONS|54):
         pvalue->u.author_name = rtxMemAllocType (pctxt, Odf_Author_name);

         if (pvalue->u.author_name == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Author_name (pvalue->u.author_name);
         stat = asn1D_Odf_Author_name (pctxt, 
            pvalue->u.author_name, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 55;
         break;

      case (TM_CTXT|TM_CONS|55):
         pvalue->u.author_initials
             = rtxMemAllocType (pctxt, Odf_Author_initials);

         if (pvalue->u.author_initials == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Author_initials (pvalue->u.author_initials);
         stat = asn1D_Odf_Author_initials (pctxt, 
            pvalue->u.author_initials, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 56;
         break;

      case (TM_CTXT|TM_CONS|56):
         pvalue->u.chapter = rtxMemAllocType (pctxt, Odf_Chapter);

         if (pvalue->u.chapter == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Chapter (pvalue->u.chapter);
         stat = asn1D_Odf_Chapter (pctxt, 
            pvalue->u.chapter, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 57;
         break;

      case (TM_CTXT|TM_CONS|57):
         pvalue->u.file_name = rtxMemAllocType (pctxt, Odf_File_name);

         if (pvalue->u.file_name == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_File_name (pvalue->u.file_name);
         stat = asn1D_Odf_File_name (pctxt, 
            pvalue->u.file_name, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 58;
         break;

      case (TM_CTXT|TM_CONS|58):
         pvalue->u.template_name = rtxMemAllocType (pctxt, Odf_Template_name);

         if (pvalue->u.template_name == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Template_name (pvalue->u.template_name);
         stat = asn1D_Odf_Template_name (pctxt, 
            pvalue->u.template_name, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 59;
         break;

      case (TM_CTXT|TM_PRIM|59):
      case (TM_CTXT|TM_CONS|59):
         stat = asn1D_Odf_Sheet_name (pctxt, 
            &pvalue->u.sheet_name, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 60;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_CONS|60):
         pvalue->u.variable_set = rtxMemAllocType (pctxt, Odf_Variable_set);

         if (pvalue->u.variable_set == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Variable_set (pvalue->u.variable_set);
         stat = asn1D_Odf_Variable_set (pctxt, 
            pvalue->u.variable_set, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 61;
         break;

      case (TM_CTXT|TM_CONS|61):
         pvalue->u.variable_get = rtxMemAllocType (pctxt, Odf_Variable_get);

         if (pvalue->u.variable_get == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Variable_get (pvalue->u.variable_get);
         stat = asn1D_Odf_Variable_get (pctxt, 
            pvalue->u.variable_get, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 62;
         break;

      case (TM_CTXT|TM_CONS|62):
         pvalue->u.variable_input
             = rtxMemAllocType (pctxt, Odf_Variable_input);

         if (pvalue->u.variable_input == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Variable_input (pvalue->u.variable_input);
         stat = asn1D_Odf_Variable_input (pctxt, 
            pvalue->u.variable_input, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 63;
         break;

      case (TM_CTXT|TM_CONS|63):
         pvalue->u.user_field_get
             = rtxMemAllocType (pctxt, Odf_User_field_get);

         if (pvalue->u.user_field_get == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_field_get (pvalue->u.user_field_get);
         stat = asn1D_Odf_User_field_get (pctxt, 
            pvalue->u.user_field_get, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 64;
         break;

      case (TM_CTXT|TM_CONS|64):
         pvalue->u.user_field_input
             = rtxMemAllocType (pctxt, Odf_User_field_input);

         if (pvalue->u.user_field_input == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_field_input (pvalue->u.user_field_input);
         stat = asn1D_Odf_User_field_input (pctxt, 
            pvalue->u.user_field_input, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 65;
         break;

      case (TM_CTXT|TM_CONS|65):
         pvalue->u.sequence = rtxMemAllocType (pctxt, Odf_Sequence);

         if (pvalue->u.sequence == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sequence (pvalue->u.sequence);
         stat = asn1D_Odf_Sequence (pctxt, 
            pvalue->u.sequence, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 66;
         break;

      case (TM_CTXT|TM_CONS|66):
         pvalue->u.expression = rtxMemAllocType (pctxt, Odf_Expression);

         if (pvalue->u.expression == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Expression (pvalue->u.expression);
         stat = asn1D_Odf_Expression (pctxt, 
            pvalue->u.expression, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 67;
         break;

      case (TM_CTXT|TM_CONS|67):
         pvalue->u.text_input = rtxMemAllocType (pctxt, Odf_Text_input);

         if (pvalue->u.text_input == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Text_input (pvalue->u.text_input);
         stat = asn1D_Odf_Text_input (pctxt, 
            pvalue->u.text_input, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 68;
         break;

      case (TM_CTXT|TM_CONS|68):
         pvalue->u.initial_creator
             = rtxMemAllocType (pctxt, Odf_Initial_creator);

         if (pvalue->u.initial_creator == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Initial_creator (pvalue->u.initial_creator);
         stat = asn1D_Odf_Initial_creator (pctxt, 
            pvalue->u.initial_creator, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 69;
         break;

      case (TM_CTXT|TM_CONS|69):
         pvalue->u.creation_date = rtxMemAllocType (pctxt, Odf_Creation_date);

         if (pvalue->u.creation_date == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Creation_date (pvalue->u.creation_date);
         stat = asn1D_Odf_Creation_date (pctxt, 
            pvalue->u.creation_date, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 70;
         break;

      case (TM_CTXT|TM_CONS|70):
         pvalue->u.creation_time = rtxMemAllocType (pctxt, Odf_Creation_time);

         if (pvalue->u.creation_time == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Creation_time (pvalue->u.creation_time);
         stat = asn1D_Odf_Creation_time (pctxt, 
            pvalue->u.creation_time, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 71;
         break;

      case (TM_CTXT|TM_CONS|71):
         pvalue->u.description = rtxMemAllocType (pctxt, Odf_Description);

         if (pvalue->u.description == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Description (pvalue->u.description);
         stat = asn1D_Odf_Description (pctxt, 
            pvalue->u.description, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 72;
         break;

      case (TM_CTXT|TM_CONS|72):
         pvalue->u.user_defined = rtxMemAllocType (pctxt, Odf_User_defined);

         if (pvalue->u.user_defined == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_defined (pvalue->u.user_defined);
         stat = asn1D_Odf_User_defined (pctxt, 
            pvalue->u.user_defined, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 73;
         break;

      case (TM_CTXT|TM_CONS|73):
         pvalue->u.print_time = rtxMemAllocType (pctxt, Odf_Print_time);

         if (pvalue->u.print_time == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Print_time (pvalue->u.print_time);
         stat = asn1D_Odf_Print_time (pctxt, 
            pvalue->u.print_time, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 74;
         break;

      case (TM_CTXT|TM_CONS|74):
         pvalue->u.print_date = rtxMemAllocType (pctxt, Odf_Print_date);

         if (pvalue->u.print_date == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Print_date (pvalue->u.print_date);
         stat = asn1D_Odf_Print_date (pctxt, 
            pvalue->u.print_date, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 75;
         break;

      case (TM_CTXT|TM_CONS|75):
         pvalue->u.printed_by = rtxMemAllocType (pctxt, Odf_Printed_by);

         if (pvalue->u.printed_by == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Printed_by (pvalue->u.printed_by);
         stat = asn1D_Odf_Printed_by (pctxt, 
            pvalue->u.printed_by, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 76;
         break;

      case (TM_CTXT|TM_CONS|76):
         pvalue->u.title = rtxMemAllocType (pctxt, Odf_Title);

         if (pvalue->u.title == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Title (pvalue->u.title);
         stat = asn1D_Odf_Title (pctxt, 
            pvalue->u.title, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 77;
         break;

      case (TM_CTXT|TM_CONS|77):
         pvalue->u.subject = rtxMemAllocType (pctxt, Odf_Subject);

         if (pvalue->u.subject == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Subject (pvalue->u.subject);
         stat = asn1D_Odf_Subject (pctxt, 
            pvalue->u.subject, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 78;
         break;

      case (TM_CTXT|TM_CONS|78):
         pvalue->u.keywords = rtxMemAllocType (pctxt, Odf_Keywords);

         if (pvalue->u.keywords == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Keywords (pvalue->u.keywords);
         stat = asn1D_Odf_Keywords (pctxt, 
            pvalue->u.keywords, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 79;
         break;

      case (TM_CTXT|TM_CONS|79):
         pvalue->u.editing_cycles
             = rtxMemAllocType (pctxt, Odf_Editing_cycles);

         if (pvalue->u.editing_cycles == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Editing_cycles (pvalue->u.editing_cycles);
         stat = asn1D_Odf_Editing_cycles (pctxt, 
            pvalue->u.editing_cycles, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 80;
         break;

      case (TM_CTXT|TM_CONS|80):
         pvalue->u.editing_duration
             = rtxMemAllocType (pctxt, Odf_Editing_duration);

         if (pvalue->u.editing_duration == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Editing_duration (pvalue->u.editing_duration);
         stat = asn1D_Odf_Editing_duration (pctxt, 
            pvalue->u.editing_duration, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 81;
         break;

      case (TM_CTXT|TM_CONS|81):
         pvalue->u.modification_time
             = rtxMemAllocType (pctxt, Odf_Modification_time);

         if (pvalue->u.modification_time == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Modification_time (pvalue->u.modification_time);
         stat = asn1D_Odf_Modification_time (pctxt, 
            pvalue->u.modification_time, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 82;
         break;

      case (TM_CTXT|TM_CONS|82):
         pvalue->u.modification_date
             = rtxMemAllocType (pctxt, Odf_Modification_date);

         if (pvalue->u.modification_date == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Modification_date (pvalue->u.modification_date);
         stat = asn1D_Odf_Modification_date (pctxt, 
            pvalue->u.modification_date, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 83;
         break;

      case (TM_CTXT|TM_CONS|83):
         pvalue->u.creator = rtxMemAllocType (pctxt, Odf_Creator);

         if (pvalue->u.creator == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Creator (pvalue->u.creator);
         stat = asn1D_Odf_Creator (pctxt, 
            pvalue->u.creator, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 84;
         break;

      case (TM_CTXT|TM_CONS|84):
         pvalue->u.element271 = rtxMemAllocType (pctxt, Odf_Element271_group);

         if (pvalue->u.element271 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Element271_group (pvalue->u.element271);
         stat = asn1D_Odf_Element271_group (pctxt, 
            pvalue->u.element271, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 85;
         break;

      case (TM_CTXT|TM_CONS|85):
         pvalue->u.database_display
             = rtxMemAllocType (pctxt, Odf_Database_display);

         if (pvalue->u.database_display == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Database_display (pvalue->u.database_display);
         stat = asn1D_Odf_Database_display (pctxt, 
            pvalue->u.database_display, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 86;
         break;

      case (TM_CTXT|TM_CONS|86):
         pvalue->u.database_next = rtxMemAllocType (pctxt, Odf_Database_next);

         if (pvalue->u.database_next == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Database_next (pvalue->u.database_next);
         stat = asn1D_Odf_Database_next (pctxt, 
            pvalue->u.database_next, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 87;
         break;

      case (TM_CTXT|TM_CONS|87):
         pvalue->u.database_row_select
             = rtxMemAllocType (pctxt, Odf_Database_row_select);

         if (pvalue->u.database_row_select == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Database_row_select (pvalue->u.database_row_select);
         stat = asn1D_Odf_Database_row_select (pctxt, 
            pvalue->u.database_row_select, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 88;
         break;

      case (TM_CTXT|TM_CONS|88):
         pvalue->u.database_row_number
             = rtxMemAllocType (pctxt, Odf_Database_row_number);

         if (pvalue->u.database_row_number == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Database_row_number (pvalue->u.database_row_number);
         stat = asn1D_Odf_Database_row_number (pctxt, 
            pvalue->u.database_row_number, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 89;
         break;

      case (TM_CTXT|TM_CONS|89):
         pvalue->u.database_name = rtxMemAllocType (pctxt, Odf_Database_name);

         if (pvalue->u.database_name == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Database_name (pvalue->u.database_name);
         stat = asn1D_Odf_Database_name (pctxt, 
            pvalue->u.database_name, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 90;
         break;

      case (TM_CTXT|TM_CONS|90):
         pvalue->u.page_variable_set
             = rtxMemAllocType (pctxt, Odf_Page_variable_set);

         if (pvalue->u.page_variable_set == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Page_variable_set (pvalue->u.page_variable_set);
         stat = asn1D_Odf_Page_variable_set (pctxt, 
            pvalue->u.page_variable_set, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 91;
         break;

      case (TM_CTXT|TM_CONS|91):
         pvalue->u.page_variable_get
             = rtxMemAllocType (pctxt, Odf_Page_variable_get);

         if (pvalue->u.page_variable_get == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Page_variable_get (pvalue->u.page_variable_get);
         stat = asn1D_Odf_Page_variable_get (pctxt, 
            pvalue->u.page_variable_get, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 92;
         break;

      case (TM_CTXT|TM_CONS|92):
         pvalue->u.placeholder = rtxMemAllocType (pctxt, Odf_Placeholder);

         if (pvalue->u.placeholder == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Placeholder (pvalue->u.placeholder);
         stat = asn1D_Odf_Placeholder (pctxt, 
            pvalue->u.placeholder, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 93;
         break;

      case (TM_CTXT|TM_CONS|93):
         pvalue->u.conditional_text
             = rtxMemAllocType (pctxt, Odf_Conditional_text);

         if (pvalue->u.conditional_text == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Conditional_text (pvalue->u.conditional_text);
         stat = asn1D_Odf_Conditional_text (pctxt, 
            pvalue->u.conditional_text, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 94;
         break;

      case (TM_CTXT|TM_CONS|94):
         pvalue->u.hidden_text = rtxMemAllocType (pctxt, Odf_Hidden_text);

         if (pvalue->u.hidden_text == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Hidden_text (pvalue->u.hidden_text);
         stat = asn1D_Odf_Hidden_text (pctxt, 
            pvalue->u.hidden_text, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 95;
         break;

      case (TM_CTXT|TM_CONS|95):
         pvalue->u.element282 = rtxMemAllocType (pctxt, Odf_Element282_group);

         if (pvalue->u.element282 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Element282_group (pvalue->u.element282);
         stat = asn1D_Odf_Element282_group (pctxt, 
            pvalue->u.element282, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 96;
         break;

      case (TM_CTXT|TM_CONS|96):
         pvalue->u.note_ref = rtxMemAllocType (pctxt, Odf_Note_ref);

         if (pvalue->u.note_ref == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Note_ref (pvalue->u.note_ref);
         stat = asn1D_Odf_Note_ref (pctxt, 
            pvalue->u.note_ref, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 97;
         break;

      case (TM_CTXT|TM_CONS|97):
         pvalue->u.sequence_ref = rtxMemAllocType (pctxt, Odf_Sequence_ref);

         if (pvalue->u.sequence_ref == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sequence_ref (pvalue->u.sequence_ref);
         stat = asn1D_Odf_Sequence_ref (pctxt, 
            pvalue->u.sequence_ref, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 98;
         break;

      case (TM_CTXT|TM_CONS|98):
         pvalue->u.script = rtxMemAllocType (pctxt, Odf_Script);

         if (pvalue->u.script == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Script (pvalue->u.script);
         stat = asn1D_Odf_Script (pctxt, 
            pvalue->u.script, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 99;
         break;

      case (TM_CTXT|TM_CONS|99):
         pvalue->u.execute_macro = rtxMemAllocType (pctxt, Odf_Execute_macro);

         if (pvalue->u.execute_macro == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Execute_macro (pvalue->u.execute_macro);
         stat = asn1D_Odf_Execute_macro (pctxt, 
            pvalue->u.execute_macro, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 100;
         break;

      case (TM_CTXT|TM_CONS|100):
         pvalue->u.hidden_paragraph
             = rtxMemAllocType (pctxt, Odf_Hidden_paragraph);

         if (pvalue->u.hidden_paragraph == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Hidden_paragraph (pvalue->u.hidden_paragraph);
         stat = asn1D_Odf_Hidden_paragraph (pctxt, 
            pvalue->u.hidden_paragraph, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 101;
         break;

      case (TM_CTXT|TM_CONS|101):
         pvalue->u.dde_connection
             = rtxMemAllocType (pctxt, Odf_Dde_connection);

         if (pvalue->u.dde_connection == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Dde_connection (pvalue->u.dde_connection);
         stat = asn1D_Odf_Dde_connection (pctxt, 
            pvalue->u.dde_connection, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 102;
         break;

      case (TM_CTXT|TM_CONS|102):
         pvalue->u.measure_1 = rtxMemAllocType (pctxt, Odf_Measure);

         if (pvalue->u.measure_1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Measure (pvalue->u.measure_1);
         stat = asn1D_Odf_Measure (pctxt, 
            pvalue->u.measure_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 103;
         break;

      case (TM_CTXT|TM_CONS|103):
         pvalue->u.table_formula = rtxMemAllocType (pctxt, Odf_Table_formula);

         if (pvalue->u.table_formula == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_formula (pvalue->u.table_formula);
         stat = asn1D_Odf_Table_formula (pctxt, 
            pvalue->u.table_formula, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 104;
         break;

      case (TM_CTXT|TM_CONS|104):
         pvalue->u.toc_mark_start
             = rtxMemAllocType (pctxt, Odf_Toc_mark_start);

         if (pvalue->u.toc_mark_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Toc_mark_start (pvalue->u.toc_mark_start);
         stat = asn1D_Odf_Toc_mark_start (pctxt, 
            pvalue->u.toc_mark_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 105;
         break;

      case (TM_CTXT|TM_CONS|105):
         pvalue->u.toc_mark_end = rtxMemAllocType (pctxt, Odf_Toc_mark_end);

         if (pvalue->u.toc_mark_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Toc_mark_end (pvalue->u.toc_mark_end);
         stat = asn1D_Odf_Toc_mark_end (pctxt, 
            pvalue->u.toc_mark_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 106;
         break;

      case (TM_CTXT|TM_CONS|106):
         pvalue->u.toc_mark = rtxMemAllocType (pctxt, Odf_Toc_mark);

         if (pvalue->u.toc_mark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Toc_mark (pvalue->u.toc_mark);
         stat = asn1D_Odf_Toc_mark (pctxt, 
            pvalue->u.toc_mark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 107;
         break;

      case (TM_CTXT|TM_CONS|107):
         pvalue->u.user_index_mark_start
             = rtxMemAllocType (pctxt, Odf_User_index_mark_start);

         if (pvalue->u.user_index_mark_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index_mark_start (pvalue->u.user_index_mark_start);
         stat = asn1D_Odf_User_index_mark_start (pctxt, 
            pvalue->u.user_index_mark_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 108;
         break;

      case (TM_CTXT|TM_CONS|108):
         pvalue->u.user_index_mark_end
             = rtxMemAllocType (pctxt, Odf_User_index_mark_end);

         if (pvalue->u.user_index_mark_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index_mark_end (pvalue->u.user_index_mark_end);
         stat = asn1D_Odf_User_index_mark_end (pctxt, 
            pvalue->u.user_index_mark_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 109;
         break;

      case (TM_CTXT|TM_CONS|109):
         pvalue->u.user_index_mark
             = rtxMemAllocType (pctxt, Odf_User_index_mark);

         if (pvalue->u.user_index_mark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index_mark (pvalue->u.user_index_mark);
         stat = asn1D_Odf_User_index_mark (pctxt, 
            pvalue->u.user_index_mark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 110;
         break;

      case (TM_CTXT|TM_CONS|110):
         pvalue->u.alphabetical_index_mark_start
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark_start);

         if (pvalue->u.alphabetical_index_mark_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index_mark_start (pvalue->u.alphabetical_index_mark_start);
         stat = asn1D_Odf_Alphabetical_index_mark_start (pctxt, 
            pvalue->u.alphabetical_index_mark_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 111;
         break;

      case (TM_CTXT|TM_CONS|111):
         pvalue->u.alphabetical_index_mark_end
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark_end);

         if (pvalue->u.alphabetical_index_mark_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index_mark_end (pvalue->u.alphabetical_index_mark_end);
         stat = asn1D_Odf_Alphabetical_index_mark_end (pctxt, 
            pvalue->u.alphabetical_index_mark_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 112;
         break;

      case (TM_CTXT|TM_CONS|112):
         pvalue->u.alphabetical_index_mark
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark);

         if (pvalue->u.alphabetical_index_mark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index_mark (pvalue->u.alphabetical_index_mark);
         stat = asn1D_Odf_Alphabetical_index_mark (pctxt, 
            pvalue->u.alphabetical_index_mark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 113;
         break;

      case (TM_CTXT|TM_CONS|113):
         pvalue->u.bibliography_mark
             = rtxMemAllocType (pctxt, Odf_Bibliography_mark);

         if (pvalue->u.bibliography_mark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bibliography_mark (pvalue->u.bibliography_mark);
         stat = asn1D_Odf_Bibliography_mark (pctxt, 
            pvalue->u.bibliography_mark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 114;
         break;

      case (TM_CTXT|TM_CONS|114):
         pvalue->u.header = rtxMemAllocType (pctxt, Ns10_Header);

         if (pvalue->u.header == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns10_Header ((Ns10_Header*)pvalue->u.header);
         stat = asn1D_Ns10_Header (pctxt, 
            (Ns10_Header*)pvalue->u.header, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 115;
         break;

      case (TM_CTXT|TM_CONS|115):
         pvalue->u.footer = rtxMemAllocType (pctxt, Ns10_Footer);

         if (pvalue->u.footer == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns10_Footer ((Ns10_Footer*)pvalue->u.footer);
         stat = asn1D_Ns10_Footer (pctxt, 
            (Ns10_Footer*)pvalue->u.footer, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 116;
         break;

      case (TM_CTXT|TM_CONS|116):
         pvalue->u.date_time = rtxMemAllocType (pctxt, Ns10_Date_time);

         if (pvalue->u.date_time == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns10_Date_time ((Ns10_Date_time*)pvalue->u.date_time);
         stat = asn1D_Ns10_Date_time (pctxt, 
            (Ns10_Date_time*)pvalue->u.date_time, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 117;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_H_element (OSCTXT* pctxt, Odf_H_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("s"), 1}, 0}, 0 },
      {{{OSUTF8("tab"), 3}, 0}, 1 },
      {{{OSUTF8("line-break"), 10}, 0}, 2 },
      {{{OSUTF8("span"), 4}, 0}, 3 },
      {{{OSUTF8("a"), 1}, 0}, 4 },
      {{{OSUTF8("bookmark"), 8}, 0}, 5 },
      {{{OSUTF8("bookmark-start"), 14}, 0}, 6 },
      {{{OSUTF8("bookmark-end"), 12}, 0}, 7 },
      {{{OSUTF8("reference-mark"), 14}, 0}, 8 },
      {{{OSUTF8("reference-mark-start"), 20}, 0}, 9 },
      {{{OSUTF8("reference-mark-end"), 18}, 0}, 10 },
      {{{OSUTF8("note"), 4}, 0}, 11 },
      {{{OSUTF8("ruby"), 4}, 0}, 12 },
      {{{OSUTF8("annotation"), 10}, 0}, 13 },
      {{{OSUTF8("change"), 6}, 0}, 14 },
      {{{OSUTF8("change-start"), 12}, 0}, 15 },
      {{{OSUTF8("change-end"), 10}, 0}, 16 },
      {{{OSUTF8("rect"), 4}, 0}, 17 },
      {{{OSUTF8("line"), 4}, 0}, 18 },
      {{{OSUTF8("polyline"), 8}, 0}, 19 },
      {{{OSUTF8("polygon"), 7}, 0}, 20 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 21 },
      {{{OSUTF8("path"), 4}, 0}, 22 },
      {{{OSUTF8("circle"), 6}, 0}, 23 },
      {{{OSUTF8("ellipse"), 7}, 0}, 24 },
      {{{OSUTF8("g"), 1}, 0}, 25 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 26 },
      {{{OSUTF8("frame"), 5}, 0}, 27 },
      {{{OSUTF8("measure"), 7}, 0}, 28 },
      {{{OSUTF8("caption"), 7}, 0}, 29 },
      {{{OSUTF8("connector"), 9}, 0}, 30 },
      {{{OSUTF8("control"), 7}, 0}, 31 },
      {{{OSUTF8("scene"), 5}, 0}, 32 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 33 },
      {{{OSUTF8("a"), 1}, 0}, 34 },
      {{{OSUTF8("date"), 4}, 0}, 35 },
      {{{OSUTF8("time"), 4}, 0}, 36 },
      {{{OSUTF8("page-number"), 11}, 0}, 37 },
      {{{OSUTF8("page-continuation"), 17}, 0}, 38 },
      {{{OSUTF8("sender-firstname"), 16}, 0}, 39 },
      {{{OSUTF8("sender-lastname"), 15}, 0}, 40 },
      {{{OSUTF8("sender-initials"), 15}, 0}, 41 },
      {{{OSUTF8("sender-title"), 12}, 0}, 42 },
      {{{OSUTF8("sender-position"), 15}, 0}, 43 },
      {{{OSUTF8("sender-email"), 12}, 0}, 44 },
      {{{OSUTF8("sender-phone-private"), 20}, 0}, 45 },
      {{{OSUTF8("sender-fax"), 10}, 0}, 46 },
      {{{OSUTF8("sender-company"), 14}, 0}, 47 },
      {{{OSUTF8("sender-phone-work"), 17}, 0}, 48 },
      {{{OSUTF8("sender-street"), 13}, 0}, 49 },
      {{{OSUTF8("sender-city"), 11}, 0}, 50 },
      {{{OSUTF8("sender-postal-code"), 18}, 0}, 51 },
      {{{OSUTF8("sender-country"), 14}, 0}, 52 },
      {{{OSUTF8("sender-state-or-province"), 24}, 0}, 53 },
      {{{OSUTF8("author-name"), 11}, 0}, 54 },
      {{{OSUTF8("author-initials"), 15}, 0}, 55 },
      {{{OSUTF8("chapter"), 7}, 0}, 56 },
      {{{OSUTF8("file-name"), 9}, 0}, 57 },
      {{{OSUTF8("template-name"), 13}, 0}, 58 },
      {{{OSUTF8("sheet-name"), 10}, 0}, 59 },
      {{{OSUTF8("variable-set"), 12}, 0}, 60 },
      {{{OSUTF8("variable-get"), 12}, 0}, 61 },
      {{{OSUTF8("variable-input"), 14}, 0}, 62 },
      {{{OSUTF8("user-field-get"), 14}, 0}, 63 },
      {{{OSUTF8("user-field-input"), 16}, 0}, 64 },
      {{{OSUTF8("sequence"), 8}, 0}, 65 },
      {{{OSUTF8("expression"), 10}, 0}, 66 },
      {{{OSUTF8("text-input"), 10}, 0}, 67 },
      {{{OSUTF8("initial-creator"), 15}, 0}, 68 },
      {{{OSUTF8("creation-date"), 13}, 0}, 69 },
      {{{OSUTF8("creation-time"), 13}, 0}, 70 },
      {{{OSUTF8("description"), 11}, 0}, 71 },
      {{{OSUTF8("user-defined"), 12}, 0}, 72 },
      {{{OSUTF8("print-time"), 10}, 0}, 73 },
      {{{OSUTF8("print-date"), 10}, 0}, 74 },
      {{{OSUTF8("printed-by"), 10}, 0}, 75 },
      {{{OSUTF8("title"), 5}, 0}, 76 },
      {{{OSUTF8("subject"), 7}, 0}, 77 },
      {{{OSUTF8("keywords"), 8}, 0}, 78 },
      {{{OSUTF8("editing-cycles"), 14}, 0}, 79 },
      {{{OSUTF8("editing-duration"), 16}, 0}, 80 },
      {{{OSUTF8("modification-time"), 17}, 0}, 81 },
      {{{OSUTF8("modification-date"), 17}, 0}, 82 },
      {{{OSUTF8("creator"), 7}, 0}, 83 },
      {{{OSUTF8("page-count"), 10}, 0}, 84 },
      {{{OSUTF8("paragraph-count"), 15}, 0}, 84 },
      {{{OSUTF8("word-count"), 10}, 0}, 84 },
      {{{OSUTF8("character-count"), 15}, 0}, 84 },
      {{{OSUTF8("table-count"), 11}, 0}, 84 },
      {{{OSUTF8("image-count"), 11}, 0}, 84 },
      {{{OSUTF8("object-count"), 12}, 0}, 84 },
      {{{OSUTF8("database-display"), 16}, 0}, 85 },
      {{{OSUTF8("database-next"), 13}, 0}, 86 },
      {{{OSUTF8("database-row-select"), 19}, 0}, 87 },
      {{{OSUTF8("database-row-number"), 19}, 0}, 88 },
      {{{OSUTF8("database-name"), 13}, 0}, 89 },
      {{{OSUTF8("page-variable-set"), 17}, 0}, 90 },
      {{{OSUTF8("page-variable-get"), 17}, 0}, 91 },
      {{{OSUTF8("placeholder"), 11}, 0}, 92 },
      {{{OSUTF8("conditional-text"), 16}, 0}, 93 },
      {{{OSUTF8("hidden-text"), 11}, 0}, 94 },
      {{{OSUTF8("reference-ref"), 13}, 0}, 95 },
      {{{OSUTF8("bookmark-ref"), 12}, 0}, 95 },
      {{{OSUTF8("note-ref"), 8}, 0}, 96 },
      {{{OSUTF8("sequence-ref"), 12}, 0}, 97 },
      {{{OSUTF8("script"), 6}, 0}, 98 },
      {{{OSUTF8("execute-macro"), 13}, 0}, 99 },
      {{{OSUTF8("hidden-paragraph"), 16}, 0}, 100 },
      {{{OSUTF8("dde-connection"), 14}, 0}, 101 },
      {{{OSUTF8("measure"), 7}, 0}, 102 },
      {{{OSUTF8("table-formula"), 13}, 0}, 103 },
      {{{OSUTF8("toc-mark-start"), 14}, 0}, 104 },
      {{{OSUTF8("toc-mark-end"), 12}, 0}, 105 },
      {{{OSUTF8("toc-mark"), 8}, 0}, 106 },
      {{{OSUTF8("user-index-mark-start"), 21}, 0}, 107 },
      {{{OSUTF8("user-index-mark-end"), 19}, 0}, 108 },
      {{{OSUTF8("user-index-mark"), 15}, 0}, 109 },
      {{{OSUTF8("alphabetical-index-mark-start"), 29}, 0}, 110 },
      {{{OSUTF8("alphabetical-index-mark-end"), 27}, 0}, 111 },
      {{{OSUTF8("alphabetical-index-mark"), 23}, 0}, 112 },
      {{{OSUTF8("bibliography-mark"), 17}, 0}, 113 },
      {{{OSUTF8("header"), 6}, 0}, 114 },
      {{{OSUTF8("footer"), 6}, 0}, 115 },
      {{{OSUTF8("date-time"), 9}, 0}, 116 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 124, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* s */
      pvalue->u.s = rtxMemAllocType (pctxt, Odf_S);

      if (pvalue->u.s == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_S (pvalue->u.s);

      stat = XmlDec_Odf_S (pctxt, pvalue->u.s);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* tab */
      pvalue->u.tab = rtxMemAllocType (pctxt, Odf_Tab);

      if (pvalue->u.tab == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Tab (pvalue->u.tab);

      stat = XmlDec_Odf_Tab (pctxt, pvalue->u.tab);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* line-break */
      pvalue->u.line_break = rtxMemAllocType (pctxt, Odf_Line_break);

      if (pvalue->u.line_break == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Line_break (pvalue->u.line_break);

      stat = XmlDec_Odf_Line_break (pctxt, pvalue->u.line_break);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* span */
      pvalue->u.span = rtxMemAllocType (pctxt, Odf_Span);

      if (pvalue->u.span == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Span ((Odf_Span*)pvalue->u.span);

      stat = XmlDec_Odf_Span (pctxt, pvalue->u.span);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* a */
      pvalue->u.a = rtxMemAllocType (pctxt, Odf_A);

      if (pvalue->u.a == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_A ((Odf_A*)pvalue->u.a);

      stat = XmlDec_Odf_A (pctxt, pvalue->u.a);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* bookmark */
      pvalue->u.bookmark = rtxMemAllocType (pctxt, Odf_Bookmark);

      if (pvalue->u.bookmark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bookmark (pvalue->u.bookmark);

      stat = XmlDec_Odf_Bookmark (pctxt, pvalue->u.bookmark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* bookmark-start */
      pvalue->u.bookmark_start = rtxMemAllocType (pctxt, Odf_Bookmark_start);

      if (pvalue->u.bookmark_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bookmark_start (pvalue->u.bookmark_start);

      stat = XmlDec_Odf_Bookmark_start (pctxt, pvalue->u.bookmark_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* bookmark-end */
      pvalue->u.bookmark_end = rtxMemAllocType (pctxt, Odf_Bookmark_end);

      if (pvalue->u.bookmark_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bookmark_end (pvalue->u.bookmark_end);

      stat = XmlDec_Odf_Bookmark_end (pctxt, pvalue->u.bookmark_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* reference-mark */
      pvalue->u.reference_mark = rtxMemAllocType (pctxt, Odf_Reference_mark);

      if (pvalue->u.reference_mark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Reference_mark (pvalue->u.reference_mark);

      stat = XmlDec_Odf_Reference_mark (pctxt, pvalue->u.reference_mark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* reference-mark-start */
      pvalue->u.reference_mark_start
          = rtxMemAllocType (pctxt, Odf_Reference_mark_start);

      if (pvalue->u.reference_mark_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Reference_mark_start (pvalue->u.reference_mark_start);

      stat = XmlDec_Odf_Reference_mark_start (pctxt, pvalue->
         u.reference_mark_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* reference-mark-end */
      pvalue->u.reference_mark_end
          = rtxMemAllocType (pctxt, Odf_Reference_mark_end);

      if (pvalue->u.reference_mark_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Reference_mark_end (pvalue->u.reference_mark_end);

      stat = XmlDec_Odf_Reference_mark_end (pctxt, pvalue->u.reference_mark_end
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* note */
      pvalue->u.note = rtxMemAllocType (pctxt, Odf_Note);

      if (pvalue->u.note == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Note ((Odf_Note*)pvalue->u.note);

      stat = XmlDec_Odf_Note (pctxt, pvalue->u.note);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* ruby */
      pvalue->u.ruby = rtxMemAllocType (pctxt, Odf_Ruby);

      if (pvalue->u.ruby == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Ruby (pvalue->u.ruby);

      stat = XmlDec_Odf_Ruby (pctxt, pvalue->u.ruby);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* annotation */
      pvalue->u.annotation = rtxMemAllocType (pctxt, Ns13_Annotation);

      if (pvalue->u.annotation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns13_Annotation ((Ns13_Annotation*)pvalue->u.annotation);

      stat = XmlDec_Ns13_Annotation (pctxt, pvalue->u.annotation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* change */
      pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

      if (pvalue->u.change == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change (pvalue->u.change);

      stat = XmlDec_Odf_Change (pctxt, pvalue->u.change);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* change-start */
      pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

      if (pvalue->u.change_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_start (pvalue->u.change_start);

      stat = XmlDec_Odf_Change_start (pctxt, pvalue->u.change_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* change-end */
      pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

      if (pvalue->u.change_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_end (pvalue->u.change_end);

      stat = XmlDec_Odf_Change_end (pctxt, pvalue->u.change_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 17: { /* rect */
      pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

      if (pvalue->u.rect == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);

      stat = XmlDec_Ns3_Rect (pctxt, pvalue->u.rect);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 18: { /* line */
      pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

      if (pvalue->u.line == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);

      stat = XmlDec_Ns3_Line (pctxt, pvalue->u.line);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 19: { /* polyline */
      pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

      if (pvalue->u.polyline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);

      stat = XmlDec_Ns3_Polyline (pctxt, pvalue->u.polyline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 20: { /* polygon */
      pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

      if (pvalue->u.polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);

      stat = XmlDec_Ns3_Polygon (pctxt, pvalue->u.polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 21: { /* regular-polygon */
      pvalue->u.regular_polygon
          = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

      if (pvalue->u.regular_polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->
         u.regular_polygon);

      stat = XmlDec_Ns3_Regular_polygon (pctxt, pvalue->u.regular_polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 22: { /* path */
      pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

      if (pvalue->u.path == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);

      stat = XmlDec_Ns3_Path (pctxt, pvalue->u.path);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 23: { /* circle */
      pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

      if (pvalue->u.circle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);

      stat = XmlDec_Ns3_Circle (pctxt, pvalue->u.circle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 24: { /* ellipse */
      pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

      if (pvalue->u.ellipse == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);

      stat = XmlDec_Ns3_Ellipse (pctxt, pvalue->u.ellipse);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 25: { /* g */
      pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

      if (pvalue->u.g == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);

      stat = XmlDec_Ns3_G (pctxt, pvalue->u.g);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 26: { /* page-thumbnail */
      pvalue->u.page_thumbnail = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

      if (pvalue->u.page_thumbnail == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->
         u.page_thumbnail);

      stat = XmlDec_Ns3_Page_thumbnail (pctxt, pvalue->u.page_thumbnail);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 27: { /* frame */
      pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

      if (pvalue->u.frame == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);

      stat = XmlDec_Ns3_Frame (pctxt, pvalue->u.frame);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 28: { /* measure */
      pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

      if (pvalue->u.measure == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);

      stat = XmlDec_Ns3_Measure (pctxt, pvalue->u.measure);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 29: { /* caption */
      pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

      if (pvalue->u.caption == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);

      stat = XmlDec_Ns3_Caption (pctxt, pvalue->u.caption);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 30: { /* connector */
      pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

      if (pvalue->u.connector == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);

      stat = XmlDec_Ns3_Connector (pctxt, pvalue->u.connector);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 31: { /* control */
      pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

      if (pvalue->u.control == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);

      stat = XmlDec_Ns3_Control (pctxt, pvalue->u.control);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 32: { /* scene */
      pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

      if (pvalue->u.scene == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);

      stat = XmlDec_Ns7_Scene (pctxt, pvalue->u.scene);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 33: { /* custom-shape */
      pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

      if (pvalue->u.custom_shape == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);

      stat = XmlDec_Ns3_Custom_shape (pctxt, pvalue->u.custom_shape);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 34: { /* a */
      pvalue->u.a_1 = rtxMemAllocType (pctxt, Ns3_A);

      if (pvalue->u.a_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_A ((Ns3_A*)pvalue->u.a_1);

      stat = XmlDec_Ns3_A (pctxt, pvalue->u.a_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 35: { /* date */
      pvalue->u.date = rtxMemAllocType (pctxt, Odf_Date);

      if (pvalue->u.date == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Date (pvalue->u.date);

      stat = XmlDec_Odf_Date (pctxt, pvalue->u.date);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 36: { /* time */
      pvalue->u.time_ = rtxMemAllocType (pctxt, Odf_Time);

      if (pvalue->u.time_ == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Time (pvalue->u.time_);

      stat = XmlDec_Odf_Time (pctxt, pvalue->u.time_);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 37: { /* page-number */
      pvalue->u.page_number = rtxMemAllocType (pctxt, Odf_Page_number);

      if (pvalue->u.page_number == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Page_number (pvalue->u.page_number);

      stat = XmlDec_Odf_Page_number (pctxt, pvalue->u.page_number);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 38: { /* page-continuation */
      pvalue->u.page_continuation
          = rtxMemAllocType (pctxt, Odf_Page_continuation);

      if (pvalue->u.page_continuation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Page_continuation (pvalue->u.page_continuation);

      stat = XmlDec_Odf_Page_continuation (pctxt, pvalue->u.page_continuation
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 39: { /* sender-firstname */
      pvalue->u.sender_firstname
          = rtxMemAllocType (pctxt, Odf_Sender_firstname);

      if (pvalue->u.sender_firstname == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_firstname (pvalue->u.sender_firstname);

      stat = XmlDec_Odf_Sender_firstname (pctxt, pvalue->u.sender_firstname);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 40: { /* sender-lastname */
      pvalue->u.sender_lastname
          = rtxMemAllocType (pctxt, Odf_Sender_lastname);

      if (pvalue->u.sender_lastname == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_lastname (pvalue->u.sender_lastname);

      stat = XmlDec_Odf_Sender_lastname (pctxt, pvalue->u.sender_lastname);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 41: { /* sender-initials */
      pvalue->u.sender_initials
          = rtxMemAllocType (pctxt, Odf_Sender_initials);

      if (pvalue->u.sender_initials == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_initials (pvalue->u.sender_initials);

      stat = XmlDec_Odf_Sender_initials (pctxt, pvalue->u.sender_initials);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 42: { /* sender-title */
      pvalue->u.sender_title = rtxMemAllocType (pctxt, Odf_Sender_title);

      if (pvalue->u.sender_title == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_title (pvalue->u.sender_title);

      stat = XmlDec_Odf_Sender_title (pctxt, pvalue->u.sender_title);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 43: { /* sender-position */
      pvalue->u.sender_position
          = rtxMemAllocType (pctxt, Odf_Sender_position);

      if (pvalue->u.sender_position == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_position (pvalue->u.sender_position);

      stat = XmlDec_Odf_Sender_position (pctxt, pvalue->u.sender_position);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 44: { /* sender-email */
      pvalue->u.sender_email = rtxMemAllocType (pctxt, Odf_Sender_email);

      if (pvalue->u.sender_email == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_email (pvalue->u.sender_email);

      stat = XmlDec_Odf_Sender_email (pctxt, pvalue->u.sender_email);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 45: { /* sender-phone-private */
      pvalue->u.sender_phone_private
          = rtxMemAllocType (pctxt, Odf_Sender_phone_private);

      if (pvalue->u.sender_phone_private == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_phone_private (pvalue->u.sender_phone_private);

      stat = XmlDec_Odf_Sender_phone_private (pctxt, pvalue->
         u.sender_phone_private);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 46: { /* sender-fax */
      pvalue->u.sender_fax = rtxMemAllocType (pctxt, Odf_Sender_fax);

      if (pvalue->u.sender_fax == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_fax (pvalue->u.sender_fax);

      stat = XmlDec_Odf_Sender_fax (pctxt, pvalue->u.sender_fax);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 47: { /* sender-company */
      pvalue->u.sender_company = rtxMemAllocType (pctxt, Odf_Sender_company);

      if (pvalue->u.sender_company == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_company (pvalue->u.sender_company);

      stat = XmlDec_Odf_Sender_company (pctxt, pvalue->u.sender_company);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 48: { /* sender-phone-work */
      pvalue->u.sender_phone_work
          = rtxMemAllocType (pctxt, Odf_Sender_phone_work);

      if (pvalue->u.sender_phone_work == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_phone_work (pvalue->u.sender_phone_work);

      stat = XmlDec_Odf_Sender_phone_work (pctxt, pvalue->u.sender_phone_work
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 49: { /* sender-street */
      pvalue->u.sender_street = rtxMemAllocType (pctxt, Odf_Sender_street);

      if (pvalue->u.sender_street == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_street (pvalue->u.sender_street);

      stat = XmlDec_Odf_Sender_street (pctxt, pvalue->u.sender_street);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 50: { /* sender-city */
      pvalue->u.sender_city = rtxMemAllocType (pctxt, Odf_Sender_city);

      if (pvalue->u.sender_city == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_city (pvalue->u.sender_city);

      stat = XmlDec_Odf_Sender_city (pctxt, pvalue->u.sender_city);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 51: { /* sender-postal-code */
      pvalue->u.sender_postal_code
          = rtxMemAllocType (pctxt, Odf_Sender_postal_code);

      if (pvalue->u.sender_postal_code == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_postal_code (pvalue->u.sender_postal_code);

      stat = XmlDec_Odf_Sender_postal_code (pctxt, pvalue->u.sender_postal_code
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 52: { /* sender-country */
      pvalue->u.sender_country = rtxMemAllocType (pctxt, Odf_Sender_country);

      if (pvalue->u.sender_country == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_country (pvalue->u.sender_country);

      stat = XmlDec_Odf_Sender_country (pctxt, pvalue->u.sender_country);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 53: { /* sender-state-or-province */
      pvalue->u.sender_state_or_province
          = rtxMemAllocType (pctxt, Odf_Sender_state_or_province);

      if (pvalue->u.sender_state_or_province == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_state_or_province (pvalue->u.sender_state_or_province
         );

      stat = XmlDec_Odf_Sender_state_or_province (pctxt, pvalue->
         u.sender_state_or_province);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 54: { /* author-name */
      pvalue->u.author_name = rtxMemAllocType (pctxt, Odf_Author_name);

      if (pvalue->u.author_name == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Author_name (pvalue->u.author_name);

      stat = XmlDec_Odf_Author_name (pctxt, pvalue->u.author_name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 55: { /* author-initials */
      pvalue->u.author_initials
          = rtxMemAllocType (pctxt, Odf_Author_initials);

      if (pvalue->u.author_initials == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Author_initials (pvalue->u.author_initials);

      stat = XmlDec_Odf_Author_initials (pctxt, pvalue->u.author_initials);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 56: { /* chapter */
      pvalue->u.chapter = rtxMemAllocType (pctxt, Odf_Chapter);

      if (pvalue->u.chapter == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Chapter (pvalue->u.chapter);

      stat = XmlDec_Odf_Chapter (pctxt, pvalue->u.chapter);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 57: { /* file-name */
      pvalue->u.file_name = rtxMemAllocType (pctxt, Odf_File_name);

      if (pvalue->u.file_name == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_File_name (pvalue->u.file_name);

      stat = XmlDec_Odf_File_name (pctxt, pvalue->u.file_name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 58: { /* template-name */
      pvalue->u.template_name = rtxMemAllocType (pctxt, Odf_Template_name);

      if (pvalue->u.template_name == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Template_name (pvalue->u.template_name);

      stat = XmlDec_Odf_Template_name (pctxt, pvalue->u.template_name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 59: { /* sheet-name */
      stat = XmlDec_Odf_Sheet_name (pctxt, &pvalue->u.sheet_name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 60: { /* variable-set */
      pvalue->u.variable_set = rtxMemAllocType (pctxt, Odf_Variable_set);

      if (pvalue->u.variable_set == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Variable_set (pvalue->u.variable_set);

      stat = XmlDec_Odf_Variable_set (pctxt, pvalue->u.variable_set);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 61: { /* variable-get */
      pvalue->u.variable_get = rtxMemAllocType (pctxt, Odf_Variable_get);

      if (pvalue->u.variable_get == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Variable_get (pvalue->u.variable_get);

      stat = XmlDec_Odf_Variable_get (pctxt, pvalue->u.variable_get);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 62: { /* variable-input */
      pvalue->u.variable_input = rtxMemAllocType (pctxt, Odf_Variable_input);

      if (pvalue->u.variable_input == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Variable_input (pvalue->u.variable_input);

      stat = XmlDec_Odf_Variable_input (pctxt, pvalue->u.variable_input);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 63: { /* user-field-get */
      pvalue->u.user_field_get = rtxMemAllocType (pctxt, Odf_User_field_get);

      if (pvalue->u.user_field_get == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_field_get (pvalue->u.user_field_get);

      stat = XmlDec_Odf_User_field_get (pctxt, pvalue->u.user_field_get);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 64: { /* user-field-input */
      pvalue->u.user_field_input
          = rtxMemAllocType (pctxt, Odf_User_field_input);

      if (pvalue->u.user_field_input == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_field_input (pvalue->u.user_field_input);

      stat = XmlDec_Odf_User_field_input (pctxt, pvalue->u.user_field_input);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 65: { /* sequence */
      pvalue->u.sequence = rtxMemAllocType (pctxt, Odf_Sequence);

      if (pvalue->u.sequence == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sequence (pvalue->u.sequence);

      stat = XmlDec_Odf_Sequence (pctxt, pvalue->u.sequence);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 66: { /* expression */
      pvalue->u.expression = rtxMemAllocType (pctxt, Odf_Expression);

      if (pvalue->u.expression == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Expression (pvalue->u.expression);

      stat = XmlDec_Odf_Expression (pctxt, pvalue->u.expression);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 67: { /* text-input */
      pvalue->u.text_input = rtxMemAllocType (pctxt, Odf_Text_input);

      if (pvalue->u.text_input == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Text_input (pvalue->u.text_input);

      stat = XmlDec_Odf_Text_input (pctxt, pvalue->u.text_input);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 68: { /* initial-creator */
      pvalue->u.initial_creator
          = rtxMemAllocType (pctxt, Odf_Initial_creator);

      if (pvalue->u.initial_creator == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Initial_creator (pvalue->u.initial_creator);

      stat = XmlDec_Odf_Initial_creator (pctxt, pvalue->u.initial_creator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 69: { /* creation-date */
      pvalue->u.creation_date = rtxMemAllocType (pctxt, Odf_Creation_date);

      if (pvalue->u.creation_date == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Creation_date (pvalue->u.creation_date);

      stat = XmlDec_Odf_Creation_date (pctxt, pvalue->u.creation_date);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 70: { /* creation-time */
      pvalue->u.creation_time = rtxMemAllocType (pctxt, Odf_Creation_time);

      if (pvalue->u.creation_time == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Creation_time (pvalue->u.creation_time);

      stat = XmlDec_Odf_Creation_time (pctxt, pvalue->u.creation_time);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 71: { /* description */
      pvalue->u.description = rtxMemAllocType (pctxt, Odf_Description);

      if (pvalue->u.description == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Description (pvalue->u.description);

      stat = XmlDec_Odf_Description (pctxt, pvalue->u.description);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 72: { /* user-defined */
      pvalue->u.user_defined = rtxMemAllocType (pctxt, Odf_User_defined);

      if (pvalue->u.user_defined == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_defined (pvalue->u.user_defined);

      stat = XmlDec_Odf_User_defined (pctxt, pvalue->u.user_defined);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 73: { /* print-time */
      pvalue->u.print_time = rtxMemAllocType (pctxt, Odf_Print_time);

      if (pvalue->u.print_time == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Print_time (pvalue->u.print_time);

      stat = XmlDec_Odf_Print_time (pctxt, pvalue->u.print_time);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 74: { /* print-date */
      pvalue->u.print_date = rtxMemAllocType (pctxt, Odf_Print_date);

      if (pvalue->u.print_date == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Print_date (pvalue->u.print_date);

      stat = XmlDec_Odf_Print_date (pctxt, pvalue->u.print_date);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 75: { /* printed-by */
      pvalue->u.printed_by = rtxMemAllocType (pctxt, Odf_Printed_by);

      if (pvalue->u.printed_by == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Printed_by (pvalue->u.printed_by);

      stat = XmlDec_Odf_Printed_by (pctxt, pvalue->u.printed_by);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 76: { /* title */
      pvalue->u.title = rtxMemAllocType (pctxt, Odf_Title);

      if (pvalue->u.title == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Title (pvalue->u.title);

      stat = XmlDec_Odf_Title (pctxt, pvalue->u.title);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 77: { /* subject */
      pvalue->u.subject = rtxMemAllocType (pctxt, Odf_Subject);

      if (pvalue->u.subject == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Subject (pvalue->u.subject);

      stat = XmlDec_Odf_Subject (pctxt, pvalue->u.subject);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 78: { /* keywords */
      pvalue->u.keywords = rtxMemAllocType (pctxt, Odf_Keywords);

      if (pvalue->u.keywords == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Keywords (pvalue->u.keywords);

      stat = XmlDec_Odf_Keywords (pctxt, pvalue->u.keywords);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 79: { /* editing-cycles */
      pvalue->u.editing_cycles = rtxMemAllocType (pctxt, Odf_Editing_cycles);

      if (pvalue->u.editing_cycles == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Editing_cycles (pvalue->u.editing_cycles);

      stat = XmlDec_Odf_Editing_cycles (pctxt, pvalue->u.editing_cycles);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 80: { /* editing-duration */
      pvalue->u.editing_duration
          = rtxMemAllocType (pctxt, Odf_Editing_duration);

      if (pvalue->u.editing_duration == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Editing_duration (pvalue->u.editing_duration);

      stat = XmlDec_Odf_Editing_duration (pctxt, pvalue->u.editing_duration);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 81: { /* modification-time */
      pvalue->u.modification_time
          = rtxMemAllocType (pctxt, Odf_Modification_time);

      if (pvalue->u.modification_time == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Modification_time (pvalue->u.modification_time);

      stat = XmlDec_Odf_Modification_time (pctxt, pvalue->u.modification_time
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 82: { /* modification-date */
      pvalue->u.modification_date
          = rtxMemAllocType (pctxt, Odf_Modification_date);

      if (pvalue->u.modification_date == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Modification_date (pvalue->u.modification_date);

      stat = XmlDec_Odf_Modification_date (pctxt, pvalue->u.modification_date
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 83: { /* creator */
      pvalue->u.creator = rtxMemAllocType (pctxt, Odf_Creator);

      if (pvalue->u.creator == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Creator (pvalue->u.creator);

      stat = XmlDec_Odf_Creator (pctxt, pvalue->u.creator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 84: { /*  */
      pvalue->u.element271 = rtxMemAllocType (pctxt, Odf_Element271_group);

      if (pvalue->u.element271 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Element271_group (pvalue->u.element271);

      stat = XmlDec_Odf_Element271_group (pctxt, pvalue->u.element271);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 85: { /* database-display */
      pvalue->u.database_display
          = rtxMemAllocType (pctxt, Odf_Database_display);

      if (pvalue->u.database_display == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Database_display (pvalue->u.database_display);

      stat = XmlDec_Odf_Database_display (pctxt, pvalue->u.database_display);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 86: { /* database-next */
      pvalue->u.database_next = rtxMemAllocType (pctxt, Odf_Database_next);

      if (pvalue->u.database_next == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Database_next (pvalue->u.database_next);

      stat = XmlDec_Odf_Database_next (pctxt, pvalue->u.database_next);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 87: { /* database-row-select */
      pvalue->u.database_row_select
          = rtxMemAllocType (pctxt, Odf_Database_row_select);

      if (pvalue->u.database_row_select == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Database_row_select (pvalue->u.database_row_select);

      stat = XmlDec_Odf_Database_row_select (pctxt, pvalue->
         u.database_row_select);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 88: { /* database-row-number */
      pvalue->u.database_row_number
          = rtxMemAllocType (pctxt, Odf_Database_row_number);

      if (pvalue->u.database_row_number == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Database_row_number (pvalue->u.database_row_number);

      stat = XmlDec_Odf_Database_row_number (pctxt, pvalue->
         u.database_row_number);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 89: { /* database-name */
      pvalue->u.database_name = rtxMemAllocType (pctxt, Odf_Database_name);

      if (pvalue->u.database_name == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Database_name (pvalue->u.database_name);

      stat = XmlDec_Odf_Database_name (pctxt, pvalue->u.database_name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 90: { /* page-variable-set */
      pvalue->u.page_variable_set
          = rtxMemAllocType (pctxt, Odf_Page_variable_set);

      if (pvalue->u.page_variable_set == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Page_variable_set (pvalue->u.page_variable_set);

      stat = XmlDec_Odf_Page_variable_set (pctxt, pvalue->u.page_variable_set
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 91: { /* page-variable-get */
      pvalue->u.page_variable_get
          = rtxMemAllocType (pctxt, Odf_Page_variable_get);

      if (pvalue->u.page_variable_get == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Page_variable_get (pvalue->u.page_variable_get);

      stat = XmlDec_Odf_Page_variable_get (pctxt, pvalue->u.page_variable_get
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 92: { /* placeholder */
      pvalue->u.placeholder = rtxMemAllocType (pctxt, Odf_Placeholder);

      if (pvalue->u.placeholder == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Placeholder (pvalue->u.placeholder);

      stat = XmlDec_Odf_Placeholder (pctxt, pvalue->u.placeholder);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 93: { /* conditional-text */
      pvalue->u.conditional_text
          = rtxMemAllocType (pctxt, Odf_Conditional_text);

      if (pvalue->u.conditional_text == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Conditional_text (pvalue->u.conditional_text);

      stat = XmlDec_Odf_Conditional_text (pctxt, pvalue->u.conditional_text);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 94: { /* hidden-text */
      pvalue->u.hidden_text = rtxMemAllocType (pctxt, Odf_Hidden_text);

      if (pvalue->u.hidden_text == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Hidden_text (pvalue->u.hidden_text);

      stat = XmlDec_Odf_Hidden_text (pctxt, pvalue->u.hidden_text);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 95: { /*  */
      pvalue->u.element282 = rtxMemAllocType (pctxt, Odf_Element282_group);

      if (pvalue->u.element282 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Element282_group (pvalue->u.element282);

      stat = XmlDec_Odf_Element282_group (pctxt, pvalue->u.element282);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 96: { /* note-ref */
      pvalue->u.note_ref = rtxMemAllocType (pctxt, Odf_Note_ref);

      if (pvalue->u.note_ref == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Note_ref (pvalue->u.note_ref);

      stat = XmlDec_Odf_Note_ref (pctxt, pvalue->u.note_ref);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 97: { /* sequence-ref */
      pvalue->u.sequence_ref = rtxMemAllocType (pctxt, Odf_Sequence_ref);

      if (pvalue->u.sequence_ref == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sequence_ref (pvalue->u.sequence_ref);

      stat = XmlDec_Odf_Sequence_ref (pctxt, pvalue->u.sequence_ref);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 98: { /* script */
      pvalue->u.script = rtxMemAllocType (pctxt, Odf_Script);

      if (pvalue->u.script == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Script (pvalue->u.script);

      stat = XmlDec_Odf_Script (pctxt, pvalue->u.script);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 99: { /* execute-macro */
      pvalue->u.execute_macro = rtxMemAllocType (pctxt, Odf_Execute_macro);

      if (pvalue->u.execute_macro == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Execute_macro (pvalue->u.execute_macro);

      stat = XmlDec_Odf_Execute_macro (pctxt, pvalue->u.execute_macro);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 100: { /* hidden-paragraph */
      pvalue->u.hidden_paragraph
          = rtxMemAllocType (pctxt, Odf_Hidden_paragraph);

      if (pvalue->u.hidden_paragraph == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Hidden_paragraph (pvalue->u.hidden_paragraph);

      stat = XmlDec_Odf_Hidden_paragraph (pctxt, pvalue->u.hidden_paragraph);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 101: { /* dde-connection */
      pvalue->u.dde_connection = rtxMemAllocType (pctxt, Odf_Dde_connection);

      if (pvalue->u.dde_connection == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Dde_connection (pvalue->u.dde_connection);

      stat = XmlDec_Odf_Dde_connection (pctxt, pvalue->u.dde_connection);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 102: { /* measure */
      pvalue->u.measure_1 = rtxMemAllocType (pctxt, Odf_Measure);

      if (pvalue->u.measure_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Measure (pvalue->u.measure_1);

      stat = XmlDec_Odf_Measure (pctxt, pvalue->u.measure_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 103: { /* table-formula */
      pvalue->u.table_formula = rtxMemAllocType (pctxt, Odf_Table_formula);

      if (pvalue->u.table_formula == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_formula (pvalue->u.table_formula);

      stat = XmlDec_Odf_Table_formula (pctxt, pvalue->u.table_formula);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 104: { /* toc-mark-start */
      pvalue->u.toc_mark_start = rtxMemAllocType (pctxt, Odf_Toc_mark_start);

      if (pvalue->u.toc_mark_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Toc_mark_start (pvalue->u.toc_mark_start);

      stat = XmlDec_Odf_Toc_mark_start (pctxt, pvalue->u.toc_mark_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 105: { /* toc-mark-end */
      pvalue->u.toc_mark_end = rtxMemAllocType (pctxt, Odf_Toc_mark_end);

      if (pvalue->u.toc_mark_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Toc_mark_end (pvalue->u.toc_mark_end);

      stat = XmlDec_Odf_Toc_mark_end (pctxt, pvalue->u.toc_mark_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 106: { /* toc-mark */
      pvalue->u.toc_mark = rtxMemAllocType (pctxt, Odf_Toc_mark);

      if (pvalue->u.toc_mark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Toc_mark (pvalue->u.toc_mark);

      stat = XmlDec_Odf_Toc_mark (pctxt, pvalue->u.toc_mark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 107: { /* user-index-mark-start */
      pvalue->u.user_index_mark_start
          = rtxMemAllocType (pctxt, Odf_User_index_mark_start);

      if (pvalue->u.user_index_mark_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index_mark_start (pvalue->u.user_index_mark_start);

      stat = XmlDec_Odf_User_index_mark_start (pctxt, pvalue->
         u.user_index_mark_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 108: { /* user-index-mark-end */
      pvalue->u.user_index_mark_end
          = rtxMemAllocType (pctxt, Odf_User_index_mark_end);

      if (pvalue->u.user_index_mark_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index_mark_end (pvalue->u.user_index_mark_end);

      stat = XmlDec_Odf_User_index_mark_end (pctxt, pvalue->
         u.user_index_mark_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 109: { /* user-index-mark */
      pvalue->u.user_index_mark
          = rtxMemAllocType (pctxt, Odf_User_index_mark);

      if (pvalue->u.user_index_mark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index_mark (pvalue->u.user_index_mark);

      stat = XmlDec_Odf_User_index_mark (pctxt, pvalue->u.user_index_mark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 110: { /* alphabetical-index-mark-start */
      pvalue->u.alphabetical_index_mark_start
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark_start);

      if (pvalue->u.alphabetical_index_mark_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index_mark_start (pvalue->
         u.alphabetical_index_mark_start);

      stat = XmlDec_Odf_Alphabetical_index_mark_start (pctxt, pvalue->
         u.alphabetical_index_mark_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 111: { /* alphabetical-index-mark-end */
      pvalue->u.alphabetical_index_mark_end
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark_end);

      if (pvalue->u.alphabetical_index_mark_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index_mark_end (pvalue->
         u.alphabetical_index_mark_end);

      stat = XmlDec_Odf_Alphabetical_index_mark_end (pctxt, pvalue->
         u.alphabetical_index_mark_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 112: { /* alphabetical-index-mark */
      pvalue->u.alphabetical_index_mark
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark);

      if (pvalue->u.alphabetical_index_mark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index_mark (pvalue->u.alphabetical_index_mark
         );

      stat = XmlDec_Odf_Alphabetical_index_mark (pctxt, pvalue->
         u.alphabetical_index_mark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 113: { /* bibliography-mark */
      pvalue->u.bibliography_mark
          = rtxMemAllocType (pctxt, Odf_Bibliography_mark);

      if (pvalue->u.bibliography_mark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bibliography_mark (pvalue->u.bibliography_mark);

      stat = XmlDec_Odf_Bibliography_mark (pctxt, pvalue->u.bibliography_mark
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 114: { /* header */
      pvalue->u.header = rtxMemAllocType (pctxt, Ns10_Header);

      if (pvalue->u.header == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns10_Header ((Ns10_Header*)pvalue->u.header);

      stat = XmlDec_Ns10_Header (pctxt, pvalue->u.header);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 115: { /* footer */
      pvalue->u.footer = rtxMemAllocType (pctxt, Ns10_Footer);

      if (pvalue->u.footer == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns10_Footer ((Ns10_Footer*)pvalue->u.footer);

      stat = XmlDec_Ns10_Footer (pctxt, pvalue->u.footer);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 116: { /* date-time */
      pvalue->u.date_time = rtxMemAllocType (pctxt, Ns10_Date_time);

      if (pvalue->u.date_time == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns10_Date_time ((Ns10_Date_time*)pvalue->u.date_time);

      stat = XmlDec_Ns10_Date_time (pctxt, pvalue->u.date_time);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Note_body_element                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Note_body_element (OSCTXT* pctxt, 
   Odf_Note_body_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

         if (pvalue->u.h == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_H (pvalue->u.h);
         stat = asn1D_Odf_H (pctxt, 
            pvalue->u.h, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P (pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List (pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.numbered_paragraph
             = rtxMemAllocType (pctxt, Odf_Numbered_paragraph);

         if (pvalue->u.numbered_paragraph == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Numbered_paragraph (pvalue->u.numbered_paragraph);
         stat = asn1D_Odf_Numbered_paragraph (pctxt, 
            pvalue->u.numbered_paragraph, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.table = rtxMemAllocType (pctxt, Table);

         if (pvalue->u.table == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table ((Table*)pvalue->u.table);
         stat = asn1D_Table (pctxt, 
            (Table*)pvalue->u.table, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.a = rtxMemAllocType (pctxt, Ns3_A);

         if (pvalue->u.a == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_A ((Ns3_A*)pvalue->u.a);
         stat = asn1D_Ns3_A (pctxt, 
            (Ns3_A*)pvalue->u.a, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.section = rtxMemAllocType (pctxt, Odf_Section);

         if (pvalue->u.section == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Section (pvalue->u.section);
         stat = asn1D_Odf_Section (pctxt, 
            pvalue->u.section, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.table_of_content
             = rtxMemAllocType (pctxt, Odf_Table_of_content);

         if (pvalue->u.table_of_content == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_of_content (pvalue->u.table_of_content);
         stat = asn1D_Odf_Table_of_content (pctxt, 
            pvalue->u.table_of_content, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.illustration_index
             = rtxMemAllocType (pctxt, Odf_Illustration_index);

         if (pvalue->u.illustration_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Illustration_index (pvalue->u.illustration_index);
         stat = asn1D_Odf_Illustration_index (pctxt, 
            pvalue->u.illustration_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.table_index = rtxMemAllocType (pctxt, Odf_Table_index);

         if (pvalue->u.table_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_index (pvalue->u.table_index);
         stat = asn1D_Odf_Table_index (pctxt, 
            pvalue->u.table_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.object_index = rtxMemAllocType (pctxt, Odf_Object_index);

         if (pvalue->u.object_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Object_index (pvalue->u.object_index);
         stat = asn1D_Odf_Object_index (pctxt, 
            pvalue->u.object_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.user_index = rtxMemAllocType (pctxt, Odf_User_index);

         if (pvalue->u.user_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index (pvalue->u.user_index);
         stat = asn1D_Odf_User_index (pctxt, 
            pvalue->u.user_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.alphabetical_index
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index);

         if (pvalue->u.alphabetical_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index (pvalue->u.alphabetical_index);
         stat = asn1D_Odf_Alphabetical_index (pctxt, 
            pvalue->u.alphabetical_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.bibliography = rtxMemAllocType (pctxt, Odf_Bibliography);

         if (pvalue->u.bibliography == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bibliography (pvalue->u.bibliography);
         stat = asn1D_Odf_Bibliography (pctxt, 
            pvalue->u.bibliography, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

         if (pvalue->u.rect == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);
         stat = asn1D_Ns3_Rect (pctxt, 
            (Ns3_Rect*)pvalue->u.rect, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

         if (pvalue->u.line == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);
         stat = asn1D_Ns3_Line (pctxt, 
            (Ns3_Line*)pvalue->u.line, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

         if (pvalue->u.polyline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);
         stat = asn1D_Ns3_Polyline (pctxt, 
            (Ns3_Polyline*)pvalue->u.polyline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      case (TM_CTXT|TM_CONS|17):
         pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

         if (pvalue->u.polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);
         stat = asn1D_Ns3_Polygon (pctxt, 
            (Ns3_Polygon*)pvalue->u.polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 18;
         break;

      case (TM_CTXT|TM_CONS|18):
         pvalue->u.regular_polygon
             = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

         if (pvalue->u.regular_polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->u.regular_polygon);
         stat = asn1D_Ns3_Regular_polygon (pctxt, 
            (Ns3_Regular_polygon*)pvalue->u.regular_polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 19;
         break;

      case (TM_CTXT|TM_CONS|19):
         pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

         if (pvalue->u.path == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);
         stat = asn1D_Ns3_Path (pctxt, 
            (Ns3_Path*)pvalue->u.path, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 20;
         break;

      case (TM_CTXT|TM_CONS|20):
         pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

         if (pvalue->u.circle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);
         stat = asn1D_Ns3_Circle (pctxt, 
            (Ns3_Circle*)pvalue->u.circle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 21;
         break;

      case (TM_CTXT|TM_CONS|21):
         pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

         if (pvalue->u.ellipse == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);
         stat = asn1D_Ns3_Ellipse (pctxt, 
            (Ns3_Ellipse*)pvalue->u.ellipse, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 22;
         break;

      case (TM_CTXT|TM_CONS|22):
         pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

         if (pvalue->u.g == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);
         stat = asn1D_Ns3_G (pctxt, 
            (Ns3_G*)pvalue->u.g, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 23;
         break;

      case (TM_CTXT|TM_CONS|23):
         pvalue->u.page_thumbnail
             = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

         if (pvalue->u.page_thumbnail == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->u.page_thumbnail);
         stat = asn1D_Ns3_Page_thumbnail (pctxt, 
            (Ns3_Page_thumbnail*)pvalue->u.page_thumbnail, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 24;
         break;

      case (TM_CTXT|TM_CONS|24):
         pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

         if (pvalue->u.frame == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);
         stat = asn1D_Ns3_Frame (pctxt, 
            (Ns3_Frame*)pvalue->u.frame, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 25;
         break;

      case (TM_CTXT|TM_CONS|25):
         pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

         if (pvalue->u.measure == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);
         stat = asn1D_Ns3_Measure (pctxt, 
            (Ns3_Measure*)pvalue->u.measure, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 26;
         break;

      case (TM_CTXT|TM_CONS|26):
         pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

         if (pvalue->u.caption == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);
         stat = asn1D_Ns3_Caption (pctxt, 
            (Ns3_Caption*)pvalue->u.caption, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 27;
         break;

      case (TM_CTXT|TM_CONS|27):
         pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

         if (pvalue->u.connector == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);
         stat = asn1D_Ns3_Connector (pctxt, 
            (Ns3_Connector*)pvalue->u.connector, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 28;
         break;

      case (TM_CTXT|TM_CONS|28):
         pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

         if (pvalue->u.control == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);
         stat = asn1D_Ns3_Control (pctxt, 
            (Ns3_Control*)pvalue->u.control, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 29;
         break;

      case (TM_CTXT|TM_CONS|29):
         pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

         if (pvalue->u.scene == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);
         stat = asn1D_Ns7_Scene (pctxt, 
            (Ns7_Scene*)pvalue->u.scene, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 30;
         break;

      case (TM_CTXT|TM_CONS|30):
         pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

         if (pvalue->u.custom_shape == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);
         stat = asn1D_Ns3_Custom_shape (pctxt, 
            (Ns3_Custom_shape*)pvalue->u.custom_shape, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 31;
         break;

      case (TM_CTXT|TM_CONS|31):
         pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

         if (pvalue->u.change == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change (pvalue->u.change);
         stat = asn1D_Odf_Change (pctxt, 
            pvalue->u.change, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 32;
         break;

      case (TM_CTXT|TM_CONS|32):
         pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

         if (pvalue->u.change_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_start (pvalue->u.change_start);
         stat = asn1D_Odf_Change_start (pctxt, 
            pvalue->u.change_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 33;
         break;

      case (TM_CTXT|TM_CONS|33):
         pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

         if (pvalue->u.change_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_end (pvalue->u.change_end);
         stat = asn1D_Odf_Change_end (pctxt, 
            pvalue->u.change_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 34;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Note_body_element (OSCTXT* pctxt, Odf_Note_body_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("h"), 1}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 1 },
      {{{OSUTF8("list"), 4}, 0}, 2 },
      {{{OSUTF8("numbered-paragraph"), 18}, 0}, 3 },
      {{{OSUTF8("table"), 5}, 0}, 4 },
      {{{OSUTF8("a"), 1}, 0}, 5 },
      {{{OSUTF8("section"), 7}, 0}, 6 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 7 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 8 },
      {{{OSUTF8("table-index"), 11}, 0}, 9 },
      {{{OSUTF8("object-index"), 12}, 0}, 10 },
      {{{OSUTF8("user-index"), 10}, 0}, 11 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 12 },
      {{{OSUTF8("bibliography"), 12}, 0}, 13 },
      {{{OSUTF8("rect"), 4}, 0}, 14 },
      {{{OSUTF8("line"), 4}, 0}, 15 },
      {{{OSUTF8("polyline"), 8}, 0}, 16 },
      {{{OSUTF8("polygon"), 7}, 0}, 17 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 18 },
      {{{OSUTF8("path"), 4}, 0}, 19 },
      {{{OSUTF8("circle"), 6}, 0}, 20 },
      {{{OSUTF8("ellipse"), 7}, 0}, 21 },
      {{{OSUTF8("g"), 1}, 0}, 22 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 23 },
      {{{OSUTF8("frame"), 5}, 0}, 24 },
      {{{OSUTF8("measure"), 7}, 0}, 25 },
      {{{OSUTF8("caption"), 7}, 0}, 26 },
      {{{OSUTF8("connector"), 9}, 0}, 27 },
      {{{OSUTF8("control"), 7}, 0}, 28 },
      {{{OSUTF8("scene"), 5}, 0}, 29 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 30 },
      {{{OSUTF8("change"), 6}, 0}, 31 },
      {{{OSUTF8("change-start"), 12}, 0}, 32 },
      {{{OSUTF8("change-end"), 10}, 0}, 33 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 34, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* h */
      pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

      if (pvalue->u.h == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_H (pvalue->u.h);

      stat = XmlDec_Odf_H (pctxt, pvalue->u.h);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P (pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List (pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* numbered-paragraph */
      pvalue->u.numbered_paragraph
          = rtxMemAllocType (pctxt, Odf_Numbered_paragraph);

      if (pvalue->u.numbered_paragraph == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Numbered_paragraph (pvalue->u.numbered_paragraph);

      stat = XmlDec_Odf_Numbered_paragraph (pctxt, pvalue->u.numbered_paragraph
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* table */
      pvalue->u.table = rtxMemAllocType (pctxt, Table);

      if (pvalue->u.table == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table ((Table*)pvalue->u.table);

      stat = XmlDec_Table (pctxt, pvalue->u.table);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* a */
      pvalue->u.a = rtxMemAllocType (pctxt, Ns3_A);

      if (pvalue->u.a == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_A ((Ns3_A*)pvalue->u.a);

      stat = XmlDec_Ns3_A (pctxt, pvalue->u.a);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* section */
      pvalue->u.section = rtxMemAllocType (pctxt, Odf_Section);

      if (pvalue->u.section == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Section (pvalue->u.section);

      stat = XmlDec_Odf_Section (pctxt, pvalue->u.section);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* table-of-content */
      pvalue->u.table_of_content
          = rtxMemAllocType (pctxt, Odf_Table_of_content);

      if (pvalue->u.table_of_content == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_of_content (pvalue->u.table_of_content);

      stat = XmlDec_Odf_Table_of_content (pctxt, pvalue->u.table_of_content);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* illustration-index */
      pvalue->u.illustration_index
          = rtxMemAllocType (pctxt, Odf_Illustration_index);

      if (pvalue->u.illustration_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Illustration_index (pvalue->u.illustration_index);

      stat = XmlDec_Odf_Illustration_index (pctxt, pvalue->u.illustration_index
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* table-index */
      pvalue->u.table_index = rtxMemAllocType (pctxt, Odf_Table_index);

      if (pvalue->u.table_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_index (pvalue->u.table_index);

      stat = XmlDec_Odf_Table_index (pctxt, pvalue->u.table_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* object-index */
      pvalue->u.object_index = rtxMemAllocType (pctxt, Odf_Object_index);

      if (pvalue->u.object_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Object_index (pvalue->u.object_index);

      stat = XmlDec_Odf_Object_index (pctxt, pvalue->u.object_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* user-index */
      pvalue->u.user_index = rtxMemAllocType (pctxt, Odf_User_index);

      if (pvalue->u.user_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index (pvalue->u.user_index);

      stat = XmlDec_Odf_User_index (pctxt, pvalue->u.user_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* alphabetical-index */
      pvalue->u.alphabetical_index
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index);

      if (pvalue->u.alphabetical_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index (pvalue->u.alphabetical_index);

      stat = XmlDec_Odf_Alphabetical_index (pctxt, pvalue->u.alphabetical_index
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* bibliography */
      pvalue->u.bibliography = rtxMemAllocType (pctxt, Odf_Bibliography);

      if (pvalue->u.bibliography == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bibliography (pvalue->u.bibliography);

      stat = XmlDec_Odf_Bibliography (pctxt, pvalue->u.bibliography);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* rect */
      pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

      if (pvalue->u.rect == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);

      stat = XmlDec_Ns3_Rect (pctxt, pvalue->u.rect);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* line */
      pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

      if (pvalue->u.line == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);

      stat = XmlDec_Ns3_Line (pctxt, pvalue->u.line);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* polyline */
      pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

      if (pvalue->u.polyline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);

      stat = XmlDec_Ns3_Polyline (pctxt, pvalue->u.polyline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 17: { /* polygon */
      pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

      if (pvalue->u.polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);

      stat = XmlDec_Ns3_Polygon (pctxt, pvalue->u.polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 18: { /* regular-polygon */
      pvalue->u.regular_polygon
          = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

      if (pvalue->u.regular_polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->
         u.regular_polygon);

      stat = XmlDec_Ns3_Regular_polygon (pctxt, pvalue->u.regular_polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 19: { /* path */
      pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

      if (pvalue->u.path == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);

      stat = XmlDec_Ns3_Path (pctxt, pvalue->u.path);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 20: { /* circle */
      pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

      if (pvalue->u.circle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);

      stat = XmlDec_Ns3_Circle (pctxt, pvalue->u.circle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 21: { /* ellipse */
      pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

      if (pvalue->u.ellipse == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);

      stat = XmlDec_Ns3_Ellipse (pctxt, pvalue->u.ellipse);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 22: { /* g */
      pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

      if (pvalue->u.g == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);

      stat = XmlDec_Ns3_G (pctxt, pvalue->u.g);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 23: { /* page-thumbnail */
      pvalue->u.page_thumbnail = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

      if (pvalue->u.page_thumbnail == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->
         u.page_thumbnail);

      stat = XmlDec_Ns3_Page_thumbnail (pctxt, pvalue->u.page_thumbnail);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 24: { /* frame */
      pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

      if (pvalue->u.frame == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);

      stat = XmlDec_Ns3_Frame (pctxt, pvalue->u.frame);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 25: { /* measure */
      pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

      if (pvalue->u.measure == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);

      stat = XmlDec_Ns3_Measure (pctxt, pvalue->u.measure);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 26: { /* caption */
      pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

      if (pvalue->u.caption == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);

      stat = XmlDec_Ns3_Caption (pctxt, pvalue->u.caption);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 27: { /* connector */
      pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

      if (pvalue->u.connector == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);

      stat = XmlDec_Ns3_Connector (pctxt, pvalue->u.connector);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 28: { /* control */
      pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

      if (pvalue->u.control == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);

      stat = XmlDec_Ns3_Control (pctxt, pvalue->u.control);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 29: { /* scene */
      pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

      if (pvalue->u.scene == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);

      stat = XmlDec_Ns7_Scene (pctxt, pvalue->u.scene);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 30: { /* custom-shape */
      pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

      if (pvalue->u.custom_shape == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);

      stat = XmlDec_Ns3_Custom_shape (pctxt, pvalue->u.custom_shape);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 31: { /* change */
      pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

      if (pvalue->u.change == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change (pvalue->u.change);

      stat = XmlDec_Odf_Change (pctxt, pvalue->u.change);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 32: { /* change-start */
      pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

      if (pvalue->u.change_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_start (pvalue->u.change_start);

      stat = XmlDec_Odf_Change_start (pctxt, pvalue->u.change_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 33: { /* change-end */
      pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

      if (pvalue->u.change_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_end (pvalue->u.change_end);

      stat = XmlDec_Odf_Change_end (pctxt, pvalue->u.change_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Note_body                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Note_body (OSCTXT* pctxt, Odf_Note_body *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   Odf_Note_body_element* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (XD_PEEKTAG (pctxt, 0x30)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_UNIV|TM_CONS|16));

   if (XD_PEEKTAG (pctxt, 0xa0)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_CTXT|TM_CONS|0));

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      rtxDListAllocNodeAndData (pctxt, Odf_Note_body_element, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Note_body_element (pdata1);

      stat = asn1D_Odf_Note_body_element (pctxt, 
         pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

int XmlDec_Odf_Note_body (OSCTXT* pctxt, Odf_Note_body* pvalue)
{
   int stat = 0;

   { int elemID;
   Odf_Note_body_element* pdata1;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("h"), 1}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("list"), 4}, 0}, 0 },
      {{{OSUTF8("numbered-paragraph"), 18}, 0}, 0 },
      {{{OSUTF8("table"), 5}, 0}, 0 },
      {{{OSUTF8("a"), 1}, 0}, 0 },
      {{{OSUTF8("section"), 7}, 0}, 0 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 0 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 0 },
      {{{OSUTF8("table-index"), 11}, 0}, 0 },
      {{{OSUTF8("object-index"), 12}, 0}, 0 },
      {{{OSUTF8("user-index"), 10}, 0}, 0 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 0 },
      {{{OSUTF8("bibliography"), 12}, 0}, 0 },
      {{{OSUTF8("rect"), 4}, 0}, 0 },
      {{{OSUTF8("line"), 4}, 0}, 0 },
      {{{OSUTF8("polyline"), 8}, 0}, 0 },
      {{{OSUTF8("polygon"), 7}, 0}, 0 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 0 },
      {{{OSUTF8("path"), 4}, 0}, 0 },
      {{{OSUTF8("circle"), 6}, 0}, 0 },
      {{{OSUTF8("ellipse"), 7}, 0}, 0 },
      {{{OSUTF8("g"), 1}, 0}, 0 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 0 },
      {{{OSUTF8("frame"), 5}, 0}, 0 },
      {{{OSUTF8("measure"), 7}, 0}, 0 },
      {{{OSUTF8("caption"), 7}, 0}, 0 },
      {{{OSUTF8("connector"), 9}, 0}, 0 },
      {{{OSUTF8("control"), 7}, 0}, 0 },
      {{{OSUTF8("scene"), 5}, 0}, 0 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 0 },
      {{{OSUTF8("change"), 6}, 0}, 0 },
      {{{OSUTF8("change-start"), 12}, 0}, 0 },
      {{{OSUTF8("change-end"), 10}, 0}, 0 }
   } ;

   rtxDListInit (pvalue);
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 34, -1, FALSE);
      if (elemID < 0 || elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0:
         rtXmlpMarkLastEventActive (pctxt);

         pdata1 = rtxMemAllocType (pctxt, Odf_Note_body_element);

         if (pdata1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Note_body_element (pdata1);

         stat = XmlDec_Odf_Note_body_element (pctxt, pdata1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         break;

      }
   }

   if (elemID == RTERR_UNEXPELEM || elemID == XML_OK_EOB) {
      stat = 0;
   }
   else return LOG_RTERR (pctxt, elemID);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Note                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Note (OSCTXT* pctxt, Odf_Note *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode note_class */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Note_note_class (pctxt, 
               &pvalue->note_class, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode note_citation */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Note_citation (pctxt, 
               &pvalue->note_citation, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode note_body */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Note_body (pctxt, 
               &pvalue->note_body, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Note (OSCTXT* pctxt, Odf_Note* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("note-class"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 1: /* note-class */
            stat = XmlDec_Odf_Note_note_class (pctxt, &pvalue->note_class);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Note");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Note");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("note-citation"), 13}, 0}, 0 },
      {{{OSUTF8("note-body"), 9}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 1, -1}, {2, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* note-citation */
         stat = XmlDec_Odf_Note_citation (pctxt, &pvalue->note_citation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* note-body */
         stat = XmlDec_Odf_Note_body (pctxt, &pvalue->note_body);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  A_element                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_A_element (OSCTXT* pctxt, Odf_A_element *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.s = rtxMemAllocType (pctxt, Odf_S);

         if (pvalue->u.s == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_S (pvalue->u.s);
         stat = asn1D_Odf_S (pctxt, 
            pvalue->u.s, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.tab = rtxMemAllocType (pctxt, Odf_Tab);

         if (pvalue->u.tab == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Tab (pvalue->u.tab);
         stat = asn1D_Odf_Tab (pctxt, 
            pvalue->u.tab, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.line_break = rtxMemAllocType (pctxt, Odf_Line_break);

         if (pvalue->u.line_break == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Line_break (pvalue->u.line_break);
         stat = asn1D_Odf_Line_break (pctxt, 
            pvalue->u.line_break, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.span = rtxMemAllocType (pctxt, Odf_Span);

         if (pvalue->u.span == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Span ((Odf_Span*)pvalue->u.span);
         stat = asn1D_Odf_Span (pctxt, 
            (Odf_Span*)pvalue->u.span, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.a = rtxMemAllocType (pctxt, Odf_A);

         if (pvalue->u.a == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_A ((Odf_A*)pvalue->u.a);
         stat = asn1D_Odf_A (pctxt, 
            (Odf_A*)pvalue->u.a, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.bookmark = rtxMemAllocType (pctxt, Odf_Bookmark);

         if (pvalue->u.bookmark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bookmark (pvalue->u.bookmark);
         stat = asn1D_Odf_Bookmark (pctxt, 
            pvalue->u.bookmark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.bookmark_start
             = rtxMemAllocType (pctxt, Odf_Bookmark_start);

         if (pvalue->u.bookmark_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bookmark_start (pvalue->u.bookmark_start);
         stat = asn1D_Odf_Bookmark_start (pctxt, 
            pvalue->u.bookmark_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.bookmark_end = rtxMemAllocType (pctxt, Odf_Bookmark_end);

         if (pvalue->u.bookmark_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bookmark_end (pvalue->u.bookmark_end);
         stat = asn1D_Odf_Bookmark_end (pctxt, 
            pvalue->u.bookmark_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.reference_mark
             = rtxMemAllocType (pctxt, Odf_Reference_mark);

         if (pvalue->u.reference_mark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Reference_mark (pvalue->u.reference_mark);
         stat = asn1D_Odf_Reference_mark (pctxt, 
            pvalue->u.reference_mark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.reference_mark_start
             = rtxMemAllocType (pctxt, Odf_Reference_mark_start);

         if (pvalue->u.reference_mark_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Reference_mark_start (pvalue->u.reference_mark_start);
         stat = asn1D_Odf_Reference_mark_start (pctxt, 
            pvalue->u.reference_mark_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.reference_mark_end
             = rtxMemAllocType (pctxt, Odf_Reference_mark_end);

         if (pvalue->u.reference_mark_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Reference_mark_end (pvalue->u.reference_mark_end);
         stat = asn1D_Odf_Reference_mark_end (pctxt, 
            pvalue->u.reference_mark_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.note = rtxMemAllocType (pctxt, Odf_Note);

         if (pvalue->u.note == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Note (pvalue->u.note);
         stat = asn1D_Odf_Note (pctxt, 
            pvalue->u.note, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.ruby = rtxMemAllocType (pctxt, Odf_Ruby);

         if (pvalue->u.ruby == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Ruby (pvalue->u.ruby);
         stat = asn1D_Odf_Ruby (pctxt, 
            pvalue->u.ruby, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.annotation = rtxMemAllocType (pctxt, Ns13_Annotation);

         if (pvalue->u.annotation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Annotation ((Ns13_Annotation*)pvalue->u.annotation);
         stat = asn1D_Ns13_Annotation (pctxt, 
            (Ns13_Annotation*)pvalue->u.annotation, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

         if (pvalue->u.change == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change (pvalue->u.change);
         stat = asn1D_Odf_Change (pctxt, 
            pvalue->u.change, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

         if (pvalue->u.change_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_start (pvalue->u.change_start);
         stat = asn1D_Odf_Change_start (pctxt, 
            pvalue->u.change_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

         if (pvalue->u.change_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_end (pvalue->u.change_end);
         stat = asn1D_Odf_Change_end (pctxt, 
            pvalue->u.change_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      case (TM_CTXT|TM_CONS|17):
         pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

         if (pvalue->u.rect == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);
         stat = asn1D_Ns3_Rect (pctxt, 
            (Ns3_Rect*)pvalue->u.rect, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 18;
         break;

      case (TM_CTXT|TM_CONS|18):
         pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

         if (pvalue->u.line == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);
         stat = asn1D_Ns3_Line (pctxt, 
            (Ns3_Line*)pvalue->u.line, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 19;
         break;

      case (TM_CTXT|TM_CONS|19):
         pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

         if (pvalue->u.polyline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);
         stat = asn1D_Ns3_Polyline (pctxt, 
            (Ns3_Polyline*)pvalue->u.polyline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 20;
         break;

      case (TM_CTXT|TM_CONS|20):
         pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

         if (pvalue->u.polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);
         stat = asn1D_Ns3_Polygon (pctxt, 
            (Ns3_Polygon*)pvalue->u.polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 21;
         break;

      case (TM_CTXT|TM_CONS|21):
         pvalue->u.regular_polygon
             = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

         if (pvalue->u.regular_polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->u.regular_polygon);
         stat = asn1D_Ns3_Regular_polygon (pctxt, 
            (Ns3_Regular_polygon*)pvalue->u.regular_polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 22;
         break;

      case (TM_CTXT|TM_CONS|22):
         pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

         if (pvalue->u.path == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);
         stat = asn1D_Ns3_Path (pctxt, 
            (Ns3_Path*)pvalue->u.path, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 23;
         break;

      case (TM_CTXT|TM_CONS|23):
         pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

         if (pvalue->u.circle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);
         stat = asn1D_Ns3_Circle (pctxt, 
            (Ns3_Circle*)pvalue->u.circle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 24;
         break;

      case (TM_CTXT|TM_CONS|24):
         pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

         if (pvalue->u.ellipse == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);
         stat = asn1D_Ns3_Ellipse (pctxt, 
            (Ns3_Ellipse*)pvalue->u.ellipse, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 25;
         break;

      case (TM_CTXT|TM_CONS|25):
         pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

         if (pvalue->u.g == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);
         stat = asn1D_Ns3_G (pctxt, 
            (Ns3_G*)pvalue->u.g, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 26;
         break;

      case (TM_CTXT|TM_CONS|26):
         pvalue->u.page_thumbnail
             = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

         if (pvalue->u.page_thumbnail == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->u.page_thumbnail);
         stat = asn1D_Ns3_Page_thumbnail (pctxt, 
            (Ns3_Page_thumbnail*)pvalue->u.page_thumbnail, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 27;
         break;

      case (TM_CTXT|TM_CONS|27):
         pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

         if (pvalue->u.frame == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);
         stat = asn1D_Ns3_Frame (pctxt, 
            (Ns3_Frame*)pvalue->u.frame, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 28;
         break;

      case (TM_CTXT|TM_CONS|28):
         pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

         if (pvalue->u.measure == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);
         stat = asn1D_Ns3_Measure (pctxt, 
            (Ns3_Measure*)pvalue->u.measure, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 29;
         break;

      case (TM_CTXT|TM_CONS|29):
         pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

         if (pvalue->u.caption == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);
         stat = asn1D_Ns3_Caption (pctxt, 
            (Ns3_Caption*)pvalue->u.caption, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 30;
         break;

      case (TM_CTXT|TM_CONS|30):
         pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

         if (pvalue->u.connector == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);
         stat = asn1D_Ns3_Connector (pctxt, 
            (Ns3_Connector*)pvalue->u.connector, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 31;
         break;

      case (TM_CTXT|TM_CONS|31):
         pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

         if (pvalue->u.control == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);
         stat = asn1D_Ns3_Control (pctxt, 
            (Ns3_Control*)pvalue->u.control, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 32;
         break;

      case (TM_CTXT|TM_CONS|32):
         pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

         if (pvalue->u.scene == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);
         stat = asn1D_Ns7_Scene (pctxt, 
            (Ns7_Scene*)pvalue->u.scene, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 33;
         break;

      case (TM_CTXT|TM_CONS|33):
         pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

         if (pvalue->u.custom_shape == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);
         stat = asn1D_Ns3_Custom_shape (pctxt, 
            (Ns3_Custom_shape*)pvalue->u.custom_shape, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 34;
         break;

      case (TM_CTXT|TM_CONS|34):
         pvalue->u.a_1 = rtxMemAllocType (pctxt, Ns3_A);

         if (pvalue->u.a_1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_A ((Ns3_A*)pvalue->u.a_1);
         stat = asn1D_Ns3_A (pctxt, 
            (Ns3_A*)pvalue->u.a_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 35;
         break;

      case (TM_CTXT|TM_CONS|35):
         pvalue->u.date = rtxMemAllocType (pctxt, Odf_Date);

         if (pvalue->u.date == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Date (pvalue->u.date);
         stat = asn1D_Odf_Date (pctxt, 
            pvalue->u.date, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 36;
         break;

      case (TM_CTXT|TM_CONS|36):
         pvalue->u.time_ = rtxMemAllocType (pctxt, Odf_Time);

         if (pvalue->u.time_ == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Time (pvalue->u.time_);
         stat = asn1D_Odf_Time (pctxt, 
            pvalue->u.time_, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 37;
         break;

      case (TM_CTXT|TM_CONS|37):
         pvalue->u.page_number = rtxMemAllocType (pctxt, Odf_Page_number);

         if (pvalue->u.page_number == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Page_number (pvalue->u.page_number);
         stat = asn1D_Odf_Page_number (pctxt, 
            pvalue->u.page_number, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 38;
         break;

      case (TM_CTXT|TM_CONS|38):
         pvalue->u.page_continuation
             = rtxMemAllocType (pctxt, Odf_Page_continuation);

         if (pvalue->u.page_continuation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Page_continuation (pvalue->u.page_continuation);
         stat = asn1D_Odf_Page_continuation (pctxt, 
            pvalue->u.page_continuation, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 39;
         break;

      case (TM_CTXT|TM_CONS|39):
         pvalue->u.sender_firstname
             = rtxMemAllocType (pctxt, Odf_Sender_firstname);

         if (pvalue->u.sender_firstname == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_firstname (pvalue->u.sender_firstname);
         stat = asn1D_Odf_Sender_firstname (pctxt, 
            pvalue->u.sender_firstname, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 40;
         break;

      case (TM_CTXT|TM_CONS|40):
         pvalue->u.sender_lastname
             = rtxMemAllocType (pctxt, Odf_Sender_lastname);

         if (pvalue->u.sender_lastname == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_lastname (pvalue->u.sender_lastname);
         stat = asn1D_Odf_Sender_lastname (pctxt, 
            pvalue->u.sender_lastname, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 41;
         break;

      case (TM_CTXT|TM_CONS|41):
         pvalue->u.sender_initials
             = rtxMemAllocType (pctxt, Odf_Sender_initials);

         if (pvalue->u.sender_initials == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_initials (pvalue->u.sender_initials);
         stat = asn1D_Odf_Sender_initials (pctxt, 
            pvalue->u.sender_initials, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 42;
         break;

      case (TM_CTXT|TM_CONS|42):
         pvalue->u.sender_title = rtxMemAllocType (pctxt, Odf_Sender_title);

         if (pvalue->u.sender_title == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_title (pvalue->u.sender_title);
         stat = asn1D_Odf_Sender_title (pctxt, 
            pvalue->u.sender_title, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 43;
         break;

      case (TM_CTXT|TM_CONS|43):
         pvalue->u.sender_position
             = rtxMemAllocType (pctxt, Odf_Sender_position);

         if (pvalue->u.sender_position == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_position (pvalue->u.sender_position);
         stat = asn1D_Odf_Sender_position (pctxt, 
            pvalue->u.sender_position, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 44;
         break;

      case (TM_CTXT|TM_CONS|44):
         pvalue->u.sender_email = rtxMemAllocType (pctxt, Odf_Sender_email);

         if (pvalue->u.sender_email == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_email (pvalue->u.sender_email);
         stat = asn1D_Odf_Sender_email (pctxt, 
            pvalue->u.sender_email, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 45;
         break;

      case (TM_CTXT|TM_CONS|45):
         pvalue->u.sender_phone_private
             = rtxMemAllocType (pctxt, Odf_Sender_phone_private);

         if (pvalue->u.sender_phone_private == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_phone_private (pvalue->u.sender_phone_private);
         stat = asn1D_Odf_Sender_phone_private (pctxt, 
            pvalue->u.sender_phone_private, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 46;
         break;

      case (TM_CTXT|TM_CONS|46):
         pvalue->u.sender_fax = rtxMemAllocType (pctxt, Odf_Sender_fax);

         if (pvalue->u.sender_fax == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_fax (pvalue->u.sender_fax);
         stat = asn1D_Odf_Sender_fax (pctxt, 
            pvalue->u.sender_fax, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 47;
         break;

      case (TM_CTXT|TM_CONS|47):
         pvalue->u.sender_company
             = rtxMemAllocType (pctxt, Odf_Sender_company);

         if (pvalue->u.sender_company == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_company (pvalue->u.sender_company);
         stat = asn1D_Odf_Sender_company (pctxt, 
            pvalue->u.sender_company, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 48;
         break;

      case (TM_CTXT|TM_CONS|48):
         pvalue->u.sender_phone_work
             = rtxMemAllocType (pctxt, Odf_Sender_phone_work);

         if (pvalue->u.sender_phone_work == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_phone_work (pvalue->u.sender_phone_work);
         stat = asn1D_Odf_Sender_phone_work (pctxt, 
            pvalue->u.sender_phone_work, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 49;
         break;

      case (TM_CTXT|TM_CONS|49):
         pvalue->u.sender_street = rtxMemAllocType (pctxt, Odf_Sender_street);

         if (pvalue->u.sender_street == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_street (pvalue->u.sender_street);
         stat = asn1D_Odf_Sender_street (pctxt, 
            pvalue->u.sender_street, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 50;
         break;

      case (TM_CTXT|TM_CONS|50):
         pvalue->u.sender_city = rtxMemAllocType (pctxt, Odf_Sender_city);

         if (pvalue->u.sender_city == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_city (pvalue->u.sender_city);
         stat = asn1D_Odf_Sender_city (pctxt, 
            pvalue->u.sender_city, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 51;
         break;

      case (TM_CTXT|TM_CONS|51):
         pvalue->u.sender_postal_code
             = rtxMemAllocType (pctxt, Odf_Sender_postal_code);

         if (pvalue->u.sender_postal_code == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_postal_code (pvalue->u.sender_postal_code);
         stat = asn1D_Odf_Sender_postal_code (pctxt, 
            pvalue->u.sender_postal_code, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 52;
         break;

      case (TM_CTXT|TM_CONS|52):
         pvalue->u.sender_country
             = rtxMemAllocType (pctxt, Odf_Sender_country);

         if (pvalue->u.sender_country == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_country (pvalue->u.sender_country);
         stat = asn1D_Odf_Sender_country (pctxt, 
            pvalue->u.sender_country, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 53;
         break;

      case (TM_CTXT|TM_CONS|53):
         pvalue->u.sender_state_or_province
             = rtxMemAllocType (pctxt, Odf_Sender_state_or_province);

         if (pvalue->u.sender_state_or_province == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_state_or_province (pvalue->u.sender_state_or_province);
         stat = asn1D_Odf_Sender_state_or_province (pctxt, 
            pvalue->u.sender_state_or_province, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 54;
         break;

      case (TM_CTXT|TM_CONS|54):
         pvalue->u.author_name = rtxMemAllocType (pctxt, Odf_Author_name);

         if (pvalue->u.author_name == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Author_name (pvalue->u.author_name);
         stat = asn1D_Odf_Author_name (pctxt, 
            pvalue->u.author_name, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 55;
         break;

      case (TM_CTXT|TM_CONS|55):
         pvalue->u.author_initials
             = rtxMemAllocType (pctxt, Odf_Author_initials);

         if (pvalue->u.author_initials == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Author_initials (pvalue->u.author_initials);
         stat = asn1D_Odf_Author_initials (pctxt, 
            pvalue->u.author_initials, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 56;
         break;

      case (TM_CTXT|TM_CONS|56):
         pvalue->u.chapter = rtxMemAllocType (pctxt, Odf_Chapter);

         if (pvalue->u.chapter == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Chapter (pvalue->u.chapter);
         stat = asn1D_Odf_Chapter (pctxt, 
            pvalue->u.chapter, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 57;
         break;

      case (TM_CTXT|TM_CONS|57):
         pvalue->u.file_name = rtxMemAllocType (pctxt, Odf_File_name);

         if (pvalue->u.file_name == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_File_name (pvalue->u.file_name);
         stat = asn1D_Odf_File_name (pctxt, 
            pvalue->u.file_name, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 58;
         break;

      case (TM_CTXT|TM_CONS|58):
         pvalue->u.template_name = rtxMemAllocType (pctxt, Odf_Template_name);

         if (pvalue->u.template_name == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Template_name (pvalue->u.template_name);
         stat = asn1D_Odf_Template_name (pctxt, 
            pvalue->u.template_name, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 59;
         break;

      case (TM_CTXT|TM_PRIM|59):
      case (TM_CTXT|TM_CONS|59):
         stat = asn1D_Odf_Sheet_name (pctxt, 
            &pvalue->u.sheet_name, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 60;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_CONS|60):
         pvalue->u.variable_set = rtxMemAllocType (pctxt, Odf_Variable_set);

         if (pvalue->u.variable_set == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Variable_set (pvalue->u.variable_set);
         stat = asn1D_Odf_Variable_set (pctxt, 
            pvalue->u.variable_set, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 61;
         break;

      case (TM_CTXT|TM_CONS|61):
         pvalue->u.variable_get = rtxMemAllocType (pctxt, Odf_Variable_get);

         if (pvalue->u.variable_get == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Variable_get (pvalue->u.variable_get);
         stat = asn1D_Odf_Variable_get (pctxt, 
            pvalue->u.variable_get, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 62;
         break;

      case (TM_CTXT|TM_CONS|62):
         pvalue->u.variable_input
             = rtxMemAllocType (pctxt, Odf_Variable_input);

         if (pvalue->u.variable_input == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Variable_input (pvalue->u.variable_input);
         stat = asn1D_Odf_Variable_input (pctxt, 
            pvalue->u.variable_input, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 63;
         break;

      case (TM_CTXT|TM_CONS|63):
         pvalue->u.user_field_get
             = rtxMemAllocType (pctxt, Odf_User_field_get);

         if (pvalue->u.user_field_get == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_field_get (pvalue->u.user_field_get);
         stat = asn1D_Odf_User_field_get (pctxt, 
            pvalue->u.user_field_get, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 64;
         break;

      case (TM_CTXT|TM_CONS|64):
         pvalue->u.user_field_input
             = rtxMemAllocType (pctxt, Odf_User_field_input);

         if (pvalue->u.user_field_input == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_field_input (pvalue->u.user_field_input);
         stat = asn1D_Odf_User_field_input (pctxt, 
            pvalue->u.user_field_input, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 65;
         break;

      case (TM_CTXT|TM_CONS|65):
         pvalue->u.sequence = rtxMemAllocType (pctxt, Odf_Sequence);

         if (pvalue->u.sequence == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sequence (pvalue->u.sequence);
         stat = asn1D_Odf_Sequence (pctxt, 
            pvalue->u.sequence, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 66;
         break;

      case (TM_CTXT|TM_CONS|66):
         pvalue->u.expression = rtxMemAllocType (pctxt, Odf_Expression);

         if (pvalue->u.expression == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Expression (pvalue->u.expression);
         stat = asn1D_Odf_Expression (pctxt, 
            pvalue->u.expression, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 67;
         break;

      case (TM_CTXT|TM_CONS|67):
         pvalue->u.text_input = rtxMemAllocType (pctxt, Odf_Text_input);

         if (pvalue->u.text_input == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Text_input (pvalue->u.text_input);
         stat = asn1D_Odf_Text_input (pctxt, 
            pvalue->u.text_input, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 68;
         break;

      case (TM_CTXT|TM_CONS|68):
         pvalue->u.initial_creator
             = rtxMemAllocType (pctxt, Odf_Initial_creator);

         if (pvalue->u.initial_creator == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Initial_creator (pvalue->u.initial_creator);
         stat = asn1D_Odf_Initial_creator (pctxt, 
            pvalue->u.initial_creator, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 69;
         break;

      case (TM_CTXT|TM_CONS|69):
         pvalue->u.creation_date = rtxMemAllocType (pctxt, Odf_Creation_date);

         if (pvalue->u.creation_date == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Creation_date (pvalue->u.creation_date);
         stat = asn1D_Odf_Creation_date (pctxt, 
            pvalue->u.creation_date, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 70;
         break;

      case (TM_CTXT|TM_CONS|70):
         pvalue->u.creation_time = rtxMemAllocType (pctxt, Odf_Creation_time);

         if (pvalue->u.creation_time == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Creation_time (pvalue->u.creation_time);
         stat = asn1D_Odf_Creation_time (pctxt, 
            pvalue->u.creation_time, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 71;
         break;

      case (TM_CTXT|TM_CONS|71):
         pvalue->u.description = rtxMemAllocType (pctxt, Odf_Description);

         if (pvalue->u.description == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Description (pvalue->u.description);
         stat = asn1D_Odf_Description (pctxt, 
            pvalue->u.description, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 72;
         break;

      case (TM_CTXT|TM_CONS|72):
         pvalue->u.user_defined = rtxMemAllocType (pctxt, Odf_User_defined);

         if (pvalue->u.user_defined == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_defined (pvalue->u.user_defined);
         stat = asn1D_Odf_User_defined (pctxt, 
            pvalue->u.user_defined, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 73;
         break;

      case (TM_CTXT|TM_CONS|73):
         pvalue->u.print_time = rtxMemAllocType (pctxt, Odf_Print_time);

         if (pvalue->u.print_time == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Print_time (pvalue->u.print_time);
         stat = asn1D_Odf_Print_time (pctxt, 
            pvalue->u.print_time, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 74;
         break;

      case (TM_CTXT|TM_CONS|74):
         pvalue->u.print_date = rtxMemAllocType (pctxt, Odf_Print_date);

         if (pvalue->u.print_date == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Print_date (pvalue->u.print_date);
         stat = asn1D_Odf_Print_date (pctxt, 
            pvalue->u.print_date, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 75;
         break;

      case (TM_CTXT|TM_CONS|75):
         pvalue->u.printed_by = rtxMemAllocType (pctxt, Odf_Printed_by);

         if (pvalue->u.printed_by == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Printed_by (pvalue->u.printed_by);
         stat = asn1D_Odf_Printed_by (pctxt, 
            pvalue->u.printed_by, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 76;
         break;

      case (TM_CTXT|TM_CONS|76):
         pvalue->u.title = rtxMemAllocType (pctxt, Odf_Title);

         if (pvalue->u.title == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Title (pvalue->u.title);
         stat = asn1D_Odf_Title (pctxt, 
            pvalue->u.title, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 77;
         break;

      case (TM_CTXT|TM_CONS|77):
         pvalue->u.subject = rtxMemAllocType (pctxt, Odf_Subject);

         if (pvalue->u.subject == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Subject (pvalue->u.subject);
         stat = asn1D_Odf_Subject (pctxt, 
            pvalue->u.subject, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 78;
         break;

      case (TM_CTXT|TM_CONS|78):
         pvalue->u.keywords = rtxMemAllocType (pctxt, Odf_Keywords);

         if (pvalue->u.keywords == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Keywords (pvalue->u.keywords);
         stat = asn1D_Odf_Keywords (pctxt, 
            pvalue->u.keywords, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 79;
         break;

      case (TM_CTXT|TM_CONS|79):
         pvalue->u.editing_cycles
             = rtxMemAllocType (pctxt, Odf_Editing_cycles);

         if (pvalue->u.editing_cycles == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Editing_cycles (pvalue->u.editing_cycles);
         stat = asn1D_Odf_Editing_cycles (pctxt, 
            pvalue->u.editing_cycles, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 80;
         break;

      case (TM_CTXT|TM_CONS|80):
         pvalue->u.editing_duration
             = rtxMemAllocType (pctxt, Odf_Editing_duration);

         if (pvalue->u.editing_duration == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Editing_duration (pvalue->u.editing_duration);
         stat = asn1D_Odf_Editing_duration (pctxt, 
            pvalue->u.editing_duration, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 81;
         break;

      case (TM_CTXT|TM_CONS|81):
         pvalue->u.modification_time
             = rtxMemAllocType (pctxt, Odf_Modification_time);

         if (pvalue->u.modification_time == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Modification_time (pvalue->u.modification_time);
         stat = asn1D_Odf_Modification_time (pctxt, 
            pvalue->u.modification_time, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 82;
         break;

      case (TM_CTXT|TM_CONS|82):
         pvalue->u.modification_date
             = rtxMemAllocType (pctxt, Odf_Modification_date);

         if (pvalue->u.modification_date == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Modification_date (pvalue->u.modification_date);
         stat = asn1D_Odf_Modification_date (pctxt, 
            pvalue->u.modification_date, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 83;
         break;

      case (TM_CTXT|TM_CONS|83):
         pvalue->u.creator = rtxMemAllocType (pctxt, Odf_Creator);

         if (pvalue->u.creator == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Creator (pvalue->u.creator);
         stat = asn1D_Odf_Creator (pctxt, 
            pvalue->u.creator, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 84;
         break;

      case (TM_CTXT|TM_CONS|84):
         pvalue->u.element271 = rtxMemAllocType (pctxt, Odf_Element271_group);

         if (pvalue->u.element271 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Element271_group (pvalue->u.element271);
         stat = asn1D_Odf_Element271_group (pctxt, 
            pvalue->u.element271, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 85;
         break;

      case (TM_CTXT|TM_CONS|85):
         pvalue->u.database_display
             = rtxMemAllocType (pctxt, Odf_Database_display);

         if (pvalue->u.database_display == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Database_display (pvalue->u.database_display);
         stat = asn1D_Odf_Database_display (pctxt, 
            pvalue->u.database_display, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 86;
         break;

      case (TM_CTXT|TM_CONS|86):
         pvalue->u.database_next = rtxMemAllocType (pctxt, Odf_Database_next);

         if (pvalue->u.database_next == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Database_next (pvalue->u.database_next);
         stat = asn1D_Odf_Database_next (pctxt, 
            pvalue->u.database_next, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 87;
         break;

      case (TM_CTXT|TM_CONS|87):
         pvalue->u.database_row_select
             = rtxMemAllocType (pctxt, Odf_Database_row_select);

         if (pvalue->u.database_row_select == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Database_row_select (pvalue->u.database_row_select);
         stat = asn1D_Odf_Database_row_select (pctxt, 
            pvalue->u.database_row_select, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 88;
         break;

      case (TM_CTXT|TM_CONS|88):
         pvalue->u.database_row_number
             = rtxMemAllocType (pctxt, Odf_Database_row_number);

         if (pvalue->u.database_row_number == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Database_row_number (pvalue->u.database_row_number);
         stat = asn1D_Odf_Database_row_number (pctxt, 
            pvalue->u.database_row_number, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 89;
         break;

      case (TM_CTXT|TM_CONS|89):
         pvalue->u.database_name = rtxMemAllocType (pctxt, Odf_Database_name);

         if (pvalue->u.database_name == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Database_name (pvalue->u.database_name);
         stat = asn1D_Odf_Database_name (pctxt, 
            pvalue->u.database_name, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 90;
         break;

      case (TM_CTXT|TM_CONS|90):
         pvalue->u.page_variable_set
             = rtxMemAllocType (pctxt, Odf_Page_variable_set);

         if (pvalue->u.page_variable_set == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Page_variable_set (pvalue->u.page_variable_set);
         stat = asn1D_Odf_Page_variable_set (pctxt, 
            pvalue->u.page_variable_set, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 91;
         break;

      case (TM_CTXT|TM_CONS|91):
         pvalue->u.page_variable_get
             = rtxMemAllocType (pctxt, Odf_Page_variable_get);

         if (pvalue->u.page_variable_get == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Page_variable_get (pvalue->u.page_variable_get);
         stat = asn1D_Odf_Page_variable_get (pctxt, 
            pvalue->u.page_variable_get, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 92;
         break;

      case (TM_CTXT|TM_CONS|92):
         pvalue->u.placeholder = rtxMemAllocType (pctxt, Odf_Placeholder);

         if (pvalue->u.placeholder == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Placeholder (pvalue->u.placeholder);
         stat = asn1D_Odf_Placeholder (pctxt, 
            pvalue->u.placeholder, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 93;
         break;

      case (TM_CTXT|TM_CONS|93):
         pvalue->u.conditional_text
             = rtxMemAllocType (pctxt, Odf_Conditional_text);

         if (pvalue->u.conditional_text == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Conditional_text (pvalue->u.conditional_text);
         stat = asn1D_Odf_Conditional_text (pctxt, 
            pvalue->u.conditional_text, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 94;
         break;

      case (TM_CTXT|TM_CONS|94):
         pvalue->u.hidden_text = rtxMemAllocType (pctxt, Odf_Hidden_text);

         if (pvalue->u.hidden_text == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Hidden_text (pvalue->u.hidden_text);
         stat = asn1D_Odf_Hidden_text (pctxt, 
            pvalue->u.hidden_text, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 95;
         break;

      case (TM_CTXT|TM_CONS|95):
         pvalue->u.element282 = rtxMemAllocType (pctxt, Odf_Element282_group);

         if (pvalue->u.element282 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Element282_group (pvalue->u.element282);
         stat = asn1D_Odf_Element282_group (pctxt, 
            pvalue->u.element282, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 96;
         break;

      case (TM_CTXT|TM_CONS|96):
         pvalue->u.note_ref = rtxMemAllocType (pctxt, Odf_Note_ref);

         if (pvalue->u.note_ref == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Note_ref (pvalue->u.note_ref);
         stat = asn1D_Odf_Note_ref (pctxt, 
            pvalue->u.note_ref, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 97;
         break;

      case (TM_CTXT|TM_CONS|97):
         pvalue->u.sequence_ref = rtxMemAllocType (pctxt, Odf_Sequence_ref);

         if (pvalue->u.sequence_ref == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sequence_ref (pvalue->u.sequence_ref);
         stat = asn1D_Odf_Sequence_ref (pctxt, 
            pvalue->u.sequence_ref, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 98;
         break;

      case (TM_CTXT|TM_CONS|98):
         pvalue->u.script = rtxMemAllocType (pctxt, Odf_Script);

         if (pvalue->u.script == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Script (pvalue->u.script);
         stat = asn1D_Odf_Script (pctxt, 
            pvalue->u.script, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 99;
         break;

      case (TM_CTXT|TM_CONS|99):
         pvalue->u.execute_macro = rtxMemAllocType (pctxt, Odf_Execute_macro);

         if (pvalue->u.execute_macro == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Execute_macro (pvalue->u.execute_macro);
         stat = asn1D_Odf_Execute_macro (pctxt, 
            pvalue->u.execute_macro, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 100;
         break;

      case (TM_CTXT|TM_CONS|100):
         pvalue->u.hidden_paragraph
             = rtxMemAllocType (pctxt, Odf_Hidden_paragraph);

         if (pvalue->u.hidden_paragraph == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Hidden_paragraph (pvalue->u.hidden_paragraph);
         stat = asn1D_Odf_Hidden_paragraph (pctxt, 
            pvalue->u.hidden_paragraph, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 101;
         break;

      case (TM_CTXT|TM_CONS|101):
         pvalue->u.dde_connection
             = rtxMemAllocType (pctxt, Odf_Dde_connection);

         if (pvalue->u.dde_connection == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Dde_connection (pvalue->u.dde_connection);
         stat = asn1D_Odf_Dde_connection (pctxt, 
            pvalue->u.dde_connection, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 102;
         break;

      case (TM_CTXT|TM_CONS|102):
         pvalue->u.measure_1 = rtxMemAllocType (pctxt, Odf_Measure);

         if (pvalue->u.measure_1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Measure (pvalue->u.measure_1);
         stat = asn1D_Odf_Measure (pctxt, 
            pvalue->u.measure_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 103;
         break;

      case (TM_CTXT|TM_CONS|103):
         pvalue->u.table_formula = rtxMemAllocType (pctxt, Odf_Table_formula);

         if (pvalue->u.table_formula == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_formula (pvalue->u.table_formula);
         stat = asn1D_Odf_Table_formula (pctxt, 
            pvalue->u.table_formula, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 104;
         break;

      case (TM_CTXT|TM_CONS|104):
         pvalue->u.toc_mark_start
             = rtxMemAllocType (pctxt, Odf_Toc_mark_start);

         if (pvalue->u.toc_mark_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Toc_mark_start (pvalue->u.toc_mark_start);
         stat = asn1D_Odf_Toc_mark_start (pctxt, 
            pvalue->u.toc_mark_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 105;
         break;

      case (TM_CTXT|TM_CONS|105):
         pvalue->u.toc_mark_end = rtxMemAllocType (pctxt, Odf_Toc_mark_end);

         if (pvalue->u.toc_mark_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Toc_mark_end (pvalue->u.toc_mark_end);
         stat = asn1D_Odf_Toc_mark_end (pctxt, 
            pvalue->u.toc_mark_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 106;
         break;

      case (TM_CTXT|TM_CONS|106):
         pvalue->u.toc_mark = rtxMemAllocType (pctxt, Odf_Toc_mark);

         if (pvalue->u.toc_mark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Toc_mark (pvalue->u.toc_mark);
         stat = asn1D_Odf_Toc_mark (pctxt, 
            pvalue->u.toc_mark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 107;
         break;

      case (TM_CTXT|TM_CONS|107):
         pvalue->u.user_index_mark_start
             = rtxMemAllocType (pctxt, Odf_User_index_mark_start);

         if (pvalue->u.user_index_mark_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index_mark_start (pvalue->u.user_index_mark_start);
         stat = asn1D_Odf_User_index_mark_start (pctxt, 
            pvalue->u.user_index_mark_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 108;
         break;

      case (TM_CTXT|TM_CONS|108):
         pvalue->u.user_index_mark_end
             = rtxMemAllocType (pctxt, Odf_User_index_mark_end);

         if (pvalue->u.user_index_mark_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index_mark_end (pvalue->u.user_index_mark_end);
         stat = asn1D_Odf_User_index_mark_end (pctxt, 
            pvalue->u.user_index_mark_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 109;
         break;

      case (TM_CTXT|TM_CONS|109):
         pvalue->u.user_index_mark
             = rtxMemAllocType (pctxt, Odf_User_index_mark);

         if (pvalue->u.user_index_mark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index_mark (pvalue->u.user_index_mark);
         stat = asn1D_Odf_User_index_mark (pctxt, 
            pvalue->u.user_index_mark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 110;
         break;

      case (TM_CTXT|TM_CONS|110):
         pvalue->u.alphabetical_index_mark_start
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark_start);

         if (pvalue->u.alphabetical_index_mark_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index_mark_start (pvalue->u.alphabetical_index_mark_start);
         stat = asn1D_Odf_Alphabetical_index_mark_start (pctxt, 
            pvalue->u.alphabetical_index_mark_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 111;
         break;

      case (TM_CTXT|TM_CONS|111):
         pvalue->u.alphabetical_index_mark_end
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark_end);

         if (pvalue->u.alphabetical_index_mark_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index_mark_end (pvalue->u.alphabetical_index_mark_end);
         stat = asn1D_Odf_Alphabetical_index_mark_end (pctxt, 
            pvalue->u.alphabetical_index_mark_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 112;
         break;

      case (TM_CTXT|TM_CONS|112):
         pvalue->u.alphabetical_index_mark
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark);

         if (pvalue->u.alphabetical_index_mark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index_mark (pvalue->u.alphabetical_index_mark);
         stat = asn1D_Odf_Alphabetical_index_mark (pctxt, 
            pvalue->u.alphabetical_index_mark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 113;
         break;

      case (TM_CTXT|TM_CONS|113):
         pvalue->u.bibliography_mark
             = rtxMemAllocType (pctxt, Odf_Bibliography_mark);

         if (pvalue->u.bibliography_mark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bibliography_mark (pvalue->u.bibliography_mark);
         stat = asn1D_Odf_Bibliography_mark (pctxt, 
            pvalue->u.bibliography_mark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 114;
         break;

      case (TM_CTXT|TM_CONS|114):
         pvalue->u.header = rtxMemAllocType (pctxt, Ns10_Header);

         if (pvalue->u.header == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns10_Header ((Ns10_Header*)pvalue->u.header);
         stat = asn1D_Ns10_Header (pctxt, 
            (Ns10_Header*)pvalue->u.header, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 115;
         break;

      case (TM_CTXT|TM_CONS|115):
         pvalue->u.footer = rtxMemAllocType (pctxt, Ns10_Footer);

         if (pvalue->u.footer == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns10_Footer ((Ns10_Footer*)pvalue->u.footer);
         stat = asn1D_Ns10_Footer (pctxt, 
            (Ns10_Footer*)pvalue->u.footer, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 116;
         break;

      case (TM_CTXT|TM_CONS|116):
         pvalue->u.date_time = rtxMemAllocType (pctxt, Ns10_Date_time);

         if (pvalue->u.date_time == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns10_Date_time ((Ns10_Date_time*)pvalue->u.date_time);
         stat = asn1D_Ns10_Date_time (pctxt, 
            (Ns10_Date_time*)pvalue->u.date_time, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 117;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_A_element (OSCTXT* pctxt, Odf_A_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("s"), 1}, 0}, 0 },
      {{{OSUTF8("tab"), 3}, 0}, 1 },
      {{{OSUTF8("line-break"), 10}, 0}, 2 },
      {{{OSUTF8("span"), 4}, 0}, 3 },
      {{{OSUTF8("a"), 1}, 0}, 4 },
      {{{OSUTF8("bookmark"), 8}, 0}, 5 },
      {{{OSUTF8("bookmark-start"), 14}, 0}, 6 },
      {{{OSUTF8("bookmark-end"), 12}, 0}, 7 },
      {{{OSUTF8("reference-mark"), 14}, 0}, 8 },
      {{{OSUTF8("reference-mark-start"), 20}, 0}, 9 },
      {{{OSUTF8("reference-mark-end"), 18}, 0}, 10 },
      {{{OSUTF8("note"), 4}, 0}, 11 },
      {{{OSUTF8("ruby"), 4}, 0}, 12 },
      {{{OSUTF8("annotation"), 10}, 0}, 13 },
      {{{OSUTF8("change"), 6}, 0}, 14 },
      {{{OSUTF8("change-start"), 12}, 0}, 15 },
      {{{OSUTF8("change-end"), 10}, 0}, 16 },
      {{{OSUTF8("rect"), 4}, 0}, 17 },
      {{{OSUTF8("line"), 4}, 0}, 18 },
      {{{OSUTF8("polyline"), 8}, 0}, 19 },
      {{{OSUTF8("polygon"), 7}, 0}, 20 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 21 },
      {{{OSUTF8("path"), 4}, 0}, 22 },
      {{{OSUTF8("circle"), 6}, 0}, 23 },
      {{{OSUTF8("ellipse"), 7}, 0}, 24 },
      {{{OSUTF8("g"), 1}, 0}, 25 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 26 },
      {{{OSUTF8("frame"), 5}, 0}, 27 },
      {{{OSUTF8("measure"), 7}, 0}, 28 },
      {{{OSUTF8("caption"), 7}, 0}, 29 },
      {{{OSUTF8("connector"), 9}, 0}, 30 },
      {{{OSUTF8("control"), 7}, 0}, 31 },
      {{{OSUTF8("scene"), 5}, 0}, 32 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 33 },
      {{{OSUTF8("a"), 1}, 0}, 34 },
      {{{OSUTF8("date"), 4}, 0}, 35 },
      {{{OSUTF8("time"), 4}, 0}, 36 },
      {{{OSUTF8("page-number"), 11}, 0}, 37 },
      {{{OSUTF8("page-continuation"), 17}, 0}, 38 },
      {{{OSUTF8("sender-firstname"), 16}, 0}, 39 },
      {{{OSUTF8("sender-lastname"), 15}, 0}, 40 },
      {{{OSUTF8("sender-initials"), 15}, 0}, 41 },
      {{{OSUTF8("sender-title"), 12}, 0}, 42 },
      {{{OSUTF8("sender-position"), 15}, 0}, 43 },
      {{{OSUTF8("sender-email"), 12}, 0}, 44 },
      {{{OSUTF8("sender-phone-private"), 20}, 0}, 45 },
      {{{OSUTF8("sender-fax"), 10}, 0}, 46 },
      {{{OSUTF8("sender-company"), 14}, 0}, 47 },
      {{{OSUTF8("sender-phone-work"), 17}, 0}, 48 },
      {{{OSUTF8("sender-street"), 13}, 0}, 49 },
      {{{OSUTF8("sender-city"), 11}, 0}, 50 },
      {{{OSUTF8("sender-postal-code"), 18}, 0}, 51 },
      {{{OSUTF8("sender-country"), 14}, 0}, 52 },
      {{{OSUTF8("sender-state-or-province"), 24}, 0}, 53 },
      {{{OSUTF8("author-name"), 11}, 0}, 54 },
      {{{OSUTF8("author-initials"), 15}, 0}, 55 },
      {{{OSUTF8("chapter"), 7}, 0}, 56 },
      {{{OSUTF8("file-name"), 9}, 0}, 57 },
      {{{OSUTF8("template-name"), 13}, 0}, 58 },
      {{{OSUTF8("sheet-name"), 10}, 0}, 59 },
      {{{OSUTF8("variable-set"), 12}, 0}, 60 },
      {{{OSUTF8("variable-get"), 12}, 0}, 61 },
      {{{OSUTF8("variable-input"), 14}, 0}, 62 },
      {{{OSUTF8("user-field-get"), 14}, 0}, 63 },
      {{{OSUTF8("user-field-input"), 16}, 0}, 64 },
      {{{OSUTF8("sequence"), 8}, 0}, 65 },
      {{{OSUTF8("expression"), 10}, 0}, 66 },
      {{{OSUTF8("text-input"), 10}, 0}, 67 },
      {{{OSUTF8("initial-creator"), 15}, 0}, 68 },
      {{{OSUTF8("creation-date"), 13}, 0}, 69 },
      {{{OSUTF8("creation-time"), 13}, 0}, 70 },
      {{{OSUTF8("description"), 11}, 0}, 71 },
      {{{OSUTF8("user-defined"), 12}, 0}, 72 },
      {{{OSUTF8("print-time"), 10}, 0}, 73 },
      {{{OSUTF8("print-date"), 10}, 0}, 74 },
      {{{OSUTF8("printed-by"), 10}, 0}, 75 },
      {{{OSUTF8("title"), 5}, 0}, 76 },
      {{{OSUTF8("subject"), 7}, 0}, 77 },
      {{{OSUTF8("keywords"), 8}, 0}, 78 },
      {{{OSUTF8("editing-cycles"), 14}, 0}, 79 },
      {{{OSUTF8("editing-duration"), 16}, 0}, 80 },
      {{{OSUTF8("modification-time"), 17}, 0}, 81 },
      {{{OSUTF8("modification-date"), 17}, 0}, 82 },
      {{{OSUTF8("creator"), 7}, 0}, 83 },
      {{{OSUTF8("page-count"), 10}, 0}, 84 },
      {{{OSUTF8("paragraph-count"), 15}, 0}, 84 },
      {{{OSUTF8("word-count"), 10}, 0}, 84 },
      {{{OSUTF8("character-count"), 15}, 0}, 84 },
      {{{OSUTF8("table-count"), 11}, 0}, 84 },
      {{{OSUTF8("image-count"), 11}, 0}, 84 },
      {{{OSUTF8("object-count"), 12}, 0}, 84 },
      {{{OSUTF8("database-display"), 16}, 0}, 85 },
      {{{OSUTF8("database-next"), 13}, 0}, 86 },
      {{{OSUTF8("database-row-select"), 19}, 0}, 87 },
      {{{OSUTF8("database-row-number"), 19}, 0}, 88 },
      {{{OSUTF8("database-name"), 13}, 0}, 89 },
      {{{OSUTF8("page-variable-set"), 17}, 0}, 90 },
      {{{OSUTF8("page-variable-get"), 17}, 0}, 91 },
      {{{OSUTF8("placeholder"), 11}, 0}, 92 },
      {{{OSUTF8("conditional-text"), 16}, 0}, 93 },
      {{{OSUTF8("hidden-text"), 11}, 0}, 94 },
      {{{OSUTF8("reference-ref"), 13}, 0}, 95 },
      {{{OSUTF8("bookmark-ref"), 12}, 0}, 95 },
      {{{OSUTF8("note-ref"), 8}, 0}, 96 },
      {{{OSUTF8("sequence-ref"), 12}, 0}, 97 },
      {{{OSUTF8("script"), 6}, 0}, 98 },
      {{{OSUTF8("execute-macro"), 13}, 0}, 99 },
      {{{OSUTF8("hidden-paragraph"), 16}, 0}, 100 },
      {{{OSUTF8("dde-connection"), 14}, 0}, 101 },
      {{{OSUTF8("measure"), 7}, 0}, 102 },
      {{{OSUTF8("table-formula"), 13}, 0}, 103 },
      {{{OSUTF8("toc-mark-start"), 14}, 0}, 104 },
      {{{OSUTF8("toc-mark-end"), 12}, 0}, 105 },
      {{{OSUTF8("toc-mark"), 8}, 0}, 106 },
      {{{OSUTF8("user-index-mark-start"), 21}, 0}, 107 },
      {{{OSUTF8("user-index-mark-end"), 19}, 0}, 108 },
      {{{OSUTF8("user-index-mark"), 15}, 0}, 109 },
      {{{OSUTF8("alphabetical-index-mark-start"), 29}, 0}, 110 },
      {{{OSUTF8("alphabetical-index-mark-end"), 27}, 0}, 111 },
      {{{OSUTF8("alphabetical-index-mark"), 23}, 0}, 112 },
      {{{OSUTF8("bibliography-mark"), 17}, 0}, 113 },
      {{{OSUTF8("header"), 6}, 0}, 114 },
      {{{OSUTF8("footer"), 6}, 0}, 115 },
      {{{OSUTF8("date-time"), 9}, 0}, 116 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 124, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* s */
      pvalue->u.s = rtxMemAllocType (pctxt, Odf_S);

      if (pvalue->u.s == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_S (pvalue->u.s);

      stat = XmlDec_Odf_S (pctxt, pvalue->u.s);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* tab */
      pvalue->u.tab = rtxMemAllocType (pctxt, Odf_Tab);

      if (pvalue->u.tab == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Tab (pvalue->u.tab);

      stat = XmlDec_Odf_Tab (pctxt, pvalue->u.tab);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* line-break */
      pvalue->u.line_break = rtxMemAllocType (pctxt, Odf_Line_break);

      if (pvalue->u.line_break == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Line_break (pvalue->u.line_break);

      stat = XmlDec_Odf_Line_break (pctxt, pvalue->u.line_break);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* span */
      pvalue->u.span = rtxMemAllocType (pctxt, Odf_Span);

      if (pvalue->u.span == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Span ((Odf_Span*)pvalue->u.span);

      stat = XmlDec_Odf_Span (pctxt, pvalue->u.span);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* a */
      pvalue->u.a = rtxMemAllocType (pctxt, Odf_A);

      if (pvalue->u.a == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_A ((Odf_A*)pvalue->u.a);

      stat = XmlDec_Odf_A (pctxt, pvalue->u.a);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* bookmark */
      pvalue->u.bookmark = rtxMemAllocType (pctxt, Odf_Bookmark);

      if (pvalue->u.bookmark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bookmark (pvalue->u.bookmark);

      stat = XmlDec_Odf_Bookmark (pctxt, pvalue->u.bookmark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* bookmark-start */
      pvalue->u.bookmark_start = rtxMemAllocType (pctxt, Odf_Bookmark_start);

      if (pvalue->u.bookmark_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bookmark_start (pvalue->u.bookmark_start);

      stat = XmlDec_Odf_Bookmark_start (pctxt, pvalue->u.bookmark_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* bookmark-end */
      pvalue->u.bookmark_end = rtxMemAllocType (pctxt, Odf_Bookmark_end);

      if (pvalue->u.bookmark_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bookmark_end (pvalue->u.bookmark_end);

      stat = XmlDec_Odf_Bookmark_end (pctxt, pvalue->u.bookmark_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* reference-mark */
      pvalue->u.reference_mark = rtxMemAllocType (pctxt, Odf_Reference_mark);

      if (pvalue->u.reference_mark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Reference_mark (pvalue->u.reference_mark);

      stat = XmlDec_Odf_Reference_mark (pctxt, pvalue->u.reference_mark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* reference-mark-start */
      pvalue->u.reference_mark_start
          = rtxMemAllocType (pctxt, Odf_Reference_mark_start);

      if (pvalue->u.reference_mark_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Reference_mark_start (pvalue->u.reference_mark_start);

      stat = XmlDec_Odf_Reference_mark_start (pctxt, pvalue->
         u.reference_mark_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* reference-mark-end */
      pvalue->u.reference_mark_end
          = rtxMemAllocType (pctxt, Odf_Reference_mark_end);

      if (pvalue->u.reference_mark_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Reference_mark_end (pvalue->u.reference_mark_end);

      stat = XmlDec_Odf_Reference_mark_end (pctxt, pvalue->u.reference_mark_end
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* note */
      pvalue->u.note = rtxMemAllocType (pctxt, Odf_Note);

      if (pvalue->u.note == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Note (pvalue->u.note);

      stat = XmlDec_Odf_Note (pctxt, pvalue->u.note);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* ruby */
      pvalue->u.ruby = rtxMemAllocType (pctxt, Odf_Ruby);

      if (pvalue->u.ruby == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Ruby (pvalue->u.ruby);

      stat = XmlDec_Odf_Ruby (pctxt, pvalue->u.ruby);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* annotation */
      pvalue->u.annotation = rtxMemAllocType (pctxt, Ns13_Annotation);

      if (pvalue->u.annotation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns13_Annotation ((Ns13_Annotation*)pvalue->u.annotation);

      stat = XmlDec_Ns13_Annotation (pctxt, pvalue->u.annotation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* change */
      pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

      if (pvalue->u.change == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change (pvalue->u.change);

      stat = XmlDec_Odf_Change (pctxt, pvalue->u.change);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* change-start */
      pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

      if (pvalue->u.change_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_start (pvalue->u.change_start);

      stat = XmlDec_Odf_Change_start (pctxt, pvalue->u.change_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* change-end */
      pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

      if (pvalue->u.change_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_end (pvalue->u.change_end);

      stat = XmlDec_Odf_Change_end (pctxt, pvalue->u.change_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 17: { /* rect */
      pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

      if (pvalue->u.rect == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);

      stat = XmlDec_Ns3_Rect (pctxt, pvalue->u.rect);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 18: { /* line */
      pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

      if (pvalue->u.line == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);

      stat = XmlDec_Ns3_Line (pctxt, pvalue->u.line);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 19: { /* polyline */
      pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

      if (pvalue->u.polyline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);

      stat = XmlDec_Ns3_Polyline (pctxt, pvalue->u.polyline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 20: { /* polygon */
      pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

      if (pvalue->u.polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);

      stat = XmlDec_Ns3_Polygon (pctxt, pvalue->u.polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 21: { /* regular-polygon */
      pvalue->u.regular_polygon
          = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

      if (pvalue->u.regular_polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->
         u.regular_polygon);

      stat = XmlDec_Ns3_Regular_polygon (pctxt, pvalue->u.regular_polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 22: { /* path */
      pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

      if (pvalue->u.path == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);

      stat = XmlDec_Ns3_Path (pctxt, pvalue->u.path);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 23: { /* circle */
      pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

      if (pvalue->u.circle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);

      stat = XmlDec_Ns3_Circle (pctxt, pvalue->u.circle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 24: { /* ellipse */
      pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

      if (pvalue->u.ellipse == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);

      stat = XmlDec_Ns3_Ellipse (pctxt, pvalue->u.ellipse);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 25: { /* g */
      pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

      if (pvalue->u.g == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);

      stat = XmlDec_Ns3_G (pctxt, pvalue->u.g);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 26: { /* page-thumbnail */
      pvalue->u.page_thumbnail = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

      if (pvalue->u.page_thumbnail == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->
         u.page_thumbnail);

      stat = XmlDec_Ns3_Page_thumbnail (pctxt, pvalue->u.page_thumbnail);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 27: { /* frame */
      pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

      if (pvalue->u.frame == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);

      stat = XmlDec_Ns3_Frame (pctxt, pvalue->u.frame);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 28: { /* measure */
      pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

      if (pvalue->u.measure == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);

      stat = XmlDec_Ns3_Measure (pctxt, pvalue->u.measure);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 29: { /* caption */
      pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

      if (pvalue->u.caption == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);

      stat = XmlDec_Ns3_Caption (pctxt, pvalue->u.caption);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 30: { /* connector */
      pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

      if (pvalue->u.connector == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);

      stat = XmlDec_Ns3_Connector (pctxt, pvalue->u.connector);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 31: { /* control */
      pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

      if (pvalue->u.control == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);

      stat = XmlDec_Ns3_Control (pctxt, pvalue->u.control);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 32: { /* scene */
      pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

      if (pvalue->u.scene == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);

      stat = XmlDec_Ns7_Scene (pctxt, pvalue->u.scene);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 33: { /* custom-shape */
      pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

      if (pvalue->u.custom_shape == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);

      stat = XmlDec_Ns3_Custom_shape (pctxt, pvalue->u.custom_shape);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 34: { /* a */
      pvalue->u.a_1 = rtxMemAllocType (pctxt, Ns3_A);

      if (pvalue->u.a_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_A ((Ns3_A*)pvalue->u.a_1);

      stat = XmlDec_Ns3_A (pctxt, pvalue->u.a_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 35: { /* date */
      pvalue->u.date = rtxMemAllocType (pctxt, Odf_Date);

      if (pvalue->u.date == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Date (pvalue->u.date);

      stat = XmlDec_Odf_Date (pctxt, pvalue->u.date);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 36: { /* time */
      pvalue->u.time_ = rtxMemAllocType (pctxt, Odf_Time);

      if (pvalue->u.time_ == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Time (pvalue->u.time_);

      stat = XmlDec_Odf_Time (pctxt, pvalue->u.time_);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 37: { /* page-number */
      pvalue->u.page_number = rtxMemAllocType (pctxt, Odf_Page_number);

      if (pvalue->u.page_number == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Page_number (pvalue->u.page_number);

      stat = XmlDec_Odf_Page_number (pctxt, pvalue->u.page_number);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 38: { /* page-continuation */
      pvalue->u.page_continuation
          = rtxMemAllocType (pctxt, Odf_Page_continuation);

      if (pvalue->u.page_continuation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Page_continuation (pvalue->u.page_continuation);

      stat = XmlDec_Odf_Page_continuation (pctxt, pvalue->u.page_continuation
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 39: { /* sender-firstname */
      pvalue->u.sender_firstname
          = rtxMemAllocType (pctxt, Odf_Sender_firstname);

      if (pvalue->u.sender_firstname == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_firstname (pvalue->u.sender_firstname);

      stat = XmlDec_Odf_Sender_firstname (pctxt, pvalue->u.sender_firstname);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 40: { /* sender-lastname */
      pvalue->u.sender_lastname
          = rtxMemAllocType (pctxt, Odf_Sender_lastname);

      if (pvalue->u.sender_lastname == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_lastname (pvalue->u.sender_lastname);

      stat = XmlDec_Odf_Sender_lastname (pctxt, pvalue->u.sender_lastname);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 41: { /* sender-initials */
      pvalue->u.sender_initials
          = rtxMemAllocType (pctxt, Odf_Sender_initials);

      if (pvalue->u.sender_initials == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_initials (pvalue->u.sender_initials);

      stat = XmlDec_Odf_Sender_initials (pctxt, pvalue->u.sender_initials);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 42: { /* sender-title */
      pvalue->u.sender_title = rtxMemAllocType (pctxt, Odf_Sender_title);

      if (pvalue->u.sender_title == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_title (pvalue->u.sender_title);

      stat = XmlDec_Odf_Sender_title (pctxt, pvalue->u.sender_title);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 43: { /* sender-position */
      pvalue->u.sender_position
          = rtxMemAllocType (pctxt, Odf_Sender_position);

      if (pvalue->u.sender_position == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_position (pvalue->u.sender_position);

      stat = XmlDec_Odf_Sender_position (pctxt, pvalue->u.sender_position);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 44: { /* sender-email */
      pvalue->u.sender_email = rtxMemAllocType (pctxt, Odf_Sender_email);

      if (pvalue->u.sender_email == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_email (pvalue->u.sender_email);

      stat = XmlDec_Odf_Sender_email (pctxt, pvalue->u.sender_email);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 45: { /* sender-phone-private */
      pvalue->u.sender_phone_private
          = rtxMemAllocType (pctxt, Odf_Sender_phone_private);

      if (pvalue->u.sender_phone_private == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_phone_private (pvalue->u.sender_phone_private);

      stat = XmlDec_Odf_Sender_phone_private (pctxt, pvalue->
         u.sender_phone_private);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 46: { /* sender-fax */
      pvalue->u.sender_fax = rtxMemAllocType (pctxt, Odf_Sender_fax);

      if (pvalue->u.sender_fax == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_fax (pvalue->u.sender_fax);

      stat = XmlDec_Odf_Sender_fax (pctxt, pvalue->u.sender_fax);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 47: { /* sender-company */
      pvalue->u.sender_company = rtxMemAllocType (pctxt, Odf_Sender_company);

      if (pvalue->u.sender_company == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_company (pvalue->u.sender_company);

      stat = XmlDec_Odf_Sender_company (pctxt, pvalue->u.sender_company);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 48: { /* sender-phone-work */
      pvalue->u.sender_phone_work
          = rtxMemAllocType (pctxt, Odf_Sender_phone_work);

      if (pvalue->u.sender_phone_work == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_phone_work (pvalue->u.sender_phone_work);

      stat = XmlDec_Odf_Sender_phone_work (pctxt, pvalue->u.sender_phone_work
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 49: { /* sender-street */
      pvalue->u.sender_street = rtxMemAllocType (pctxt, Odf_Sender_street);

      if (pvalue->u.sender_street == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_street (pvalue->u.sender_street);

      stat = XmlDec_Odf_Sender_street (pctxt, pvalue->u.sender_street);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 50: { /* sender-city */
      pvalue->u.sender_city = rtxMemAllocType (pctxt, Odf_Sender_city);

      if (pvalue->u.sender_city == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_city (pvalue->u.sender_city);

      stat = XmlDec_Odf_Sender_city (pctxt, pvalue->u.sender_city);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 51: { /* sender-postal-code */
      pvalue->u.sender_postal_code
          = rtxMemAllocType (pctxt, Odf_Sender_postal_code);

      if (pvalue->u.sender_postal_code == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_postal_code (pvalue->u.sender_postal_code);

      stat = XmlDec_Odf_Sender_postal_code (pctxt, pvalue->u.sender_postal_code
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 52: { /* sender-country */
      pvalue->u.sender_country = rtxMemAllocType (pctxt, Odf_Sender_country);

      if (pvalue->u.sender_country == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_country (pvalue->u.sender_country);

      stat = XmlDec_Odf_Sender_country (pctxt, pvalue->u.sender_country);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 53: { /* sender-state-or-province */
      pvalue->u.sender_state_or_province
          = rtxMemAllocType (pctxt, Odf_Sender_state_or_province);

      if (pvalue->u.sender_state_or_province == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_state_or_province (pvalue->u.sender_state_or_province
         );

      stat = XmlDec_Odf_Sender_state_or_province (pctxt, pvalue->
         u.sender_state_or_province);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 54: { /* author-name */
      pvalue->u.author_name = rtxMemAllocType (pctxt, Odf_Author_name);

      if (pvalue->u.author_name == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Author_name (pvalue->u.author_name);

      stat = XmlDec_Odf_Author_name (pctxt, pvalue->u.author_name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 55: { /* author-initials */
      pvalue->u.author_initials
          = rtxMemAllocType (pctxt, Odf_Author_initials);

      if (pvalue->u.author_initials == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Author_initials (pvalue->u.author_initials);

      stat = XmlDec_Odf_Author_initials (pctxt, pvalue->u.author_initials);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 56: { /* chapter */
      pvalue->u.chapter = rtxMemAllocType (pctxt, Odf_Chapter);

      if (pvalue->u.chapter == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Chapter (pvalue->u.chapter);

      stat = XmlDec_Odf_Chapter (pctxt, pvalue->u.chapter);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 57: { /* file-name */
      pvalue->u.file_name = rtxMemAllocType (pctxt, Odf_File_name);

      if (pvalue->u.file_name == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_File_name (pvalue->u.file_name);

      stat = XmlDec_Odf_File_name (pctxt, pvalue->u.file_name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 58: { /* template-name */
      pvalue->u.template_name = rtxMemAllocType (pctxt, Odf_Template_name);

      if (pvalue->u.template_name == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Template_name (pvalue->u.template_name);

      stat = XmlDec_Odf_Template_name (pctxt, pvalue->u.template_name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 59: { /* sheet-name */
      stat = XmlDec_Odf_Sheet_name (pctxt, &pvalue->u.sheet_name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 60: { /* variable-set */
      pvalue->u.variable_set = rtxMemAllocType (pctxt, Odf_Variable_set);

      if (pvalue->u.variable_set == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Variable_set (pvalue->u.variable_set);

      stat = XmlDec_Odf_Variable_set (pctxt, pvalue->u.variable_set);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 61: { /* variable-get */
      pvalue->u.variable_get = rtxMemAllocType (pctxt, Odf_Variable_get);

      if (pvalue->u.variable_get == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Variable_get (pvalue->u.variable_get);

      stat = XmlDec_Odf_Variable_get (pctxt, pvalue->u.variable_get);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 62: { /* variable-input */
      pvalue->u.variable_input = rtxMemAllocType (pctxt, Odf_Variable_input);

      if (pvalue->u.variable_input == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Variable_input (pvalue->u.variable_input);

      stat = XmlDec_Odf_Variable_input (pctxt, pvalue->u.variable_input);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 63: { /* user-field-get */
      pvalue->u.user_field_get = rtxMemAllocType (pctxt, Odf_User_field_get);

      if (pvalue->u.user_field_get == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_field_get (pvalue->u.user_field_get);

      stat = XmlDec_Odf_User_field_get (pctxt, pvalue->u.user_field_get);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 64: { /* user-field-input */
      pvalue->u.user_field_input
          = rtxMemAllocType (pctxt, Odf_User_field_input);

      if (pvalue->u.user_field_input == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_field_input (pvalue->u.user_field_input);

      stat = XmlDec_Odf_User_field_input (pctxt, pvalue->u.user_field_input);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 65: { /* sequence */
      pvalue->u.sequence = rtxMemAllocType (pctxt, Odf_Sequence);

      if (pvalue->u.sequence == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sequence (pvalue->u.sequence);

      stat = XmlDec_Odf_Sequence (pctxt, pvalue->u.sequence);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 66: { /* expression */
      pvalue->u.expression = rtxMemAllocType (pctxt, Odf_Expression);

      if (pvalue->u.expression == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Expression (pvalue->u.expression);

      stat = XmlDec_Odf_Expression (pctxt, pvalue->u.expression);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 67: { /* text-input */
      pvalue->u.text_input = rtxMemAllocType (pctxt, Odf_Text_input);

      if (pvalue->u.text_input == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Text_input (pvalue->u.text_input);

      stat = XmlDec_Odf_Text_input (pctxt, pvalue->u.text_input);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 68: { /* initial-creator */
      pvalue->u.initial_creator
          = rtxMemAllocType (pctxt, Odf_Initial_creator);

      if (pvalue->u.initial_creator == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Initial_creator (pvalue->u.initial_creator);

      stat = XmlDec_Odf_Initial_creator (pctxt, pvalue->u.initial_creator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 69: { /* creation-date */
      pvalue->u.creation_date = rtxMemAllocType (pctxt, Odf_Creation_date);

      if (pvalue->u.creation_date == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Creation_date (pvalue->u.creation_date);

      stat = XmlDec_Odf_Creation_date (pctxt, pvalue->u.creation_date);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 70: { /* creation-time */
      pvalue->u.creation_time = rtxMemAllocType (pctxt, Odf_Creation_time);

      if (pvalue->u.creation_time == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Creation_time (pvalue->u.creation_time);

      stat = XmlDec_Odf_Creation_time (pctxt, pvalue->u.creation_time);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 71: { /* description */
      pvalue->u.description = rtxMemAllocType (pctxt, Odf_Description);

      if (pvalue->u.description == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Description (pvalue->u.description);

      stat = XmlDec_Odf_Description (pctxt, pvalue->u.description);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 72: { /* user-defined */
      pvalue->u.user_defined = rtxMemAllocType (pctxt, Odf_User_defined);

      if (pvalue->u.user_defined == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_defined (pvalue->u.user_defined);

      stat = XmlDec_Odf_User_defined (pctxt, pvalue->u.user_defined);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 73: { /* print-time */
      pvalue->u.print_time = rtxMemAllocType (pctxt, Odf_Print_time);

      if (pvalue->u.print_time == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Print_time (pvalue->u.print_time);

      stat = XmlDec_Odf_Print_time (pctxt, pvalue->u.print_time);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 74: { /* print-date */
      pvalue->u.print_date = rtxMemAllocType (pctxt, Odf_Print_date);

      if (pvalue->u.print_date == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Print_date (pvalue->u.print_date);

      stat = XmlDec_Odf_Print_date (pctxt, pvalue->u.print_date);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 75: { /* printed-by */
      pvalue->u.printed_by = rtxMemAllocType (pctxt, Odf_Printed_by);

      if (pvalue->u.printed_by == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Printed_by (pvalue->u.printed_by);

      stat = XmlDec_Odf_Printed_by (pctxt, pvalue->u.printed_by);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 76: { /* title */
      pvalue->u.title = rtxMemAllocType (pctxt, Odf_Title);

      if (pvalue->u.title == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Title (pvalue->u.title);

      stat = XmlDec_Odf_Title (pctxt, pvalue->u.title);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 77: { /* subject */
      pvalue->u.subject = rtxMemAllocType (pctxt, Odf_Subject);

      if (pvalue->u.subject == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Subject (pvalue->u.subject);

      stat = XmlDec_Odf_Subject (pctxt, pvalue->u.subject);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 78: { /* keywords */
      pvalue->u.keywords = rtxMemAllocType (pctxt, Odf_Keywords);

      if (pvalue->u.keywords == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Keywords (pvalue->u.keywords);

      stat = XmlDec_Odf_Keywords (pctxt, pvalue->u.keywords);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 79: { /* editing-cycles */
      pvalue->u.editing_cycles = rtxMemAllocType (pctxt, Odf_Editing_cycles);

      if (pvalue->u.editing_cycles == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Editing_cycles (pvalue->u.editing_cycles);

      stat = XmlDec_Odf_Editing_cycles (pctxt, pvalue->u.editing_cycles);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 80: { /* editing-duration */
      pvalue->u.editing_duration
          = rtxMemAllocType (pctxt, Odf_Editing_duration);

      if (pvalue->u.editing_duration == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Editing_duration (pvalue->u.editing_duration);

      stat = XmlDec_Odf_Editing_duration (pctxt, pvalue->u.editing_duration);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 81: { /* modification-time */
      pvalue->u.modification_time
          = rtxMemAllocType (pctxt, Odf_Modification_time);

      if (pvalue->u.modification_time == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Modification_time (pvalue->u.modification_time);

      stat = XmlDec_Odf_Modification_time (pctxt, pvalue->u.modification_time
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 82: { /* modification-date */
      pvalue->u.modification_date
          = rtxMemAllocType (pctxt, Odf_Modification_date);

      if (pvalue->u.modification_date == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Modification_date (pvalue->u.modification_date);

      stat = XmlDec_Odf_Modification_date (pctxt, pvalue->u.modification_date
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 83: { /* creator */
      pvalue->u.creator = rtxMemAllocType (pctxt, Odf_Creator);

      if (pvalue->u.creator == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Creator (pvalue->u.creator);

      stat = XmlDec_Odf_Creator (pctxt, pvalue->u.creator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 84: { /*  */
      pvalue->u.element271 = rtxMemAllocType (pctxt, Odf_Element271_group);

      if (pvalue->u.element271 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Element271_group (pvalue->u.element271);

      stat = XmlDec_Odf_Element271_group (pctxt, pvalue->u.element271);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 85: { /* database-display */
      pvalue->u.database_display
          = rtxMemAllocType (pctxt, Odf_Database_display);

      if (pvalue->u.database_display == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Database_display (pvalue->u.database_display);

      stat = XmlDec_Odf_Database_display (pctxt, pvalue->u.database_display);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 86: { /* database-next */
      pvalue->u.database_next = rtxMemAllocType (pctxt, Odf_Database_next);

      if (pvalue->u.database_next == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Database_next (pvalue->u.database_next);

      stat = XmlDec_Odf_Database_next (pctxt, pvalue->u.database_next);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 87: { /* database-row-select */
      pvalue->u.database_row_select
          = rtxMemAllocType (pctxt, Odf_Database_row_select);

      if (pvalue->u.database_row_select == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Database_row_select (pvalue->u.database_row_select);

      stat = XmlDec_Odf_Database_row_select (pctxt, pvalue->
         u.database_row_select);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 88: { /* database-row-number */
      pvalue->u.database_row_number
          = rtxMemAllocType (pctxt, Odf_Database_row_number);

      if (pvalue->u.database_row_number == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Database_row_number (pvalue->u.database_row_number);

      stat = XmlDec_Odf_Database_row_number (pctxt, pvalue->
         u.database_row_number);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 89: { /* database-name */
      pvalue->u.database_name = rtxMemAllocType (pctxt, Odf_Database_name);

      if (pvalue->u.database_name == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Database_name (pvalue->u.database_name);

      stat = XmlDec_Odf_Database_name (pctxt, pvalue->u.database_name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 90: { /* page-variable-set */
      pvalue->u.page_variable_set
          = rtxMemAllocType (pctxt, Odf_Page_variable_set);

      if (pvalue->u.page_variable_set == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Page_variable_set (pvalue->u.page_variable_set);

      stat = XmlDec_Odf_Page_variable_set (pctxt, pvalue->u.page_variable_set
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 91: { /* page-variable-get */
      pvalue->u.page_variable_get
          = rtxMemAllocType (pctxt, Odf_Page_variable_get);

      if (pvalue->u.page_variable_get == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Page_variable_get (pvalue->u.page_variable_get);

      stat = XmlDec_Odf_Page_variable_get (pctxt, pvalue->u.page_variable_get
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 92: { /* placeholder */
      pvalue->u.placeholder = rtxMemAllocType (pctxt, Odf_Placeholder);

      if (pvalue->u.placeholder == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Placeholder (pvalue->u.placeholder);

      stat = XmlDec_Odf_Placeholder (pctxt, pvalue->u.placeholder);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 93: { /* conditional-text */
      pvalue->u.conditional_text
          = rtxMemAllocType (pctxt, Odf_Conditional_text);

      if (pvalue->u.conditional_text == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Conditional_text (pvalue->u.conditional_text);

      stat = XmlDec_Odf_Conditional_text (pctxt, pvalue->u.conditional_text);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 94: { /* hidden-text */
      pvalue->u.hidden_text = rtxMemAllocType (pctxt, Odf_Hidden_text);

      if (pvalue->u.hidden_text == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Hidden_text (pvalue->u.hidden_text);

      stat = XmlDec_Odf_Hidden_text (pctxt, pvalue->u.hidden_text);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 95: { /*  */
      pvalue->u.element282 = rtxMemAllocType (pctxt, Odf_Element282_group);

      if (pvalue->u.element282 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Element282_group (pvalue->u.element282);

      stat = XmlDec_Odf_Element282_group (pctxt, pvalue->u.element282);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 96: { /* note-ref */
      pvalue->u.note_ref = rtxMemAllocType (pctxt, Odf_Note_ref);

      if (pvalue->u.note_ref == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Note_ref (pvalue->u.note_ref);

      stat = XmlDec_Odf_Note_ref (pctxt, pvalue->u.note_ref);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 97: { /* sequence-ref */
      pvalue->u.sequence_ref = rtxMemAllocType (pctxt, Odf_Sequence_ref);

      if (pvalue->u.sequence_ref == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sequence_ref (pvalue->u.sequence_ref);

      stat = XmlDec_Odf_Sequence_ref (pctxt, pvalue->u.sequence_ref);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 98: { /* script */
      pvalue->u.script = rtxMemAllocType (pctxt, Odf_Script);

      if (pvalue->u.script == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Script (pvalue->u.script);

      stat = XmlDec_Odf_Script (pctxt, pvalue->u.script);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 99: { /* execute-macro */
      pvalue->u.execute_macro = rtxMemAllocType (pctxt, Odf_Execute_macro);

      if (pvalue->u.execute_macro == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Execute_macro (pvalue->u.execute_macro);

      stat = XmlDec_Odf_Execute_macro (pctxt, pvalue->u.execute_macro);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 100: { /* hidden-paragraph */
      pvalue->u.hidden_paragraph
          = rtxMemAllocType (pctxt, Odf_Hidden_paragraph);

      if (pvalue->u.hidden_paragraph == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Hidden_paragraph (pvalue->u.hidden_paragraph);

      stat = XmlDec_Odf_Hidden_paragraph (pctxt, pvalue->u.hidden_paragraph);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 101: { /* dde-connection */
      pvalue->u.dde_connection = rtxMemAllocType (pctxt, Odf_Dde_connection);

      if (pvalue->u.dde_connection == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Dde_connection (pvalue->u.dde_connection);

      stat = XmlDec_Odf_Dde_connection (pctxt, pvalue->u.dde_connection);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 102: { /* measure */
      pvalue->u.measure_1 = rtxMemAllocType (pctxt, Odf_Measure);

      if (pvalue->u.measure_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Measure (pvalue->u.measure_1);

      stat = XmlDec_Odf_Measure (pctxt, pvalue->u.measure_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 103: { /* table-formula */
      pvalue->u.table_formula = rtxMemAllocType (pctxt, Odf_Table_formula);

      if (pvalue->u.table_formula == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_formula (pvalue->u.table_formula);

      stat = XmlDec_Odf_Table_formula (pctxt, pvalue->u.table_formula);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 104: { /* toc-mark-start */
      pvalue->u.toc_mark_start = rtxMemAllocType (pctxt, Odf_Toc_mark_start);

      if (pvalue->u.toc_mark_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Toc_mark_start (pvalue->u.toc_mark_start);

      stat = XmlDec_Odf_Toc_mark_start (pctxt, pvalue->u.toc_mark_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 105: { /* toc-mark-end */
      pvalue->u.toc_mark_end = rtxMemAllocType (pctxt, Odf_Toc_mark_end);

      if (pvalue->u.toc_mark_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Toc_mark_end (pvalue->u.toc_mark_end);

      stat = XmlDec_Odf_Toc_mark_end (pctxt, pvalue->u.toc_mark_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 106: { /* toc-mark */
      pvalue->u.toc_mark = rtxMemAllocType (pctxt, Odf_Toc_mark);

      if (pvalue->u.toc_mark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Toc_mark (pvalue->u.toc_mark);

      stat = XmlDec_Odf_Toc_mark (pctxt, pvalue->u.toc_mark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 107: { /* user-index-mark-start */
      pvalue->u.user_index_mark_start
          = rtxMemAllocType (pctxt, Odf_User_index_mark_start);

      if (pvalue->u.user_index_mark_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index_mark_start (pvalue->u.user_index_mark_start);

      stat = XmlDec_Odf_User_index_mark_start (pctxt, pvalue->
         u.user_index_mark_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 108: { /* user-index-mark-end */
      pvalue->u.user_index_mark_end
          = rtxMemAllocType (pctxt, Odf_User_index_mark_end);

      if (pvalue->u.user_index_mark_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index_mark_end (pvalue->u.user_index_mark_end);

      stat = XmlDec_Odf_User_index_mark_end (pctxt, pvalue->
         u.user_index_mark_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 109: { /* user-index-mark */
      pvalue->u.user_index_mark
          = rtxMemAllocType (pctxt, Odf_User_index_mark);

      if (pvalue->u.user_index_mark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index_mark (pvalue->u.user_index_mark);

      stat = XmlDec_Odf_User_index_mark (pctxt, pvalue->u.user_index_mark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 110: { /* alphabetical-index-mark-start */
      pvalue->u.alphabetical_index_mark_start
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark_start);

      if (pvalue->u.alphabetical_index_mark_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index_mark_start (pvalue->
         u.alphabetical_index_mark_start);

      stat = XmlDec_Odf_Alphabetical_index_mark_start (pctxt, pvalue->
         u.alphabetical_index_mark_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 111: { /* alphabetical-index-mark-end */
      pvalue->u.alphabetical_index_mark_end
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark_end);

      if (pvalue->u.alphabetical_index_mark_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index_mark_end (pvalue->
         u.alphabetical_index_mark_end);

      stat = XmlDec_Odf_Alphabetical_index_mark_end (pctxt, pvalue->
         u.alphabetical_index_mark_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 112: { /* alphabetical-index-mark */
      pvalue->u.alphabetical_index_mark
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark);

      if (pvalue->u.alphabetical_index_mark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index_mark (pvalue->u.alphabetical_index_mark
         );

      stat = XmlDec_Odf_Alphabetical_index_mark (pctxt, pvalue->
         u.alphabetical_index_mark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 113: { /* bibliography-mark */
      pvalue->u.bibliography_mark
          = rtxMemAllocType (pctxt, Odf_Bibliography_mark);

      if (pvalue->u.bibliography_mark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bibliography_mark (pvalue->u.bibliography_mark);

      stat = XmlDec_Odf_Bibliography_mark (pctxt, pvalue->u.bibliography_mark
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 114: { /* header */
      pvalue->u.header = rtxMemAllocType (pctxt, Ns10_Header);

      if (pvalue->u.header == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns10_Header ((Ns10_Header*)pvalue->u.header);

      stat = XmlDec_Ns10_Header (pctxt, pvalue->u.header);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 115: { /* footer */
      pvalue->u.footer = rtxMemAllocType (pctxt, Ns10_Footer);

      if (pvalue->u.footer == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns10_Footer ((Ns10_Footer*)pvalue->u.footer);

      stat = XmlDec_Ns10_Footer (pctxt, pvalue->u.footer);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 116: { /* date-time */
      pvalue->u.date_time = rtxMemAllocType (pctxt, Ns10_Date_time);

      if (pvalue->u.date_time == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns10_Date_time ((Ns10_Date_time*)pvalue->u.date_time);

      stat = XmlDec_Ns10_Date_time (pctxt, pvalue->u.date_time);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  A                                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_A (OSCTXT* pctxt, Odf_A *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode actuate */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_A_actuate (pctxt, 
               &pvalue->actuate, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.actuatePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode href */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Href (pctxt, 
               &pvalue->href, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode show */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_A_show (pctxt, 
               &pvalue->show, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.showPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Type (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.typePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Name (pctxt, 
               (Ns13_Name*)&pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode target_frame_name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->target_frame_name
                = rtxMemAllocType (pctxt, Ns13_Target_frame_name);

            if (pvalue->target_frame_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Target_frame_name ((Ns13_Target_frame_name*)pvalue->target_frame_name);
            asn1Init_Ns13_Target_frame_name ((Ns13_Target_frame_name*)pvalue->target_frame_name);

            stat = asn1D_Ns13_Target_frame_name (pctxt, 
               (Ns13_Target_frame_name*)pvalue->target_frame_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.target_frame_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_A_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode visited_style_name */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_A_visited_style_name (pctxt, 
               &pvalue->visited_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.visited_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_A_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_A_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_A_element (pdata2);

                  stat = asn1D_Odf_A_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_A (OSCTXT* pctxt, Odf_A* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("actuate"), 7}, 0 },
         { {OSUTF8("href"), 4}, 0 },
         { {OSUTF8("show"), 4}, 0 },
         { {OSUTF8("type"), 4}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("target-frame-name"), 17}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("visited-style-name"), 18}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 8, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* actuate */
            stat = XmlDec_Odf_A_actuate (pctxt, &pvalue->actuate);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.actuatePresent = TRUE;
            break;

         case 1: /* href */
            stat = XmlDec_Xlink_Href (pctxt, &pvalue->href);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* show */
            stat = XmlDec_Odf_A_show (pctxt, &pvalue->show);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.showPresent = TRUE;
            break;

         case 3: /* type */
            stat = XmlDec_Xlink_Type (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.typePresent = TRUE;
            break;

         case 4: /* name */
            stat = XmlDec_Ns13_Name (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 5: /* target-frame-name */
            pvalue->target_frame_name
                = rtxMemAllocType (pctxt, Ns13_Target_frame_name);

            if (pvalue->target_frame_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Target_frame_name ((Ns13_Target_frame_name*)pvalue->
               target_frame_name);

            stat = XmlDec_Ns13_Target_frame_name (pctxt, pvalue->
               target_frame_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.target_frame_namePresent = TRUE;
            break;

         case 6: /* style-name */
            stat = XmlDec_Odf_A_style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 7: /* visited-style-name */
            stat = XmlDec_Odf_A_visited_style_name (pctxt, &pvalue->
               visited_style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.visited_style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_A");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_A");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("event-listeners"), 15}, 0}, 0 },
      {{{OSUTF8("s"), 1}, 0}, 1 },
      {{{OSUTF8("tab"), 3}, 0}, 1 },
      {{{OSUTF8("line-break"), 10}, 0}, 1 },
      {{{OSUTF8("span"), 4}, 0}, 1 },
      {{{OSUTF8("a"), 1}, 0}, 1 },
      {{{OSUTF8("bookmark"), 8}, 0}, 1 },
      {{{OSUTF8("bookmark-start"), 14}, 0}, 1 },
      {{{OSUTF8("bookmark-end"), 12}, 0}, 1 },
      {{{OSUTF8("reference-mark"), 14}, 0}, 1 },
      {{{OSUTF8("reference-mark-start"), 20}, 0}, 1 },
      {{{OSUTF8("reference-mark-end"), 18}, 0}, 1 },
      {{{OSUTF8("note"), 4}, 0}, 1 },
      {{{OSUTF8("ruby"), 4}, 0}, 1 },
      {{{OSUTF8("annotation"), 10}, 0}, 1 },
      {{{OSUTF8("change"), 6}, 0}, 1 },
      {{{OSUTF8("change-start"), 12}, 0}, 1 },
      {{{OSUTF8("change-end"), 10}, 0}, 1 },
      {{{OSUTF8("rect"), 4}, 0}, 1 },
      {{{OSUTF8("line"), 4}, 0}, 1 },
      {{{OSUTF8("polyline"), 8}, 0}, 1 },
      {{{OSUTF8("polygon"), 7}, 0}, 1 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 1 },
      {{{OSUTF8("path"), 4}, 0}, 1 },
      {{{OSUTF8("circle"), 6}, 0}, 1 },
      {{{OSUTF8("ellipse"), 7}, 0}, 1 },
      {{{OSUTF8("g"), 1}, 0}, 1 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 1 },
      {{{OSUTF8("frame"), 5}, 0}, 1 },
      {{{OSUTF8("measure"), 7}, 0}, 1 },
      {{{OSUTF8("caption"), 7}, 0}, 1 },
      {{{OSUTF8("connector"), 9}, 0}, 1 },
      {{{OSUTF8("control"), 7}, 0}, 1 },
      {{{OSUTF8("scene"), 5}, 0}, 1 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 1 },
      {{{OSUTF8("date"), 4}, 0}, 1 },
      {{{OSUTF8("time"), 4}, 0}, 1 },
      {{{OSUTF8("page-number"), 11}, 0}, 1 },
      {{{OSUTF8("page-continuation"), 17}, 0}, 1 },
      {{{OSUTF8("sender-firstname"), 16}, 0}, 1 },
      {{{OSUTF8("sender-lastname"), 15}, 0}, 1 },
      {{{OSUTF8("sender-initials"), 15}, 0}, 1 },
      {{{OSUTF8("sender-title"), 12}, 0}, 1 },
      {{{OSUTF8("sender-position"), 15}, 0}, 1 },
      {{{OSUTF8("sender-email"), 12}, 0}, 1 },
      {{{OSUTF8("sender-phone-private"), 20}, 0}, 1 },
      {{{OSUTF8("sender-fax"), 10}, 0}, 1 },
      {{{OSUTF8("sender-company"), 14}, 0}, 1 },
      {{{OSUTF8("sender-phone-work"), 17}, 0}, 1 },
      {{{OSUTF8("sender-street"), 13}, 0}, 1 },
      {{{OSUTF8("sender-city"), 11}, 0}, 1 },
      {{{OSUTF8("sender-postal-code"), 18}, 0}, 1 },
      {{{OSUTF8("sender-country"), 14}, 0}, 1 },
      {{{OSUTF8("sender-state-or-province"), 24}, 0}, 1 },
      {{{OSUTF8("author-name"), 11}, 0}, 1 },
      {{{OSUTF8("author-initials"), 15}, 0}, 1 },
      {{{OSUTF8("chapter"), 7}, 0}, 1 },
      {{{OSUTF8("file-name"), 9}, 0}, 1 },
      {{{OSUTF8("template-name"), 13}, 0}, 1 },
      {{{OSUTF8("sheet-name"), 10}, 0}, 1 },
      {{{OSUTF8("variable-set"), 12}, 0}, 1 },
      {{{OSUTF8("variable-get"), 12}, 0}, 1 },
      {{{OSUTF8("variable-input"), 14}, 0}, 1 },
      {{{OSUTF8("user-field-get"), 14}, 0}, 1 },
      {{{OSUTF8("user-field-input"), 16}, 0}, 1 },
      {{{OSUTF8("sequence"), 8}, 0}, 1 },
      {{{OSUTF8("expression"), 10}, 0}, 1 },
      {{{OSUTF8("text-input"), 10}, 0}, 1 },
      {{{OSUTF8("initial-creator"), 15}, 0}, 1 },
      {{{OSUTF8("creation-date"), 13}, 0}, 1 },
      {{{OSUTF8("creation-time"), 13}, 0}, 1 },
      {{{OSUTF8("description"), 11}, 0}, 1 },
      {{{OSUTF8("user-defined"), 12}, 0}, 1 },
      {{{OSUTF8("print-time"), 10}, 0}, 1 },
      {{{OSUTF8("print-date"), 10}, 0}, 1 },
      {{{OSUTF8("printed-by"), 10}, 0}, 1 },
      {{{OSUTF8("title"), 5}, 0}, 1 },
      {{{OSUTF8("subject"), 7}, 0}, 1 },
      {{{OSUTF8("keywords"), 8}, 0}, 1 },
      {{{OSUTF8("editing-cycles"), 14}, 0}, 1 },
      {{{OSUTF8("editing-duration"), 16}, 0}, 1 },
      {{{OSUTF8("modification-time"), 17}, 0}, 1 },
      {{{OSUTF8("modification-date"), 17}, 0}, 1 },
      {{{OSUTF8("creator"), 7}, 0}, 1 },
      {{{OSUTF8("page-count"), 10}, 0}, 1 },
      {{{OSUTF8("paragraph-count"), 15}, 0}, 1 },
      {{{OSUTF8("word-count"), 10}, 0}, 1 },
      {{{OSUTF8("character-count"), 15}, 0}, 1 },
      {{{OSUTF8("table-count"), 11}, 0}, 1 },
      {{{OSUTF8("image-count"), 11}, 0}, 1 },
      {{{OSUTF8("object-count"), 12}, 0}, 1 },
      {{{OSUTF8("database-display"), 16}, 0}, 1 },
      {{{OSUTF8("database-next"), 13}, 0}, 1 },
      {{{OSUTF8("database-row-select"), 19}, 0}, 1 },
      {{{OSUTF8("database-row-number"), 19}, 0}, 1 },
      {{{OSUTF8("database-name"), 13}, 0}, 1 },
      {{{OSUTF8("page-variable-set"), 17}, 0}, 1 },
      {{{OSUTF8("page-variable-get"), 17}, 0}, 1 },
      {{{OSUTF8("placeholder"), 11}, 0}, 1 },
      {{{OSUTF8("conditional-text"), 16}, 0}, 1 },
      {{{OSUTF8("hidden-text"), 11}, 0}, 1 },
      {{{OSUTF8("reference-ref"), 13}, 0}, 1 },
      {{{OSUTF8("bookmark-ref"), 12}, 0}, 1 },
      {{{OSUTF8("note-ref"), 8}, 0}, 1 },
      {{{OSUTF8("sequence-ref"), 12}, 0}, 1 },
      {{{OSUTF8("script"), 6}, 0}, 1 },
      {{{OSUTF8("execute-macro"), 13}, 0}, 1 },
      {{{OSUTF8("hidden-paragraph"), 16}, 0}, 1 },
      {{{OSUTF8("dde-connection"), 14}, 0}, 1 },
      {{{OSUTF8("table-formula"), 13}, 0}, 1 },
      {{{OSUTF8("toc-mark-start"), 14}, 0}, 1 },
      {{{OSUTF8("toc-mark-end"), 12}, 0}, 1 },
      {{{OSUTF8("toc-mark"), 8}, 0}, 1 },
      {{{OSUTF8("user-index-mark-start"), 21}, 0}, 1 },
      {{{OSUTF8("user-index-mark-end"), 19}, 0}, 1 },
      {{{OSUTF8("user-index-mark"), 15}, 0}, 1 },
      {{{OSUTF8("alphabetical-index-mark-start"), 29}, 0}, 1 },
      {{{OSUTF8("alphabetical-index-mark-end"), 27}, 0}, 1 },
      {{{OSUTF8("alphabetical-index-mark"), 23}, 0}, 1 },
      {{{OSUTF8("bibliography-mark"), 17}, 0}, 1 },
      {{{OSUTF8("header"), 6}, 0}, 1 },
      {{{OSUTF8("footer"), 6}, 0}, 1 },
      {{{OSUTF8("date-time"), 9}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 123, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      case 1: {
         Odf_A_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_A_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_A_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Odf_A_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 122, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Span_element                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Span_element (OSCTXT* pctxt, Odf_Span_element *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.s = rtxMemAllocType (pctxt, Odf_S);

         if (pvalue->u.s == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_S (pvalue->u.s);
         stat = asn1D_Odf_S (pctxt, 
            pvalue->u.s, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.tab = rtxMemAllocType (pctxt, Odf_Tab);

         if (pvalue->u.tab == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Tab (pvalue->u.tab);
         stat = asn1D_Odf_Tab (pctxt, 
            pvalue->u.tab, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.line_break = rtxMemAllocType (pctxt, Odf_Line_break);

         if (pvalue->u.line_break == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Line_break (pvalue->u.line_break);
         stat = asn1D_Odf_Line_break (pctxt, 
            pvalue->u.line_break, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.span = rtxMemAllocType (pctxt, Odf_Span);

         if (pvalue->u.span == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Span ((Odf_Span*)pvalue->u.span);
         stat = asn1D_Odf_Span (pctxt, 
            (Odf_Span*)pvalue->u.span, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.a = rtxMemAllocType (pctxt, Odf_A);

         if (pvalue->u.a == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_A (pvalue->u.a);
         stat = asn1D_Odf_A (pctxt, 
            pvalue->u.a, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.bookmark = rtxMemAllocType (pctxt, Odf_Bookmark);

         if (pvalue->u.bookmark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bookmark (pvalue->u.bookmark);
         stat = asn1D_Odf_Bookmark (pctxt, 
            pvalue->u.bookmark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.bookmark_start
             = rtxMemAllocType (pctxt, Odf_Bookmark_start);

         if (pvalue->u.bookmark_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bookmark_start (pvalue->u.bookmark_start);
         stat = asn1D_Odf_Bookmark_start (pctxt, 
            pvalue->u.bookmark_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.bookmark_end = rtxMemAllocType (pctxt, Odf_Bookmark_end);

         if (pvalue->u.bookmark_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bookmark_end (pvalue->u.bookmark_end);
         stat = asn1D_Odf_Bookmark_end (pctxt, 
            pvalue->u.bookmark_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.reference_mark
             = rtxMemAllocType (pctxt, Odf_Reference_mark);

         if (pvalue->u.reference_mark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Reference_mark (pvalue->u.reference_mark);
         stat = asn1D_Odf_Reference_mark (pctxt, 
            pvalue->u.reference_mark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.reference_mark_start
             = rtxMemAllocType (pctxt, Odf_Reference_mark_start);

         if (pvalue->u.reference_mark_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Reference_mark_start (pvalue->u.reference_mark_start);
         stat = asn1D_Odf_Reference_mark_start (pctxt, 
            pvalue->u.reference_mark_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.reference_mark_end
             = rtxMemAllocType (pctxt, Odf_Reference_mark_end);

         if (pvalue->u.reference_mark_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Reference_mark_end (pvalue->u.reference_mark_end);
         stat = asn1D_Odf_Reference_mark_end (pctxt, 
            pvalue->u.reference_mark_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.note = rtxMemAllocType (pctxt, Odf_Note);

         if (pvalue->u.note == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Note (pvalue->u.note);
         stat = asn1D_Odf_Note (pctxt, 
            pvalue->u.note, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.ruby = rtxMemAllocType (pctxt, Odf_Ruby);

         if (pvalue->u.ruby == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Ruby (pvalue->u.ruby);
         stat = asn1D_Odf_Ruby (pctxt, 
            pvalue->u.ruby, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.annotation = rtxMemAllocType (pctxt, Ns13_Annotation);

         if (pvalue->u.annotation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Annotation ((Ns13_Annotation*)pvalue->u.annotation);
         stat = asn1D_Ns13_Annotation (pctxt, 
            (Ns13_Annotation*)pvalue->u.annotation, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

         if (pvalue->u.change == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change (pvalue->u.change);
         stat = asn1D_Odf_Change (pctxt, 
            pvalue->u.change, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

         if (pvalue->u.change_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_start (pvalue->u.change_start);
         stat = asn1D_Odf_Change_start (pctxt, 
            pvalue->u.change_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

         if (pvalue->u.change_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_end (pvalue->u.change_end);
         stat = asn1D_Odf_Change_end (pctxt, 
            pvalue->u.change_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      case (TM_CTXT|TM_CONS|17):
         pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

         if (pvalue->u.rect == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);
         stat = asn1D_Ns3_Rect (pctxt, 
            (Ns3_Rect*)pvalue->u.rect, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 18;
         break;

      case (TM_CTXT|TM_CONS|18):
         pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

         if (pvalue->u.line == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);
         stat = asn1D_Ns3_Line (pctxt, 
            (Ns3_Line*)pvalue->u.line, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 19;
         break;

      case (TM_CTXT|TM_CONS|19):
         pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

         if (pvalue->u.polyline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);
         stat = asn1D_Ns3_Polyline (pctxt, 
            (Ns3_Polyline*)pvalue->u.polyline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 20;
         break;

      case (TM_CTXT|TM_CONS|20):
         pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

         if (pvalue->u.polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);
         stat = asn1D_Ns3_Polygon (pctxt, 
            (Ns3_Polygon*)pvalue->u.polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 21;
         break;

      case (TM_CTXT|TM_CONS|21):
         pvalue->u.regular_polygon
             = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

         if (pvalue->u.regular_polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->u.regular_polygon);
         stat = asn1D_Ns3_Regular_polygon (pctxt, 
            (Ns3_Regular_polygon*)pvalue->u.regular_polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 22;
         break;

      case (TM_CTXT|TM_CONS|22):
         pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

         if (pvalue->u.path == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);
         stat = asn1D_Ns3_Path (pctxt, 
            (Ns3_Path*)pvalue->u.path, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 23;
         break;

      case (TM_CTXT|TM_CONS|23):
         pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

         if (pvalue->u.circle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);
         stat = asn1D_Ns3_Circle (pctxt, 
            (Ns3_Circle*)pvalue->u.circle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 24;
         break;

      case (TM_CTXT|TM_CONS|24):
         pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

         if (pvalue->u.ellipse == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);
         stat = asn1D_Ns3_Ellipse (pctxt, 
            (Ns3_Ellipse*)pvalue->u.ellipse, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 25;
         break;

      case (TM_CTXT|TM_CONS|25):
         pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

         if (pvalue->u.g == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);
         stat = asn1D_Ns3_G (pctxt, 
            (Ns3_G*)pvalue->u.g, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 26;
         break;

      case (TM_CTXT|TM_CONS|26):
         pvalue->u.page_thumbnail
             = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

         if (pvalue->u.page_thumbnail == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->u.page_thumbnail);
         stat = asn1D_Ns3_Page_thumbnail (pctxt, 
            (Ns3_Page_thumbnail*)pvalue->u.page_thumbnail, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 27;
         break;

      case (TM_CTXT|TM_CONS|27):
         pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

         if (pvalue->u.frame == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);
         stat = asn1D_Ns3_Frame (pctxt, 
            (Ns3_Frame*)pvalue->u.frame, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 28;
         break;

      case (TM_CTXT|TM_CONS|28):
         pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

         if (pvalue->u.measure == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);
         stat = asn1D_Ns3_Measure (pctxt, 
            (Ns3_Measure*)pvalue->u.measure, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 29;
         break;

      case (TM_CTXT|TM_CONS|29):
         pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

         if (pvalue->u.caption == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);
         stat = asn1D_Ns3_Caption (pctxt, 
            (Ns3_Caption*)pvalue->u.caption, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 30;
         break;

      case (TM_CTXT|TM_CONS|30):
         pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

         if (pvalue->u.connector == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);
         stat = asn1D_Ns3_Connector (pctxt, 
            (Ns3_Connector*)pvalue->u.connector, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 31;
         break;

      case (TM_CTXT|TM_CONS|31):
         pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

         if (pvalue->u.control == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);
         stat = asn1D_Ns3_Control (pctxt, 
            (Ns3_Control*)pvalue->u.control, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 32;
         break;

      case (TM_CTXT|TM_CONS|32):
         pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

         if (pvalue->u.scene == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);
         stat = asn1D_Ns7_Scene (pctxt, 
            (Ns7_Scene*)pvalue->u.scene, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 33;
         break;

      case (TM_CTXT|TM_CONS|33):
         pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

         if (pvalue->u.custom_shape == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);
         stat = asn1D_Ns3_Custom_shape (pctxt, 
            (Ns3_Custom_shape*)pvalue->u.custom_shape, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 34;
         break;

      case (TM_CTXT|TM_CONS|34):
         pvalue->u.a_1 = rtxMemAllocType (pctxt, Ns3_A);

         if (pvalue->u.a_1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_A ((Ns3_A*)pvalue->u.a_1);
         stat = asn1D_Ns3_A (pctxt, 
            (Ns3_A*)pvalue->u.a_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 35;
         break;

      case (TM_CTXT|TM_CONS|35):
         pvalue->u.date = rtxMemAllocType (pctxt, Odf_Date);

         if (pvalue->u.date == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Date (pvalue->u.date);
         stat = asn1D_Odf_Date (pctxt, 
            pvalue->u.date, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 36;
         break;

      case (TM_CTXT|TM_CONS|36):
         pvalue->u.time_ = rtxMemAllocType (pctxt, Odf_Time);

         if (pvalue->u.time_ == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Time (pvalue->u.time_);
         stat = asn1D_Odf_Time (pctxt, 
            pvalue->u.time_, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 37;
         break;

      case (TM_CTXT|TM_CONS|37):
         pvalue->u.page_number = rtxMemAllocType (pctxt, Odf_Page_number);

         if (pvalue->u.page_number == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Page_number (pvalue->u.page_number);
         stat = asn1D_Odf_Page_number (pctxt, 
            pvalue->u.page_number, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 38;
         break;

      case (TM_CTXT|TM_CONS|38):
         pvalue->u.page_continuation
             = rtxMemAllocType (pctxt, Odf_Page_continuation);

         if (pvalue->u.page_continuation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Page_continuation (pvalue->u.page_continuation);
         stat = asn1D_Odf_Page_continuation (pctxt, 
            pvalue->u.page_continuation, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 39;
         break;

      case (TM_CTXT|TM_CONS|39):
         pvalue->u.sender_firstname
             = rtxMemAllocType (pctxt, Odf_Sender_firstname);

         if (pvalue->u.sender_firstname == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_firstname (pvalue->u.sender_firstname);
         stat = asn1D_Odf_Sender_firstname (pctxt, 
            pvalue->u.sender_firstname, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 40;
         break;

      case (TM_CTXT|TM_CONS|40):
         pvalue->u.sender_lastname
             = rtxMemAllocType (pctxt, Odf_Sender_lastname);

         if (pvalue->u.sender_lastname == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_lastname (pvalue->u.sender_lastname);
         stat = asn1D_Odf_Sender_lastname (pctxt, 
            pvalue->u.sender_lastname, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 41;
         break;

      case (TM_CTXT|TM_CONS|41):
         pvalue->u.sender_initials
             = rtxMemAllocType (pctxt, Odf_Sender_initials);

         if (pvalue->u.sender_initials == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_initials (pvalue->u.sender_initials);
         stat = asn1D_Odf_Sender_initials (pctxt, 
            pvalue->u.sender_initials, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 42;
         break;

      case (TM_CTXT|TM_CONS|42):
         pvalue->u.sender_title = rtxMemAllocType (pctxt, Odf_Sender_title);

         if (pvalue->u.sender_title == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_title (pvalue->u.sender_title);
         stat = asn1D_Odf_Sender_title (pctxt, 
            pvalue->u.sender_title, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 43;
         break;

      case (TM_CTXT|TM_CONS|43):
         pvalue->u.sender_position
             = rtxMemAllocType (pctxt, Odf_Sender_position);

         if (pvalue->u.sender_position == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_position (pvalue->u.sender_position);
         stat = asn1D_Odf_Sender_position (pctxt, 
            pvalue->u.sender_position, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 44;
         break;

      case (TM_CTXT|TM_CONS|44):
         pvalue->u.sender_email = rtxMemAllocType (pctxt, Odf_Sender_email);

         if (pvalue->u.sender_email == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_email (pvalue->u.sender_email);
         stat = asn1D_Odf_Sender_email (pctxt, 
            pvalue->u.sender_email, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 45;
         break;

      case (TM_CTXT|TM_CONS|45):
         pvalue->u.sender_phone_private
             = rtxMemAllocType (pctxt, Odf_Sender_phone_private);

         if (pvalue->u.sender_phone_private == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_phone_private (pvalue->u.sender_phone_private);
         stat = asn1D_Odf_Sender_phone_private (pctxt, 
            pvalue->u.sender_phone_private, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 46;
         break;

      case (TM_CTXT|TM_CONS|46):
         pvalue->u.sender_fax = rtxMemAllocType (pctxt, Odf_Sender_fax);

         if (pvalue->u.sender_fax == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_fax (pvalue->u.sender_fax);
         stat = asn1D_Odf_Sender_fax (pctxt, 
            pvalue->u.sender_fax, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 47;
         break;

      case (TM_CTXT|TM_CONS|47):
         pvalue->u.sender_company
             = rtxMemAllocType (pctxt, Odf_Sender_company);

         if (pvalue->u.sender_company == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_company (pvalue->u.sender_company);
         stat = asn1D_Odf_Sender_company (pctxt, 
            pvalue->u.sender_company, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 48;
         break;

      case (TM_CTXT|TM_CONS|48):
         pvalue->u.sender_phone_work
             = rtxMemAllocType (pctxt, Odf_Sender_phone_work);

         if (pvalue->u.sender_phone_work == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_phone_work (pvalue->u.sender_phone_work);
         stat = asn1D_Odf_Sender_phone_work (pctxt, 
            pvalue->u.sender_phone_work, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 49;
         break;

      case (TM_CTXT|TM_CONS|49):
         pvalue->u.sender_street = rtxMemAllocType (pctxt, Odf_Sender_street);

         if (pvalue->u.sender_street == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_street (pvalue->u.sender_street);
         stat = asn1D_Odf_Sender_street (pctxt, 
            pvalue->u.sender_street, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 50;
         break;

      case (TM_CTXT|TM_CONS|50):
         pvalue->u.sender_city = rtxMemAllocType (pctxt, Odf_Sender_city);

         if (pvalue->u.sender_city == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_city (pvalue->u.sender_city);
         stat = asn1D_Odf_Sender_city (pctxt, 
            pvalue->u.sender_city, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 51;
         break;

      case (TM_CTXT|TM_CONS|51):
         pvalue->u.sender_postal_code
             = rtxMemAllocType (pctxt, Odf_Sender_postal_code);

         if (pvalue->u.sender_postal_code == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_postal_code (pvalue->u.sender_postal_code);
         stat = asn1D_Odf_Sender_postal_code (pctxt, 
            pvalue->u.sender_postal_code, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 52;
         break;

      case (TM_CTXT|TM_CONS|52):
         pvalue->u.sender_country
             = rtxMemAllocType (pctxt, Odf_Sender_country);

         if (pvalue->u.sender_country == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_country (pvalue->u.sender_country);
         stat = asn1D_Odf_Sender_country (pctxt, 
            pvalue->u.sender_country, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 53;
         break;

      case (TM_CTXT|TM_CONS|53):
         pvalue->u.sender_state_or_province
             = rtxMemAllocType (pctxt, Odf_Sender_state_or_province);

         if (pvalue->u.sender_state_or_province == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_state_or_province (pvalue->u.sender_state_or_province);
         stat = asn1D_Odf_Sender_state_or_province (pctxt, 
            pvalue->u.sender_state_or_province, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 54;
         break;

      case (TM_CTXT|TM_CONS|54):
         pvalue->u.author_name = rtxMemAllocType (pctxt, Odf_Author_name);

         if (pvalue->u.author_name == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Author_name (pvalue->u.author_name);
         stat = asn1D_Odf_Author_name (pctxt, 
            pvalue->u.author_name, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 55;
         break;

      case (TM_CTXT|TM_CONS|55):
         pvalue->u.author_initials
             = rtxMemAllocType (pctxt, Odf_Author_initials);

         if (pvalue->u.author_initials == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Author_initials (pvalue->u.author_initials);
         stat = asn1D_Odf_Author_initials (pctxt, 
            pvalue->u.author_initials, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 56;
         break;

      case (TM_CTXT|TM_CONS|56):
         pvalue->u.chapter = rtxMemAllocType (pctxt, Odf_Chapter);

         if (pvalue->u.chapter == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Chapter (pvalue->u.chapter);
         stat = asn1D_Odf_Chapter (pctxt, 
            pvalue->u.chapter, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 57;
         break;

      case (TM_CTXT|TM_CONS|57):
         pvalue->u.file_name = rtxMemAllocType (pctxt, Odf_File_name);

         if (pvalue->u.file_name == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_File_name (pvalue->u.file_name);
         stat = asn1D_Odf_File_name (pctxt, 
            pvalue->u.file_name, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 58;
         break;

      case (TM_CTXT|TM_CONS|58):
         pvalue->u.template_name = rtxMemAllocType (pctxt, Odf_Template_name);

         if (pvalue->u.template_name == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Template_name (pvalue->u.template_name);
         stat = asn1D_Odf_Template_name (pctxt, 
            pvalue->u.template_name, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 59;
         break;

      case (TM_CTXT|TM_PRIM|59):
      case (TM_CTXT|TM_CONS|59):
         stat = asn1D_Odf_Sheet_name (pctxt, 
            &pvalue->u.sheet_name, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 60;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_CONS|60):
         pvalue->u.variable_set = rtxMemAllocType (pctxt, Odf_Variable_set);

         if (pvalue->u.variable_set == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Variable_set (pvalue->u.variable_set);
         stat = asn1D_Odf_Variable_set (pctxt, 
            pvalue->u.variable_set, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 61;
         break;

      case (TM_CTXT|TM_CONS|61):
         pvalue->u.variable_get = rtxMemAllocType (pctxt, Odf_Variable_get);

         if (pvalue->u.variable_get == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Variable_get (pvalue->u.variable_get);
         stat = asn1D_Odf_Variable_get (pctxt, 
            pvalue->u.variable_get, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 62;
         break;

      case (TM_CTXT|TM_CONS|62):
         pvalue->u.variable_input
             = rtxMemAllocType (pctxt, Odf_Variable_input);

         if (pvalue->u.variable_input == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Variable_input (pvalue->u.variable_input);
         stat = asn1D_Odf_Variable_input (pctxt, 
            pvalue->u.variable_input, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 63;
         break;

      case (TM_CTXT|TM_CONS|63):
         pvalue->u.user_field_get
             = rtxMemAllocType (pctxt, Odf_User_field_get);

         if (pvalue->u.user_field_get == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_field_get (pvalue->u.user_field_get);
         stat = asn1D_Odf_User_field_get (pctxt, 
            pvalue->u.user_field_get, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 64;
         break;

      case (TM_CTXT|TM_CONS|64):
         pvalue->u.user_field_input
             = rtxMemAllocType (pctxt, Odf_User_field_input);

         if (pvalue->u.user_field_input == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_field_input (pvalue->u.user_field_input);
         stat = asn1D_Odf_User_field_input (pctxt, 
            pvalue->u.user_field_input, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 65;
         break;

      case (TM_CTXT|TM_CONS|65):
         pvalue->u.sequence = rtxMemAllocType (pctxt, Odf_Sequence);

         if (pvalue->u.sequence == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sequence (pvalue->u.sequence);
         stat = asn1D_Odf_Sequence (pctxt, 
            pvalue->u.sequence, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 66;
         break;

      case (TM_CTXT|TM_CONS|66):
         pvalue->u.expression = rtxMemAllocType (pctxt, Odf_Expression);

         if (pvalue->u.expression == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Expression (pvalue->u.expression);
         stat = asn1D_Odf_Expression (pctxt, 
            pvalue->u.expression, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 67;
         break;

      case (TM_CTXT|TM_CONS|67):
         pvalue->u.text_input = rtxMemAllocType (pctxt, Odf_Text_input);

         if (pvalue->u.text_input == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Text_input (pvalue->u.text_input);
         stat = asn1D_Odf_Text_input (pctxt, 
            pvalue->u.text_input, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 68;
         break;

      case (TM_CTXT|TM_CONS|68):
         pvalue->u.initial_creator
             = rtxMemAllocType (pctxt, Odf_Initial_creator);

         if (pvalue->u.initial_creator == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Initial_creator (pvalue->u.initial_creator);
         stat = asn1D_Odf_Initial_creator (pctxt, 
            pvalue->u.initial_creator, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 69;
         break;

      case (TM_CTXT|TM_CONS|69):
         pvalue->u.creation_date = rtxMemAllocType (pctxt, Odf_Creation_date);

         if (pvalue->u.creation_date == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Creation_date (pvalue->u.creation_date);
         stat = asn1D_Odf_Creation_date (pctxt, 
            pvalue->u.creation_date, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 70;
         break;

      case (TM_CTXT|TM_CONS|70):
         pvalue->u.creation_time = rtxMemAllocType (pctxt, Odf_Creation_time);

         if (pvalue->u.creation_time == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Creation_time (pvalue->u.creation_time);
         stat = asn1D_Odf_Creation_time (pctxt, 
            pvalue->u.creation_time, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 71;
         break;

      case (TM_CTXT|TM_CONS|71):
         pvalue->u.description = rtxMemAllocType (pctxt, Odf_Description);

         if (pvalue->u.description == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Description (pvalue->u.description);
         stat = asn1D_Odf_Description (pctxt, 
            pvalue->u.description, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 72;
         break;

      case (TM_CTXT|TM_CONS|72):
         pvalue->u.user_defined = rtxMemAllocType (pctxt, Odf_User_defined);

         if (pvalue->u.user_defined == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_defined (pvalue->u.user_defined);
         stat = asn1D_Odf_User_defined (pctxt, 
            pvalue->u.user_defined, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 73;
         break;

      case (TM_CTXT|TM_CONS|73):
         pvalue->u.print_time = rtxMemAllocType (pctxt, Odf_Print_time);

         if (pvalue->u.print_time == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Print_time (pvalue->u.print_time);
         stat = asn1D_Odf_Print_time (pctxt, 
            pvalue->u.print_time, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 74;
         break;

      case (TM_CTXT|TM_CONS|74):
         pvalue->u.print_date = rtxMemAllocType (pctxt, Odf_Print_date);

         if (pvalue->u.print_date == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Print_date (pvalue->u.print_date);
         stat = asn1D_Odf_Print_date (pctxt, 
            pvalue->u.print_date, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 75;
         break;

      case (TM_CTXT|TM_CONS|75):
         pvalue->u.printed_by = rtxMemAllocType (pctxt, Odf_Printed_by);

         if (pvalue->u.printed_by == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Printed_by (pvalue->u.printed_by);
         stat = asn1D_Odf_Printed_by (pctxt, 
            pvalue->u.printed_by, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 76;
         break;

      case (TM_CTXT|TM_CONS|76):
         pvalue->u.title = rtxMemAllocType (pctxt, Odf_Title);

         if (pvalue->u.title == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Title (pvalue->u.title);
         stat = asn1D_Odf_Title (pctxt, 
            pvalue->u.title, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 77;
         break;

      case (TM_CTXT|TM_CONS|77):
         pvalue->u.subject = rtxMemAllocType (pctxt, Odf_Subject);

         if (pvalue->u.subject == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Subject (pvalue->u.subject);
         stat = asn1D_Odf_Subject (pctxt, 
            pvalue->u.subject, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 78;
         break;

      case (TM_CTXT|TM_CONS|78):
         pvalue->u.keywords = rtxMemAllocType (pctxt, Odf_Keywords);

         if (pvalue->u.keywords == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Keywords (pvalue->u.keywords);
         stat = asn1D_Odf_Keywords (pctxt, 
            pvalue->u.keywords, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 79;
         break;

      case (TM_CTXT|TM_CONS|79):
         pvalue->u.editing_cycles
             = rtxMemAllocType (pctxt, Odf_Editing_cycles);

         if (pvalue->u.editing_cycles == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Editing_cycles (pvalue->u.editing_cycles);
         stat = asn1D_Odf_Editing_cycles (pctxt, 
            pvalue->u.editing_cycles, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 80;
         break;

      case (TM_CTXT|TM_CONS|80):
         pvalue->u.editing_duration
             = rtxMemAllocType (pctxt, Odf_Editing_duration);

         if (pvalue->u.editing_duration == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Editing_duration (pvalue->u.editing_duration);
         stat = asn1D_Odf_Editing_duration (pctxt, 
            pvalue->u.editing_duration, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 81;
         break;

      case (TM_CTXT|TM_CONS|81):
         pvalue->u.modification_time
             = rtxMemAllocType (pctxt, Odf_Modification_time);

         if (pvalue->u.modification_time == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Modification_time (pvalue->u.modification_time);
         stat = asn1D_Odf_Modification_time (pctxt, 
            pvalue->u.modification_time, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 82;
         break;

      case (TM_CTXT|TM_CONS|82):
         pvalue->u.modification_date
             = rtxMemAllocType (pctxt, Odf_Modification_date);

         if (pvalue->u.modification_date == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Modification_date (pvalue->u.modification_date);
         stat = asn1D_Odf_Modification_date (pctxt, 
            pvalue->u.modification_date, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 83;
         break;

      case (TM_CTXT|TM_CONS|83):
         pvalue->u.creator = rtxMemAllocType (pctxt, Odf_Creator);

         if (pvalue->u.creator == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Creator (pvalue->u.creator);
         stat = asn1D_Odf_Creator (pctxt, 
            pvalue->u.creator, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 84;
         break;

      case (TM_CTXT|TM_CONS|84):
         pvalue->u.element271 = rtxMemAllocType (pctxt, Odf_Element271_group);

         if (pvalue->u.element271 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Element271_group (pvalue->u.element271);
         stat = asn1D_Odf_Element271_group (pctxt, 
            pvalue->u.element271, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 85;
         break;

      case (TM_CTXT|TM_CONS|85):
         pvalue->u.database_display
             = rtxMemAllocType (pctxt, Odf_Database_display);

         if (pvalue->u.database_display == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Database_display (pvalue->u.database_display);
         stat = asn1D_Odf_Database_display (pctxt, 
            pvalue->u.database_display, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 86;
         break;

      case (TM_CTXT|TM_CONS|86):
         pvalue->u.database_next = rtxMemAllocType (pctxt, Odf_Database_next);

         if (pvalue->u.database_next == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Database_next (pvalue->u.database_next);
         stat = asn1D_Odf_Database_next (pctxt, 
            pvalue->u.database_next, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 87;
         break;

      case (TM_CTXT|TM_CONS|87):
         pvalue->u.database_row_select
             = rtxMemAllocType (pctxt, Odf_Database_row_select);

         if (pvalue->u.database_row_select == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Database_row_select (pvalue->u.database_row_select);
         stat = asn1D_Odf_Database_row_select (pctxt, 
            pvalue->u.database_row_select, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 88;
         break;

      case (TM_CTXT|TM_CONS|88):
         pvalue->u.database_row_number
             = rtxMemAllocType (pctxt, Odf_Database_row_number);

         if (pvalue->u.database_row_number == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Database_row_number (pvalue->u.database_row_number);
         stat = asn1D_Odf_Database_row_number (pctxt, 
            pvalue->u.database_row_number, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 89;
         break;

      case (TM_CTXT|TM_CONS|89):
         pvalue->u.database_name = rtxMemAllocType (pctxt, Odf_Database_name);

         if (pvalue->u.database_name == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Database_name (pvalue->u.database_name);
         stat = asn1D_Odf_Database_name (pctxt, 
            pvalue->u.database_name, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 90;
         break;

      case (TM_CTXT|TM_CONS|90):
         pvalue->u.page_variable_set
             = rtxMemAllocType (pctxt, Odf_Page_variable_set);

         if (pvalue->u.page_variable_set == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Page_variable_set (pvalue->u.page_variable_set);
         stat = asn1D_Odf_Page_variable_set (pctxt, 
            pvalue->u.page_variable_set, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 91;
         break;

      case (TM_CTXT|TM_CONS|91):
         pvalue->u.page_variable_get
             = rtxMemAllocType (pctxt, Odf_Page_variable_get);

         if (pvalue->u.page_variable_get == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Page_variable_get (pvalue->u.page_variable_get);
         stat = asn1D_Odf_Page_variable_get (pctxt, 
            pvalue->u.page_variable_get, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 92;
         break;

      case (TM_CTXT|TM_CONS|92):
         pvalue->u.placeholder = rtxMemAllocType (pctxt, Odf_Placeholder);

         if (pvalue->u.placeholder == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Placeholder (pvalue->u.placeholder);
         stat = asn1D_Odf_Placeholder (pctxt, 
            pvalue->u.placeholder, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 93;
         break;

      case (TM_CTXT|TM_CONS|93):
         pvalue->u.conditional_text
             = rtxMemAllocType (pctxt, Odf_Conditional_text);

         if (pvalue->u.conditional_text == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Conditional_text (pvalue->u.conditional_text);
         stat = asn1D_Odf_Conditional_text (pctxt, 
            pvalue->u.conditional_text, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 94;
         break;

      case (TM_CTXT|TM_CONS|94):
         pvalue->u.hidden_text = rtxMemAllocType (pctxt, Odf_Hidden_text);

         if (pvalue->u.hidden_text == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Hidden_text (pvalue->u.hidden_text);
         stat = asn1D_Odf_Hidden_text (pctxt, 
            pvalue->u.hidden_text, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 95;
         break;

      case (TM_CTXT|TM_CONS|95):
         pvalue->u.element282 = rtxMemAllocType (pctxt, Odf_Element282_group);

         if (pvalue->u.element282 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Element282_group (pvalue->u.element282);
         stat = asn1D_Odf_Element282_group (pctxt, 
            pvalue->u.element282, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 96;
         break;

      case (TM_CTXT|TM_CONS|96):
         pvalue->u.note_ref = rtxMemAllocType (pctxt, Odf_Note_ref);

         if (pvalue->u.note_ref == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Note_ref (pvalue->u.note_ref);
         stat = asn1D_Odf_Note_ref (pctxt, 
            pvalue->u.note_ref, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 97;
         break;

      case (TM_CTXT|TM_CONS|97):
         pvalue->u.sequence_ref = rtxMemAllocType (pctxt, Odf_Sequence_ref);

         if (pvalue->u.sequence_ref == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sequence_ref (pvalue->u.sequence_ref);
         stat = asn1D_Odf_Sequence_ref (pctxt, 
            pvalue->u.sequence_ref, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 98;
         break;

      case (TM_CTXT|TM_CONS|98):
         pvalue->u.script = rtxMemAllocType (pctxt, Odf_Script);

         if (pvalue->u.script == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Script (pvalue->u.script);
         stat = asn1D_Odf_Script (pctxt, 
            pvalue->u.script, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 99;
         break;

      case (TM_CTXT|TM_CONS|99):
         pvalue->u.execute_macro = rtxMemAllocType (pctxt, Odf_Execute_macro);

         if (pvalue->u.execute_macro == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Execute_macro (pvalue->u.execute_macro);
         stat = asn1D_Odf_Execute_macro (pctxt, 
            pvalue->u.execute_macro, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 100;
         break;

      case (TM_CTXT|TM_CONS|100):
         pvalue->u.hidden_paragraph
             = rtxMemAllocType (pctxt, Odf_Hidden_paragraph);

         if (pvalue->u.hidden_paragraph == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Hidden_paragraph (pvalue->u.hidden_paragraph);
         stat = asn1D_Odf_Hidden_paragraph (pctxt, 
            pvalue->u.hidden_paragraph, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 101;
         break;

      case (TM_CTXT|TM_CONS|101):
         pvalue->u.dde_connection
             = rtxMemAllocType (pctxt, Odf_Dde_connection);

         if (pvalue->u.dde_connection == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Dde_connection (pvalue->u.dde_connection);
         stat = asn1D_Odf_Dde_connection (pctxt, 
            pvalue->u.dde_connection, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 102;
         break;

      case (TM_CTXT|TM_CONS|102):
         pvalue->u.measure_1 = rtxMemAllocType (pctxt, Odf_Measure);

         if (pvalue->u.measure_1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Measure (pvalue->u.measure_1);
         stat = asn1D_Odf_Measure (pctxt, 
            pvalue->u.measure_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 103;
         break;

      case (TM_CTXT|TM_CONS|103):
         pvalue->u.table_formula = rtxMemAllocType (pctxt, Odf_Table_formula);

         if (pvalue->u.table_formula == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_formula (pvalue->u.table_formula);
         stat = asn1D_Odf_Table_formula (pctxt, 
            pvalue->u.table_formula, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 104;
         break;

      case (TM_CTXT|TM_CONS|104):
         pvalue->u.toc_mark_start
             = rtxMemAllocType (pctxt, Odf_Toc_mark_start);

         if (pvalue->u.toc_mark_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Toc_mark_start (pvalue->u.toc_mark_start);
         stat = asn1D_Odf_Toc_mark_start (pctxt, 
            pvalue->u.toc_mark_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 105;
         break;

      case (TM_CTXT|TM_CONS|105):
         pvalue->u.toc_mark_end = rtxMemAllocType (pctxt, Odf_Toc_mark_end);

         if (pvalue->u.toc_mark_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Toc_mark_end (pvalue->u.toc_mark_end);
         stat = asn1D_Odf_Toc_mark_end (pctxt, 
            pvalue->u.toc_mark_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 106;
         break;

      case (TM_CTXT|TM_CONS|106):
         pvalue->u.toc_mark = rtxMemAllocType (pctxt, Odf_Toc_mark);

         if (pvalue->u.toc_mark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Toc_mark (pvalue->u.toc_mark);
         stat = asn1D_Odf_Toc_mark (pctxt, 
            pvalue->u.toc_mark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 107;
         break;

      case (TM_CTXT|TM_CONS|107):
         pvalue->u.user_index_mark_start
             = rtxMemAllocType (pctxt, Odf_User_index_mark_start);

         if (pvalue->u.user_index_mark_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index_mark_start (pvalue->u.user_index_mark_start);
         stat = asn1D_Odf_User_index_mark_start (pctxt, 
            pvalue->u.user_index_mark_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 108;
         break;

      case (TM_CTXT|TM_CONS|108):
         pvalue->u.user_index_mark_end
             = rtxMemAllocType (pctxt, Odf_User_index_mark_end);

         if (pvalue->u.user_index_mark_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index_mark_end (pvalue->u.user_index_mark_end);
         stat = asn1D_Odf_User_index_mark_end (pctxt, 
            pvalue->u.user_index_mark_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 109;
         break;

      case (TM_CTXT|TM_CONS|109):
         pvalue->u.user_index_mark
             = rtxMemAllocType (pctxt, Odf_User_index_mark);

         if (pvalue->u.user_index_mark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index_mark (pvalue->u.user_index_mark);
         stat = asn1D_Odf_User_index_mark (pctxt, 
            pvalue->u.user_index_mark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 110;
         break;

      case (TM_CTXT|TM_CONS|110):
         pvalue->u.alphabetical_index_mark_start
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark_start);

         if (pvalue->u.alphabetical_index_mark_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index_mark_start (pvalue->u.alphabetical_index_mark_start);
         stat = asn1D_Odf_Alphabetical_index_mark_start (pctxt, 
            pvalue->u.alphabetical_index_mark_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 111;
         break;

      case (TM_CTXT|TM_CONS|111):
         pvalue->u.alphabetical_index_mark_end
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark_end);

         if (pvalue->u.alphabetical_index_mark_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index_mark_end (pvalue->u.alphabetical_index_mark_end);
         stat = asn1D_Odf_Alphabetical_index_mark_end (pctxt, 
            pvalue->u.alphabetical_index_mark_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 112;
         break;

      case (TM_CTXT|TM_CONS|112):
         pvalue->u.alphabetical_index_mark
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark);

         if (pvalue->u.alphabetical_index_mark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index_mark (pvalue->u.alphabetical_index_mark);
         stat = asn1D_Odf_Alphabetical_index_mark (pctxt, 
            pvalue->u.alphabetical_index_mark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 113;
         break;

      case (TM_CTXT|TM_CONS|113):
         pvalue->u.bibliography_mark
             = rtxMemAllocType (pctxt, Odf_Bibliography_mark);

         if (pvalue->u.bibliography_mark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bibliography_mark (pvalue->u.bibliography_mark);
         stat = asn1D_Odf_Bibliography_mark (pctxt, 
            pvalue->u.bibliography_mark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 114;
         break;

      case (TM_CTXT|TM_CONS|114):
         pvalue->u.header = rtxMemAllocType (pctxt, Ns10_Header);

         if (pvalue->u.header == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns10_Header ((Ns10_Header*)pvalue->u.header);
         stat = asn1D_Ns10_Header (pctxt, 
            (Ns10_Header*)pvalue->u.header, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 115;
         break;

      case (TM_CTXT|TM_CONS|115):
         pvalue->u.footer = rtxMemAllocType (pctxt, Ns10_Footer);

         if (pvalue->u.footer == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns10_Footer ((Ns10_Footer*)pvalue->u.footer);
         stat = asn1D_Ns10_Footer (pctxt, 
            (Ns10_Footer*)pvalue->u.footer, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 116;
         break;

      case (TM_CTXT|TM_CONS|116):
         pvalue->u.date_time = rtxMemAllocType (pctxt, Ns10_Date_time);

         if (pvalue->u.date_time == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns10_Date_time ((Ns10_Date_time*)pvalue->u.date_time);
         stat = asn1D_Ns10_Date_time (pctxt, 
            (Ns10_Date_time*)pvalue->u.date_time, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 117;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Span_element (OSCTXT* pctxt, Odf_Span_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("s"), 1}, 0}, 0 },
      {{{OSUTF8("tab"), 3}, 0}, 1 },
      {{{OSUTF8("line-break"), 10}, 0}, 2 },
      {{{OSUTF8("span"), 4}, 0}, 3 },
      {{{OSUTF8("a"), 1}, 0}, 4 },
      {{{OSUTF8("bookmark"), 8}, 0}, 5 },
      {{{OSUTF8("bookmark-start"), 14}, 0}, 6 },
      {{{OSUTF8("bookmark-end"), 12}, 0}, 7 },
      {{{OSUTF8("reference-mark"), 14}, 0}, 8 },
      {{{OSUTF8("reference-mark-start"), 20}, 0}, 9 },
      {{{OSUTF8("reference-mark-end"), 18}, 0}, 10 },
      {{{OSUTF8("note"), 4}, 0}, 11 },
      {{{OSUTF8("ruby"), 4}, 0}, 12 },
      {{{OSUTF8("annotation"), 10}, 0}, 13 },
      {{{OSUTF8("change"), 6}, 0}, 14 },
      {{{OSUTF8("change-start"), 12}, 0}, 15 },
      {{{OSUTF8("change-end"), 10}, 0}, 16 },
      {{{OSUTF8("rect"), 4}, 0}, 17 },
      {{{OSUTF8("line"), 4}, 0}, 18 },
      {{{OSUTF8("polyline"), 8}, 0}, 19 },
      {{{OSUTF8("polygon"), 7}, 0}, 20 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 21 },
      {{{OSUTF8("path"), 4}, 0}, 22 },
      {{{OSUTF8("circle"), 6}, 0}, 23 },
      {{{OSUTF8("ellipse"), 7}, 0}, 24 },
      {{{OSUTF8("g"), 1}, 0}, 25 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 26 },
      {{{OSUTF8("frame"), 5}, 0}, 27 },
      {{{OSUTF8("measure"), 7}, 0}, 28 },
      {{{OSUTF8("caption"), 7}, 0}, 29 },
      {{{OSUTF8("connector"), 9}, 0}, 30 },
      {{{OSUTF8("control"), 7}, 0}, 31 },
      {{{OSUTF8("scene"), 5}, 0}, 32 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 33 },
      {{{OSUTF8("a"), 1}, 0}, 34 },
      {{{OSUTF8("date"), 4}, 0}, 35 },
      {{{OSUTF8("time"), 4}, 0}, 36 },
      {{{OSUTF8("page-number"), 11}, 0}, 37 },
      {{{OSUTF8("page-continuation"), 17}, 0}, 38 },
      {{{OSUTF8("sender-firstname"), 16}, 0}, 39 },
      {{{OSUTF8("sender-lastname"), 15}, 0}, 40 },
      {{{OSUTF8("sender-initials"), 15}, 0}, 41 },
      {{{OSUTF8("sender-title"), 12}, 0}, 42 },
      {{{OSUTF8("sender-position"), 15}, 0}, 43 },
      {{{OSUTF8("sender-email"), 12}, 0}, 44 },
      {{{OSUTF8("sender-phone-private"), 20}, 0}, 45 },
      {{{OSUTF8("sender-fax"), 10}, 0}, 46 },
      {{{OSUTF8("sender-company"), 14}, 0}, 47 },
      {{{OSUTF8("sender-phone-work"), 17}, 0}, 48 },
      {{{OSUTF8("sender-street"), 13}, 0}, 49 },
      {{{OSUTF8("sender-city"), 11}, 0}, 50 },
      {{{OSUTF8("sender-postal-code"), 18}, 0}, 51 },
      {{{OSUTF8("sender-country"), 14}, 0}, 52 },
      {{{OSUTF8("sender-state-or-province"), 24}, 0}, 53 },
      {{{OSUTF8("author-name"), 11}, 0}, 54 },
      {{{OSUTF8("author-initials"), 15}, 0}, 55 },
      {{{OSUTF8("chapter"), 7}, 0}, 56 },
      {{{OSUTF8("file-name"), 9}, 0}, 57 },
      {{{OSUTF8("template-name"), 13}, 0}, 58 },
      {{{OSUTF8("sheet-name"), 10}, 0}, 59 },
      {{{OSUTF8("variable-set"), 12}, 0}, 60 },
      {{{OSUTF8("variable-get"), 12}, 0}, 61 },
      {{{OSUTF8("variable-input"), 14}, 0}, 62 },
      {{{OSUTF8("user-field-get"), 14}, 0}, 63 },
      {{{OSUTF8("user-field-input"), 16}, 0}, 64 },
      {{{OSUTF8("sequence"), 8}, 0}, 65 },
      {{{OSUTF8("expression"), 10}, 0}, 66 },
      {{{OSUTF8("text-input"), 10}, 0}, 67 },
      {{{OSUTF8("initial-creator"), 15}, 0}, 68 },
      {{{OSUTF8("creation-date"), 13}, 0}, 69 },
      {{{OSUTF8("creation-time"), 13}, 0}, 70 },
      {{{OSUTF8("description"), 11}, 0}, 71 },
      {{{OSUTF8("user-defined"), 12}, 0}, 72 },
      {{{OSUTF8("print-time"), 10}, 0}, 73 },
      {{{OSUTF8("print-date"), 10}, 0}, 74 },
      {{{OSUTF8("printed-by"), 10}, 0}, 75 },
      {{{OSUTF8("title"), 5}, 0}, 76 },
      {{{OSUTF8("subject"), 7}, 0}, 77 },
      {{{OSUTF8("keywords"), 8}, 0}, 78 },
      {{{OSUTF8("editing-cycles"), 14}, 0}, 79 },
      {{{OSUTF8("editing-duration"), 16}, 0}, 80 },
      {{{OSUTF8("modification-time"), 17}, 0}, 81 },
      {{{OSUTF8("modification-date"), 17}, 0}, 82 },
      {{{OSUTF8("creator"), 7}, 0}, 83 },
      {{{OSUTF8("page-count"), 10}, 0}, 84 },
      {{{OSUTF8("paragraph-count"), 15}, 0}, 84 },
      {{{OSUTF8("word-count"), 10}, 0}, 84 },
      {{{OSUTF8("character-count"), 15}, 0}, 84 },
      {{{OSUTF8("table-count"), 11}, 0}, 84 },
      {{{OSUTF8("image-count"), 11}, 0}, 84 },
      {{{OSUTF8("object-count"), 12}, 0}, 84 },
      {{{OSUTF8("database-display"), 16}, 0}, 85 },
      {{{OSUTF8("database-next"), 13}, 0}, 86 },
      {{{OSUTF8("database-row-select"), 19}, 0}, 87 },
      {{{OSUTF8("database-row-number"), 19}, 0}, 88 },
      {{{OSUTF8("database-name"), 13}, 0}, 89 },
      {{{OSUTF8("page-variable-set"), 17}, 0}, 90 },
      {{{OSUTF8("page-variable-get"), 17}, 0}, 91 },
      {{{OSUTF8("placeholder"), 11}, 0}, 92 },
      {{{OSUTF8("conditional-text"), 16}, 0}, 93 },
      {{{OSUTF8("hidden-text"), 11}, 0}, 94 },
      {{{OSUTF8("reference-ref"), 13}, 0}, 95 },
      {{{OSUTF8("bookmark-ref"), 12}, 0}, 95 },
      {{{OSUTF8("note-ref"), 8}, 0}, 96 },
      {{{OSUTF8("sequence-ref"), 12}, 0}, 97 },
      {{{OSUTF8("script"), 6}, 0}, 98 },
      {{{OSUTF8("execute-macro"), 13}, 0}, 99 },
      {{{OSUTF8("hidden-paragraph"), 16}, 0}, 100 },
      {{{OSUTF8("dde-connection"), 14}, 0}, 101 },
      {{{OSUTF8("measure"), 7}, 0}, 102 },
      {{{OSUTF8("table-formula"), 13}, 0}, 103 },
      {{{OSUTF8("toc-mark-start"), 14}, 0}, 104 },
      {{{OSUTF8("toc-mark-end"), 12}, 0}, 105 },
      {{{OSUTF8("toc-mark"), 8}, 0}, 106 },
      {{{OSUTF8("user-index-mark-start"), 21}, 0}, 107 },
      {{{OSUTF8("user-index-mark-end"), 19}, 0}, 108 },
      {{{OSUTF8("user-index-mark"), 15}, 0}, 109 },
      {{{OSUTF8("alphabetical-index-mark-start"), 29}, 0}, 110 },
      {{{OSUTF8("alphabetical-index-mark-end"), 27}, 0}, 111 },
      {{{OSUTF8("alphabetical-index-mark"), 23}, 0}, 112 },
      {{{OSUTF8("bibliography-mark"), 17}, 0}, 113 },
      {{{OSUTF8("header"), 6}, 0}, 114 },
      {{{OSUTF8("footer"), 6}, 0}, 115 },
      {{{OSUTF8("date-time"), 9}, 0}, 116 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 124, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* s */
      pvalue->u.s = rtxMemAllocType (pctxt, Odf_S);

      if (pvalue->u.s == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_S (pvalue->u.s);

      stat = XmlDec_Odf_S (pctxt, pvalue->u.s);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* tab */
      pvalue->u.tab = rtxMemAllocType (pctxt, Odf_Tab);

      if (pvalue->u.tab == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Tab (pvalue->u.tab);

      stat = XmlDec_Odf_Tab (pctxt, pvalue->u.tab);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* line-break */
      pvalue->u.line_break = rtxMemAllocType (pctxt, Odf_Line_break);

      if (pvalue->u.line_break == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Line_break (pvalue->u.line_break);

      stat = XmlDec_Odf_Line_break (pctxt, pvalue->u.line_break);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* span */
      pvalue->u.span = rtxMemAllocType (pctxt, Odf_Span);

      if (pvalue->u.span == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Span ((Odf_Span*)pvalue->u.span);

      stat = XmlDec_Odf_Span (pctxt, pvalue->u.span);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* a */
      pvalue->u.a = rtxMemAllocType (pctxt, Odf_A);

      if (pvalue->u.a == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_A (pvalue->u.a);

      stat = XmlDec_Odf_A (pctxt, pvalue->u.a);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* bookmark */
      pvalue->u.bookmark = rtxMemAllocType (pctxt, Odf_Bookmark);

      if (pvalue->u.bookmark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bookmark (pvalue->u.bookmark);

      stat = XmlDec_Odf_Bookmark (pctxt, pvalue->u.bookmark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* bookmark-start */
      pvalue->u.bookmark_start = rtxMemAllocType (pctxt, Odf_Bookmark_start);

      if (pvalue->u.bookmark_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bookmark_start (pvalue->u.bookmark_start);

      stat = XmlDec_Odf_Bookmark_start (pctxt, pvalue->u.bookmark_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* bookmark-end */
      pvalue->u.bookmark_end = rtxMemAllocType (pctxt, Odf_Bookmark_end);

      if (pvalue->u.bookmark_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bookmark_end (pvalue->u.bookmark_end);

      stat = XmlDec_Odf_Bookmark_end (pctxt, pvalue->u.bookmark_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* reference-mark */
      pvalue->u.reference_mark = rtxMemAllocType (pctxt, Odf_Reference_mark);

      if (pvalue->u.reference_mark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Reference_mark (pvalue->u.reference_mark);

      stat = XmlDec_Odf_Reference_mark (pctxt, pvalue->u.reference_mark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* reference-mark-start */
      pvalue->u.reference_mark_start
          = rtxMemAllocType (pctxt, Odf_Reference_mark_start);

      if (pvalue->u.reference_mark_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Reference_mark_start (pvalue->u.reference_mark_start);

      stat = XmlDec_Odf_Reference_mark_start (pctxt, pvalue->
         u.reference_mark_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* reference-mark-end */
      pvalue->u.reference_mark_end
          = rtxMemAllocType (pctxt, Odf_Reference_mark_end);

      if (pvalue->u.reference_mark_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Reference_mark_end (pvalue->u.reference_mark_end);

      stat = XmlDec_Odf_Reference_mark_end (pctxt, pvalue->u.reference_mark_end
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* note */
      pvalue->u.note = rtxMemAllocType (pctxt, Odf_Note);

      if (pvalue->u.note == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Note (pvalue->u.note);

      stat = XmlDec_Odf_Note (pctxt, pvalue->u.note);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* ruby */
      pvalue->u.ruby = rtxMemAllocType (pctxt, Odf_Ruby);

      if (pvalue->u.ruby == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Ruby (pvalue->u.ruby);

      stat = XmlDec_Odf_Ruby (pctxt, pvalue->u.ruby);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* annotation */
      pvalue->u.annotation = rtxMemAllocType (pctxt, Ns13_Annotation);

      if (pvalue->u.annotation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns13_Annotation ((Ns13_Annotation*)pvalue->u.annotation);

      stat = XmlDec_Ns13_Annotation (pctxt, pvalue->u.annotation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* change */
      pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

      if (pvalue->u.change == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change (pvalue->u.change);

      stat = XmlDec_Odf_Change (pctxt, pvalue->u.change);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* change-start */
      pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

      if (pvalue->u.change_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_start (pvalue->u.change_start);

      stat = XmlDec_Odf_Change_start (pctxt, pvalue->u.change_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* change-end */
      pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

      if (pvalue->u.change_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_end (pvalue->u.change_end);

      stat = XmlDec_Odf_Change_end (pctxt, pvalue->u.change_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 17: { /* rect */
      pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

      if (pvalue->u.rect == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);

      stat = XmlDec_Ns3_Rect (pctxt, pvalue->u.rect);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 18: { /* line */
      pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

      if (pvalue->u.line == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);

      stat = XmlDec_Ns3_Line (pctxt, pvalue->u.line);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 19: { /* polyline */
      pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

      if (pvalue->u.polyline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);

      stat = XmlDec_Ns3_Polyline (pctxt, pvalue->u.polyline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 20: { /* polygon */
      pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

      if (pvalue->u.polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);

      stat = XmlDec_Ns3_Polygon (pctxt, pvalue->u.polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 21: { /* regular-polygon */
      pvalue->u.regular_polygon
          = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

      if (pvalue->u.regular_polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->
         u.regular_polygon);

      stat = XmlDec_Ns3_Regular_polygon (pctxt, pvalue->u.regular_polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 22: { /* path */
      pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

      if (pvalue->u.path == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);

      stat = XmlDec_Ns3_Path (pctxt, pvalue->u.path);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 23: { /* circle */
      pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

      if (pvalue->u.circle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);

      stat = XmlDec_Ns3_Circle (pctxt, pvalue->u.circle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 24: { /* ellipse */
      pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

      if (pvalue->u.ellipse == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);

      stat = XmlDec_Ns3_Ellipse (pctxt, pvalue->u.ellipse);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 25: { /* g */
      pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

      if (pvalue->u.g == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);

      stat = XmlDec_Ns3_G (pctxt, pvalue->u.g);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 26: { /* page-thumbnail */
      pvalue->u.page_thumbnail = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

      if (pvalue->u.page_thumbnail == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->
         u.page_thumbnail);

      stat = XmlDec_Ns3_Page_thumbnail (pctxt, pvalue->u.page_thumbnail);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 27: { /* frame */
      pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

      if (pvalue->u.frame == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);

      stat = XmlDec_Ns3_Frame (pctxt, pvalue->u.frame);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 28: { /* measure */
      pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

      if (pvalue->u.measure == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);

      stat = XmlDec_Ns3_Measure (pctxt, pvalue->u.measure);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 29: { /* caption */
      pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

      if (pvalue->u.caption == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);

      stat = XmlDec_Ns3_Caption (pctxt, pvalue->u.caption);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 30: { /* connector */
      pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

      if (pvalue->u.connector == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);

      stat = XmlDec_Ns3_Connector (pctxt, pvalue->u.connector);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 31: { /* control */
      pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

      if (pvalue->u.control == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);

      stat = XmlDec_Ns3_Control (pctxt, pvalue->u.control);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 32: { /* scene */
      pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

      if (pvalue->u.scene == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);

      stat = XmlDec_Ns7_Scene (pctxt, pvalue->u.scene);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 33: { /* custom-shape */
      pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

      if (pvalue->u.custom_shape == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);

      stat = XmlDec_Ns3_Custom_shape (pctxt, pvalue->u.custom_shape);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 34: { /* a */
      pvalue->u.a_1 = rtxMemAllocType (pctxt, Ns3_A);

      if (pvalue->u.a_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_A ((Ns3_A*)pvalue->u.a_1);

      stat = XmlDec_Ns3_A (pctxt, pvalue->u.a_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 35: { /* date */
      pvalue->u.date = rtxMemAllocType (pctxt, Odf_Date);

      if (pvalue->u.date == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Date (pvalue->u.date);

      stat = XmlDec_Odf_Date (pctxt, pvalue->u.date);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 36: { /* time */
      pvalue->u.time_ = rtxMemAllocType (pctxt, Odf_Time);

      if (pvalue->u.time_ == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Time (pvalue->u.time_);

      stat = XmlDec_Odf_Time (pctxt, pvalue->u.time_);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 37: { /* page-number */
      pvalue->u.page_number = rtxMemAllocType (pctxt, Odf_Page_number);

      if (pvalue->u.page_number == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Page_number (pvalue->u.page_number);

      stat = XmlDec_Odf_Page_number (pctxt, pvalue->u.page_number);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 38: { /* page-continuation */
      pvalue->u.page_continuation
          = rtxMemAllocType (pctxt, Odf_Page_continuation);

      if (pvalue->u.page_continuation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Page_continuation (pvalue->u.page_continuation);

      stat = XmlDec_Odf_Page_continuation (pctxt, pvalue->u.page_continuation
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 39: { /* sender-firstname */
      pvalue->u.sender_firstname
          = rtxMemAllocType (pctxt, Odf_Sender_firstname);

      if (pvalue->u.sender_firstname == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_firstname (pvalue->u.sender_firstname);

      stat = XmlDec_Odf_Sender_firstname (pctxt, pvalue->u.sender_firstname);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 40: { /* sender-lastname */
      pvalue->u.sender_lastname
          = rtxMemAllocType (pctxt, Odf_Sender_lastname);

      if (pvalue->u.sender_lastname == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_lastname (pvalue->u.sender_lastname);

      stat = XmlDec_Odf_Sender_lastname (pctxt, pvalue->u.sender_lastname);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 41: { /* sender-initials */
      pvalue->u.sender_initials
          = rtxMemAllocType (pctxt, Odf_Sender_initials);

      if (pvalue->u.sender_initials == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_initials (pvalue->u.sender_initials);

      stat = XmlDec_Odf_Sender_initials (pctxt, pvalue->u.sender_initials);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 42: { /* sender-title */
      pvalue->u.sender_title = rtxMemAllocType (pctxt, Odf_Sender_title);

      if (pvalue->u.sender_title == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_title (pvalue->u.sender_title);

      stat = XmlDec_Odf_Sender_title (pctxt, pvalue->u.sender_title);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 43: { /* sender-position */
      pvalue->u.sender_position
          = rtxMemAllocType (pctxt, Odf_Sender_position);

      if (pvalue->u.sender_position == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_position (pvalue->u.sender_position);

      stat = XmlDec_Odf_Sender_position (pctxt, pvalue->u.sender_position);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 44: { /* sender-email */
      pvalue->u.sender_email = rtxMemAllocType (pctxt, Odf_Sender_email);

      if (pvalue->u.sender_email == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_email (pvalue->u.sender_email);

      stat = XmlDec_Odf_Sender_email (pctxt, pvalue->u.sender_email);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 45: { /* sender-phone-private */
      pvalue->u.sender_phone_private
          = rtxMemAllocType (pctxt, Odf_Sender_phone_private);

      if (pvalue->u.sender_phone_private == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_phone_private (pvalue->u.sender_phone_private);

      stat = XmlDec_Odf_Sender_phone_private (pctxt, pvalue->
         u.sender_phone_private);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 46: { /* sender-fax */
      pvalue->u.sender_fax = rtxMemAllocType (pctxt, Odf_Sender_fax);

      if (pvalue->u.sender_fax == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_fax (pvalue->u.sender_fax);

      stat = XmlDec_Odf_Sender_fax (pctxt, pvalue->u.sender_fax);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 47: { /* sender-company */
      pvalue->u.sender_company = rtxMemAllocType (pctxt, Odf_Sender_company);

      if (pvalue->u.sender_company == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_company (pvalue->u.sender_company);

      stat = XmlDec_Odf_Sender_company (pctxt, pvalue->u.sender_company);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 48: { /* sender-phone-work */
      pvalue->u.sender_phone_work
          = rtxMemAllocType (pctxt, Odf_Sender_phone_work);

      if (pvalue->u.sender_phone_work == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_phone_work (pvalue->u.sender_phone_work);

      stat = XmlDec_Odf_Sender_phone_work (pctxt, pvalue->u.sender_phone_work
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 49: { /* sender-street */
      pvalue->u.sender_street = rtxMemAllocType (pctxt, Odf_Sender_street);

      if (pvalue->u.sender_street == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_street (pvalue->u.sender_street);

      stat = XmlDec_Odf_Sender_street (pctxt, pvalue->u.sender_street);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 50: { /* sender-city */
      pvalue->u.sender_city = rtxMemAllocType (pctxt, Odf_Sender_city);

      if (pvalue->u.sender_city == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_city (pvalue->u.sender_city);

      stat = XmlDec_Odf_Sender_city (pctxt, pvalue->u.sender_city);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 51: { /* sender-postal-code */
      pvalue->u.sender_postal_code
          = rtxMemAllocType (pctxt, Odf_Sender_postal_code);

      if (pvalue->u.sender_postal_code == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_postal_code (pvalue->u.sender_postal_code);

      stat = XmlDec_Odf_Sender_postal_code (pctxt, pvalue->u.sender_postal_code
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 52: { /* sender-country */
      pvalue->u.sender_country = rtxMemAllocType (pctxt, Odf_Sender_country);

      if (pvalue->u.sender_country == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_country (pvalue->u.sender_country);

      stat = XmlDec_Odf_Sender_country (pctxt, pvalue->u.sender_country);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 53: { /* sender-state-or-province */
      pvalue->u.sender_state_or_province
          = rtxMemAllocType (pctxt, Odf_Sender_state_or_province);

      if (pvalue->u.sender_state_or_province == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_state_or_province (pvalue->u.sender_state_or_province
         );

      stat = XmlDec_Odf_Sender_state_or_province (pctxt, pvalue->
         u.sender_state_or_province);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 54: { /* author-name */
      pvalue->u.author_name = rtxMemAllocType (pctxt, Odf_Author_name);

      if (pvalue->u.author_name == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Author_name (pvalue->u.author_name);

      stat = XmlDec_Odf_Author_name (pctxt, pvalue->u.author_name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 55: { /* author-initials */
      pvalue->u.author_initials
          = rtxMemAllocType (pctxt, Odf_Author_initials);

      if (pvalue->u.author_initials == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Author_initials (pvalue->u.author_initials);

      stat = XmlDec_Odf_Author_initials (pctxt, pvalue->u.author_initials);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 56: { /* chapter */
      pvalue->u.chapter = rtxMemAllocType (pctxt, Odf_Chapter);

      if (pvalue->u.chapter == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Chapter (pvalue->u.chapter);

      stat = XmlDec_Odf_Chapter (pctxt, pvalue->u.chapter);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 57: { /* file-name */
      pvalue->u.file_name = rtxMemAllocType (pctxt, Odf_File_name);

      if (pvalue->u.file_name == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_File_name (pvalue->u.file_name);

      stat = XmlDec_Odf_File_name (pctxt, pvalue->u.file_name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 58: { /* template-name */
      pvalue->u.template_name = rtxMemAllocType (pctxt, Odf_Template_name);

      if (pvalue->u.template_name == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Template_name (pvalue->u.template_name);

      stat = XmlDec_Odf_Template_name (pctxt, pvalue->u.template_name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 59: { /* sheet-name */
      stat = XmlDec_Odf_Sheet_name (pctxt, &pvalue->u.sheet_name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 60: { /* variable-set */
      pvalue->u.variable_set = rtxMemAllocType (pctxt, Odf_Variable_set);

      if (pvalue->u.variable_set == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Variable_set (pvalue->u.variable_set);

      stat = XmlDec_Odf_Variable_set (pctxt, pvalue->u.variable_set);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 61: { /* variable-get */
      pvalue->u.variable_get = rtxMemAllocType (pctxt, Odf_Variable_get);

      if (pvalue->u.variable_get == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Variable_get (pvalue->u.variable_get);

      stat = XmlDec_Odf_Variable_get (pctxt, pvalue->u.variable_get);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 62: { /* variable-input */
      pvalue->u.variable_input = rtxMemAllocType (pctxt, Odf_Variable_input);

      if (pvalue->u.variable_input == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Variable_input (pvalue->u.variable_input);

      stat = XmlDec_Odf_Variable_input (pctxt, pvalue->u.variable_input);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 63: { /* user-field-get */
      pvalue->u.user_field_get = rtxMemAllocType (pctxt, Odf_User_field_get);

      if (pvalue->u.user_field_get == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_field_get (pvalue->u.user_field_get);

      stat = XmlDec_Odf_User_field_get (pctxt, pvalue->u.user_field_get);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 64: { /* user-field-input */
      pvalue->u.user_field_input
          = rtxMemAllocType (pctxt, Odf_User_field_input);

      if (pvalue->u.user_field_input == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_field_input (pvalue->u.user_field_input);

      stat = XmlDec_Odf_User_field_input (pctxt, pvalue->u.user_field_input);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 65: { /* sequence */
      pvalue->u.sequence = rtxMemAllocType (pctxt, Odf_Sequence);

      if (pvalue->u.sequence == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sequence (pvalue->u.sequence);

      stat = XmlDec_Odf_Sequence (pctxt, pvalue->u.sequence);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 66: { /* expression */
      pvalue->u.expression = rtxMemAllocType (pctxt, Odf_Expression);

      if (pvalue->u.expression == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Expression (pvalue->u.expression);

      stat = XmlDec_Odf_Expression (pctxt, pvalue->u.expression);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 67: { /* text-input */
      pvalue->u.text_input = rtxMemAllocType (pctxt, Odf_Text_input);

      if (pvalue->u.text_input == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Text_input (pvalue->u.text_input);

      stat = XmlDec_Odf_Text_input (pctxt, pvalue->u.text_input);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 68: { /* initial-creator */
      pvalue->u.initial_creator
          = rtxMemAllocType (pctxt, Odf_Initial_creator);

      if (pvalue->u.initial_creator == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Initial_creator (pvalue->u.initial_creator);

      stat = XmlDec_Odf_Initial_creator (pctxt, pvalue->u.initial_creator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 69: { /* creation-date */
      pvalue->u.creation_date = rtxMemAllocType (pctxt, Odf_Creation_date);

      if (pvalue->u.creation_date == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Creation_date (pvalue->u.creation_date);

      stat = XmlDec_Odf_Creation_date (pctxt, pvalue->u.creation_date);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 70: { /* creation-time */
      pvalue->u.creation_time = rtxMemAllocType (pctxt, Odf_Creation_time);

      if (pvalue->u.creation_time == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Creation_time (pvalue->u.creation_time);

      stat = XmlDec_Odf_Creation_time (pctxt, pvalue->u.creation_time);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 71: { /* description */
      pvalue->u.description = rtxMemAllocType (pctxt, Odf_Description);

      if (pvalue->u.description == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Description (pvalue->u.description);

      stat = XmlDec_Odf_Description (pctxt, pvalue->u.description);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 72: { /* user-defined */
      pvalue->u.user_defined = rtxMemAllocType (pctxt, Odf_User_defined);

      if (pvalue->u.user_defined == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_defined (pvalue->u.user_defined);

      stat = XmlDec_Odf_User_defined (pctxt, pvalue->u.user_defined);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 73: { /* print-time */
      pvalue->u.print_time = rtxMemAllocType (pctxt, Odf_Print_time);

      if (pvalue->u.print_time == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Print_time (pvalue->u.print_time);

      stat = XmlDec_Odf_Print_time (pctxt, pvalue->u.print_time);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 74: { /* print-date */
      pvalue->u.print_date = rtxMemAllocType (pctxt, Odf_Print_date);

      if (pvalue->u.print_date == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Print_date (pvalue->u.print_date);

      stat = XmlDec_Odf_Print_date (pctxt, pvalue->u.print_date);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 75: { /* printed-by */
      pvalue->u.printed_by = rtxMemAllocType (pctxt, Odf_Printed_by);

      if (pvalue->u.printed_by == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Printed_by (pvalue->u.printed_by);

      stat = XmlDec_Odf_Printed_by (pctxt, pvalue->u.printed_by);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 76: { /* title */
      pvalue->u.title = rtxMemAllocType (pctxt, Odf_Title);

      if (pvalue->u.title == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Title (pvalue->u.title);

      stat = XmlDec_Odf_Title (pctxt, pvalue->u.title);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 77: { /* subject */
      pvalue->u.subject = rtxMemAllocType (pctxt, Odf_Subject);

      if (pvalue->u.subject == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Subject (pvalue->u.subject);

      stat = XmlDec_Odf_Subject (pctxt, pvalue->u.subject);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 78: { /* keywords */
      pvalue->u.keywords = rtxMemAllocType (pctxt, Odf_Keywords);

      if (pvalue->u.keywords == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Keywords (pvalue->u.keywords);

      stat = XmlDec_Odf_Keywords (pctxt, pvalue->u.keywords);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 79: { /* editing-cycles */
      pvalue->u.editing_cycles = rtxMemAllocType (pctxt, Odf_Editing_cycles);

      if (pvalue->u.editing_cycles == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Editing_cycles (pvalue->u.editing_cycles);

      stat = XmlDec_Odf_Editing_cycles (pctxt, pvalue->u.editing_cycles);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 80: { /* editing-duration */
      pvalue->u.editing_duration
          = rtxMemAllocType (pctxt, Odf_Editing_duration);

      if (pvalue->u.editing_duration == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Editing_duration (pvalue->u.editing_duration);

      stat = XmlDec_Odf_Editing_duration (pctxt, pvalue->u.editing_duration);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 81: { /* modification-time */
      pvalue->u.modification_time
          = rtxMemAllocType (pctxt, Odf_Modification_time);

      if (pvalue->u.modification_time == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Modification_time (pvalue->u.modification_time);

      stat = XmlDec_Odf_Modification_time (pctxt, pvalue->u.modification_time
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 82: { /* modification-date */
      pvalue->u.modification_date
          = rtxMemAllocType (pctxt, Odf_Modification_date);

      if (pvalue->u.modification_date == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Modification_date (pvalue->u.modification_date);

      stat = XmlDec_Odf_Modification_date (pctxt, pvalue->u.modification_date
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 83: { /* creator */
      pvalue->u.creator = rtxMemAllocType (pctxt, Odf_Creator);

      if (pvalue->u.creator == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Creator (pvalue->u.creator);

      stat = XmlDec_Odf_Creator (pctxt, pvalue->u.creator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 84: { /*  */
      pvalue->u.element271 = rtxMemAllocType (pctxt, Odf_Element271_group);

      if (pvalue->u.element271 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Element271_group (pvalue->u.element271);

      stat = XmlDec_Odf_Element271_group (pctxt, pvalue->u.element271);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 85: { /* database-display */
      pvalue->u.database_display
          = rtxMemAllocType (pctxt, Odf_Database_display);

      if (pvalue->u.database_display == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Database_display (pvalue->u.database_display);

      stat = XmlDec_Odf_Database_display (pctxt, pvalue->u.database_display);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 86: { /* database-next */
      pvalue->u.database_next = rtxMemAllocType (pctxt, Odf_Database_next);

      if (pvalue->u.database_next == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Database_next (pvalue->u.database_next);

      stat = XmlDec_Odf_Database_next (pctxt, pvalue->u.database_next);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 87: { /* database-row-select */
      pvalue->u.database_row_select
          = rtxMemAllocType (pctxt, Odf_Database_row_select);

      if (pvalue->u.database_row_select == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Database_row_select (pvalue->u.database_row_select);

      stat = XmlDec_Odf_Database_row_select (pctxt, pvalue->
         u.database_row_select);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 88: { /* database-row-number */
      pvalue->u.database_row_number
          = rtxMemAllocType (pctxt, Odf_Database_row_number);

      if (pvalue->u.database_row_number == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Database_row_number (pvalue->u.database_row_number);

      stat = XmlDec_Odf_Database_row_number (pctxt, pvalue->
         u.database_row_number);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 89: { /* database-name */
      pvalue->u.database_name = rtxMemAllocType (pctxt, Odf_Database_name);

      if (pvalue->u.database_name == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Database_name (pvalue->u.database_name);

      stat = XmlDec_Odf_Database_name (pctxt, pvalue->u.database_name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 90: { /* page-variable-set */
      pvalue->u.page_variable_set
          = rtxMemAllocType (pctxt, Odf_Page_variable_set);

      if (pvalue->u.page_variable_set == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Page_variable_set (pvalue->u.page_variable_set);

      stat = XmlDec_Odf_Page_variable_set (pctxt, pvalue->u.page_variable_set
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 91: { /* page-variable-get */
      pvalue->u.page_variable_get
          = rtxMemAllocType (pctxt, Odf_Page_variable_get);

      if (pvalue->u.page_variable_get == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Page_variable_get (pvalue->u.page_variable_get);

      stat = XmlDec_Odf_Page_variable_get (pctxt, pvalue->u.page_variable_get
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 92: { /* placeholder */
      pvalue->u.placeholder = rtxMemAllocType (pctxt, Odf_Placeholder);

      if (pvalue->u.placeholder == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Placeholder (pvalue->u.placeholder);

      stat = XmlDec_Odf_Placeholder (pctxt, pvalue->u.placeholder);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 93: { /* conditional-text */
      pvalue->u.conditional_text
          = rtxMemAllocType (pctxt, Odf_Conditional_text);

      if (pvalue->u.conditional_text == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Conditional_text (pvalue->u.conditional_text);

      stat = XmlDec_Odf_Conditional_text (pctxt, pvalue->u.conditional_text);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 94: { /* hidden-text */
      pvalue->u.hidden_text = rtxMemAllocType (pctxt, Odf_Hidden_text);

      if (pvalue->u.hidden_text == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Hidden_text (pvalue->u.hidden_text);

      stat = XmlDec_Odf_Hidden_text (pctxt, pvalue->u.hidden_text);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 95: { /*  */
      pvalue->u.element282 = rtxMemAllocType (pctxt, Odf_Element282_group);

      if (pvalue->u.element282 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Element282_group (pvalue->u.element282);

      stat = XmlDec_Odf_Element282_group (pctxt, pvalue->u.element282);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 96: { /* note-ref */
      pvalue->u.note_ref = rtxMemAllocType (pctxt, Odf_Note_ref);

      if (pvalue->u.note_ref == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Note_ref (pvalue->u.note_ref);

      stat = XmlDec_Odf_Note_ref (pctxt, pvalue->u.note_ref);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 97: { /* sequence-ref */
      pvalue->u.sequence_ref = rtxMemAllocType (pctxt, Odf_Sequence_ref);

      if (pvalue->u.sequence_ref == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sequence_ref (pvalue->u.sequence_ref);

      stat = XmlDec_Odf_Sequence_ref (pctxt, pvalue->u.sequence_ref);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 98: { /* script */
      pvalue->u.script = rtxMemAllocType (pctxt, Odf_Script);

      if (pvalue->u.script == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Script (pvalue->u.script);

      stat = XmlDec_Odf_Script (pctxt, pvalue->u.script);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 99: { /* execute-macro */
      pvalue->u.execute_macro = rtxMemAllocType (pctxt, Odf_Execute_macro);

      if (pvalue->u.execute_macro == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Execute_macro (pvalue->u.execute_macro);

      stat = XmlDec_Odf_Execute_macro (pctxt, pvalue->u.execute_macro);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 100: { /* hidden-paragraph */
      pvalue->u.hidden_paragraph
          = rtxMemAllocType (pctxt, Odf_Hidden_paragraph);

      if (pvalue->u.hidden_paragraph == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Hidden_paragraph (pvalue->u.hidden_paragraph);

      stat = XmlDec_Odf_Hidden_paragraph (pctxt, pvalue->u.hidden_paragraph);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 101: { /* dde-connection */
      pvalue->u.dde_connection = rtxMemAllocType (pctxt, Odf_Dde_connection);

      if (pvalue->u.dde_connection == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Dde_connection (pvalue->u.dde_connection);

      stat = XmlDec_Odf_Dde_connection (pctxt, pvalue->u.dde_connection);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 102: { /* measure */
      pvalue->u.measure_1 = rtxMemAllocType (pctxt, Odf_Measure);

      if (pvalue->u.measure_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Measure (pvalue->u.measure_1);

      stat = XmlDec_Odf_Measure (pctxt, pvalue->u.measure_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 103: { /* table-formula */
      pvalue->u.table_formula = rtxMemAllocType (pctxt, Odf_Table_formula);

      if (pvalue->u.table_formula == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_formula (pvalue->u.table_formula);

      stat = XmlDec_Odf_Table_formula (pctxt, pvalue->u.table_formula);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 104: { /* toc-mark-start */
      pvalue->u.toc_mark_start = rtxMemAllocType (pctxt, Odf_Toc_mark_start);

      if (pvalue->u.toc_mark_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Toc_mark_start (pvalue->u.toc_mark_start);

      stat = XmlDec_Odf_Toc_mark_start (pctxt, pvalue->u.toc_mark_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 105: { /* toc-mark-end */
      pvalue->u.toc_mark_end = rtxMemAllocType (pctxt, Odf_Toc_mark_end);

      if (pvalue->u.toc_mark_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Toc_mark_end (pvalue->u.toc_mark_end);

      stat = XmlDec_Odf_Toc_mark_end (pctxt, pvalue->u.toc_mark_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 106: { /* toc-mark */
      pvalue->u.toc_mark = rtxMemAllocType (pctxt, Odf_Toc_mark);

      if (pvalue->u.toc_mark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Toc_mark (pvalue->u.toc_mark);

      stat = XmlDec_Odf_Toc_mark (pctxt, pvalue->u.toc_mark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 107: { /* user-index-mark-start */
      pvalue->u.user_index_mark_start
          = rtxMemAllocType (pctxt, Odf_User_index_mark_start);

      if (pvalue->u.user_index_mark_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index_mark_start (pvalue->u.user_index_mark_start);

      stat = XmlDec_Odf_User_index_mark_start (pctxt, pvalue->
         u.user_index_mark_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 108: { /* user-index-mark-end */
      pvalue->u.user_index_mark_end
          = rtxMemAllocType (pctxt, Odf_User_index_mark_end);

      if (pvalue->u.user_index_mark_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index_mark_end (pvalue->u.user_index_mark_end);

      stat = XmlDec_Odf_User_index_mark_end (pctxt, pvalue->
         u.user_index_mark_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 109: { /* user-index-mark */
      pvalue->u.user_index_mark
          = rtxMemAllocType (pctxt, Odf_User_index_mark);

      if (pvalue->u.user_index_mark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index_mark (pvalue->u.user_index_mark);

      stat = XmlDec_Odf_User_index_mark (pctxt, pvalue->u.user_index_mark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 110: { /* alphabetical-index-mark-start */
      pvalue->u.alphabetical_index_mark_start
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark_start);

      if (pvalue->u.alphabetical_index_mark_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index_mark_start (pvalue->
         u.alphabetical_index_mark_start);

      stat = XmlDec_Odf_Alphabetical_index_mark_start (pctxt, pvalue->
         u.alphabetical_index_mark_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 111: { /* alphabetical-index-mark-end */
      pvalue->u.alphabetical_index_mark_end
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark_end);

      if (pvalue->u.alphabetical_index_mark_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index_mark_end (pvalue->
         u.alphabetical_index_mark_end);

      stat = XmlDec_Odf_Alphabetical_index_mark_end (pctxt, pvalue->
         u.alphabetical_index_mark_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 112: { /* alphabetical-index-mark */
      pvalue->u.alphabetical_index_mark
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark);

      if (pvalue->u.alphabetical_index_mark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index_mark (pvalue->u.alphabetical_index_mark
         );

      stat = XmlDec_Odf_Alphabetical_index_mark (pctxt, pvalue->
         u.alphabetical_index_mark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 113: { /* bibliography-mark */
      pvalue->u.bibliography_mark
          = rtxMemAllocType (pctxt, Odf_Bibliography_mark);

      if (pvalue->u.bibliography_mark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bibliography_mark (pvalue->u.bibliography_mark);

      stat = XmlDec_Odf_Bibliography_mark (pctxt, pvalue->u.bibliography_mark
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 114: { /* header */
      pvalue->u.header = rtxMemAllocType (pctxt, Ns10_Header);

      if (pvalue->u.header == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns10_Header ((Ns10_Header*)pvalue->u.header);

      stat = XmlDec_Ns10_Header (pctxt, pvalue->u.header);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 115: { /* footer */
      pvalue->u.footer = rtxMemAllocType (pctxt, Ns10_Footer);

      if (pvalue->u.footer == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns10_Footer ((Ns10_Footer*)pvalue->u.footer);

      stat = XmlDec_Ns10_Footer (pctxt, pvalue->u.footer);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 116: { /* date-time */
      pvalue->u.date_time = rtxMemAllocType (pctxt, Ns10_Date_time);

      if (pvalue->u.date_time == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns10_Date_time ((Ns10_Date_time*)pvalue->u.date_time);

      stat = XmlDec_Ns10_Date_time (pctxt, pvalue->u.date_time);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Span                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Span (OSCTXT* pctxt, Odf_Span *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode class_names */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->class_names);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->class_names, pnode);
               }

            }
            if (stat == 0) {
               pvalue->m.class_namesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Span_style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Span_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Span_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_Span_element (pdata2);

                  stat = asn1D_Odf_Span_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Span (OSCTXT* pctxt, Odf_Span* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* class-names */
            rtxDListInit (&pvalue->class_names);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_namesPresent = TRUE;
            break;

         case 1: /* style-name */
            stat = XmlDec_Odf_Span_style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Span");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Span");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("s"), 1}, 0}, 0 },
      {{{OSUTF8("tab"), 3}, 0}, 0 },
      {{{OSUTF8("line-break"), 10}, 0}, 0 },
      {{{OSUTF8("span"), 4}, 0}, 0 },
      {{{OSUTF8("a"), 1}, 0}, 0 },
      {{{OSUTF8("bookmark"), 8}, 0}, 0 },
      {{{OSUTF8("bookmark-start"), 14}, 0}, 0 },
      {{{OSUTF8("bookmark-end"), 12}, 0}, 0 },
      {{{OSUTF8("reference-mark"), 14}, 0}, 0 },
      {{{OSUTF8("reference-mark-start"), 20}, 0}, 0 },
      {{{OSUTF8("reference-mark-end"), 18}, 0}, 0 },
      {{{OSUTF8("note"), 4}, 0}, 0 },
      {{{OSUTF8("ruby"), 4}, 0}, 0 },
      {{{OSUTF8("annotation"), 10}, 0}, 0 },
      {{{OSUTF8("change"), 6}, 0}, 0 },
      {{{OSUTF8("change-start"), 12}, 0}, 0 },
      {{{OSUTF8("change-end"), 10}, 0}, 0 },
      {{{OSUTF8("rect"), 4}, 0}, 0 },
      {{{OSUTF8("line"), 4}, 0}, 0 },
      {{{OSUTF8("polyline"), 8}, 0}, 0 },
      {{{OSUTF8("polygon"), 7}, 0}, 0 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 0 },
      {{{OSUTF8("path"), 4}, 0}, 0 },
      {{{OSUTF8("circle"), 6}, 0}, 0 },
      {{{OSUTF8("ellipse"), 7}, 0}, 0 },
      {{{OSUTF8("g"), 1}, 0}, 0 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 0 },
      {{{OSUTF8("frame"), 5}, 0}, 0 },
      {{{OSUTF8("measure"), 7}, 0}, 0 },
      {{{OSUTF8("caption"), 7}, 0}, 0 },
      {{{OSUTF8("connector"), 9}, 0}, 0 },
      {{{OSUTF8("control"), 7}, 0}, 0 },
      {{{OSUTF8("scene"), 5}, 0}, 0 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 0 },
      {{{OSUTF8("date"), 4}, 0}, 0 },
      {{{OSUTF8("time"), 4}, 0}, 0 },
      {{{OSUTF8("page-number"), 11}, 0}, 0 },
      {{{OSUTF8("page-continuation"), 17}, 0}, 0 },
      {{{OSUTF8("sender-firstname"), 16}, 0}, 0 },
      {{{OSUTF8("sender-lastname"), 15}, 0}, 0 },
      {{{OSUTF8("sender-initials"), 15}, 0}, 0 },
      {{{OSUTF8("sender-title"), 12}, 0}, 0 },
      {{{OSUTF8("sender-position"), 15}, 0}, 0 },
      {{{OSUTF8("sender-email"), 12}, 0}, 0 },
      {{{OSUTF8("sender-phone-private"), 20}, 0}, 0 },
      {{{OSUTF8("sender-fax"), 10}, 0}, 0 },
      {{{OSUTF8("sender-company"), 14}, 0}, 0 },
      {{{OSUTF8("sender-phone-work"), 17}, 0}, 0 },
      {{{OSUTF8("sender-street"), 13}, 0}, 0 },
      {{{OSUTF8("sender-city"), 11}, 0}, 0 },
      {{{OSUTF8("sender-postal-code"), 18}, 0}, 0 },
      {{{OSUTF8("sender-country"), 14}, 0}, 0 },
      {{{OSUTF8("sender-state-or-province"), 24}, 0}, 0 },
      {{{OSUTF8("author-name"), 11}, 0}, 0 },
      {{{OSUTF8("author-initials"), 15}, 0}, 0 },
      {{{OSUTF8("chapter"), 7}, 0}, 0 },
      {{{OSUTF8("file-name"), 9}, 0}, 0 },
      {{{OSUTF8("template-name"), 13}, 0}, 0 },
      {{{OSUTF8("sheet-name"), 10}, 0}, 0 },
      {{{OSUTF8("variable-set"), 12}, 0}, 0 },
      {{{OSUTF8("variable-get"), 12}, 0}, 0 },
      {{{OSUTF8("variable-input"), 14}, 0}, 0 },
      {{{OSUTF8("user-field-get"), 14}, 0}, 0 },
      {{{OSUTF8("user-field-input"), 16}, 0}, 0 },
      {{{OSUTF8("sequence"), 8}, 0}, 0 },
      {{{OSUTF8("expression"), 10}, 0}, 0 },
      {{{OSUTF8("text-input"), 10}, 0}, 0 },
      {{{OSUTF8("initial-creator"), 15}, 0}, 0 },
      {{{OSUTF8("creation-date"), 13}, 0}, 0 },
      {{{OSUTF8("creation-time"), 13}, 0}, 0 },
      {{{OSUTF8("description"), 11}, 0}, 0 },
      {{{OSUTF8("user-defined"), 12}, 0}, 0 },
      {{{OSUTF8("print-time"), 10}, 0}, 0 },
      {{{OSUTF8("print-date"), 10}, 0}, 0 },
      {{{OSUTF8("printed-by"), 10}, 0}, 0 },
      {{{OSUTF8("title"), 5}, 0}, 0 },
      {{{OSUTF8("subject"), 7}, 0}, 0 },
      {{{OSUTF8("keywords"), 8}, 0}, 0 },
      {{{OSUTF8("editing-cycles"), 14}, 0}, 0 },
      {{{OSUTF8("editing-duration"), 16}, 0}, 0 },
      {{{OSUTF8("modification-time"), 17}, 0}, 0 },
      {{{OSUTF8("modification-date"), 17}, 0}, 0 },
      {{{OSUTF8("creator"), 7}, 0}, 0 },
      {{{OSUTF8("page-count"), 10}, 0}, 0 },
      {{{OSUTF8("paragraph-count"), 15}, 0}, 0 },
      {{{OSUTF8("word-count"), 10}, 0}, 0 },
      {{{OSUTF8("character-count"), 15}, 0}, 0 },
      {{{OSUTF8("table-count"), 11}, 0}, 0 },
      {{{OSUTF8("image-count"), 11}, 0}, 0 },
      {{{OSUTF8("object-count"), 12}, 0}, 0 },
      {{{OSUTF8("database-display"), 16}, 0}, 0 },
      {{{OSUTF8("database-next"), 13}, 0}, 0 },
      {{{OSUTF8("database-row-select"), 19}, 0}, 0 },
      {{{OSUTF8("database-row-number"), 19}, 0}, 0 },
      {{{OSUTF8("database-name"), 13}, 0}, 0 },
      {{{OSUTF8("page-variable-set"), 17}, 0}, 0 },
      {{{OSUTF8("page-variable-get"), 17}, 0}, 0 },
      {{{OSUTF8("placeholder"), 11}, 0}, 0 },
      {{{OSUTF8("conditional-text"), 16}, 0}, 0 },
      {{{OSUTF8("hidden-text"), 11}, 0}, 0 },
      {{{OSUTF8("reference-ref"), 13}, 0}, 0 },
      {{{OSUTF8("bookmark-ref"), 12}, 0}, 0 },
      {{{OSUTF8("note-ref"), 8}, 0}, 0 },
      {{{OSUTF8("sequence-ref"), 12}, 0}, 0 },
      {{{OSUTF8("script"), 6}, 0}, 0 },
      {{{OSUTF8("execute-macro"), 13}, 0}, 0 },
      {{{OSUTF8("hidden-paragraph"), 16}, 0}, 0 },
      {{{OSUTF8("dde-connection"), 14}, 0}, 0 },
      {{{OSUTF8("table-formula"), 13}, 0}, 0 },
      {{{OSUTF8("toc-mark-start"), 14}, 0}, 0 },
      {{{OSUTF8("toc-mark-end"), 12}, 0}, 0 },
      {{{OSUTF8("toc-mark"), 8}, 0}, 0 },
      {{{OSUTF8("user-index-mark-start"), 21}, 0}, 0 },
      {{{OSUTF8("user-index-mark-end"), 19}, 0}, 0 },
      {{{OSUTF8("user-index-mark"), 15}, 0}, 0 },
      {{{OSUTF8("alphabetical-index-mark-start"), 29}, 0}, 0 },
      {{{OSUTF8("alphabetical-index-mark-end"), 27}, 0}, 0 },
      {{{OSUTF8("alphabetical-index-mark"), 23}, 0}, 0 },
      {{{OSUTF8("bibliography-mark"), 17}, 0}, 0 },
      {{{OSUTF8("header"), 6}, 0}, 0 },
      {{{OSUTF8("footer"), 6}, 0}, 0 },
      {{{OSUTF8("date-time"), 9}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 122, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_Span_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_Span_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Span_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Odf_Span_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 122, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  P_element                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_P_element (OSCTXT* pctxt, Odf_P_element *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.s = rtxMemAllocType (pctxt, Odf_S);

         if (pvalue->u.s == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_S (pvalue->u.s);
         stat = asn1D_Odf_S (pctxt, 
            pvalue->u.s, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.tab = rtxMemAllocType (pctxt, Odf_Tab);

         if (pvalue->u.tab == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Tab (pvalue->u.tab);
         stat = asn1D_Odf_Tab (pctxt, 
            pvalue->u.tab, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.line_break = rtxMemAllocType (pctxt, Odf_Line_break);

         if (pvalue->u.line_break == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Line_break (pvalue->u.line_break);
         stat = asn1D_Odf_Line_break (pctxt, 
            pvalue->u.line_break, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.span = rtxMemAllocType (pctxt, Odf_Span);

         if (pvalue->u.span == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Span (pvalue->u.span);
         stat = asn1D_Odf_Span (pctxt, 
            pvalue->u.span, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.a = rtxMemAllocType (pctxt, Odf_A);

         if (pvalue->u.a == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_A (pvalue->u.a);
         stat = asn1D_Odf_A (pctxt, 
            pvalue->u.a, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.bookmark = rtxMemAllocType (pctxt, Odf_Bookmark);

         if (pvalue->u.bookmark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bookmark (pvalue->u.bookmark);
         stat = asn1D_Odf_Bookmark (pctxt, 
            pvalue->u.bookmark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.bookmark_start
             = rtxMemAllocType (pctxt, Odf_Bookmark_start);

         if (pvalue->u.bookmark_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bookmark_start (pvalue->u.bookmark_start);
         stat = asn1D_Odf_Bookmark_start (pctxt, 
            pvalue->u.bookmark_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.bookmark_end = rtxMemAllocType (pctxt, Odf_Bookmark_end);

         if (pvalue->u.bookmark_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bookmark_end (pvalue->u.bookmark_end);
         stat = asn1D_Odf_Bookmark_end (pctxt, 
            pvalue->u.bookmark_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.reference_mark
             = rtxMemAllocType (pctxt, Odf_Reference_mark);

         if (pvalue->u.reference_mark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Reference_mark (pvalue->u.reference_mark);
         stat = asn1D_Odf_Reference_mark (pctxt, 
            pvalue->u.reference_mark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.reference_mark_start
             = rtxMemAllocType (pctxt, Odf_Reference_mark_start);

         if (pvalue->u.reference_mark_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Reference_mark_start (pvalue->u.reference_mark_start);
         stat = asn1D_Odf_Reference_mark_start (pctxt, 
            pvalue->u.reference_mark_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.reference_mark_end
             = rtxMemAllocType (pctxt, Odf_Reference_mark_end);

         if (pvalue->u.reference_mark_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Reference_mark_end (pvalue->u.reference_mark_end);
         stat = asn1D_Odf_Reference_mark_end (pctxt, 
            pvalue->u.reference_mark_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.note = rtxMemAllocType (pctxt, Odf_Note);

         if (pvalue->u.note == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Note (pvalue->u.note);
         stat = asn1D_Odf_Note (pctxt, 
            pvalue->u.note, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.ruby = rtxMemAllocType (pctxt, Odf_Ruby);

         if (pvalue->u.ruby == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Ruby (pvalue->u.ruby);
         stat = asn1D_Odf_Ruby (pctxt, 
            pvalue->u.ruby, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.annotation = rtxMemAllocType (pctxt, Ns13_Annotation);

         if (pvalue->u.annotation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Annotation ((Ns13_Annotation*)pvalue->u.annotation);
         stat = asn1D_Ns13_Annotation (pctxt, 
            (Ns13_Annotation*)pvalue->u.annotation, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

         if (pvalue->u.change == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change (pvalue->u.change);
         stat = asn1D_Odf_Change (pctxt, 
            pvalue->u.change, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

         if (pvalue->u.change_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_start (pvalue->u.change_start);
         stat = asn1D_Odf_Change_start (pctxt, 
            pvalue->u.change_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

         if (pvalue->u.change_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_end (pvalue->u.change_end);
         stat = asn1D_Odf_Change_end (pctxt, 
            pvalue->u.change_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      case (TM_CTXT|TM_CONS|17):
         pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

         if (pvalue->u.rect == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);
         stat = asn1D_Ns3_Rect (pctxt, 
            (Ns3_Rect*)pvalue->u.rect, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 18;
         break;

      case (TM_CTXT|TM_CONS|18):
         pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

         if (pvalue->u.line == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);
         stat = asn1D_Ns3_Line (pctxt, 
            (Ns3_Line*)pvalue->u.line, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 19;
         break;

      case (TM_CTXT|TM_CONS|19):
         pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

         if (pvalue->u.polyline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);
         stat = asn1D_Ns3_Polyline (pctxt, 
            (Ns3_Polyline*)pvalue->u.polyline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 20;
         break;

      case (TM_CTXT|TM_CONS|20):
         pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

         if (pvalue->u.polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);
         stat = asn1D_Ns3_Polygon (pctxt, 
            (Ns3_Polygon*)pvalue->u.polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 21;
         break;

      case (TM_CTXT|TM_CONS|21):
         pvalue->u.regular_polygon
             = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

         if (pvalue->u.regular_polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->u.regular_polygon);
         stat = asn1D_Ns3_Regular_polygon (pctxt, 
            (Ns3_Regular_polygon*)pvalue->u.regular_polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 22;
         break;

      case (TM_CTXT|TM_CONS|22):
         pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

         if (pvalue->u.path == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);
         stat = asn1D_Ns3_Path (pctxt, 
            (Ns3_Path*)pvalue->u.path, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 23;
         break;

      case (TM_CTXT|TM_CONS|23):
         pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

         if (pvalue->u.circle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);
         stat = asn1D_Ns3_Circle (pctxt, 
            (Ns3_Circle*)pvalue->u.circle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 24;
         break;

      case (TM_CTXT|TM_CONS|24):
         pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

         if (pvalue->u.ellipse == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);
         stat = asn1D_Ns3_Ellipse (pctxt, 
            (Ns3_Ellipse*)pvalue->u.ellipse, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 25;
         break;

      case (TM_CTXT|TM_CONS|25):
         pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

         if (pvalue->u.g == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);
         stat = asn1D_Ns3_G (pctxt, 
            (Ns3_G*)pvalue->u.g, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 26;
         break;

      case (TM_CTXT|TM_CONS|26):
         pvalue->u.page_thumbnail
             = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

         if (pvalue->u.page_thumbnail == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->u.page_thumbnail);
         stat = asn1D_Ns3_Page_thumbnail (pctxt, 
            (Ns3_Page_thumbnail*)pvalue->u.page_thumbnail, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 27;
         break;

      case (TM_CTXT|TM_CONS|27):
         pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

         if (pvalue->u.frame == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);
         stat = asn1D_Ns3_Frame (pctxt, 
            (Ns3_Frame*)pvalue->u.frame, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 28;
         break;

      case (TM_CTXT|TM_CONS|28):
         pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

         if (pvalue->u.measure == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);
         stat = asn1D_Ns3_Measure (pctxt, 
            (Ns3_Measure*)pvalue->u.measure, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 29;
         break;

      case (TM_CTXT|TM_CONS|29):
         pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

         if (pvalue->u.caption == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);
         stat = asn1D_Ns3_Caption (pctxt, 
            (Ns3_Caption*)pvalue->u.caption, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 30;
         break;

      case (TM_CTXT|TM_CONS|30):
         pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

         if (pvalue->u.connector == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);
         stat = asn1D_Ns3_Connector (pctxt, 
            (Ns3_Connector*)pvalue->u.connector, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 31;
         break;

      case (TM_CTXT|TM_CONS|31):
         pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

         if (pvalue->u.control == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);
         stat = asn1D_Ns3_Control (pctxt, 
            (Ns3_Control*)pvalue->u.control, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 32;
         break;

      case (TM_CTXT|TM_CONS|32):
         pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

         if (pvalue->u.scene == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);
         stat = asn1D_Ns7_Scene (pctxt, 
            (Ns7_Scene*)pvalue->u.scene, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 33;
         break;

      case (TM_CTXT|TM_CONS|33):
         pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

         if (pvalue->u.custom_shape == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);
         stat = asn1D_Ns3_Custom_shape (pctxt, 
            (Ns3_Custom_shape*)pvalue->u.custom_shape, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 34;
         break;

      case (TM_CTXT|TM_CONS|34):
         pvalue->u.a_1 = rtxMemAllocType (pctxt, Ns3_A);

         if (pvalue->u.a_1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_A ((Ns3_A*)pvalue->u.a_1);
         stat = asn1D_Ns3_A (pctxt, 
            (Ns3_A*)pvalue->u.a_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 35;
         break;

      case (TM_CTXT|TM_CONS|35):
         pvalue->u.date = rtxMemAllocType (pctxt, Odf_Date);

         if (pvalue->u.date == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Date (pvalue->u.date);
         stat = asn1D_Odf_Date (pctxt, 
            pvalue->u.date, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 36;
         break;

      case (TM_CTXT|TM_CONS|36):
         pvalue->u.time_ = rtxMemAllocType (pctxt, Odf_Time);

         if (pvalue->u.time_ == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Time (pvalue->u.time_);
         stat = asn1D_Odf_Time (pctxt, 
            pvalue->u.time_, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 37;
         break;

      case (TM_CTXT|TM_CONS|37):
         pvalue->u.page_number = rtxMemAllocType (pctxt, Odf_Page_number);

         if (pvalue->u.page_number == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Page_number (pvalue->u.page_number);
         stat = asn1D_Odf_Page_number (pctxt, 
            pvalue->u.page_number, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 38;
         break;

      case (TM_CTXT|TM_CONS|38):
         pvalue->u.page_continuation
             = rtxMemAllocType (pctxt, Odf_Page_continuation);

         if (pvalue->u.page_continuation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Page_continuation (pvalue->u.page_continuation);
         stat = asn1D_Odf_Page_continuation (pctxt, 
            pvalue->u.page_continuation, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 39;
         break;

      case (TM_CTXT|TM_CONS|39):
         pvalue->u.sender_firstname
             = rtxMemAllocType (pctxt, Odf_Sender_firstname);

         if (pvalue->u.sender_firstname == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_firstname (pvalue->u.sender_firstname);
         stat = asn1D_Odf_Sender_firstname (pctxt, 
            pvalue->u.sender_firstname, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 40;
         break;

      case (TM_CTXT|TM_CONS|40):
         pvalue->u.sender_lastname
             = rtxMemAllocType (pctxt, Odf_Sender_lastname);

         if (pvalue->u.sender_lastname == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_lastname (pvalue->u.sender_lastname);
         stat = asn1D_Odf_Sender_lastname (pctxt, 
            pvalue->u.sender_lastname, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 41;
         break;

      case (TM_CTXT|TM_CONS|41):
         pvalue->u.sender_initials
             = rtxMemAllocType (pctxt, Odf_Sender_initials);

         if (pvalue->u.sender_initials == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_initials (pvalue->u.sender_initials);
         stat = asn1D_Odf_Sender_initials (pctxt, 
            pvalue->u.sender_initials, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 42;
         break;

      case (TM_CTXT|TM_CONS|42):
         pvalue->u.sender_title = rtxMemAllocType (pctxt, Odf_Sender_title);

         if (pvalue->u.sender_title == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_title (pvalue->u.sender_title);
         stat = asn1D_Odf_Sender_title (pctxt, 
            pvalue->u.sender_title, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 43;
         break;

      case (TM_CTXT|TM_CONS|43):
         pvalue->u.sender_position
             = rtxMemAllocType (pctxt, Odf_Sender_position);

         if (pvalue->u.sender_position == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_position (pvalue->u.sender_position);
         stat = asn1D_Odf_Sender_position (pctxt, 
            pvalue->u.sender_position, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 44;
         break;

      case (TM_CTXT|TM_CONS|44):
         pvalue->u.sender_email = rtxMemAllocType (pctxt, Odf_Sender_email);

         if (pvalue->u.sender_email == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_email (pvalue->u.sender_email);
         stat = asn1D_Odf_Sender_email (pctxt, 
            pvalue->u.sender_email, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 45;
         break;

      case (TM_CTXT|TM_CONS|45):
         pvalue->u.sender_phone_private
             = rtxMemAllocType (pctxt, Odf_Sender_phone_private);

         if (pvalue->u.sender_phone_private == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_phone_private (pvalue->u.sender_phone_private);
         stat = asn1D_Odf_Sender_phone_private (pctxt, 
            pvalue->u.sender_phone_private, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 46;
         break;

      case (TM_CTXT|TM_CONS|46):
         pvalue->u.sender_fax = rtxMemAllocType (pctxt, Odf_Sender_fax);

         if (pvalue->u.sender_fax == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_fax (pvalue->u.sender_fax);
         stat = asn1D_Odf_Sender_fax (pctxt, 
            pvalue->u.sender_fax, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 47;
         break;

      case (TM_CTXT|TM_CONS|47):
         pvalue->u.sender_company
             = rtxMemAllocType (pctxt, Odf_Sender_company);

         if (pvalue->u.sender_company == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_company (pvalue->u.sender_company);
         stat = asn1D_Odf_Sender_company (pctxt, 
            pvalue->u.sender_company, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 48;
         break;

      case (TM_CTXT|TM_CONS|48):
         pvalue->u.sender_phone_work
             = rtxMemAllocType (pctxt, Odf_Sender_phone_work);

         if (pvalue->u.sender_phone_work == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_phone_work (pvalue->u.sender_phone_work);
         stat = asn1D_Odf_Sender_phone_work (pctxt, 
            pvalue->u.sender_phone_work, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 49;
         break;

      case (TM_CTXT|TM_CONS|49):
         pvalue->u.sender_street = rtxMemAllocType (pctxt, Odf_Sender_street);

         if (pvalue->u.sender_street == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_street (pvalue->u.sender_street);
         stat = asn1D_Odf_Sender_street (pctxt, 
            pvalue->u.sender_street, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 50;
         break;

      case (TM_CTXT|TM_CONS|50):
         pvalue->u.sender_city = rtxMemAllocType (pctxt, Odf_Sender_city);

         if (pvalue->u.sender_city == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_city (pvalue->u.sender_city);
         stat = asn1D_Odf_Sender_city (pctxt, 
            pvalue->u.sender_city, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 51;
         break;

      case (TM_CTXT|TM_CONS|51):
         pvalue->u.sender_postal_code
             = rtxMemAllocType (pctxt, Odf_Sender_postal_code);

         if (pvalue->u.sender_postal_code == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_postal_code (pvalue->u.sender_postal_code);
         stat = asn1D_Odf_Sender_postal_code (pctxt, 
            pvalue->u.sender_postal_code, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 52;
         break;

      case (TM_CTXT|TM_CONS|52):
         pvalue->u.sender_country
             = rtxMemAllocType (pctxt, Odf_Sender_country);

         if (pvalue->u.sender_country == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_country (pvalue->u.sender_country);
         stat = asn1D_Odf_Sender_country (pctxt, 
            pvalue->u.sender_country, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 53;
         break;

      case (TM_CTXT|TM_CONS|53):
         pvalue->u.sender_state_or_province
             = rtxMemAllocType (pctxt, Odf_Sender_state_or_province);

         if (pvalue->u.sender_state_or_province == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sender_state_or_province (pvalue->u.sender_state_or_province);
         stat = asn1D_Odf_Sender_state_or_province (pctxt, 
            pvalue->u.sender_state_or_province, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 54;
         break;

      case (TM_CTXT|TM_CONS|54):
         pvalue->u.author_name = rtxMemAllocType (pctxt, Odf_Author_name);

         if (pvalue->u.author_name == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Author_name (pvalue->u.author_name);
         stat = asn1D_Odf_Author_name (pctxt, 
            pvalue->u.author_name, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 55;
         break;

      case (TM_CTXT|TM_CONS|55):
         pvalue->u.author_initials
             = rtxMemAllocType (pctxt, Odf_Author_initials);

         if (pvalue->u.author_initials == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Author_initials (pvalue->u.author_initials);
         stat = asn1D_Odf_Author_initials (pctxt, 
            pvalue->u.author_initials, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 56;
         break;

      case (TM_CTXT|TM_CONS|56):
         pvalue->u.chapter = rtxMemAllocType (pctxt, Odf_Chapter);

         if (pvalue->u.chapter == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Chapter (pvalue->u.chapter);
         stat = asn1D_Odf_Chapter (pctxt, 
            pvalue->u.chapter, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 57;
         break;

      case (TM_CTXT|TM_CONS|57):
         pvalue->u.file_name = rtxMemAllocType (pctxt, Odf_File_name);

         if (pvalue->u.file_name == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_File_name (pvalue->u.file_name);
         stat = asn1D_Odf_File_name (pctxt, 
            pvalue->u.file_name, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 58;
         break;

      case (TM_CTXT|TM_CONS|58):
         pvalue->u.template_name = rtxMemAllocType (pctxt, Odf_Template_name);

         if (pvalue->u.template_name == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Template_name (pvalue->u.template_name);
         stat = asn1D_Odf_Template_name (pctxt, 
            pvalue->u.template_name, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 59;
         break;

      case (TM_CTXT|TM_PRIM|59):
      case (TM_CTXT|TM_CONS|59):
         stat = asn1D_Odf_Sheet_name (pctxt, 
            &pvalue->u.sheet_name, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 60;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_CONS|60):
         pvalue->u.variable_set = rtxMemAllocType (pctxt, Odf_Variable_set);

         if (pvalue->u.variable_set == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Variable_set (pvalue->u.variable_set);
         stat = asn1D_Odf_Variable_set (pctxt, 
            pvalue->u.variable_set, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 61;
         break;

      case (TM_CTXT|TM_CONS|61):
         pvalue->u.variable_get = rtxMemAllocType (pctxt, Odf_Variable_get);

         if (pvalue->u.variable_get == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Variable_get (pvalue->u.variable_get);
         stat = asn1D_Odf_Variable_get (pctxt, 
            pvalue->u.variable_get, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 62;
         break;

      case (TM_CTXT|TM_CONS|62):
         pvalue->u.variable_input
             = rtxMemAllocType (pctxt, Odf_Variable_input);

         if (pvalue->u.variable_input == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Variable_input (pvalue->u.variable_input);
         stat = asn1D_Odf_Variable_input (pctxt, 
            pvalue->u.variable_input, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 63;
         break;

      case (TM_CTXT|TM_CONS|63):
         pvalue->u.user_field_get
             = rtxMemAllocType (pctxt, Odf_User_field_get);

         if (pvalue->u.user_field_get == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_field_get (pvalue->u.user_field_get);
         stat = asn1D_Odf_User_field_get (pctxt, 
            pvalue->u.user_field_get, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 64;
         break;

      case (TM_CTXT|TM_CONS|64):
         pvalue->u.user_field_input
             = rtxMemAllocType (pctxt, Odf_User_field_input);

         if (pvalue->u.user_field_input == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_field_input (pvalue->u.user_field_input);
         stat = asn1D_Odf_User_field_input (pctxt, 
            pvalue->u.user_field_input, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 65;
         break;

      case (TM_CTXT|TM_CONS|65):
         pvalue->u.sequence = rtxMemAllocType (pctxt, Odf_Sequence);

         if (pvalue->u.sequence == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sequence (pvalue->u.sequence);
         stat = asn1D_Odf_Sequence (pctxt, 
            pvalue->u.sequence, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 66;
         break;

      case (TM_CTXT|TM_CONS|66):
         pvalue->u.expression = rtxMemAllocType (pctxt, Odf_Expression);

         if (pvalue->u.expression == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Expression (pvalue->u.expression);
         stat = asn1D_Odf_Expression (pctxt, 
            pvalue->u.expression, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 67;
         break;

      case (TM_CTXT|TM_CONS|67):
         pvalue->u.text_input = rtxMemAllocType (pctxt, Odf_Text_input);

         if (pvalue->u.text_input == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Text_input (pvalue->u.text_input);
         stat = asn1D_Odf_Text_input (pctxt, 
            pvalue->u.text_input, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 68;
         break;

      case (TM_CTXT|TM_CONS|68):
         pvalue->u.initial_creator
             = rtxMemAllocType (pctxt, Odf_Initial_creator);

         if (pvalue->u.initial_creator == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Initial_creator (pvalue->u.initial_creator);
         stat = asn1D_Odf_Initial_creator (pctxt, 
            pvalue->u.initial_creator, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 69;
         break;

      case (TM_CTXT|TM_CONS|69):
         pvalue->u.creation_date = rtxMemAllocType (pctxt, Odf_Creation_date);

         if (pvalue->u.creation_date == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Creation_date (pvalue->u.creation_date);
         stat = asn1D_Odf_Creation_date (pctxt, 
            pvalue->u.creation_date, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 70;
         break;

      case (TM_CTXT|TM_CONS|70):
         pvalue->u.creation_time = rtxMemAllocType (pctxt, Odf_Creation_time);

         if (pvalue->u.creation_time == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Creation_time (pvalue->u.creation_time);
         stat = asn1D_Odf_Creation_time (pctxt, 
            pvalue->u.creation_time, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 71;
         break;

      case (TM_CTXT|TM_CONS|71):
         pvalue->u.description = rtxMemAllocType (pctxt, Odf_Description);

         if (pvalue->u.description == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Description (pvalue->u.description);
         stat = asn1D_Odf_Description (pctxt, 
            pvalue->u.description, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 72;
         break;

      case (TM_CTXT|TM_CONS|72):
         pvalue->u.user_defined = rtxMemAllocType (pctxt, Odf_User_defined);

         if (pvalue->u.user_defined == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_defined (pvalue->u.user_defined);
         stat = asn1D_Odf_User_defined (pctxt, 
            pvalue->u.user_defined, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 73;
         break;

      case (TM_CTXT|TM_CONS|73):
         pvalue->u.print_time = rtxMemAllocType (pctxt, Odf_Print_time);

         if (pvalue->u.print_time == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Print_time (pvalue->u.print_time);
         stat = asn1D_Odf_Print_time (pctxt, 
            pvalue->u.print_time, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 74;
         break;

      case (TM_CTXT|TM_CONS|74):
         pvalue->u.print_date = rtxMemAllocType (pctxt, Odf_Print_date);

         if (pvalue->u.print_date == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Print_date (pvalue->u.print_date);
         stat = asn1D_Odf_Print_date (pctxt, 
            pvalue->u.print_date, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 75;
         break;

      case (TM_CTXT|TM_CONS|75):
         pvalue->u.printed_by = rtxMemAllocType (pctxt, Odf_Printed_by);

         if (pvalue->u.printed_by == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Printed_by (pvalue->u.printed_by);
         stat = asn1D_Odf_Printed_by (pctxt, 
            pvalue->u.printed_by, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 76;
         break;

      case (TM_CTXT|TM_CONS|76):
         pvalue->u.title = rtxMemAllocType (pctxt, Odf_Title);

         if (pvalue->u.title == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Title (pvalue->u.title);
         stat = asn1D_Odf_Title (pctxt, 
            pvalue->u.title, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 77;
         break;

      case (TM_CTXT|TM_CONS|77):
         pvalue->u.subject = rtxMemAllocType (pctxt, Odf_Subject);

         if (pvalue->u.subject == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Subject (pvalue->u.subject);
         stat = asn1D_Odf_Subject (pctxt, 
            pvalue->u.subject, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 78;
         break;

      case (TM_CTXT|TM_CONS|78):
         pvalue->u.keywords = rtxMemAllocType (pctxt, Odf_Keywords);

         if (pvalue->u.keywords == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Keywords (pvalue->u.keywords);
         stat = asn1D_Odf_Keywords (pctxt, 
            pvalue->u.keywords, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 79;
         break;

      case (TM_CTXT|TM_CONS|79):
         pvalue->u.editing_cycles
             = rtxMemAllocType (pctxt, Odf_Editing_cycles);

         if (pvalue->u.editing_cycles == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Editing_cycles (pvalue->u.editing_cycles);
         stat = asn1D_Odf_Editing_cycles (pctxt, 
            pvalue->u.editing_cycles, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 80;
         break;

      case (TM_CTXT|TM_CONS|80):
         pvalue->u.editing_duration
             = rtxMemAllocType (pctxt, Odf_Editing_duration);

         if (pvalue->u.editing_duration == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Editing_duration (pvalue->u.editing_duration);
         stat = asn1D_Odf_Editing_duration (pctxt, 
            pvalue->u.editing_duration, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 81;
         break;

      case (TM_CTXT|TM_CONS|81):
         pvalue->u.modification_time
             = rtxMemAllocType (pctxt, Odf_Modification_time);

         if (pvalue->u.modification_time == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Modification_time (pvalue->u.modification_time);
         stat = asn1D_Odf_Modification_time (pctxt, 
            pvalue->u.modification_time, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 82;
         break;

      case (TM_CTXT|TM_CONS|82):
         pvalue->u.modification_date
             = rtxMemAllocType (pctxt, Odf_Modification_date);

         if (pvalue->u.modification_date == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Modification_date (pvalue->u.modification_date);
         stat = asn1D_Odf_Modification_date (pctxt, 
            pvalue->u.modification_date, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 83;
         break;

      case (TM_CTXT|TM_CONS|83):
         pvalue->u.creator = rtxMemAllocType (pctxt, Odf_Creator);

         if (pvalue->u.creator == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Creator (pvalue->u.creator);
         stat = asn1D_Odf_Creator (pctxt, 
            pvalue->u.creator, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 84;
         break;

      case (TM_CTXT|TM_CONS|84):
         pvalue->u.element271 = rtxMemAllocType (pctxt, Odf_Element271_group);

         if (pvalue->u.element271 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Element271_group (pvalue->u.element271);
         stat = asn1D_Odf_Element271_group (pctxt, 
            pvalue->u.element271, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 85;
         break;

      case (TM_CTXT|TM_CONS|85):
         pvalue->u.database_display
             = rtxMemAllocType (pctxt, Odf_Database_display);

         if (pvalue->u.database_display == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Database_display (pvalue->u.database_display);
         stat = asn1D_Odf_Database_display (pctxt, 
            pvalue->u.database_display, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 86;
         break;

      case (TM_CTXT|TM_CONS|86):
         pvalue->u.database_next = rtxMemAllocType (pctxt, Odf_Database_next);

         if (pvalue->u.database_next == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Database_next (pvalue->u.database_next);
         stat = asn1D_Odf_Database_next (pctxt, 
            pvalue->u.database_next, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 87;
         break;

      case (TM_CTXT|TM_CONS|87):
         pvalue->u.database_row_select
             = rtxMemAllocType (pctxt, Odf_Database_row_select);

         if (pvalue->u.database_row_select == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Database_row_select (pvalue->u.database_row_select);
         stat = asn1D_Odf_Database_row_select (pctxt, 
            pvalue->u.database_row_select, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 88;
         break;

      case (TM_CTXT|TM_CONS|88):
         pvalue->u.database_row_number
             = rtxMemAllocType (pctxt, Odf_Database_row_number);

         if (pvalue->u.database_row_number == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Database_row_number (pvalue->u.database_row_number);
         stat = asn1D_Odf_Database_row_number (pctxt, 
            pvalue->u.database_row_number, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 89;
         break;

      case (TM_CTXT|TM_CONS|89):
         pvalue->u.database_name = rtxMemAllocType (pctxt, Odf_Database_name);

         if (pvalue->u.database_name == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Database_name (pvalue->u.database_name);
         stat = asn1D_Odf_Database_name (pctxt, 
            pvalue->u.database_name, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 90;
         break;

      case (TM_CTXT|TM_CONS|90):
         pvalue->u.page_variable_set
             = rtxMemAllocType (pctxt, Odf_Page_variable_set);

         if (pvalue->u.page_variable_set == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Page_variable_set (pvalue->u.page_variable_set);
         stat = asn1D_Odf_Page_variable_set (pctxt, 
            pvalue->u.page_variable_set, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 91;
         break;

      case (TM_CTXT|TM_CONS|91):
         pvalue->u.page_variable_get
             = rtxMemAllocType (pctxt, Odf_Page_variable_get);

         if (pvalue->u.page_variable_get == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Page_variable_get (pvalue->u.page_variable_get);
         stat = asn1D_Odf_Page_variable_get (pctxt, 
            pvalue->u.page_variable_get, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 92;
         break;

      case (TM_CTXT|TM_CONS|92):
         pvalue->u.placeholder = rtxMemAllocType (pctxt, Odf_Placeholder);

         if (pvalue->u.placeholder == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Placeholder (pvalue->u.placeholder);
         stat = asn1D_Odf_Placeholder (pctxt, 
            pvalue->u.placeholder, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 93;
         break;

      case (TM_CTXT|TM_CONS|93):
         pvalue->u.conditional_text
             = rtxMemAllocType (pctxt, Odf_Conditional_text);

         if (pvalue->u.conditional_text == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Conditional_text (pvalue->u.conditional_text);
         stat = asn1D_Odf_Conditional_text (pctxt, 
            pvalue->u.conditional_text, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 94;
         break;

      case (TM_CTXT|TM_CONS|94):
         pvalue->u.hidden_text = rtxMemAllocType (pctxt, Odf_Hidden_text);

         if (pvalue->u.hidden_text == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Hidden_text (pvalue->u.hidden_text);
         stat = asn1D_Odf_Hidden_text (pctxt, 
            pvalue->u.hidden_text, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 95;
         break;

      case (TM_CTXT|TM_CONS|95):
         pvalue->u.element282 = rtxMemAllocType (pctxt, Odf_Element282_group);

         if (pvalue->u.element282 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Element282_group (pvalue->u.element282);
         stat = asn1D_Odf_Element282_group (pctxt, 
            pvalue->u.element282, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 96;
         break;

      case (TM_CTXT|TM_CONS|96):
         pvalue->u.note_ref = rtxMemAllocType (pctxt, Odf_Note_ref);

         if (pvalue->u.note_ref == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Note_ref (pvalue->u.note_ref);
         stat = asn1D_Odf_Note_ref (pctxt, 
            pvalue->u.note_ref, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 97;
         break;

      case (TM_CTXT|TM_CONS|97):
         pvalue->u.sequence_ref = rtxMemAllocType (pctxt, Odf_Sequence_ref);

         if (pvalue->u.sequence_ref == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sequence_ref (pvalue->u.sequence_ref);
         stat = asn1D_Odf_Sequence_ref (pctxt, 
            pvalue->u.sequence_ref, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 98;
         break;

      case (TM_CTXT|TM_CONS|98):
         pvalue->u.script = rtxMemAllocType (pctxt, Odf_Script);

         if (pvalue->u.script == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Script (pvalue->u.script);
         stat = asn1D_Odf_Script (pctxt, 
            pvalue->u.script, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 99;
         break;

      case (TM_CTXT|TM_CONS|99):
         pvalue->u.execute_macro = rtxMemAllocType (pctxt, Odf_Execute_macro);

         if (pvalue->u.execute_macro == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Execute_macro (pvalue->u.execute_macro);
         stat = asn1D_Odf_Execute_macro (pctxt, 
            pvalue->u.execute_macro, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 100;
         break;

      case (TM_CTXT|TM_CONS|100):
         pvalue->u.hidden_paragraph
             = rtxMemAllocType (pctxt, Odf_Hidden_paragraph);

         if (pvalue->u.hidden_paragraph == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Hidden_paragraph (pvalue->u.hidden_paragraph);
         stat = asn1D_Odf_Hidden_paragraph (pctxt, 
            pvalue->u.hidden_paragraph, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 101;
         break;

      case (TM_CTXT|TM_CONS|101):
         pvalue->u.dde_connection
             = rtxMemAllocType (pctxt, Odf_Dde_connection);

         if (pvalue->u.dde_connection == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Dde_connection (pvalue->u.dde_connection);
         stat = asn1D_Odf_Dde_connection (pctxt, 
            pvalue->u.dde_connection, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 102;
         break;

      case (TM_CTXT|TM_CONS|102):
         pvalue->u.measure_1 = rtxMemAllocType (pctxt, Odf_Measure);

         if (pvalue->u.measure_1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Measure (pvalue->u.measure_1);
         stat = asn1D_Odf_Measure (pctxt, 
            pvalue->u.measure_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 103;
         break;

      case (TM_CTXT|TM_CONS|103):
         pvalue->u.table_formula = rtxMemAllocType (pctxt, Odf_Table_formula);

         if (pvalue->u.table_formula == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_formula (pvalue->u.table_formula);
         stat = asn1D_Odf_Table_formula (pctxt, 
            pvalue->u.table_formula, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 104;
         break;

      case (TM_CTXT|TM_CONS|104):
         pvalue->u.toc_mark_start
             = rtxMemAllocType (pctxt, Odf_Toc_mark_start);

         if (pvalue->u.toc_mark_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Toc_mark_start (pvalue->u.toc_mark_start);
         stat = asn1D_Odf_Toc_mark_start (pctxt, 
            pvalue->u.toc_mark_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 105;
         break;

      case (TM_CTXT|TM_CONS|105):
         pvalue->u.toc_mark_end = rtxMemAllocType (pctxt, Odf_Toc_mark_end);

         if (pvalue->u.toc_mark_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Toc_mark_end (pvalue->u.toc_mark_end);
         stat = asn1D_Odf_Toc_mark_end (pctxt, 
            pvalue->u.toc_mark_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 106;
         break;

      case (TM_CTXT|TM_CONS|106):
         pvalue->u.toc_mark = rtxMemAllocType (pctxt, Odf_Toc_mark);

         if (pvalue->u.toc_mark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Toc_mark (pvalue->u.toc_mark);
         stat = asn1D_Odf_Toc_mark (pctxt, 
            pvalue->u.toc_mark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 107;
         break;

      case (TM_CTXT|TM_CONS|107):
         pvalue->u.user_index_mark_start
             = rtxMemAllocType (pctxt, Odf_User_index_mark_start);

         if (pvalue->u.user_index_mark_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index_mark_start (pvalue->u.user_index_mark_start);
         stat = asn1D_Odf_User_index_mark_start (pctxt, 
            pvalue->u.user_index_mark_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 108;
         break;

      case (TM_CTXT|TM_CONS|108):
         pvalue->u.user_index_mark_end
             = rtxMemAllocType (pctxt, Odf_User_index_mark_end);

         if (pvalue->u.user_index_mark_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index_mark_end (pvalue->u.user_index_mark_end);
         stat = asn1D_Odf_User_index_mark_end (pctxt, 
            pvalue->u.user_index_mark_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 109;
         break;

      case (TM_CTXT|TM_CONS|109):
         pvalue->u.user_index_mark
             = rtxMemAllocType (pctxt, Odf_User_index_mark);

         if (pvalue->u.user_index_mark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index_mark (pvalue->u.user_index_mark);
         stat = asn1D_Odf_User_index_mark (pctxt, 
            pvalue->u.user_index_mark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 110;
         break;

      case (TM_CTXT|TM_CONS|110):
         pvalue->u.alphabetical_index_mark_start
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark_start);

         if (pvalue->u.alphabetical_index_mark_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index_mark_start (pvalue->u.alphabetical_index_mark_start);
         stat = asn1D_Odf_Alphabetical_index_mark_start (pctxt, 
            pvalue->u.alphabetical_index_mark_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 111;
         break;

      case (TM_CTXT|TM_CONS|111):
         pvalue->u.alphabetical_index_mark_end
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark_end);

         if (pvalue->u.alphabetical_index_mark_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index_mark_end (pvalue->u.alphabetical_index_mark_end);
         stat = asn1D_Odf_Alphabetical_index_mark_end (pctxt, 
            pvalue->u.alphabetical_index_mark_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 112;
         break;

      case (TM_CTXT|TM_CONS|112):
         pvalue->u.alphabetical_index_mark
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark);

         if (pvalue->u.alphabetical_index_mark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index_mark (pvalue->u.alphabetical_index_mark);
         stat = asn1D_Odf_Alphabetical_index_mark (pctxt, 
            pvalue->u.alphabetical_index_mark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 113;
         break;

      case (TM_CTXT|TM_CONS|113):
         pvalue->u.bibliography_mark
             = rtxMemAllocType (pctxt, Odf_Bibliography_mark);

         if (pvalue->u.bibliography_mark == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bibliography_mark (pvalue->u.bibliography_mark);
         stat = asn1D_Odf_Bibliography_mark (pctxt, 
            pvalue->u.bibliography_mark, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 114;
         break;

      case (TM_CTXT|TM_CONS|114):
         pvalue->u.header = rtxMemAllocType (pctxt, Ns10_Header);

         if (pvalue->u.header == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns10_Header ((Ns10_Header*)pvalue->u.header);
         stat = asn1D_Ns10_Header (pctxt, 
            (Ns10_Header*)pvalue->u.header, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 115;
         break;

      case (TM_CTXT|TM_CONS|115):
         pvalue->u.footer = rtxMemAllocType (pctxt, Ns10_Footer);

         if (pvalue->u.footer == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns10_Footer ((Ns10_Footer*)pvalue->u.footer);
         stat = asn1D_Ns10_Footer (pctxt, 
            (Ns10_Footer*)pvalue->u.footer, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 116;
         break;

      case (TM_CTXT|TM_CONS|116):
         pvalue->u.date_time = rtxMemAllocType (pctxt, Ns10_Date_time);

         if (pvalue->u.date_time == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns10_Date_time ((Ns10_Date_time*)pvalue->u.date_time);
         stat = asn1D_Ns10_Date_time (pctxt, 
            (Ns10_Date_time*)pvalue->u.date_time, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 117;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_P_element (OSCTXT* pctxt, Odf_P_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("s"), 1}, 0}, 0 },
      {{{OSUTF8("tab"), 3}, 0}, 1 },
      {{{OSUTF8("line-break"), 10}, 0}, 2 },
      {{{OSUTF8("span"), 4}, 0}, 3 },
      {{{OSUTF8("a"), 1}, 0}, 4 },
      {{{OSUTF8("bookmark"), 8}, 0}, 5 },
      {{{OSUTF8("bookmark-start"), 14}, 0}, 6 },
      {{{OSUTF8("bookmark-end"), 12}, 0}, 7 },
      {{{OSUTF8("reference-mark"), 14}, 0}, 8 },
      {{{OSUTF8("reference-mark-start"), 20}, 0}, 9 },
      {{{OSUTF8("reference-mark-end"), 18}, 0}, 10 },
      {{{OSUTF8("note"), 4}, 0}, 11 },
      {{{OSUTF8("ruby"), 4}, 0}, 12 },
      {{{OSUTF8("annotation"), 10}, 0}, 13 },
      {{{OSUTF8("change"), 6}, 0}, 14 },
      {{{OSUTF8("change-start"), 12}, 0}, 15 },
      {{{OSUTF8("change-end"), 10}, 0}, 16 },
      {{{OSUTF8("rect"), 4}, 0}, 17 },
      {{{OSUTF8("line"), 4}, 0}, 18 },
      {{{OSUTF8("polyline"), 8}, 0}, 19 },
      {{{OSUTF8("polygon"), 7}, 0}, 20 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 21 },
      {{{OSUTF8("path"), 4}, 0}, 22 },
      {{{OSUTF8("circle"), 6}, 0}, 23 },
      {{{OSUTF8("ellipse"), 7}, 0}, 24 },
      {{{OSUTF8("g"), 1}, 0}, 25 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 26 },
      {{{OSUTF8("frame"), 5}, 0}, 27 },
      {{{OSUTF8("measure"), 7}, 0}, 28 },
      {{{OSUTF8("caption"), 7}, 0}, 29 },
      {{{OSUTF8("connector"), 9}, 0}, 30 },
      {{{OSUTF8("control"), 7}, 0}, 31 },
      {{{OSUTF8("scene"), 5}, 0}, 32 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 33 },
      {{{OSUTF8("a"), 1}, 0}, 34 },
      {{{OSUTF8("date"), 4}, 0}, 35 },
      {{{OSUTF8("time"), 4}, 0}, 36 },
      {{{OSUTF8("page-number"), 11}, 0}, 37 },
      {{{OSUTF8("page-continuation"), 17}, 0}, 38 },
      {{{OSUTF8("sender-firstname"), 16}, 0}, 39 },
      {{{OSUTF8("sender-lastname"), 15}, 0}, 40 },
      {{{OSUTF8("sender-initials"), 15}, 0}, 41 },
      {{{OSUTF8("sender-title"), 12}, 0}, 42 },
      {{{OSUTF8("sender-position"), 15}, 0}, 43 },
      {{{OSUTF8("sender-email"), 12}, 0}, 44 },
      {{{OSUTF8("sender-phone-private"), 20}, 0}, 45 },
      {{{OSUTF8("sender-fax"), 10}, 0}, 46 },
      {{{OSUTF8("sender-company"), 14}, 0}, 47 },
      {{{OSUTF8("sender-phone-work"), 17}, 0}, 48 },
      {{{OSUTF8("sender-street"), 13}, 0}, 49 },
      {{{OSUTF8("sender-city"), 11}, 0}, 50 },
      {{{OSUTF8("sender-postal-code"), 18}, 0}, 51 },
      {{{OSUTF8("sender-country"), 14}, 0}, 52 },
      {{{OSUTF8("sender-state-or-province"), 24}, 0}, 53 },
      {{{OSUTF8("author-name"), 11}, 0}, 54 },
      {{{OSUTF8("author-initials"), 15}, 0}, 55 },
      {{{OSUTF8("chapter"), 7}, 0}, 56 },
      {{{OSUTF8("file-name"), 9}, 0}, 57 },
      {{{OSUTF8("template-name"), 13}, 0}, 58 },
      {{{OSUTF8("sheet-name"), 10}, 0}, 59 },
      {{{OSUTF8("variable-set"), 12}, 0}, 60 },
      {{{OSUTF8("variable-get"), 12}, 0}, 61 },
      {{{OSUTF8("variable-input"), 14}, 0}, 62 },
      {{{OSUTF8("user-field-get"), 14}, 0}, 63 },
      {{{OSUTF8("user-field-input"), 16}, 0}, 64 },
      {{{OSUTF8("sequence"), 8}, 0}, 65 },
      {{{OSUTF8("expression"), 10}, 0}, 66 },
      {{{OSUTF8("text-input"), 10}, 0}, 67 },
      {{{OSUTF8("initial-creator"), 15}, 0}, 68 },
      {{{OSUTF8("creation-date"), 13}, 0}, 69 },
      {{{OSUTF8("creation-time"), 13}, 0}, 70 },
      {{{OSUTF8("description"), 11}, 0}, 71 },
      {{{OSUTF8("user-defined"), 12}, 0}, 72 },
      {{{OSUTF8("print-time"), 10}, 0}, 73 },
      {{{OSUTF8("print-date"), 10}, 0}, 74 },
      {{{OSUTF8("printed-by"), 10}, 0}, 75 },
      {{{OSUTF8("title"), 5}, 0}, 76 },
      {{{OSUTF8("subject"), 7}, 0}, 77 },
      {{{OSUTF8("keywords"), 8}, 0}, 78 },
      {{{OSUTF8("editing-cycles"), 14}, 0}, 79 },
      {{{OSUTF8("editing-duration"), 16}, 0}, 80 },
      {{{OSUTF8("modification-time"), 17}, 0}, 81 },
      {{{OSUTF8("modification-date"), 17}, 0}, 82 },
      {{{OSUTF8("creator"), 7}, 0}, 83 },
      {{{OSUTF8("page-count"), 10}, 0}, 84 },
      {{{OSUTF8("paragraph-count"), 15}, 0}, 84 },
      {{{OSUTF8("word-count"), 10}, 0}, 84 },
      {{{OSUTF8("character-count"), 15}, 0}, 84 },
      {{{OSUTF8("table-count"), 11}, 0}, 84 },
      {{{OSUTF8("image-count"), 11}, 0}, 84 },
      {{{OSUTF8("object-count"), 12}, 0}, 84 },
      {{{OSUTF8("database-display"), 16}, 0}, 85 },
      {{{OSUTF8("database-next"), 13}, 0}, 86 },
      {{{OSUTF8("database-row-select"), 19}, 0}, 87 },
      {{{OSUTF8("database-row-number"), 19}, 0}, 88 },
      {{{OSUTF8("database-name"), 13}, 0}, 89 },
      {{{OSUTF8("page-variable-set"), 17}, 0}, 90 },
      {{{OSUTF8("page-variable-get"), 17}, 0}, 91 },
      {{{OSUTF8("placeholder"), 11}, 0}, 92 },
      {{{OSUTF8("conditional-text"), 16}, 0}, 93 },
      {{{OSUTF8("hidden-text"), 11}, 0}, 94 },
      {{{OSUTF8("reference-ref"), 13}, 0}, 95 },
      {{{OSUTF8("bookmark-ref"), 12}, 0}, 95 },
      {{{OSUTF8("note-ref"), 8}, 0}, 96 },
      {{{OSUTF8("sequence-ref"), 12}, 0}, 97 },
      {{{OSUTF8("script"), 6}, 0}, 98 },
      {{{OSUTF8("execute-macro"), 13}, 0}, 99 },
      {{{OSUTF8("hidden-paragraph"), 16}, 0}, 100 },
      {{{OSUTF8("dde-connection"), 14}, 0}, 101 },
      {{{OSUTF8("measure"), 7}, 0}, 102 },
      {{{OSUTF8("table-formula"), 13}, 0}, 103 },
      {{{OSUTF8("toc-mark-start"), 14}, 0}, 104 },
      {{{OSUTF8("toc-mark-end"), 12}, 0}, 105 },
      {{{OSUTF8("toc-mark"), 8}, 0}, 106 },
      {{{OSUTF8("user-index-mark-start"), 21}, 0}, 107 },
      {{{OSUTF8("user-index-mark-end"), 19}, 0}, 108 },
      {{{OSUTF8("user-index-mark"), 15}, 0}, 109 },
      {{{OSUTF8("alphabetical-index-mark-start"), 29}, 0}, 110 },
      {{{OSUTF8("alphabetical-index-mark-end"), 27}, 0}, 111 },
      {{{OSUTF8("alphabetical-index-mark"), 23}, 0}, 112 },
      {{{OSUTF8("bibliography-mark"), 17}, 0}, 113 },
      {{{OSUTF8("header"), 6}, 0}, 114 },
      {{{OSUTF8("footer"), 6}, 0}, 115 },
      {{{OSUTF8("date-time"), 9}, 0}, 116 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 124, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* s */
      pvalue->u.s = rtxMemAllocType (pctxt, Odf_S);

      if (pvalue->u.s == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_S (pvalue->u.s);

      stat = XmlDec_Odf_S (pctxt, pvalue->u.s);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* tab */
      pvalue->u.tab = rtxMemAllocType (pctxt, Odf_Tab);

      if (pvalue->u.tab == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Tab (pvalue->u.tab);

      stat = XmlDec_Odf_Tab (pctxt, pvalue->u.tab);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* line-break */
      pvalue->u.line_break = rtxMemAllocType (pctxt, Odf_Line_break);

      if (pvalue->u.line_break == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Line_break (pvalue->u.line_break);

      stat = XmlDec_Odf_Line_break (pctxt, pvalue->u.line_break);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* span */
      pvalue->u.span = rtxMemAllocType (pctxt, Odf_Span);

      if (pvalue->u.span == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Span (pvalue->u.span);

      stat = XmlDec_Odf_Span (pctxt, pvalue->u.span);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* a */
      pvalue->u.a = rtxMemAllocType (pctxt, Odf_A);

      if (pvalue->u.a == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_A (pvalue->u.a);

      stat = XmlDec_Odf_A (pctxt, pvalue->u.a);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* bookmark */
      pvalue->u.bookmark = rtxMemAllocType (pctxt, Odf_Bookmark);

      if (pvalue->u.bookmark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bookmark (pvalue->u.bookmark);

      stat = XmlDec_Odf_Bookmark (pctxt, pvalue->u.bookmark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* bookmark-start */
      pvalue->u.bookmark_start = rtxMemAllocType (pctxt, Odf_Bookmark_start);

      if (pvalue->u.bookmark_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bookmark_start (pvalue->u.bookmark_start);

      stat = XmlDec_Odf_Bookmark_start (pctxt, pvalue->u.bookmark_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* bookmark-end */
      pvalue->u.bookmark_end = rtxMemAllocType (pctxt, Odf_Bookmark_end);

      if (pvalue->u.bookmark_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bookmark_end (pvalue->u.bookmark_end);

      stat = XmlDec_Odf_Bookmark_end (pctxt, pvalue->u.bookmark_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* reference-mark */
      pvalue->u.reference_mark = rtxMemAllocType (pctxt, Odf_Reference_mark);

      if (pvalue->u.reference_mark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Reference_mark (pvalue->u.reference_mark);

      stat = XmlDec_Odf_Reference_mark (pctxt, pvalue->u.reference_mark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* reference-mark-start */
      pvalue->u.reference_mark_start
          = rtxMemAllocType (pctxt, Odf_Reference_mark_start);

      if (pvalue->u.reference_mark_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Reference_mark_start (pvalue->u.reference_mark_start);

      stat = XmlDec_Odf_Reference_mark_start (pctxt, pvalue->
         u.reference_mark_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* reference-mark-end */
      pvalue->u.reference_mark_end
          = rtxMemAllocType (pctxt, Odf_Reference_mark_end);

      if (pvalue->u.reference_mark_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Reference_mark_end (pvalue->u.reference_mark_end);

      stat = XmlDec_Odf_Reference_mark_end (pctxt, pvalue->u.reference_mark_end
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* note */
      pvalue->u.note = rtxMemAllocType (pctxt, Odf_Note);

      if (pvalue->u.note == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Note (pvalue->u.note);

      stat = XmlDec_Odf_Note (pctxt, pvalue->u.note);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* ruby */
      pvalue->u.ruby = rtxMemAllocType (pctxt, Odf_Ruby);

      if (pvalue->u.ruby == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Ruby (pvalue->u.ruby);

      stat = XmlDec_Odf_Ruby (pctxt, pvalue->u.ruby);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* annotation */
      pvalue->u.annotation = rtxMemAllocType (pctxt, Ns13_Annotation);

      if (pvalue->u.annotation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns13_Annotation ((Ns13_Annotation*)pvalue->u.annotation);

      stat = XmlDec_Ns13_Annotation (pctxt, pvalue->u.annotation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* change */
      pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

      if (pvalue->u.change == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change (pvalue->u.change);

      stat = XmlDec_Odf_Change (pctxt, pvalue->u.change);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* change-start */
      pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

      if (pvalue->u.change_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_start (pvalue->u.change_start);

      stat = XmlDec_Odf_Change_start (pctxt, pvalue->u.change_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* change-end */
      pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

      if (pvalue->u.change_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_end (pvalue->u.change_end);

      stat = XmlDec_Odf_Change_end (pctxt, pvalue->u.change_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 17: { /* rect */
      pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

      if (pvalue->u.rect == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);

      stat = XmlDec_Ns3_Rect (pctxt, pvalue->u.rect);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 18: { /* line */
      pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

      if (pvalue->u.line == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);

      stat = XmlDec_Ns3_Line (pctxt, pvalue->u.line);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 19: { /* polyline */
      pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

      if (pvalue->u.polyline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);

      stat = XmlDec_Ns3_Polyline (pctxt, pvalue->u.polyline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 20: { /* polygon */
      pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

      if (pvalue->u.polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);

      stat = XmlDec_Ns3_Polygon (pctxt, pvalue->u.polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 21: { /* regular-polygon */
      pvalue->u.regular_polygon
          = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

      if (pvalue->u.regular_polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->
         u.regular_polygon);

      stat = XmlDec_Ns3_Regular_polygon (pctxt, pvalue->u.regular_polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 22: { /* path */
      pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

      if (pvalue->u.path == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);

      stat = XmlDec_Ns3_Path (pctxt, pvalue->u.path);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 23: { /* circle */
      pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

      if (pvalue->u.circle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);

      stat = XmlDec_Ns3_Circle (pctxt, pvalue->u.circle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 24: { /* ellipse */
      pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

      if (pvalue->u.ellipse == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);

      stat = XmlDec_Ns3_Ellipse (pctxt, pvalue->u.ellipse);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 25: { /* g */
      pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

      if (pvalue->u.g == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);

      stat = XmlDec_Ns3_G (pctxt, pvalue->u.g);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 26: { /* page-thumbnail */
      pvalue->u.page_thumbnail = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

      if (pvalue->u.page_thumbnail == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->
         u.page_thumbnail);

      stat = XmlDec_Ns3_Page_thumbnail (pctxt, pvalue->u.page_thumbnail);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 27: { /* frame */
      pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

      if (pvalue->u.frame == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);

      stat = XmlDec_Ns3_Frame (pctxt, pvalue->u.frame);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 28: { /* measure */
      pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

      if (pvalue->u.measure == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);

      stat = XmlDec_Ns3_Measure (pctxt, pvalue->u.measure);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 29: { /* caption */
      pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

      if (pvalue->u.caption == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);

      stat = XmlDec_Ns3_Caption (pctxt, pvalue->u.caption);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 30: { /* connector */
      pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

      if (pvalue->u.connector == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);

      stat = XmlDec_Ns3_Connector (pctxt, pvalue->u.connector);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 31: { /* control */
      pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

      if (pvalue->u.control == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);

      stat = XmlDec_Ns3_Control (pctxt, pvalue->u.control);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 32: { /* scene */
      pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

      if (pvalue->u.scene == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);

      stat = XmlDec_Ns7_Scene (pctxt, pvalue->u.scene);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 33: { /* custom-shape */
      pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

      if (pvalue->u.custom_shape == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);

      stat = XmlDec_Ns3_Custom_shape (pctxt, pvalue->u.custom_shape);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 34: { /* a */
      pvalue->u.a_1 = rtxMemAllocType (pctxt, Ns3_A);

      if (pvalue->u.a_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_A ((Ns3_A*)pvalue->u.a_1);

      stat = XmlDec_Ns3_A (pctxt, pvalue->u.a_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 35: { /* date */
      pvalue->u.date = rtxMemAllocType (pctxt, Odf_Date);

      if (pvalue->u.date == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Date (pvalue->u.date);

      stat = XmlDec_Odf_Date (pctxt, pvalue->u.date);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 36: { /* time */
      pvalue->u.time_ = rtxMemAllocType (pctxt, Odf_Time);

      if (pvalue->u.time_ == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Time (pvalue->u.time_);

      stat = XmlDec_Odf_Time (pctxt, pvalue->u.time_);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 37: { /* page-number */
      pvalue->u.page_number = rtxMemAllocType (pctxt, Odf_Page_number);

      if (pvalue->u.page_number == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Page_number (pvalue->u.page_number);

      stat = XmlDec_Odf_Page_number (pctxt, pvalue->u.page_number);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 38: { /* page-continuation */
      pvalue->u.page_continuation
          = rtxMemAllocType (pctxt, Odf_Page_continuation);

      if (pvalue->u.page_continuation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Page_continuation (pvalue->u.page_continuation);

      stat = XmlDec_Odf_Page_continuation (pctxt, pvalue->u.page_continuation
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 39: { /* sender-firstname */
      pvalue->u.sender_firstname
          = rtxMemAllocType (pctxt, Odf_Sender_firstname);

      if (pvalue->u.sender_firstname == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_firstname (pvalue->u.sender_firstname);

      stat = XmlDec_Odf_Sender_firstname (pctxt, pvalue->u.sender_firstname);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 40: { /* sender-lastname */
      pvalue->u.sender_lastname
          = rtxMemAllocType (pctxt, Odf_Sender_lastname);

      if (pvalue->u.sender_lastname == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_lastname (pvalue->u.sender_lastname);

      stat = XmlDec_Odf_Sender_lastname (pctxt, pvalue->u.sender_lastname);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 41: { /* sender-initials */
      pvalue->u.sender_initials
          = rtxMemAllocType (pctxt, Odf_Sender_initials);

      if (pvalue->u.sender_initials == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_initials (pvalue->u.sender_initials);

      stat = XmlDec_Odf_Sender_initials (pctxt, pvalue->u.sender_initials);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 42: { /* sender-title */
      pvalue->u.sender_title = rtxMemAllocType (pctxt, Odf_Sender_title);

      if (pvalue->u.sender_title == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_title (pvalue->u.sender_title);

      stat = XmlDec_Odf_Sender_title (pctxt, pvalue->u.sender_title);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 43: { /* sender-position */
      pvalue->u.sender_position
          = rtxMemAllocType (pctxt, Odf_Sender_position);

      if (pvalue->u.sender_position == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_position (pvalue->u.sender_position);

      stat = XmlDec_Odf_Sender_position (pctxt, pvalue->u.sender_position);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 44: { /* sender-email */
      pvalue->u.sender_email = rtxMemAllocType (pctxt, Odf_Sender_email);

      if (pvalue->u.sender_email == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_email (pvalue->u.sender_email);

      stat = XmlDec_Odf_Sender_email (pctxt, pvalue->u.sender_email);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 45: { /* sender-phone-private */
      pvalue->u.sender_phone_private
          = rtxMemAllocType (pctxt, Odf_Sender_phone_private);

      if (pvalue->u.sender_phone_private == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_phone_private (pvalue->u.sender_phone_private);

      stat = XmlDec_Odf_Sender_phone_private (pctxt, pvalue->
         u.sender_phone_private);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 46: { /* sender-fax */
      pvalue->u.sender_fax = rtxMemAllocType (pctxt, Odf_Sender_fax);

      if (pvalue->u.sender_fax == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_fax (pvalue->u.sender_fax);

      stat = XmlDec_Odf_Sender_fax (pctxt, pvalue->u.sender_fax);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 47: { /* sender-company */
      pvalue->u.sender_company = rtxMemAllocType (pctxt, Odf_Sender_company);

      if (pvalue->u.sender_company == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_company (pvalue->u.sender_company);

      stat = XmlDec_Odf_Sender_company (pctxt, pvalue->u.sender_company);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 48: { /* sender-phone-work */
      pvalue->u.sender_phone_work
          = rtxMemAllocType (pctxt, Odf_Sender_phone_work);

      if (pvalue->u.sender_phone_work == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_phone_work (pvalue->u.sender_phone_work);

      stat = XmlDec_Odf_Sender_phone_work (pctxt, pvalue->u.sender_phone_work
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 49: { /* sender-street */
      pvalue->u.sender_street = rtxMemAllocType (pctxt, Odf_Sender_street);

      if (pvalue->u.sender_street == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_street (pvalue->u.sender_street);

      stat = XmlDec_Odf_Sender_street (pctxt, pvalue->u.sender_street);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 50: { /* sender-city */
      pvalue->u.sender_city = rtxMemAllocType (pctxt, Odf_Sender_city);

      if (pvalue->u.sender_city == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_city (pvalue->u.sender_city);

      stat = XmlDec_Odf_Sender_city (pctxt, pvalue->u.sender_city);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 51: { /* sender-postal-code */
      pvalue->u.sender_postal_code
          = rtxMemAllocType (pctxt, Odf_Sender_postal_code);

      if (pvalue->u.sender_postal_code == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_postal_code (pvalue->u.sender_postal_code);

      stat = XmlDec_Odf_Sender_postal_code (pctxt, pvalue->u.sender_postal_code
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 52: { /* sender-country */
      pvalue->u.sender_country = rtxMemAllocType (pctxt, Odf_Sender_country);

      if (pvalue->u.sender_country == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_country (pvalue->u.sender_country);

      stat = XmlDec_Odf_Sender_country (pctxt, pvalue->u.sender_country);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 53: { /* sender-state-or-province */
      pvalue->u.sender_state_or_province
          = rtxMemAllocType (pctxt, Odf_Sender_state_or_province);

      if (pvalue->u.sender_state_or_province == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sender_state_or_province (pvalue->u.sender_state_or_province
         );

      stat = XmlDec_Odf_Sender_state_or_province (pctxt, pvalue->
         u.sender_state_or_province);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 54: { /* author-name */
      pvalue->u.author_name = rtxMemAllocType (pctxt, Odf_Author_name);

      if (pvalue->u.author_name == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Author_name (pvalue->u.author_name);

      stat = XmlDec_Odf_Author_name (pctxt, pvalue->u.author_name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 55: { /* author-initials */
      pvalue->u.author_initials
          = rtxMemAllocType (pctxt, Odf_Author_initials);

      if (pvalue->u.author_initials == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Author_initials (pvalue->u.author_initials);

      stat = XmlDec_Odf_Author_initials (pctxt, pvalue->u.author_initials);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 56: { /* chapter */
      pvalue->u.chapter = rtxMemAllocType (pctxt, Odf_Chapter);

      if (pvalue->u.chapter == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Chapter (pvalue->u.chapter);

      stat = XmlDec_Odf_Chapter (pctxt, pvalue->u.chapter);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 57: { /* file-name */
      pvalue->u.file_name = rtxMemAllocType (pctxt, Odf_File_name);

      if (pvalue->u.file_name == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_File_name (pvalue->u.file_name);

      stat = XmlDec_Odf_File_name (pctxt, pvalue->u.file_name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 58: { /* template-name */
      pvalue->u.template_name = rtxMemAllocType (pctxt, Odf_Template_name);

      if (pvalue->u.template_name == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Template_name (pvalue->u.template_name);

      stat = XmlDec_Odf_Template_name (pctxt, pvalue->u.template_name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 59: { /* sheet-name */
      stat = XmlDec_Odf_Sheet_name (pctxt, &pvalue->u.sheet_name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 60: { /* variable-set */
      pvalue->u.variable_set = rtxMemAllocType (pctxt, Odf_Variable_set);

      if (pvalue->u.variable_set == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Variable_set (pvalue->u.variable_set);

      stat = XmlDec_Odf_Variable_set (pctxt, pvalue->u.variable_set);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 61: { /* variable-get */
      pvalue->u.variable_get = rtxMemAllocType (pctxt, Odf_Variable_get);

      if (pvalue->u.variable_get == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Variable_get (pvalue->u.variable_get);

      stat = XmlDec_Odf_Variable_get (pctxt, pvalue->u.variable_get);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 62: { /* variable-input */
      pvalue->u.variable_input = rtxMemAllocType (pctxt, Odf_Variable_input);

      if (pvalue->u.variable_input == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Variable_input (pvalue->u.variable_input);

      stat = XmlDec_Odf_Variable_input (pctxt, pvalue->u.variable_input);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 63: { /* user-field-get */
      pvalue->u.user_field_get = rtxMemAllocType (pctxt, Odf_User_field_get);

      if (pvalue->u.user_field_get == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_field_get (pvalue->u.user_field_get);

      stat = XmlDec_Odf_User_field_get (pctxt, pvalue->u.user_field_get);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 64: { /* user-field-input */
      pvalue->u.user_field_input
          = rtxMemAllocType (pctxt, Odf_User_field_input);

      if (pvalue->u.user_field_input == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_field_input (pvalue->u.user_field_input);

      stat = XmlDec_Odf_User_field_input (pctxt, pvalue->u.user_field_input);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 65: { /* sequence */
      pvalue->u.sequence = rtxMemAllocType (pctxt, Odf_Sequence);

      if (pvalue->u.sequence == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sequence (pvalue->u.sequence);

      stat = XmlDec_Odf_Sequence (pctxt, pvalue->u.sequence);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 66: { /* expression */
      pvalue->u.expression = rtxMemAllocType (pctxt, Odf_Expression);

      if (pvalue->u.expression == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Expression (pvalue->u.expression);

      stat = XmlDec_Odf_Expression (pctxt, pvalue->u.expression);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 67: { /* text-input */
      pvalue->u.text_input = rtxMemAllocType (pctxt, Odf_Text_input);

      if (pvalue->u.text_input == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Text_input (pvalue->u.text_input);

      stat = XmlDec_Odf_Text_input (pctxt, pvalue->u.text_input);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 68: { /* initial-creator */
      pvalue->u.initial_creator
          = rtxMemAllocType (pctxt, Odf_Initial_creator);

      if (pvalue->u.initial_creator == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Initial_creator (pvalue->u.initial_creator);

      stat = XmlDec_Odf_Initial_creator (pctxt, pvalue->u.initial_creator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 69: { /* creation-date */
      pvalue->u.creation_date = rtxMemAllocType (pctxt, Odf_Creation_date);

      if (pvalue->u.creation_date == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Creation_date (pvalue->u.creation_date);

      stat = XmlDec_Odf_Creation_date (pctxt, pvalue->u.creation_date);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 70: { /* creation-time */
      pvalue->u.creation_time = rtxMemAllocType (pctxt, Odf_Creation_time);

      if (pvalue->u.creation_time == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Creation_time (pvalue->u.creation_time);

      stat = XmlDec_Odf_Creation_time (pctxt, pvalue->u.creation_time);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 71: { /* description */
      pvalue->u.description = rtxMemAllocType (pctxt, Odf_Description);

      if (pvalue->u.description == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Description (pvalue->u.description);

      stat = XmlDec_Odf_Description (pctxt, pvalue->u.description);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 72: { /* user-defined */
      pvalue->u.user_defined = rtxMemAllocType (pctxt, Odf_User_defined);

      if (pvalue->u.user_defined == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_defined (pvalue->u.user_defined);

      stat = XmlDec_Odf_User_defined (pctxt, pvalue->u.user_defined);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 73: { /* print-time */
      pvalue->u.print_time = rtxMemAllocType (pctxt, Odf_Print_time);

      if (pvalue->u.print_time == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Print_time (pvalue->u.print_time);

      stat = XmlDec_Odf_Print_time (pctxt, pvalue->u.print_time);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 74: { /* print-date */
      pvalue->u.print_date = rtxMemAllocType (pctxt, Odf_Print_date);

      if (pvalue->u.print_date == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Print_date (pvalue->u.print_date);

      stat = XmlDec_Odf_Print_date (pctxt, pvalue->u.print_date);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 75: { /* printed-by */
      pvalue->u.printed_by = rtxMemAllocType (pctxt, Odf_Printed_by);

      if (pvalue->u.printed_by == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Printed_by (pvalue->u.printed_by);

      stat = XmlDec_Odf_Printed_by (pctxt, pvalue->u.printed_by);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 76: { /* title */
      pvalue->u.title = rtxMemAllocType (pctxt, Odf_Title);

      if (pvalue->u.title == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Title (pvalue->u.title);

      stat = XmlDec_Odf_Title (pctxt, pvalue->u.title);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 77: { /* subject */
      pvalue->u.subject = rtxMemAllocType (pctxt, Odf_Subject);

      if (pvalue->u.subject == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Subject (pvalue->u.subject);

      stat = XmlDec_Odf_Subject (pctxt, pvalue->u.subject);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 78: { /* keywords */
      pvalue->u.keywords = rtxMemAllocType (pctxt, Odf_Keywords);

      if (pvalue->u.keywords == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Keywords (pvalue->u.keywords);

      stat = XmlDec_Odf_Keywords (pctxt, pvalue->u.keywords);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 79: { /* editing-cycles */
      pvalue->u.editing_cycles = rtxMemAllocType (pctxt, Odf_Editing_cycles);

      if (pvalue->u.editing_cycles == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Editing_cycles (pvalue->u.editing_cycles);

      stat = XmlDec_Odf_Editing_cycles (pctxt, pvalue->u.editing_cycles);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 80: { /* editing-duration */
      pvalue->u.editing_duration
          = rtxMemAllocType (pctxt, Odf_Editing_duration);

      if (pvalue->u.editing_duration == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Editing_duration (pvalue->u.editing_duration);

      stat = XmlDec_Odf_Editing_duration (pctxt, pvalue->u.editing_duration);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 81: { /* modification-time */
      pvalue->u.modification_time
          = rtxMemAllocType (pctxt, Odf_Modification_time);

      if (pvalue->u.modification_time == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Modification_time (pvalue->u.modification_time);

      stat = XmlDec_Odf_Modification_time (pctxt, pvalue->u.modification_time
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 82: { /* modification-date */
      pvalue->u.modification_date
          = rtxMemAllocType (pctxt, Odf_Modification_date);

      if (pvalue->u.modification_date == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Modification_date (pvalue->u.modification_date);

      stat = XmlDec_Odf_Modification_date (pctxt, pvalue->u.modification_date
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 83: { /* creator */
      pvalue->u.creator = rtxMemAllocType (pctxt, Odf_Creator);

      if (pvalue->u.creator == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Creator (pvalue->u.creator);

      stat = XmlDec_Odf_Creator (pctxt, pvalue->u.creator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 84: { /*  */
      pvalue->u.element271 = rtxMemAllocType (pctxt, Odf_Element271_group);

      if (pvalue->u.element271 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Element271_group (pvalue->u.element271);

      stat = XmlDec_Odf_Element271_group (pctxt, pvalue->u.element271);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 85: { /* database-display */
      pvalue->u.database_display
          = rtxMemAllocType (pctxt, Odf_Database_display);

      if (pvalue->u.database_display == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Database_display (pvalue->u.database_display);

      stat = XmlDec_Odf_Database_display (pctxt, pvalue->u.database_display);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 86: { /* database-next */
      pvalue->u.database_next = rtxMemAllocType (pctxt, Odf_Database_next);

      if (pvalue->u.database_next == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Database_next (pvalue->u.database_next);

      stat = XmlDec_Odf_Database_next (pctxt, pvalue->u.database_next);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 87: { /* database-row-select */
      pvalue->u.database_row_select
          = rtxMemAllocType (pctxt, Odf_Database_row_select);

      if (pvalue->u.database_row_select == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Database_row_select (pvalue->u.database_row_select);

      stat = XmlDec_Odf_Database_row_select (pctxt, pvalue->
         u.database_row_select);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 88: { /* database-row-number */
      pvalue->u.database_row_number
          = rtxMemAllocType (pctxt, Odf_Database_row_number);

      if (pvalue->u.database_row_number == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Database_row_number (pvalue->u.database_row_number);

      stat = XmlDec_Odf_Database_row_number (pctxt, pvalue->
         u.database_row_number);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 89: { /* database-name */
      pvalue->u.database_name = rtxMemAllocType (pctxt, Odf_Database_name);

      if (pvalue->u.database_name == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Database_name (pvalue->u.database_name);

      stat = XmlDec_Odf_Database_name (pctxt, pvalue->u.database_name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 90: { /* page-variable-set */
      pvalue->u.page_variable_set
          = rtxMemAllocType (pctxt, Odf_Page_variable_set);

      if (pvalue->u.page_variable_set == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Page_variable_set (pvalue->u.page_variable_set);

      stat = XmlDec_Odf_Page_variable_set (pctxt, pvalue->u.page_variable_set
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 91: { /* page-variable-get */
      pvalue->u.page_variable_get
          = rtxMemAllocType (pctxt, Odf_Page_variable_get);

      if (pvalue->u.page_variable_get == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Page_variable_get (pvalue->u.page_variable_get);

      stat = XmlDec_Odf_Page_variable_get (pctxt, pvalue->u.page_variable_get
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 92: { /* placeholder */
      pvalue->u.placeholder = rtxMemAllocType (pctxt, Odf_Placeholder);

      if (pvalue->u.placeholder == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Placeholder (pvalue->u.placeholder);

      stat = XmlDec_Odf_Placeholder (pctxt, pvalue->u.placeholder);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 93: { /* conditional-text */
      pvalue->u.conditional_text
          = rtxMemAllocType (pctxt, Odf_Conditional_text);

      if (pvalue->u.conditional_text == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Conditional_text (pvalue->u.conditional_text);

      stat = XmlDec_Odf_Conditional_text (pctxt, pvalue->u.conditional_text);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 94: { /* hidden-text */
      pvalue->u.hidden_text = rtxMemAllocType (pctxt, Odf_Hidden_text);

      if (pvalue->u.hidden_text == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Hidden_text (pvalue->u.hidden_text);

      stat = XmlDec_Odf_Hidden_text (pctxt, pvalue->u.hidden_text);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 95: { /*  */
      pvalue->u.element282 = rtxMemAllocType (pctxt, Odf_Element282_group);

      if (pvalue->u.element282 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Element282_group (pvalue->u.element282);

      stat = XmlDec_Odf_Element282_group (pctxt, pvalue->u.element282);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 96: { /* note-ref */
      pvalue->u.note_ref = rtxMemAllocType (pctxt, Odf_Note_ref);

      if (pvalue->u.note_ref == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Note_ref (pvalue->u.note_ref);

      stat = XmlDec_Odf_Note_ref (pctxt, pvalue->u.note_ref);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 97: { /* sequence-ref */
      pvalue->u.sequence_ref = rtxMemAllocType (pctxt, Odf_Sequence_ref);

      if (pvalue->u.sequence_ref == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Sequence_ref (pvalue->u.sequence_ref);

      stat = XmlDec_Odf_Sequence_ref (pctxt, pvalue->u.sequence_ref);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 98: { /* script */
      pvalue->u.script = rtxMemAllocType (pctxt, Odf_Script);

      if (pvalue->u.script == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Script (pvalue->u.script);

      stat = XmlDec_Odf_Script (pctxt, pvalue->u.script);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 99: { /* execute-macro */
      pvalue->u.execute_macro = rtxMemAllocType (pctxt, Odf_Execute_macro);

      if (pvalue->u.execute_macro == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Execute_macro (pvalue->u.execute_macro);

      stat = XmlDec_Odf_Execute_macro (pctxt, pvalue->u.execute_macro);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 100: { /* hidden-paragraph */
      pvalue->u.hidden_paragraph
          = rtxMemAllocType (pctxt, Odf_Hidden_paragraph);

      if (pvalue->u.hidden_paragraph == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Hidden_paragraph (pvalue->u.hidden_paragraph);

      stat = XmlDec_Odf_Hidden_paragraph (pctxt, pvalue->u.hidden_paragraph);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 101: { /* dde-connection */
      pvalue->u.dde_connection = rtxMemAllocType (pctxt, Odf_Dde_connection);

      if (pvalue->u.dde_connection == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Dde_connection (pvalue->u.dde_connection);

      stat = XmlDec_Odf_Dde_connection (pctxt, pvalue->u.dde_connection);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 102: { /* measure */
      pvalue->u.measure_1 = rtxMemAllocType (pctxt, Odf_Measure);

      if (pvalue->u.measure_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Measure (pvalue->u.measure_1);

      stat = XmlDec_Odf_Measure (pctxt, pvalue->u.measure_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 103: { /* table-formula */
      pvalue->u.table_formula = rtxMemAllocType (pctxt, Odf_Table_formula);

      if (pvalue->u.table_formula == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_formula (pvalue->u.table_formula);

      stat = XmlDec_Odf_Table_formula (pctxt, pvalue->u.table_formula);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 104: { /* toc-mark-start */
      pvalue->u.toc_mark_start = rtxMemAllocType (pctxt, Odf_Toc_mark_start);

      if (pvalue->u.toc_mark_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Toc_mark_start (pvalue->u.toc_mark_start);

      stat = XmlDec_Odf_Toc_mark_start (pctxt, pvalue->u.toc_mark_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 105: { /* toc-mark-end */
      pvalue->u.toc_mark_end = rtxMemAllocType (pctxt, Odf_Toc_mark_end);

      if (pvalue->u.toc_mark_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Toc_mark_end (pvalue->u.toc_mark_end);

      stat = XmlDec_Odf_Toc_mark_end (pctxt, pvalue->u.toc_mark_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 106: { /* toc-mark */
      pvalue->u.toc_mark = rtxMemAllocType (pctxt, Odf_Toc_mark);

      if (pvalue->u.toc_mark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Toc_mark (pvalue->u.toc_mark);

      stat = XmlDec_Odf_Toc_mark (pctxt, pvalue->u.toc_mark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 107: { /* user-index-mark-start */
      pvalue->u.user_index_mark_start
          = rtxMemAllocType (pctxt, Odf_User_index_mark_start);

      if (pvalue->u.user_index_mark_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index_mark_start (pvalue->u.user_index_mark_start);

      stat = XmlDec_Odf_User_index_mark_start (pctxt, pvalue->
         u.user_index_mark_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 108: { /* user-index-mark-end */
      pvalue->u.user_index_mark_end
          = rtxMemAllocType (pctxt, Odf_User_index_mark_end);

      if (pvalue->u.user_index_mark_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index_mark_end (pvalue->u.user_index_mark_end);

      stat = XmlDec_Odf_User_index_mark_end (pctxt, pvalue->
         u.user_index_mark_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 109: { /* user-index-mark */
      pvalue->u.user_index_mark
          = rtxMemAllocType (pctxt, Odf_User_index_mark);

      if (pvalue->u.user_index_mark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index_mark (pvalue->u.user_index_mark);

      stat = XmlDec_Odf_User_index_mark (pctxt, pvalue->u.user_index_mark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 110: { /* alphabetical-index-mark-start */
      pvalue->u.alphabetical_index_mark_start
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark_start);

      if (pvalue->u.alphabetical_index_mark_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index_mark_start (pvalue->
         u.alphabetical_index_mark_start);

      stat = XmlDec_Odf_Alphabetical_index_mark_start (pctxt, pvalue->
         u.alphabetical_index_mark_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 111: { /* alphabetical-index-mark-end */
      pvalue->u.alphabetical_index_mark_end
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark_end);

      if (pvalue->u.alphabetical_index_mark_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index_mark_end (pvalue->
         u.alphabetical_index_mark_end);

      stat = XmlDec_Odf_Alphabetical_index_mark_end (pctxt, pvalue->
         u.alphabetical_index_mark_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 112: { /* alphabetical-index-mark */
      pvalue->u.alphabetical_index_mark
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index_mark);

      if (pvalue->u.alphabetical_index_mark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index_mark (pvalue->u.alphabetical_index_mark
         );

      stat = XmlDec_Odf_Alphabetical_index_mark (pctxt, pvalue->
         u.alphabetical_index_mark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 113: { /* bibliography-mark */
      pvalue->u.bibliography_mark
          = rtxMemAllocType (pctxt, Odf_Bibliography_mark);

      if (pvalue->u.bibliography_mark == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bibliography_mark (pvalue->u.bibliography_mark);

      stat = XmlDec_Odf_Bibliography_mark (pctxt, pvalue->u.bibliography_mark
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 114: { /* header */
      pvalue->u.header = rtxMemAllocType (pctxt, Ns10_Header);

      if (pvalue->u.header == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns10_Header ((Ns10_Header*)pvalue->u.header);

      stat = XmlDec_Ns10_Header (pctxt, pvalue->u.header);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 115: { /* footer */
      pvalue->u.footer = rtxMemAllocType (pctxt, Ns10_Footer);

      if (pvalue->u.footer == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns10_Footer ((Ns10_Footer*)pvalue->u.footer);

      stat = XmlDec_Ns10_Footer (pctxt, pvalue->u.footer);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 116: { /* date-time */
      pvalue->u.date_time = rtxMemAllocType (pctxt, Ns10_Date_time);

      if (pvalue->u.date_time == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns10_Date_time ((Ns10_Date_time*)pvalue->u.date_time);

      stat = XmlDec_Ns10_Date_time (pctxt, pvalue->u.date_time);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Insertion                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Insertion (OSCTXT* pctxt, Odf_Insertion *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode change_info */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->change_info = rtxMemAllocType (pctxt, Ns13_Change_info);

            if (pvalue->change_info == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Change_info ((Ns13_Change_info*)pvalue->change_info);
            asn1Init_Ns13_Change_info ((Ns13_Change_info*)pvalue->change_info);

            stat = asn1D_Ns13_Change_info (pctxt, 
               (Ns13_Change_info*)pvalue->change_info, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Insertion (OSCTXT* pctxt, Odf_Insertion* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("change-info"), 11}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* change-info */
         pvalue->change_info = rtxMemAllocType (pctxt, Ns13_Change_info);

         if (pvalue->change_info == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Change_info ((Ns13_Change_info*)pvalue->change_info);

         stat = XmlDec_Ns13_Change_info (pctxt, pvalue->change_info);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Deletion_element                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Deletion_element (OSCTXT* pctxt, 
   Odf_Deletion_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

         if (pvalue->u.h == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_H (pvalue->u.h);
         stat = asn1D_Odf_H (pctxt, 
            pvalue->u.h, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P (pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List (pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.numbered_paragraph
             = rtxMemAllocType (pctxt, Odf_Numbered_paragraph);

         if (pvalue->u.numbered_paragraph == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Numbered_paragraph (pvalue->u.numbered_paragraph);
         stat = asn1D_Odf_Numbered_paragraph (pctxt, 
            pvalue->u.numbered_paragraph, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.table = rtxMemAllocType (pctxt, Table);

         if (pvalue->u.table == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table ((Table*)pvalue->u.table);
         stat = asn1D_Table (pctxt, 
            (Table*)pvalue->u.table, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.a = rtxMemAllocType (pctxt, Ns3_A);

         if (pvalue->u.a == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_A ((Ns3_A*)pvalue->u.a);
         stat = asn1D_Ns3_A (pctxt, 
            (Ns3_A*)pvalue->u.a, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.section = rtxMemAllocType (pctxt, Odf_Section);

         if (pvalue->u.section == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Section (pvalue->u.section);
         stat = asn1D_Odf_Section (pctxt, 
            pvalue->u.section, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.table_of_content
             = rtxMemAllocType (pctxt, Odf_Table_of_content);

         if (pvalue->u.table_of_content == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_of_content (pvalue->u.table_of_content);
         stat = asn1D_Odf_Table_of_content (pctxt, 
            pvalue->u.table_of_content, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.illustration_index
             = rtxMemAllocType (pctxt, Odf_Illustration_index);

         if (pvalue->u.illustration_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Illustration_index (pvalue->u.illustration_index);
         stat = asn1D_Odf_Illustration_index (pctxt, 
            pvalue->u.illustration_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.table_index = rtxMemAllocType (pctxt, Odf_Table_index);

         if (pvalue->u.table_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_index (pvalue->u.table_index);
         stat = asn1D_Odf_Table_index (pctxt, 
            pvalue->u.table_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.object_index = rtxMemAllocType (pctxt, Odf_Object_index);

         if (pvalue->u.object_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Object_index (pvalue->u.object_index);
         stat = asn1D_Odf_Object_index (pctxt, 
            pvalue->u.object_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.user_index = rtxMemAllocType (pctxt, Odf_User_index);

         if (pvalue->u.user_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index (pvalue->u.user_index);
         stat = asn1D_Odf_User_index (pctxt, 
            pvalue->u.user_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.alphabetical_index
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index);

         if (pvalue->u.alphabetical_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index (pvalue->u.alphabetical_index);
         stat = asn1D_Odf_Alphabetical_index (pctxt, 
            pvalue->u.alphabetical_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.bibliography = rtxMemAllocType (pctxt, Odf_Bibliography);

         if (pvalue->u.bibliography == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bibliography (pvalue->u.bibliography);
         stat = asn1D_Odf_Bibliography (pctxt, 
            pvalue->u.bibliography, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

         if (pvalue->u.rect == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);
         stat = asn1D_Ns3_Rect (pctxt, 
            (Ns3_Rect*)pvalue->u.rect, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

         if (pvalue->u.line == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);
         stat = asn1D_Ns3_Line (pctxt, 
            (Ns3_Line*)pvalue->u.line, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

         if (pvalue->u.polyline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);
         stat = asn1D_Ns3_Polyline (pctxt, 
            (Ns3_Polyline*)pvalue->u.polyline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      case (TM_CTXT|TM_CONS|17):
         pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

         if (pvalue->u.polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);
         stat = asn1D_Ns3_Polygon (pctxt, 
            (Ns3_Polygon*)pvalue->u.polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 18;
         break;

      case (TM_CTXT|TM_CONS|18):
         pvalue->u.regular_polygon
             = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

         if (pvalue->u.regular_polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->u.regular_polygon);
         stat = asn1D_Ns3_Regular_polygon (pctxt, 
            (Ns3_Regular_polygon*)pvalue->u.regular_polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 19;
         break;

      case (TM_CTXT|TM_CONS|19):
         pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

         if (pvalue->u.path == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);
         stat = asn1D_Ns3_Path (pctxt, 
            (Ns3_Path*)pvalue->u.path, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 20;
         break;

      case (TM_CTXT|TM_CONS|20):
         pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

         if (pvalue->u.circle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);
         stat = asn1D_Ns3_Circle (pctxt, 
            (Ns3_Circle*)pvalue->u.circle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 21;
         break;

      case (TM_CTXT|TM_CONS|21):
         pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

         if (pvalue->u.ellipse == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);
         stat = asn1D_Ns3_Ellipse (pctxt, 
            (Ns3_Ellipse*)pvalue->u.ellipse, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 22;
         break;

      case (TM_CTXT|TM_CONS|22):
         pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

         if (pvalue->u.g == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);
         stat = asn1D_Ns3_G (pctxt, 
            (Ns3_G*)pvalue->u.g, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 23;
         break;

      case (TM_CTXT|TM_CONS|23):
         pvalue->u.page_thumbnail
             = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

         if (pvalue->u.page_thumbnail == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->u.page_thumbnail);
         stat = asn1D_Ns3_Page_thumbnail (pctxt, 
            (Ns3_Page_thumbnail*)pvalue->u.page_thumbnail, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 24;
         break;

      case (TM_CTXT|TM_CONS|24):
         pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

         if (pvalue->u.frame == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);
         stat = asn1D_Ns3_Frame (pctxt, 
            (Ns3_Frame*)pvalue->u.frame, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 25;
         break;

      case (TM_CTXT|TM_CONS|25):
         pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

         if (pvalue->u.measure == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);
         stat = asn1D_Ns3_Measure (pctxt, 
            (Ns3_Measure*)pvalue->u.measure, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 26;
         break;

      case (TM_CTXT|TM_CONS|26):
         pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

         if (pvalue->u.caption == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);
         stat = asn1D_Ns3_Caption (pctxt, 
            (Ns3_Caption*)pvalue->u.caption, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 27;
         break;

      case (TM_CTXT|TM_CONS|27):
         pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

         if (pvalue->u.connector == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);
         stat = asn1D_Ns3_Connector (pctxt, 
            (Ns3_Connector*)pvalue->u.connector, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 28;
         break;

      case (TM_CTXT|TM_CONS|28):
         pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

         if (pvalue->u.control == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);
         stat = asn1D_Ns3_Control (pctxt, 
            (Ns3_Control*)pvalue->u.control, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 29;
         break;

      case (TM_CTXT|TM_CONS|29):
         pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

         if (pvalue->u.scene == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);
         stat = asn1D_Ns7_Scene (pctxt, 
            (Ns7_Scene*)pvalue->u.scene, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 30;
         break;

      case (TM_CTXT|TM_CONS|30):
         pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

         if (pvalue->u.custom_shape == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);
         stat = asn1D_Ns3_Custom_shape (pctxt, 
            (Ns3_Custom_shape*)pvalue->u.custom_shape, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 31;
         break;

      case (TM_CTXT|TM_CONS|31):
         pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

         if (pvalue->u.change == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change (pvalue->u.change);
         stat = asn1D_Odf_Change (pctxt, 
            pvalue->u.change, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 32;
         break;

      case (TM_CTXT|TM_CONS|32):
         pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

         if (pvalue->u.change_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_start (pvalue->u.change_start);
         stat = asn1D_Odf_Change_start (pctxt, 
            pvalue->u.change_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 33;
         break;

      case (TM_CTXT|TM_CONS|33):
         pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

         if (pvalue->u.change_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_end (pvalue->u.change_end);
         stat = asn1D_Odf_Change_end (pctxt, 
            pvalue->u.change_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 34;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Deletion_element (OSCTXT* pctxt, Odf_Deletion_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("h"), 1}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 1 },
      {{{OSUTF8("list"), 4}, 0}, 2 },
      {{{OSUTF8("numbered-paragraph"), 18}, 0}, 3 },
      {{{OSUTF8("table"), 5}, 0}, 4 },
      {{{OSUTF8("a"), 1}, 0}, 5 },
      {{{OSUTF8("section"), 7}, 0}, 6 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 7 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 8 },
      {{{OSUTF8("table-index"), 11}, 0}, 9 },
      {{{OSUTF8("object-index"), 12}, 0}, 10 },
      {{{OSUTF8("user-index"), 10}, 0}, 11 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 12 },
      {{{OSUTF8("bibliography"), 12}, 0}, 13 },
      {{{OSUTF8("rect"), 4}, 0}, 14 },
      {{{OSUTF8("line"), 4}, 0}, 15 },
      {{{OSUTF8("polyline"), 8}, 0}, 16 },
      {{{OSUTF8("polygon"), 7}, 0}, 17 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 18 },
      {{{OSUTF8("path"), 4}, 0}, 19 },
      {{{OSUTF8("circle"), 6}, 0}, 20 },
      {{{OSUTF8("ellipse"), 7}, 0}, 21 },
      {{{OSUTF8("g"), 1}, 0}, 22 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 23 },
      {{{OSUTF8("frame"), 5}, 0}, 24 },
      {{{OSUTF8("measure"), 7}, 0}, 25 },
      {{{OSUTF8("caption"), 7}, 0}, 26 },
      {{{OSUTF8("connector"), 9}, 0}, 27 },
      {{{OSUTF8("control"), 7}, 0}, 28 },
      {{{OSUTF8("scene"), 5}, 0}, 29 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 30 },
      {{{OSUTF8("change"), 6}, 0}, 31 },
      {{{OSUTF8("change-start"), 12}, 0}, 32 },
      {{{OSUTF8("change-end"), 10}, 0}, 33 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 34, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* h */
      pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

      if (pvalue->u.h == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_H (pvalue->u.h);

      stat = XmlDec_Odf_H (pctxt, pvalue->u.h);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P (pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List (pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* numbered-paragraph */
      pvalue->u.numbered_paragraph
          = rtxMemAllocType (pctxt, Odf_Numbered_paragraph);

      if (pvalue->u.numbered_paragraph == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Numbered_paragraph (pvalue->u.numbered_paragraph);

      stat = XmlDec_Odf_Numbered_paragraph (pctxt, pvalue->u.numbered_paragraph
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* table */
      pvalue->u.table = rtxMemAllocType (pctxt, Table);

      if (pvalue->u.table == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table ((Table*)pvalue->u.table);

      stat = XmlDec_Table (pctxt, pvalue->u.table);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* a */
      pvalue->u.a = rtxMemAllocType (pctxt, Ns3_A);

      if (pvalue->u.a == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_A ((Ns3_A*)pvalue->u.a);

      stat = XmlDec_Ns3_A (pctxt, pvalue->u.a);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* section */
      pvalue->u.section = rtxMemAllocType (pctxt, Odf_Section);

      if (pvalue->u.section == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Section (pvalue->u.section);

      stat = XmlDec_Odf_Section (pctxt, pvalue->u.section);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* table-of-content */
      pvalue->u.table_of_content
          = rtxMemAllocType (pctxt, Odf_Table_of_content);

      if (pvalue->u.table_of_content == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_of_content (pvalue->u.table_of_content);

      stat = XmlDec_Odf_Table_of_content (pctxt, pvalue->u.table_of_content);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* illustration-index */
      pvalue->u.illustration_index
          = rtxMemAllocType (pctxt, Odf_Illustration_index);

      if (pvalue->u.illustration_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Illustration_index (pvalue->u.illustration_index);

      stat = XmlDec_Odf_Illustration_index (pctxt, pvalue->u.illustration_index
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* table-index */
      pvalue->u.table_index = rtxMemAllocType (pctxt, Odf_Table_index);

      if (pvalue->u.table_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_index (pvalue->u.table_index);

      stat = XmlDec_Odf_Table_index (pctxt, pvalue->u.table_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* object-index */
      pvalue->u.object_index = rtxMemAllocType (pctxt, Odf_Object_index);

      if (pvalue->u.object_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Object_index (pvalue->u.object_index);

      stat = XmlDec_Odf_Object_index (pctxt, pvalue->u.object_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* user-index */
      pvalue->u.user_index = rtxMemAllocType (pctxt, Odf_User_index);

      if (pvalue->u.user_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index (pvalue->u.user_index);

      stat = XmlDec_Odf_User_index (pctxt, pvalue->u.user_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* alphabetical-index */
      pvalue->u.alphabetical_index
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index);

      if (pvalue->u.alphabetical_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index (pvalue->u.alphabetical_index);

      stat = XmlDec_Odf_Alphabetical_index (pctxt, pvalue->u.alphabetical_index
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* bibliography */
      pvalue->u.bibliography = rtxMemAllocType (pctxt, Odf_Bibliography);

      if (pvalue->u.bibliography == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bibliography (pvalue->u.bibliography);

      stat = XmlDec_Odf_Bibliography (pctxt, pvalue->u.bibliography);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* rect */
      pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

      if (pvalue->u.rect == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);

      stat = XmlDec_Ns3_Rect (pctxt, pvalue->u.rect);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* line */
      pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

      if (pvalue->u.line == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);

      stat = XmlDec_Ns3_Line (pctxt, pvalue->u.line);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* polyline */
      pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

      if (pvalue->u.polyline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);

      stat = XmlDec_Ns3_Polyline (pctxt, pvalue->u.polyline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 17: { /* polygon */
      pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

      if (pvalue->u.polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);

      stat = XmlDec_Ns3_Polygon (pctxt, pvalue->u.polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 18: { /* regular-polygon */
      pvalue->u.regular_polygon
          = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

      if (pvalue->u.regular_polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->
         u.regular_polygon);

      stat = XmlDec_Ns3_Regular_polygon (pctxt, pvalue->u.regular_polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 19: { /* path */
      pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

      if (pvalue->u.path == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);

      stat = XmlDec_Ns3_Path (pctxt, pvalue->u.path);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 20: { /* circle */
      pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

      if (pvalue->u.circle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);

      stat = XmlDec_Ns3_Circle (pctxt, pvalue->u.circle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 21: { /* ellipse */
      pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

      if (pvalue->u.ellipse == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);

      stat = XmlDec_Ns3_Ellipse (pctxt, pvalue->u.ellipse);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 22: { /* g */
      pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

      if (pvalue->u.g == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);

      stat = XmlDec_Ns3_G (pctxt, pvalue->u.g);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 23: { /* page-thumbnail */
      pvalue->u.page_thumbnail = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

      if (pvalue->u.page_thumbnail == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->
         u.page_thumbnail);

      stat = XmlDec_Ns3_Page_thumbnail (pctxt, pvalue->u.page_thumbnail);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 24: { /* frame */
      pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

      if (pvalue->u.frame == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);

      stat = XmlDec_Ns3_Frame (pctxt, pvalue->u.frame);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 25: { /* measure */
      pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

      if (pvalue->u.measure == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);

      stat = XmlDec_Ns3_Measure (pctxt, pvalue->u.measure);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 26: { /* caption */
      pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

      if (pvalue->u.caption == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);

      stat = XmlDec_Ns3_Caption (pctxt, pvalue->u.caption);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 27: { /* connector */
      pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

      if (pvalue->u.connector == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);

      stat = XmlDec_Ns3_Connector (pctxt, pvalue->u.connector);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 28: { /* control */
      pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

      if (pvalue->u.control == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);

      stat = XmlDec_Ns3_Control (pctxt, pvalue->u.control);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 29: { /* scene */
      pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

      if (pvalue->u.scene == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);

      stat = XmlDec_Ns7_Scene (pctxt, pvalue->u.scene);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 30: { /* custom-shape */
      pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

      if (pvalue->u.custom_shape == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);

      stat = XmlDec_Ns3_Custom_shape (pctxt, pvalue->u.custom_shape);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 31: { /* change */
      pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

      if (pvalue->u.change == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change (pvalue->u.change);

      stat = XmlDec_Odf_Change (pctxt, pvalue->u.change);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 32: { /* change-start */
      pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

      if (pvalue->u.change_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_start (pvalue->u.change_start);

      stat = XmlDec_Odf_Change_start (pctxt, pvalue->u.change_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 33: { /* change-end */
      pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

      if (pvalue->u.change_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_end (pvalue->u.change_end);

      stat = XmlDec_Odf_Change_end (pctxt, pvalue->u.change_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Deletion                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Deletion (OSCTXT* pctxt, Odf_Deletion *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode change_info */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->change_info = rtxMemAllocType (pctxt, Ns13_Change_info);

            if (pvalue->change_info == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Change_info ((Ns13_Change_info*)pvalue->change_info);
            asn1Init_Ns13_Change_info ((Ns13_Change_info*)pvalue->change_info);

            stat = asn1D_Ns13_Change_info (pctxt, 
               (Ns13_Change_info*)pvalue->change_info, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Deletion_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Deletion_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_Deletion_element (pdata2);

                  stat = asn1D_Odf_Deletion_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Deletion (OSCTXT* pctxt, Odf_Deletion* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("change-info"), 11}, 0}, 0 },
      {{{OSUTF8("h"), 1}, 0}, 1 },
      {{{OSUTF8("p"), 1}, 0}, 1 },
      {{{OSUTF8("list"), 4}, 0}, 1 },
      {{{OSUTF8("numbered-paragraph"), 18}, 0}, 1 },
      {{{OSUTF8("table"), 5}, 0}, 1 },
      {{{OSUTF8("a"), 1}, 0}, 1 },
      {{{OSUTF8("section"), 7}, 0}, 1 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 1 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 1 },
      {{{OSUTF8("table-index"), 11}, 0}, 1 },
      {{{OSUTF8("object-index"), 12}, 0}, 1 },
      {{{OSUTF8("user-index"), 10}, 0}, 1 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 1 },
      {{{OSUTF8("bibliography"), 12}, 0}, 1 },
      {{{OSUTF8("rect"), 4}, 0}, 1 },
      {{{OSUTF8("line"), 4}, 0}, 1 },
      {{{OSUTF8("polyline"), 8}, 0}, 1 },
      {{{OSUTF8("polygon"), 7}, 0}, 1 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 1 },
      {{{OSUTF8("path"), 4}, 0}, 1 },
      {{{OSUTF8("circle"), 6}, 0}, 1 },
      {{{OSUTF8("ellipse"), 7}, 0}, 1 },
      {{{OSUTF8("g"), 1}, 0}, 1 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 1 },
      {{{OSUTF8("frame"), 5}, 0}, 1 },
      {{{OSUTF8("measure"), 7}, 0}, 1 },
      {{{OSUTF8("caption"), 7}, 0}, 1 },
      {{{OSUTF8("connector"), 9}, 0}, 1 },
      {{{OSUTF8("control"), 7}, 0}, 1 },
      {{{OSUTF8("scene"), 5}, 0}, 1 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 1 },
      {{{OSUTF8("change"), 6}, 0}, 1 },
      {{{OSUTF8("change-start"), 12}, 0}, 1 },
      {{{OSUTF8("change-end"), 10}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 34, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* change-info */
         pvalue->change_info = rtxMemAllocType (pctxt, Ns13_Change_info);

         if (pvalue->change_info == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Change_info ((Ns13_Change_info*)pvalue->change_info);

         stat = XmlDec_Ns13_Change_info (pctxt, pvalue->change_info);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: {
         Odf_Deletion_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_Deletion_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Deletion_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Odf_Deletion_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 34, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Format_change                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Format_change (OSCTXT* pctxt, Odf_Format_change *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode change_info */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->change_info = rtxMemAllocType (pctxt, Ns13_Change_info);

            if (pvalue->change_info == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Change_info ((Ns13_Change_info*)pvalue->change_info);
            asn1Init_Ns13_Change_info ((Ns13_Change_info*)pvalue->change_info);

            stat = asn1D_Ns13_Change_info (pctxt, 
               (Ns13_Change_info*)pvalue->change_info, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Format_change (OSCTXT* pctxt, Odf_Format_change* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("change-info"), 11}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* change-info */
         pvalue->change_info = rtxMemAllocType (pctxt, Ns13_Change_info);

         if (pvalue->change_info == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Change_info ((Ns13_Change_info*)pvalue->change_info);

         stat = XmlDec_Ns13_Change_info (pctxt, pvalue->change_info);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Changed_region_choice                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Changed_region_choice (OSCTXT* pctxt, 
   Odf_Changed_region_choice *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.insertion = rtxMemAllocType (pctxt, Odf_Insertion);

         if (pvalue->u.insertion == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Insertion (pvalue->u.insertion);
         stat = asn1D_Odf_Insertion (pctxt, 
            pvalue->u.insertion, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.deletion = rtxMemAllocType (pctxt, Odf_Deletion);

         if (pvalue->u.deletion == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Deletion (pvalue->u.deletion);
         stat = asn1D_Odf_Deletion (pctxt, 
            pvalue->u.deletion, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.format_change = rtxMemAllocType (pctxt, Odf_Format_change);

         if (pvalue->u.format_change == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Format_change (pvalue->u.format_change);
         stat = asn1D_Odf_Format_change (pctxt, 
            pvalue->u.format_change, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Changed_region_choice (OSCTXT* pctxt, 
   Odf_Changed_region_choice* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("insertion"), 9}, 0}, 0 },
      {{{OSUTF8("deletion"), 8}, 0}, 1 },
      {{{OSUTF8("format-change"), 13}, 0}, 2 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* insertion */
      pvalue->u.insertion = rtxMemAllocType (pctxt, Odf_Insertion);

      if (pvalue->u.insertion == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Insertion (pvalue->u.insertion);

      stat = XmlDec_Odf_Insertion (pctxt, pvalue->u.insertion);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* deletion */
      pvalue->u.deletion = rtxMemAllocType (pctxt, Odf_Deletion);

      if (pvalue->u.deletion == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Deletion (pvalue->u.deletion);

      stat = XmlDec_Odf_Deletion (pctxt, pvalue->u.deletion);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* format-change */
      pvalue->u.format_change = rtxMemAllocType (pctxt, Odf_Format_change);

      if (pvalue->u.format_change == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Format_change (pvalue->u.format_change);

      stat = XmlDec_Odf_Format_change (pctxt, pvalue->u.format_change);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Changed_region                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Changed_region (OSCTXT* pctxt, 
   Odf_Changed_region *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Changed_region_choice (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Changed_region (OSCTXT* pctxt, Odf_Changed_region* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("id"), 2}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Changed_region");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Changed_region");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("insertion"), 9}, 0}, 0 },
      {{{OSUTF8("deletion"), 8}, 0}, 0 },
      {{{OSUTF8("format-change"), 13}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}, {3, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_Odf_Changed_region_choice (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Element271                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Element271 (OSCTXT* pctxt, Odf_Element271 *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode num_format */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->num_format = rtxMemAllocType (pctxt, Ns8_Num_format);

            if (pvalue->num_format == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);
            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);

            stat = asn1D_Ns8_Num_format (pctxt, 
               (Ns8_Num_format*)pvalue->num_format, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.num_formatPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode num_letter_sync */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Num_letter_sync (pctxt, 
               (Ns8_Num_letter_sync*)&pvalue->num_letter_sync, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.num_letter_syncPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Element271 (OSCTXT* pctxt, Odf_Element271* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("num-format"), 10}, 0 },
         { {OSUTF8("num-letter-sync"), 15}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* num-format */
            pvalue->num_format = rtxMemAllocType (pctxt, Ns8_Num_format);

            if (pvalue->num_format == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Num_format ((Ns8_Num_format*)pvalue->num_format);

            stat = XmlDec_Ns8_Num_format (pctxt, pvalue->num_format);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.num_formatPresent = TRUE;
            break;

         case 1: /* num-letter-sync */
            stat = XmlDec_Ns8_Num_letter_sync (pctxt, &pvalue->num_letter_sync
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.num_letter_syncPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Element271");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Element271");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Element282                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Element282 (OSCTXT* pctxt, Odf_Element282 *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode ref_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->ref_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.ref_namePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode reference_format */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Element282_reference_format (pctxt, 
               &pvalue->reference_format, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.reference_formatPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Element282 (OSCTXT* pctxt, Odf_Element282* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("ref-name"), 8}, 0 },
         { {OSUTF8("reference-format"), 16}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* ref-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->ref_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.ref_namePresent = TRUE;
            break;

         case 1: /* reference-format */
            stat = XmlDec_Odf_Element282_reference_format (pctxt, &pvalue->
               reference_format);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.reference_formatPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Element282");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Element282");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Element480                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Element480 (OSCTXT* pctxt, Odf_Element480 *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode list_value */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->list_value = rtxMemAllocType (pctxt, List_value);

            if (pvalue->list_value == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_List_value ((List_value*)pvalue->list_value);
            asn1Init_List_value ((List_value*)pvalue->list_value);

            stat = asn1D_List_value (pctxt, 
               (List_value*)pvalue->list_value, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Element480 (OSCTXT* pctxt, Odf_Element480* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("list-value"), 10}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* list-value */
         pvalue->list_value = rtxMemAllocType (pctxt, List_value);

         if (pvalue->list_value == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_List_value ((List_value*)pvalue->list_value);

         stat = XmlDec_List_value (pctxt, pvalue->list_value);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Element480_derivations_list_property                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Element480_derivations_list_property (OSCTXT* pctxt, 
   Odf_Element480_derivations_list_property *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode property_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->property_name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode value_type */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Element480_derivations_list_property_value_type (pctxt, 
               &pvalue->value_type, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode list_value */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->list_value = rtxMemAllocType (pctxt, List_value);

            if (pvalue->list_value == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_List_value ((List_value*)pvalue->list_value);
            asn1Init_List_value ((List_value*)pvalue->list_value);

            stat = asn1D_List_value (pctxt, 
               (List_value*)pvalue->list_value, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Odf_Element480_derivations_list_property (OSCTXT* pctxt, 
   Odf_Element480_derivations_list_property* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("property-name"), 13}, 0 },
         { {OSUTF8("value-type"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* property-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->property_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* value-type */
            stat = XmlDec_Odf_Element480_derivations_list_property_value_type 
               (pctxt, &pvalue->value_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Odf_Element480_derivations_list_property");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Odf_Element480_derivations_list_property");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("list-value"), 10}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* list-value */
         pvalue->list_value = rtxMemAllocType (pctxt, List_value);

         if (pvalue->list_value == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_List_value ((List_value*)pvalue->list_value);

         stat = XmlDec_List_value (pctxt, pvalue->list_value);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Element480_derivations                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Odf_Element480_derivations (OSCTXT* pctxt, 
   Odf_Element480_derivations *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.element480 = rtxMemAllocType (pctxt, Odf_Element480);

         if (pvalue->u.element480 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Element480 (pvalue->u.element480);
         stat = asn1D_Odf_Element480 (pctxt, 
            pvalue->u.element480, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.list_property
             = rtxMemAllocType (pctxt, Odf_Element480_derivations_list_property);

         if (pvalue->u.list_property == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Element480_derivations_list_property (pvalue->u.list_property);
         stat = asn1D_Odf_Element480_derivations_list_property (pctxt, 
            pvalue->u.list_property, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Odf_Element480_derivations (OSCTXT* pctxt, 
   Odf_Element480_derivations* pvalue)
{
   const OSUTF8CHAR* xsiType = 0;
   int stat = 0;

   /* decode xsi:type attribute */
   if (rtXmlpHasAttributes (pctxt)) {
      OSUINT32 i, nAttrs = 0;
      OSXMLNameFragments attrName;

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) == 0 &&
             rtXmlpDecXSITypeAttr (pctxt, &attrName, &xsiType) == 0) break;
      }
   }

   /* decode content */
   if (!OS_ISEMPTY (xsiType)) {
      xsiType = rtXmlDecQName (pctxt, xsiType, 0);
   }
   if (OS_ISEMPTY (xsiType)) {
      pvalue->t = 1;
      pvalue->u.element480 = rtxMemAllocType (pctxt, Odf_Element480);

      if (pvalue->u.element480 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Element480 (pvalue->u.element480);

      stat = XmlDec_Odf_Element480 (pctxt, pvalue->u.element480);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("Element480")))
   {
      pvalue->t = 1;
      pvalue->u.element480 = rtxMemAllocType (pctxt, Odf_Element480);

      if (pvalue->u.element480 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Element480 (pvalue->u.element480);

      stat = XmlDec_Odf_Element480 (pctxt, pvalue->u.element480);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("_list-property")))
   {
      pvalue->t = 2;
      pvalue->u.list_property
          = rtxMemAllocType (pctxt, Odf_Element480_derivations_list_property);

      if (pvalue->u.list_property == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Element480_derivations_list_property (pvalue->
         u.list_property);

      stat = XmlDec_Odf_Element480_derivations_list_property (pctxt, pvalue->
         u.list_property);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

   }

   return (stat);
}

int XmlDec_Odf_Element271_PDU (OSCTXT* pctxt, Odf_Element271* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   asn1Init_Odf_Element271 (pvalue);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("element271"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_Odf_Element271 (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_Odf_Element282_PDU (OSCTXT* pctxt, Odf_Element282* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   asn1Init_Odf_Element282 (pvalue);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("element282"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_Odf_Element282 (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
