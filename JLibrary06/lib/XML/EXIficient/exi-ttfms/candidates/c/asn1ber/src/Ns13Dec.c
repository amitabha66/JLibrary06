/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "Ns13.h"
#include "Ns10.h"
#include "Odf.h"
#include "Ns3.h"
#include "Ns15.h"
#include "Ns4.h"
#include "Xforms.h"
#include "Ns8.h"
#include "Ns14.h"
#include "Ns12.h"
#include "Ns7.h"
#include "Ns5.h"
#include "rtxsrc/rtxCommon.h"

/**************************************************************/
/*                                                            */
/*  Binary_data                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Binary_data (OSCTXT* pctxt, Ns13_Binary_data *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_octstr (pctxt, &pvalue->data, &pvalue->numocts, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns13_Binary_data (OSCTXT* pctxt, Ns13_Binary_data* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynBase64Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Name                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Name (OSCTXT* pctxt, Ns13_Name *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns13_Name (OSCTXT* pctxt, Ns13_Name* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Target_frame_name_alt_1                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Target_frame_name_alt_1 (OSCTXT* pctxt, 
   Ns13_Target_frame_name_alt_1 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns13_Target_frame_name_alt_1 (OSCTXT* pctxt, 
   Ns13_Target_frame_name_alt_1* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns13_Target_frame_name_alt_1_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Target_frame_name_alt_2                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Target_frame_name_alt_2 (OSCTXT* pctxt, 
   Ns13_Target_frame_name_alt_2 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns13_Target_frame_name_alt_2 (OSCTXT* pctxt, 
   Ns13_Target_frame_name_alt_2* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns13_Target_frame_name_alt_2_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Target_frame_name_alt_3                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Target_frame_name_alt_3 (OSCTXT* pctxt, 
   Ns13_Target_frame_name_alt_3 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns13_Target_frame_name_alt_3 (OSCTXT* pctxt, 
   Ns13_Target_frame_name_alt_3* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns13_Target_frame_name_alt_3_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Target_frame_name_alt_4                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Target_frame_name_alt_4 (OSCTXT* pctxt, 
   Ns13_Target_frame_name_alt_4 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns13_Target_frame_name_alt_4 (OSCTXT* pctxt, 
   Ns13_Target_frame_name_alt_4* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns13_Target_frame_name_alt_4_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Target_frame_name                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Target_frame_name (OSCTXT* pctxt, 
   Ns13_Target_frame_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
         stat = asn1D_Ns13_Target_frame_name_alt_1 (pctxt, 
            &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_PRIM|2):
         stat = asn1D_Ns13_Target_frame_name_alt_2 (pctxt, 
            &pvalue->u.alt_2, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_PRIM|3):
         stat = asn1D_Ns13_Target_frame_name_alt_3 (pctxt, 
            &pvalue->u.alt_3, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_PRIM|4):
         stat = asn1D_Ns13_Target_frame_name_alt_4 (pctxt, 
            &pvalue->u.alt_4, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns13_Target_frame_name (OSCTXT* pctxt, 
   Ns13_Target_frame_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      stat = Ns13_Target_frame_name_alt_1_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_1);
      if (stat == 0) pvalue->t = 2;
   }
   if (pvalue->t == 0) {
      stat = Ns13_Target_frame_name_alt_2_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_2);
      if (stat == 0) pvalue->t = 3;
   }
   if (pvalue->t == 0) {
      stat = Ns13_Target_frame_name_alt_3_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_3);
      if (stat == 0) pvalue->t = 4;
   }
   if (pvalue->t == 0) {
      stat = Ns13_Target_frame_name_alt_4_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_4);
      if (stat == 0) pvalue->t = 5;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Event_listeners_element                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Event_listeners_element (OSCTXT* pctxt, 
   Ns13_Event_listeners_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.event_listener
             = rtxMemAllocType (pctxt, Ns10_Event_listener);

         if (pvalue->u.event_listener == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns10_Event_listener ((Ns10_Event_listener*)pvalue->u.event_listener);
         stat = asn1D_Ns10_Event_listener (pctxt, 
            (Ns10_Event_listener*)pvalue->u.event_listener, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.event_listener_1
             = rtxMemAllocType (pctxt, Ns10_Event_listener);

         if (pvalue->u.event_listener_1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns10_Event_listener ((Ns10_Event_listener*)pvalue->u.event_listener_1);
         stat = asn1D_Ns10_Event_listener (pctxt, 
            (Ns10_Event_listener*)pvalue->u.event_listener_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns13_Event_listeners_element (OSCTXT* pctxt, 
   Ns13_Event_listeners_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("event-listener"), 14}, 0}, 0 },
      {{{OSUTF8("event-listener"), 14}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* event-listener */
      pvalue->u.event_listener = rtxMemAllocType (pctxt, Ns10_Event_listener);

      if (pvalue->u.event_listener == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns10_Event_listener ((Ns10_Event_listener*)pvalue->
         u.event_listener);

      stat = XmlDec_Ns10_Event_listener (pctxt, pvalue->u.event_listener);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* event-listener */
      pvalue->u.event_listener_1
          = rtxMemAllocType (pctxt, Ns10_Event_listener);

      if (pvalue->u.event_listener_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns10_Event_listener ((Ns10_Event_listener*)pvalue->
         u.event_listener_1);

      stat = XmlDec_Ns10_Event_listener (pctxt, pvalue->u.event_listener_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Event_listeners                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Event_listeners (OSCTXT* pctxt, 
   Ns13_Event_listeners *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   Ns13_Event_listeners_element* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (XD_PEEKTAG (pctxt, 0x30)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_UNIV|TM_CONS|16));

   if (XD_PEEKTAG (pctxt, 0xa0)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_CTXT|TM_CONS|0));

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      rtxDListAllocNodeAndData (pctxt, Ns13_Event_listeners_element, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns13_Event_listeners_element (pdata1);

      stat = asn1D_Ns13_Event_listeners_element (pctxt, 
         pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

int XmlDec_Ns13_Event_listeners (OSCTXT* pctxt, Ns13_Event_listeners* pvalue)
{
   int stat = 0;

   { int elemID;
   Ns13_Event_listeners_element* pdata1;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("event-listener"), 14}, 0}, 0 }
   } ;

   rtxDListInit (pvalue);
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 1, -1, FALSE);
      if (elemID < 0 || elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0:
         rtXmlpMarkLastEventActive (pctxt);

         pdata1 = rtxMemAllocType (pctxt, Ns13_Event_listeners_element);

         if (pdata1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Event_listeners_element (pdata1);

         stat = XmlDec_Ns13_Event_listeners_element (pctxt, pdata1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         break;

      }
   }

   if (elemID == RTERR_UNEXPELEM || elemID == XML_OK_EOB) {
      stat = 0;
   }
   else return LOG_RTERR (pctxt, elemID);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Annotation_display                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Annotation_display (OSCTXT* pctxt, 
   Ns13_Annotation_display *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns13_Annotation_display (OSCTXT* pctxt, 
   Ns13_Annotation_display* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns13_Annotation_display_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Annotation_element                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Annotation_element (OSCTXT* pctxt, 
   Ns13_Annotation_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P ((Odf_P*)pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            (Odf_P*)pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List ((Odf_List*)pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            (Odf_List*)pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns13_Annotation_element (OSCTXT* pctxt, 
   Ns13_Annotation_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("list"), 4}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P ((Odf_P*)pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List ((Odf_List*)pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Annotation                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Annotation (OSCTXT* pctxt, Ns13_Annotation *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode caption_point_x */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Caption_point_x (pctxt, 
               (Ns3_Caption_point_x*)&pvalue->caption_point_x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.caption_point_xPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode caption_point_y */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Caption_point_y (pctxt, 
               (Ns3_Caption_point_y*)&pvalue->caption_point_y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.caption_point_yPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode class_names */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               (Ns3_Class_names*)&pvalue->class_names, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_namesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode corner_radius */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Corner_radius (pctxt, 
               (Ns3_Corner_radius*)&pvalue->corner_radius, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.corner_radiusPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Id (pctxt, 
               (Ns3_Id*)&pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode layer */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Layer_1 (pctxt, 
               (Ns3_Layer_1*)&pvalue->layer, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.layerPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->style_name = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name);
            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name);

            stat = asn1D_Ns3_Style_name (pctxt, 
               (Ns3_Style_name*)pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode text_style_name */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->text_style_name
                = rtxMemAllocType (pctxt, Ns3_Text_style_name);

            if (pvalue->text_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Text_style_name ((Ns3_Text_style_name*)pvalue->text_style_name);
            asn1Init_Ns3_Text_style_name ((Ns3_Text_style_name*)pvalue->text_style_name);

            stat = asn1D_Ns3_Text_style_name (pctxt, 
               (Ns3_Text_style_name*)pvalue->text_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode transform */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Transform (pctxt, 
               (Ns3_Transform*)&pvalue->transform, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.transformPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode z_index */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Z_index (pctxt, 
               (Ns3_Z_index*)&pvalue->z_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.z_indexPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode display */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Annotation_display (pctxt, 
               &pvalue->display, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.displayPresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode class_names_1 */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               (Ns3_Class_names*)&pvalue->class_names_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_names_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 13:
         /* decode style_name_1 */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->style_name_1 = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name_1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name_1);
            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name_1);

            stat = asn1D_Ns3_Style_name (pctxt, 
               (Ns3_Style_name*)pvalue->style_name_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_name_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 14:
         /* decode height */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->height, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.heightPresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode width */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->width, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.widthPresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode x */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.xPresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode y */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.yPresent = TRUE;
            }
         }
         break;

      case 18:
         /* decode end_cell_address */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_cell_address (pctxt, 
               (End_cell_address*)&pvalue->end_cell_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_cell_addressPresent = TRUE;
            }
         }
         break;

      case 19:
         /* decode end_x */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_x (pctxt, 
               (End_x*)&pvalue->end_x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_xPresent = TRUE;
            }
         }
         break;

      case 20:
         /* decode end_y */
         if (XD_PEEKTAG (pctxt, 0x94)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_y (pctxt, 
               (End_y*)&pvalue->end_y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_yPresent = TRUE;
            }
         }
         break;

      case 21:
         /* decode table_background */
         if (XD_PEEKTAG (pctxt, 0x95)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_background (pctxt, 
               (Table_background*)&pvalue->table_background, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_backgroundPresent = TRUE;
            }
         }
         break;

      case 22:
         /* decode anchor_page_number */
         if (XD_PEEKTAG (pctxt, 0x96)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_page_number (pctxt, 
               (Odf_Anchor_page_number*)&pvalue->anchor_page_number, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_page_numberPresent = TRUE;
            }
         }
         break;

      case 23:
         /* decode anchor_type */
         if (XD_PEEKTAG (pctxt, 0x97)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_type (pctxt, 
               (Odf_Anchor_type*)&pvalue->anchor_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_typePresent = TRUE;
            }
         }
         break;

      case 24:
         /* decode creator */
         if (XD_PEEKTAG (pctxt, 0x98)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Creator (pctxt, 
               &pvalue->creator, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.creatorPresent = TRUE;
            }
         }
         break;

      case 25:
         /* decode date */
         if (XD_PEEKTAG (pctxt, 0x99)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Elements_Date (pctxt, 
               &pvalue->date, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.datePresent = TRUE;
            }
         }
         break;

      case 26:
         /* decode date_string */
         if (XD_PEEKTAG (pctxt, 0x9a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Date_string (pctxt, 
               &pvalue->date_string, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.date_stringPresent = TRUE;
            }
         }
         break;

      case 27:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x9b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns13_Annotation_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns13_Annotation_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns13_Annotation_element (pdata2);

                  stat = asn1D_Ns13_Annotation_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_PRIM|17):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_PRIM|18):
         case (TM_CTXT|TM_CONS|18):
         case (TM_CTXT|TM_PRIM|19):
         case (TM_CTXT|TM_CONS|19):
         case (TM_CTXT|TM_PRIM|20):
         case (TM_CTXT|TM_CONS|20):
         case (TM_CTXT|TM_PRIM|21):
         case (TM_CTXT|TM_PRIM|22):
         case (TM_CTXT|TM_PRIM|23):
         case (TM_CTXT|TM_PRIM|24):
         case (TM_CTXT|TM_CONS|24):
         case (TM_CTXT|TM_PRIM|25):
         case (TM_CTXT|TM_CONS|25):
         case (TM_CTXT|TM_PRIM|26):
         case (TM_CTXT|TM_CONS|26):
         case (TM_CTXT|TM_CONS|27):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns13_Annotation (OSCTXT* pctxt, Ns13_Annotation* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("caption-point-x"), 15}, 0 },
         { {OSUTF8("caption-point-y"), 15}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("corner-radius"), 13}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("layer"), 5}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("text-style-name"), 15}, 0 },
         { {OSUTF8("transform"), 9}, 0 },
         { {OSUTF8("z-index"), 7}, 0 },
         { {OSUTF8("display"), 7}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("height"), 6}, 0 },
         { {OSUTF8("width"), 5}, 0 },
         { {OSUTF8("x"), 1}, 0 },
         { {OSUTF8("y"), 1}, 0 },
         { {OSUTF8("end-cell-address"), 16}, 0 },
         { {OSUTF8("end-x"), 5}, 0 },
         { {OSUTF8("end-y"), 5}, 0 },
         { {OSUTF8("table-background"), 16}, 0 },
         { {OSUTF8("anchor-page-number"), 18}, 0 },
         { {OSUTF8("anchor-type"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 24, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* caption-point-x */
            stat = XmlDec_Ns3_Caption_point_x (pctxt, &pvalue->caption_point_x
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.caption_point_xPresent = TRUE;
            break;

         case 1: /* caption-point-y */
            stat = XmlDec_Ns3_Caption_point_y (pctxt, &pvalue->caption_point_y
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.caption_point_yPresent = TRUE;
            break;

         case 2: /* class-names */
            rtxDListInit (&pvalue->class_names);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_namesPresent = TRUE;
            break;

         case 3: /* corner-radius */
            stat = XmlDec_Ns3_Corner_radius (pctxt, &pvalue->corner_radius);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.corner_radiusPresent = TRUE;
            break;

         case 4: /* id */
            stat = XmlDec_Ns3_Id (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 5: /* layer */
            stat = XmlDec_Ns3_Layer_1 (pctxt, &pvalue->layer);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.layerPresent = TRUE;
            break;

         case 6: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 7: /* style-name */
            pvalue->style_name = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name);

            stat = XmlDec_Ns3_Style_name (pctxt, pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 8: /* text-style-name */
            pvalue->text_style_name
                = rtxMemAllocType (pctxt, Ns3_Text_style_name);

            if (pvalue->text_style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Text_style_name ((Ns3_Text_style_name*)pvalue->
               text_style_name);

            stat = XmlDec_Ns3_Text_style_name (pctxt, pvalue->text_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.text_style_namePresent = TRUE;
            break;

         case 9: /* transform */
            stat = XmlDec_Ns3_Transform (pctxt, &pvalue->transform);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.transformPresent = TRUE;
            break;

         case 10: /* z-index */
            stat = XmlDec_Ns3_Z_index (pctxt, &pvalue->z_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.z_indexPresent = TRUE;
            break;

         case 11: /* display */
            stat = XmlDec_Ns13_Annotation_display (pctxt, &pvalue->display);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.displayPresent = TRUE;
            break;

         case 12: /* class-names */
            rtxDListInit (&pvalue->class_names_1);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_names_1Present = TRUE;
            break;

         case 13: /* style-name */
            pvalue->style_name_1 = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name_1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name_1);

            stat = XmlDec_Ns3_Style_name (pctxt, pvalue->style_name_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_name_1Present = TRUE;
            break;

         case 14: /* height */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->height);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.heightPresent = TRUE;
            break;

         case 15: /* width */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->width);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.widthPresent = TRUE;
            break;

         case 16: /* x */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.xPresent = TRUE;
            break;

         case 17: /* y */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.yPresent = TRUE;
            break;

         case 18: /* end-cell-address */
            stat = XmlDec_End_cell_address (pctxt, &pvalue->end_cell_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_cell_addressPresent = TRUE;
            break;

         case 19: /* end-x */
            stat = XmlDec_End_x (pctxt, &pvalue->end_x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_xPresent = TRUE;
            break;

         case 20: /* end-y */
            stat = XmlDec_End_y (pctxt, &pvalue->end_y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_yPresent = TRUE;
            break;

         case 21: /* table-background */
            stat = XmlDec_Table_background (pctxt, &pvalue->table_background);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.table_backgroundPresent = TRUE;
            break;

         case 22: /* anchor-page-number */
            stat = XmlDec_Odf_Anchor_page_number (pctxt, &pvalue->
               anchor_page_number);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_page_numberPresent = TRUE;
            break;

         case 23: /* anchor-type */
            stat = XmlDec_Odf_Anchor_type (pctxt, &pvalue->anchor_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_typePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns13_Annotation");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns13_Annotation");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("creator"), 7}, 0}, 0 },
      {{{OSUTF8("date"), 4}, 0}, 1 },
      {{{OSUTF8("date-string"), 11}, 0}, 2 },
      {{{OSUTF8("p"), 1}, 0}, 3 },
      {{{OSUTF8("list"), 4}, 0}, 3 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 5, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 4; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* creator */
         stat = XmlDec_Creator (pctxt, &pvalue->creator);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.creatorPresent = TRUE;
         break;
      }
      case 1: { /* date */
         stat = XmlDec_Elements_Date (pctxt, &pvalue->date);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.datePresent = TRUE;
         break;
      }
      case 2: { /* date-string */
         stat = XmlDec_Date_string (pctxt, &pvalue->date_string);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.date_stringPresent = TRUE;
         break;
      }
      case 3: {
         Ns13_Annotation_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns13_Annotation_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Annotation_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns13_Annotation_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 3, 2, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 3);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Automatic_update                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Automatic_update (OSCTXT* pctxt, 
   Ns13_Automatic_update *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns13_Automatic_update (OSCTXT* pctxt, Ns13_Automatic_update* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns13_Automatic_update_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Dde_source_conversion_mode                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Dde_source_conversion_mode (OSCTXT* pctxt, 
   Ns13_Dde_source_conversion_mode *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns13_Dde_source_conversion_mode (OSCTXT* pctxt, 
   Ns13_Dde_source_conversion_mode* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns13_Dde_source_conversion_mode_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Dde_application                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Dde_application (OSCTXT* pctxt, 
   Ns13_Dde_application *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns13_Dde_application (OSCTXT* pctxt, Ns13_Dde_application* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Dde_item                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Dde_item (OSCTXT* pctxt, Ns13_Dde_item *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns13_Dde_item (OSCTXT* pctxt, Ns13_Dde_item* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Dde_topic                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Dde_topic (OSCTXT* pctxt, Ns13_Dde_topic *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns13_Dde_topic (OSCTXT* pctxt, Ns13_Dde_topic* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Dde_source                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Dde_source (OSCTXT* pctxt, Ns13_Dde_source *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode automatic_update */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Automatic_update (pctxt, 
               &pvalue->automatic_update, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.automatic_updatePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode conversion_mode */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Dde_source_conversion_mode (pctxt, 
               &pvalue->conversion_mode, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.conversion_modePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode dde_application */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Dde_application (pctxt, 
               &pvalue->dde_application, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode dde_item */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Dde_item (pctxt, 
               &pvalue->dde_item, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode dde_topic */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Dde_topic (pctxt, 
               &pvalue->dde_topic, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Name (pctxt, 
               &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns13_Dde_source (OSCTXT* pctxt, Ns13_Dde_source* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("automatic-update"), 16}, 0 },
         { {OSUTF8("conversion-mode"), 15}, 0 },
         { {OSUTF8("dde-application"), 15}, 0 },
         { {OSUTF8("dde-item"), 8}, 0 },
         { {OSUTF8("dde-topic"), 9}, 0 },
         { {OSUTF8("name"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 6, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* automatic-update */
            stat = XmlDec_Ns13_Automatic_update (pctxt, &pvalue->
               automatic_update);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.automatic_updatePresent = TRUE;
            break;

         case 1: /* conversion-mode */
            stat = XmlDec_Ns13_Dde_source_conversion_mode (pctxt, &pvalue->
               conversion_mode);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.conversion_modePresent = TRUE;
            break;

         case 2: /* dde-application */
            stat = XmlDec_Ns13_Dde_application (pctxt, &pvalue->dde_application
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* dde-item */
            stat = XmlDec_Ns13_Dde_item (pctxt, &pvalue->dde_item);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* dde-topic */
            stat = XmlDec_Ns13_Dde_topic (pctxt, &pvalue->dde_topic);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* name */
            stat = XmlDec_Ns13_Name (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns13_Dde_source");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns13_Dde_source");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Target_frame_alt_1                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Target_frame_alt_1 (OSCTXT* pctxt, 
   Ns13_Target_frame_alt_1 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns13_Target_frame_alt_1 (OSCTXT* pctxt, 
   Ns13_Target_frame_alt_1* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns13_Target_frame_alt_1_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Target_frame_alt_2                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Target_frame_alt_2 (OSCTXT* pctxt, 
   Ns13_Target_frame_alt_2 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns13_Target_frame_alt_2 (OSCTXT* pctxt, 
   Ns13_Target_frame_alt_2* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns13_Target_frame_alt_2_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Target_frame_alt_3                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Target_frame_alt_3 (OSCTXT* pctxt, 
   Ns13_Target_frame_alt_3 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns13_Target_frame_alt_3 (OSCTXT* pctxt, 
   Ns13_Target_frame_alt_3* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns13_Target_frame_alt_3_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Target_frame_alt_4                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Target_frame_alt_4 (OSCTXT* pctxt, 
   Ns13_Target_frame_alt_4 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns13_Target_frame_alt_4 (OSCTXT* pctxt, 
   Ns13_Target_frame_alt_4* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns13_Target_frame_alt_4_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Target_frame                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Target_frame (OSCTXT* pctxt, Ns13_Target_frame *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
         stat = asn1D_Ns13_Target_frame_alt_1 (pctxt, 
            &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_PRIM|2):
         stat = asn1D_Ns13_Target_frame_alt_2 (pctxt, 
            &pvalue->u.alt_2, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_PRIM|3):
         stat = asn1D_Ns13_Target_frame_alt_3 (pctxt, 
            &pvalue->u.alt_3, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_PRIM|4):
         stat = asn1D_Ns13_Target_frame_alt_4 (pctxt, 
            &pvalue->u.alt_4, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns13_Target_frame (OSCTXT* pctxt, Ns13_Target_frame* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      stat = Ns13_Target_frame_alt_1_ToEnum (pctxt, pdata1, &pvalue->u.alt_1);
      if (stat == 0) pvalue->t = 2;
   }
   if (pvalue->t == 0) {
      stat = Ns13_Target_frame_alt_2_ToEnum (pctxt, pdata1, &pvalue->u.alt_2);
      if (stat == 0) pvalue->t = 3;
   }
   if (pvalue->t == 0) {
      stat = Ns13_Target_frame_alt_3_ToEnum (pctxt, pdata1, &pvalue->u.alt_3);
      if (stat == 0) pvalue->t = 4;
   }
   if (pvalue->t == 0) {
      stat = Ns13_Target_frame_alt_4_ToEnum (pctxt, pdata1, &pvalue->u.alt_4);
      if (stat == 0) pvalue->t = 5;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Boolean_value                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Boolean_value (OSCTXT* pctxt, 
   Ns13_Boolean_value *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns13_Boolean_value (OSCTXT* pctxt, Ns13_Boolean_value* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns13_Boolean_value_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Currency                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Currency (OSCTXT* pctxt, Ns13_Currency *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns13_Currency (OSCTXT* pctxt, Ns13_Currency* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Date_value                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Date_value (OSCTXT* pctxt, Ns13_Date_value *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_charstr (pctxt, &pvalue->u.alt, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|26), length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_charstr (pctxt, &pvalue->u.alt_1, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|26), length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns13_Date_value (OSCTXT* pctxt, Ns13_Date_value* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = (const char*)pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = (const char*)pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  String_value                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_String_value (OSCTXT* pctxt, Ns13_String_value *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns13_String_value (OSCTXT* pctxt, Ns13_String_value* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Time_value                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Time_value (OSCTXT* pctxt, Ns13_Time_value *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns13_Time_value (OSCTXT* pctxt, Ns13_Time_value* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Value                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Value (OSCTXT* pctxt, Ns13_Value *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_real (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns13_Value (OSCTXT* pctxt, Ns13_Value* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDouble (pctxt, pvalue, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Forms_element                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Forms_element (OSCTXT* pctxt, 
   Ns13_Forms_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.form = rtxMemAllocType (pctxt, Form);

         if (pvalue->u.form == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Form ((Form*)pvalue->u.form);
         stat = asn1D_Form (pctxt, 
            (Form*)pvalue->u.form, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.model = rtxMemAllocType (pctxt, Model);

         if (pvalue->u.model == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Model ((Model*)pvalue->u.model);
         stat = asn1D_Model (pctxt, 
            (Model*)pvalue->u.model, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns13_Forms_element (OSCTXT* pctxt, Ns13_Forms_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("form"), 4}, 0}, 0 },
      {{{OSUTF8("model"), 5}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* form */
      pvalue->u.form = rtxMemAllocType (pctxt, Form);

      if (pvalue->u.form == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Form ((Form*)pvalue->u.form);

      stat = XmlDec_Form (pctxt, pvalue->u.form);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* model */
      pvalue->u.model = rtxMemAllocType (pctxt, Model);

      if (pvalue->u.model == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Model ((Model*)pvalue->u.model);

      stat = XmlDec_Model (pctxt, pvalue->u.model);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Forms                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Forms (OSCTXT* pctxt, Ns13_Forms *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode apply_design_mode */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Apply_design_mode (pctxt, 
               (Apply_design_mode*)&pvalue->apply_design_mode, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.apply_design_modePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode automatic_focus */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Automatic_focus (pctxt, 
               (Automatic_focus*)&pvalue->automatic_focus, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.automatic_focusPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns13_Forms_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns13_Forms_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns13_Forms_element (pdata2);

                  stat = asn1D_Ns13_Forms_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns13_Forms (OSCTXT* pctxt, Ns13_Forms* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("apply-design-mode"), 17}, 0 },
         { {OSUTF8("automatic-focus"), 15}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* apply-design-mode */
            stat = XmlDec_Apply_design_mode (pctxt, &pvalue->apply_design_mode
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.apply_design_modePresent = TRUE;
            break;

         case 1: /* automatic-focus */
            stat = XmlDec_Automatic_focus (pctxt, &pvalue->automatic_focus);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.automatic_focusPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns13_Forms");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns13_Forms");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("form"), 4}, 0}, 0 },
      {{{OSUTF8("model"), 5}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Ns13_Forms_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns13_Forms_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Forms_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns13_Forms_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 2, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Server_map                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Server_map (OSCTXT* pctxt, Ns13_Server_map *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns13_Server_map (OSCTXT* pctxt, Ns13_Server_map* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns13_Server_map_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Meta                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Meta (OSCTXT* pctxt, Ns13_Meta *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   Odf_Element14* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (XD_PEEKTAG (pctxt, 0x30)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_UNIV|TM_CONS|16));

   if (XD_PEEKTAG (pctxt, 0xa0)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_CTXT|TM_CONS|0));

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      rtxDListAllocNodeAndData (pctxt, Odf_Element14, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1D_Odf_Element14 (pctxt, 
         (Odf_Element14*)pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

int XmlDec_Ns13_Meta (OSCTXT* pctxt, Ns13_Meta* pvalue)
{
   int stat = 0;

   { OSXSDAny* pdata1;
   OSXMLElemDescr elemDescr;
   const OSUTF8CHAR* pxmlstr;
   for (;;) {
      stat = rtXmlpGetNextElem (pctxt, &elemDescr, -1);
      if (0 != stat) break;

      stat = rtXmlpDecAnyElem (pctxt, &pxmlstr);
      if (0 != stat) break;

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      pdata1 = rtxMemAllocType (pctxt, OSXSDAny);
      if (0 == pdata1) return LOG_RTERR (pctxt, RTERR_NOMEM);

      pdata1->t = OSXSDAny_xmlText;
      pdata1->u.xmlText = pxmlstr;

      if (0 == rtxDListAppend (pctxt, pvalue, pdata1))
         return LOG_RTERR (pctxt, RTERR_NOMEM);
   }
   if (stat == XML_OK_EOB) stat = 0;
   else return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Settings                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Settings (OSCTXT* pctxt, Ns13_Settings *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode config_item_set_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Config_item_set* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->config_item_set_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Config_item_set, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Config_item_set (pdata2);

                  stat = asn1D_Config_item_set (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->config_item_set_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns13_Settings (OSCTXT* pctxt, Ns13_Settings* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("config-item-set"), 15}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Config_item_set* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Config_item_set);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Config_item_set (pdata1);

            stat = XmlDec_Config_item_set (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->config_item_set_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Script                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Script (OSCTXT* pctxt, Ns13_Script *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns6_Language (pctxt, 
               &pvalue->language, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode element14_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Element14* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->element14_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Element14, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = asn1D_Odf_Element14 (pctxt, 
                     (Odf_Element14*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->element14_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns13_Script (OSCTXT* pctxt, Ns13_Script* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("language"), 8}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* language */
            stat = XmlDec_Ns6_Language (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns13_Script");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns13_Script");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { OSXSDAny* pdata1;
   OSXMLElemDescr elemDescr;
   const OSUTF8CHAR* pxmlstr;
   for (;;) {
      stat = rtXmlpGetNextElem (pctxt, &elemDescr, -1);
      if (0 != stat) break;

      stat = rtXmlpDecAnyElem (pctxt, &pxmlstr);
      if (0 != stat) break;

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      pdata1 = rtxMemAllocType (pctxt, OSXSDAny);
      if (0 == pdata1) return LOG_RTERR (pctxt, RTERR_NOMEM);

      pdata1->t = OSXSDAny_xmlText;
      pdata1->u.xmlText = pxmlstr;

      if (0 == rtxDListAppend (pctxt, &pvalue->element14_list, pdata1))
         return LOG_RTERR (pctxt, RTERR_NOMEM);
   }
   if (stat == XML_OK_EOB) stat = 0;
   else return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Scripts                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Scripts (OSCTXT* pctxt, Ns13_Scripts *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode script_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns13_Script* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->script_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns13_Script, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns13_Script (pdata2);

                  stat = asn1D_Ns13_Script (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->script_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               &pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns13_Scripts (OSCTXT* pctxt, Ns13_Scripts* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("script"), 6}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Ns13_Script* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns13_Script);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Script (pdata1);

            stat = XmlDec_Ns13_Script (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->script_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Font_face_decls                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Font_face_decls (OSCTXT* pctxt, 
   Ns13_Font_face_decls *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode font_face_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns8_Font_face* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->font_face_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns8_Font_face, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns8_Font_face ((Ns8_Font_face*)pdata2);

                  stat = asn1D_Ns8_Font_face (pctxt, 
                     (Ns8_Font_face*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->font_face_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns13_Font_face_decls (OSCTXT* pctxt, Ns13_Font_face_decls* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("font-face"), 9}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Ns8_Font_face* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns8_Font_face);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Font_face ((Ns8_Font_face*)pdata1);

            stat = XmlDec_Ns8_Font_face (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->font_face_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Styles_element                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Styles_element (OSCTXT* pctxt, 
   Ns13_Styles_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.style = rtxMemAllocType (pctxt, Ns8_Style);

         if (pvalue->u.style == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns8_Style ((Ns8_Style*)pvalue->u.style);
         stat = asn1D_Ns8_Style (pctxt, 
            (Ns8_Style*)pvalue->u.style, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.list_style = rtxMemAllocType (pctxt, Odf_List_style);

         if (pvalue->u.list_style == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List_style ((Odf_List_style*)pvalue->u.list_style);
         stat = asn1D_Odf_List_style (pctxt, 
            (Odf_List_style*)pvalue->u.list_style, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.number_style = rtxMemAllocType (pctxt, Number_style);

         if (pvalue->u.number_style == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Number_style ((Number_style*)pvalue->u.number_style);
         stat = asn1D_Number_style (pctxt, 
            (Number_style*)pvalue->u.number_style, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.currency_style = rtxMemAllocType (pctxt, Currency_style);

         if (pvalue->u.currency_style == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Currency_style ((Currency_style*)pvalue->u.currency_style);
         stat = asn1D_Currency_style (pctxt, 
            (Currency_style*)pvalue->u.currency_style, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.percentage_style
             = rtxMemAllocType (pctxt, Percentage_style);

         if (pvalue->u.percentage_style == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Percentage_style ((Percentage_style*)pvalue->u.percentage_style);
         stat = asn1D_Percentage_style (pctxt, 
            (Percentage_style*)pvalue->u.percentage_style, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.date_style = rtxMemAllocType (pctxt, Date_style);

         if (pvalue->u.date_style == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Date_style ((Date_style*)pvalue->u.date_style);
         stat = asn1D_Date_style (pctxt, 
            (Date_style*)pvalue->u.date_style, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.time_style = rtxMemAllocType (pctxt, Time_style);

         if (pvalue->u.time_style == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Time_style ((Time_style*)pvalue->u.time_style);
         stat = asn1D_Time_style (pctxt, 
            (Time_style*)pvalue->u.time_style, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.boolean_style = rtxMemAllocType (pctxt, Boolean_style);

         if (pvalue->u.boolean_style == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Boolean_style ((Boolean_style*)pvalue->u.boolean_style);
         stat = asn1D_Boolean_style (pctxt, 
            (Boolean_style*)pvalue->u.boolean_style, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.text_style = rtxMemAllocType (pctxt, Text_style);

         if (pvalue->u.text_style == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Text_style ((Text_style*)pvalue->u.text_style);
         stat = asn1D_Text_style (pctxt, 
            (Text_style*)pvalue->u.text_style, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.default_style = rtxMemAllocType (pctxt, Ns8_Default_style);

         if (pvalue->u.default_style == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns8_Default_style ((Ns8_Default_style*)pvalue->u.default_style);
         stat = asn1D_Ns8_Default_style (pctxt, 
            (Ns8_Default_style*)pvalue->u.default_style, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.outline_style = rtxMemAllocType (pctxt, Odf_Outline_style);

         if (pvalue->u.outline_style == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Outline_style ((Odf_Outline_style*)pvalue->u.outline_style);
         stat = asn1D_Odf_Outline_style (pctxt, 
            (Odf_Outline_style*)pvalue->u.outline_style, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.notes_configuration
             = rtxMemAllocType (pctxt, Odf_Notes_configuration);

         if (pvalue->u.notes_configuration == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Notes_configuration ((Odf_Notes_configuration*)pvalue->u.notes_configuration);
         stat = asn1D_Odf_Notes_configuration (pctxt, 
            (Odf_Notes_configuration*)pvalue->u.notes_configuration, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.bibliography_configuration
             = rtxMemAllocType (pctxt, Odf_Bibliography_configuration);

         if (pvalue->u.bibliography_configuration == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bibliography_configuration ((Odf_Bibliography_configuration*)pvalue->u.bibliography_configuration);
         stat = asn1D_Odf_Bibliography_configuration (pctxt, 
            (Odf_Bibliography_configuration*)pvalue->u.bibliography_configuration, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.linenumbering_configuration
             = rtxMemAllocType (pctxt, Odf_Linenumbering_configuration);

         if (pvalue->u.linenumbering_configuration == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Linenumbering_configuration ((Odf_Linenumbering_configuration*)pvalue->u.linenumbering_configuration);
         stat = asn1D_Odf_Linenumbering_configuration (pctxt, 
            (Odf_Linenumbering_configuration*)pvalue->u.linenumbering_configuration, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.gradient = rtxMemAllocType (pctxt, Ns3_Gradient);

         if (pvalue->u.gradient == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Gradient ((Ns3_Gradient*)pvalue->u.gradient);
         stat = asn1D_Ns3_Gradient (pctxt, 
            (Ns3_Gradient*)pvalue->u.gradient, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.linearGradient = rtxMemAllocType (pctxt, LinearGradient);

         if (pvalue->u.linearGradient == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_LinearGradient ((LinearGradient*)pvalue->u.linearGradient);
         stat = asn1D_LinearGradient (pctxt, 
            (LinearGradient*)pvalue->u.linearGradient, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.radialGradient = rtxMemAllocType (pctxt, RadialGradient);

         if (pvalue->u.radialGradient == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RadialGradient ((RadialGradient*)pvalue->u.radialGradient);
         stat = asn1D_RadialGradient (pctxt, 
            (RadialGradient*)pvalue->u.radialGradient, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      case (TM_CTXT|TM_CONS|17):
         pvalue->u.hatch = rtxMemAllocType (pctxt, Ns3_Hatch);

         if (pvalue->u.hatch == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Hatch ((Ns3_Hatch*)pvalue->u.hatch);
         stat = asn1D_Ns3_Hatch (pctxt, 
            (Ns3_Hatch*)pvalue->u.hatch, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 18;
         break;

      case (TM_CTXT|TM_CONS|18):
         pvalue->u.fill_image = rtxMemAllocType (pctxt, Ns3_Fill_image);

         if (pvalue->u.fill_image == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Fill_image ((Ns3_Fill_image*)pvalue->u.fill_image);
         stat = asn1D_Ns3_Fill_image (pctxt, 
            (Ns3_Fill_image*)pvalue->u.fill_image, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 19;
         break;

      case (TM_CTXT|TM_CONS|19):
         pvalue->u.marker = rtxMemAllocType (pctxt, Ns3_Marker);

         if (pvalue->u.marker == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Marker ((Ns3_Marker*)pvalue->u.marker);
         stat = asn1D_Ns3_Marker (pctxt, 
            (Ns3_Marker*)pvalue->u.marker, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 20;
         break;

      case (TM_CTXT|TM_CONS|20):
         pvalue->u.stroke_dash = rtxMemAllocType (pctxt, Ns3_Stroke_dash);

         if (pvalue->u.stroke_dash == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Stroke_dash ((Ns3_Stroke_dash*)pvalue->u.stroke_dash);
         stat = asn1D_Ns3_Stroke_dash (pctxt, 
            (Ns3_Stroke_dash*)pvalue->u.stroke_dash, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 21;
         break;

      case (TM_CTXT|TM_CONS|21):
         pvalue->u.opacity = rtxMemAllocType (pctxt, Ns3_Opacity);

         if (pvalue->u.opacity == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Opacity ((Ns3_Opacity*)pvalue->u.opacity);
         stat = asn1D_Ns3_Opacity (pctxt, 
            (Ns3_Opacity*)pvalue->u.opacity, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 22;
         break;

      case (TM_CTXT|TM_CONS|22):
         pvalue->u.presentation_page_layout
             = rtxMemAllocType (pctxt, Ns8_Presentation_page_layout);

         if (pvalue->u.presentation_page_layout == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns8_Presentation_page_layout ((Ns8_Presentation_page_layout*)pvalue->u.presentation_page_layout);
         stat = asn1D_Ns8_Presentation_page_layout (pctxt, 
            (Ns8_Presentation_page_layout*)pvalue->u.presentation_page_layout, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 23;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns13_Styles_element (OSCTXT* pctxt, Ns13_Styles_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("style"), 5}, 0}, 0 },
      {{{OSUTF8("list-style"), 10}, 0}, 1 },
      {{{OSUTF8("number-style"), 12}, 0}, 2 },
      {{{OSUTF8("currency-style"), 14}, 0}, 3 },
      {{{OSUTF8("percentage-style"), 16}, 0}, 4 },
      {{{OSUTF8("date-style"), 10}, 0}, 5 },
      {{{OSUTF8("time-style"), 10}, 0}, 6 },
      {{{OSUTF8("boolean-style"), 13}, 0}, 7 },
      {{{OSUTF8("text-style"), 10}, 0}, 8 },
      {{{OSUTF8("default-style"), 13}, 0}, 9 },
      {{{OSUTF8("outline-style"), 13}, 0}, 10 },
      {{{OSUTF8("notes-configuration"), 19}, 0}, 11 },
      {{{OSUTF8("bibliography-configuration"), 26}, 0}, 12 },
      {{{OSUTF8("linenumbering-configuration"), 27}, 0}, 13 },
      {{{OSUTF8("gradient"), 8}, 0}, 14 },
      {{{OSUTF8("linearGradient"), 14}, 0}, 15 },
      {{{OSUTF8("radialGradient"), 14}, 0}, 16 },
      {{{OSUTF8("hatch"), 5}, 0}, 17 },
      {{{OSUTF8("fill-image"), 10}, 0}, 18 },
      {{{OSUTF8("marker"), 6}, 0}, 19 },
      {{{OSUTF8("stroke-dash"), 11}, 0}, 20 },
      {{{OSUTF8("opacity"), 7}, 0}, 21 },
      {{{OSUTF8("presentation-page-layout"), 24}, 0}, 22 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 23, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* style */
      pvalue->u.style = rtxMemAllocType (pctxt, Ns8_Style);

      if (pvalue->u.style == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns8_Style ((Ns8_Style*)pvalue->u.style);

      stat = XmlDec_Ns8_Style (pctxt, pvalue->u.style);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* list-style */
      pvalue->u.list_style = rtxMemAllocType (pctxt, Odf_List_style);

      if (pvalue->u.list_style == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List_style ((Odf_List_style*)pvalue->u.list_style);

      stat = XmlDec_Odf_List_style (pctxt, pvalue->u.list_style);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* number-style */
      pvalue->u.number_style = rtxMemAllocType (pctxt, Number_style);

      if (pvalue->u.number_style == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Number_style ((Number_style*)pvalue->u.number_style);

      stat = XmlDec_Number_style (pctxt, pvalue->u.number_style);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* currency-style */
      pvalue->u.currency_style = rtxMemAllocType (pctxt, Currency_style);

      if (pvalue->u.currency_style == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Currency_style ((Currency_style*)pvalue->u.currency_style);

      stat = XmlDec_Currency_style (pctxt, pvalue->u.currency_style);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* percentage-style */
      pvalue->u.percentage_style = rtxMemAllocType (pctxt, Percentage_style);

      if (pvalue->u.percentage_style == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Percentage_style ((Percentage_style*)pvalue->u.percentage_style
         );

      stat = XmlDec_Percentage_style (pctxt, pvalue->u.percentage_style);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* date-style */
      pvalue->u.date_style = rtxMemAllocType (pctxt, Date_style);

      if (pvalue->u.date_style == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Date_style ((Date_style*)pvalue->u.date_style);

      stat = XmlDec_Date_style (pctxt, pvalue->u.date_style);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* time-style */
      pvalue->u.time_style = rtxMemAllocType (pctxt, Time_style);

      if (pvalue->u.time_style == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Time_style ((Time_style*)pvalue->u.time_style);

      stat = XmlDec_Time_style (pctxt, pvalue->u.time_style);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* boolean-style */
      pvalue->u.boolean_style = rtxMemAllocType (pctxt, Boolean_style);

      if (pvalue->u.boolean_style == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Boolean_style ((Boolean_style*)pvalue->u.boolean_style);

      stat = XmlDec_Boolean_style (pctxt, pvalue->u.boolean_style);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* text-style */
      pvalue->u.text_style = rtxMemAllocType (pctxt, Text_style);

      if (pvalue->u.text_style == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Text_style ((Text_style*)pvalue->u.text_style);

      stat = XmlDec_Text_style (pctxt, pvalue->u.text_style);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* default-style */
      pvalue->u.default_style = rtxMemAllocType (pctxt, Ns8_Default_style);

      if (pvalue->u.default_style == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns8_Default_style ((Ns8_Default_style*)pvalue->u.default_style
         );

      stat = XmlDec_Ns8_Default_style (pctxt, pvalue->u.default_style);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* outline-style */
      pvalue->u.outline_style = rtxMemAllocType (pctxt, Odf_Outline_style);

      if (pvalue->u.outline_style == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Outline_style ((Odf_Outline_style*)pvalue->u.outline_style
         );

      stat = XmlDec_Odf_Outline_style (pctxt, pvalue->u.outline_style);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* notes-configuration */
      pvalue->u.notes_configuration
          = rtxMemAllocType (pctxt, Odf_Notes_configuration);

      if (pvalue->u.notes_configuration == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Notes_configuration ((Odf_Notes_configuration*)pvalue->
         u.notes_configuration);

      stat = XmlDec_Odf_Notes_configuration (pctxt, pvalue->
         u.notes_configuration);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* bibliography-configuration */
      pvalue->u.bibliography_configuration
          = rtxMemAllocType (pctxt, Odf_Bibliography_configuration);

      if (pvalue->u.bibliography_configuration == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bibliography_configuration (
         (Odf_Bibliography_configuration*)pvalue->u.bibliography_configuration
         );

      stat = XmlDec_Odf_Bibliography_configuration (pctxt, pvalue->
         u.bibliography_configuration);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* linenumbering-configuration */
      pvalue->u.linenumbering_configuration
          = rtxMemAllocType (pctxt, Odf_Linenumbering_configuration);

      if (pvalue->u.linenumbering_configuration == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Linenumbering_configuration (
         (Odf_Linenumbering_configuration*)pvalue->
         u.linenumbering_configuration);

      stat = XmlDec_Odf_Linenumbering_configuration (pctxt, pvalue->
         u.linenumbering_configuration);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* gradient */
      pvalue->u.gradient = rtxMemAllocType (pctxt, Ns3_Gradient);

      if (pvalue->u.gradient == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Gradient ((Ns3_Gradient*)pvalue->u.gradient);

      stat = XmlDec_Ns3_Gradient (pctxt, pvalue->u.gradient);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* linearGradient */
      pvalue->u.linearGradient = rtxMemAllocType (pctxt, LinearGradient);

      if (pvalue->u.linearGradient == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_LinearGradient ((LinearGradient*)pvalue->u.linearGradient);

      stat = XmlDec_LinearGradient (pctxt, pvalue->u.linearGradient);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* radialGradient */
      pvalue->u.radialGradient = rtxMemAllocType (pctxt, RadialGradient);

      if (pvalue->u.radialGradient == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RadialGradient ((RadialGradient*)pvalue->u.radialGradient);

      stat = XmlDec_RadialGradient (pctxt, pvalue->u.radialGradient);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 17: { /* hatch */
      pvalue->u.hatch = rtxMemAllocType (pctxt, Ns3_Hatch);

      if (pvalue->u.hatch == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Hatch ((Ns3_Hatch*)pvalue->u.hatch);

      stat = XmlDec_Ns3_Hatch (pctxt, pvalue->u.hatch);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 18: { /* fill-image */
      pvalue->u.fill_image = rtxMemAllocType (pctxt, Ns3_Fill_image);

      if (pvalue->u.fill_image == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Fill_image ((Ns3_Fill_image*)pvalue->u.fill_image);

      stat = XmlDec_Ns3_Fill_image (pctxt, pvalue->u.fill_image);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 19: { /* marker */
      pvalue->u.marker = rtxMemAllocType (pctxt, Ns3_Marker);

      if (pvalue->u.marker == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Marker ((Ns3_Marker*)pvalue->u.marker);

      stat = XmlDec_Ns3_Marker (pctxt, pvalue->u.marker);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 20: { /* stroke-dash */
      pvalue->u.stroke_dash = rtxMemAllocType (pctxt, Ns3_Stroke_dash);

      if (pvalue->u.stroke_dash == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Stroke_dash ((Ns3_Stroke_dash*)pvalue->u.stroke_dash);

      stat = XmlDec_Ns3_Stroke_dash (pctxt, pvalue->u.stroke_dash);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 21: { /* opacity */
      pvalue->u.opacity = rtxMemAllocType (pctxt, Ns3_Opacity);

      if (pvalue->u.opacity == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Opacity ((Ns3_Opacity*)pvalue->u.opacity);

      stat = XmlDec_Ns3_Opacity (pctxt, pvalue->u.opacity);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 22: { /* presentation-page-layout */
      pvalue->u.presentation_page_layout
          = rtxMemAllocType (pctxt, Ns8_Presentation_page_layout);

      if (pvalue->u.presentation_page_layout == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns8_Presentation_page_layout ((Ns8_Presentation_page_layout*)
         pvalue->u.presentation_page_layout);

      stat = XmlDec_Ns8_Presentation_page_layout (pctxt, pvalue->
         u.presentation_page_layout);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Styles                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Styles (OSCTXT* pctxt, Ns13_Styles *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   Ns13_Styles_element* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (XD_PEEKTAG (pctxt, 0x30)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_UNIV|TM_CONS|16));

   if (XD_PEEKTAG (pctxt, 0xa0)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_CTXT|TM_CONS|0));

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      rtxDListAllocNodeAndData (pctxt, Ns13_Styles_element, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns13_Styles_element (pdata1);

      stat = asn1D_Ns13_Styles_element (pctxt, 
         pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

int XmlDec_Ns13_Styles (OSCTXT* pctxt, Ns13_Styles* pvalue)
{
   int stat = 0;

   { int elemID;
   Ns13_Styles_element* pdata1;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("style"), 5}, 0}, 0 },
      {{{OSUTF8("list-style"), 10}, 0}, 0 },
      {{{OSUTF8("number-style"), 12}, 0}, 0 },
      {{{OSUTF8("currency-style"), 14}, 0}, 0 },
      {{{OSUTF8("percentage-style"), 16}, 0}, 0 },
      {{{OSUTF8("date-style"), 10}, 0}, 0 },
      {{{OSUTF8("time-style"), 10}, 0}, 0 },
      {{{OSUTF8("boolean-style"), 13}, 0}, 0 },
      {{{OSUTF8("text-style"), 10}, 0}, 0 },
      {{{OSUTF8("default-style"), 13}, 0}, 0 },
      {{{OSUTF8("outline-style"), 13}, 0}, 0 },
      {{{OSUTF8("notes-configuration"), 19}, 0}, 0 },
      {{{OSUTF8("bibliography-configuration"), 26}, 0}, 0 },
      {{{OSUTF8("linenumbering-configuration"), 27}, 0}, 0 },
      {{{OSUTF8("gradient"), 8}, 0}, 0 },
      {{{OSUTF8("linearGradient"), 14}, 0}, 0 },
      {{{OSUTF8("radialGradient"), 14}, 0}, 0 },
      {{{OSUTF8("hatch"), 5}, 0}, 0 },
      {{{OSUTF8("fill-image"), 10}, 0}, 0 },
      {{{OSUTF8("marker"), 6}, 0}, 0 },
      {{{OSUTF8("stroke-dash"), 11}, 0}, 0 },
      {{{OSUTF8("opacity"), 7}, 0}, 0 },
      {{{OSUTF8("presentation-page-layout"), 24}, 0}, 0 }
   } ;

   rtxDListInit (pvalue);
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 23, -1, FALSE);
      if (elemID < 0 || elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0:
         rtXmlpMarkLastEventActive (pctxt);

         pdata1 = rtxMemAllocType (pctxt, Ns13_Styles_element);

         if (pdata1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Styles_element (pdata1);

         stat = XmlDec_Ns13_Styles_element (pctxt, pdata1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         break;

      }
   }

   if (elemID == RTERR_UNEXPELEM || elemID == XML_OK_EOB) {
      stat = 0;
   }
   else return LOG_RTERR (pctxt, elemID);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Automatic_styles_element                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Automatic_styles_element (OSCTXT* pctxt, 
   Ns13_Automatic_styles_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.style = rtxMemAllocType (pctxt, Ns8_Style);

         if (pvalue->u.style == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns8_Style ((Ns8_Style*)pvalue->u.style);
         stat = asn1D_Ns8_Style (pctxt, 
            (Ns8_Style*)pvalue->u.style, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.list_style = rtxMemAllocType (pctxt, Odf_List_style);

         if (pvalue->u.list_style == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List_style ((Odf_List_style*)pvalue->u.list_style);
         stat = asn1D_Odf_List_style (pctxt, 
            (Odf_List_style*)pvalue->u.list_style, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.number_style = rtxMemAllocType (pctxt, Number_style);

         if (pvalue->u.number_style == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Number_style ((Number_style*)pvalue->u.number_style);
         stat = asn1D_Number_style (pctxt, 
            (Number_style*)pvalue->u.number_style, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.currency_style = rtxMemAllocType (pctxt, Currency_style);

         if (pvalue->u.currency_style == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Currency_style ((Currency_style*)pvalue->u.currency_style);
         stat = asn1D_Currency_style (pctxt, 
            (Currency_style*)pvalue->u.currency_style, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.percentage_style
             = rtxMemAllocType (pctxt, Percentage_style);

         if (pvalue->u.percentage_style == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Percentage_style ((Percentage_style*)pvalue->u.percentage_style);
         stat = asn1D_Percentage_style (pctxt, 
            (Percentage_style*)pvalue->u.percentage_style, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.date_style = rtxMemAllocType (pctxt, Date_style);

         if (pvalue->u.date_style == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Date_style ((Date_style*)pvalue->u.date_style);
         stat = asn1D_Date_style (pctxt, 
            (Date_style*)pvalue->u.date_style, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.time_style = rtxMemAllocType (pctxt, Time_style);

         if (pvalue->u.time_style == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Time_style ((Time_style*)pvalue->u.time_style);
         stat = asn1D_Time_style (pctxt, 
            (Time_style*)pvalue->u.time_style, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.boolean_style = rtxMemAllocType (pctxt, Boolean_style);

         if (pvalue->u.boolean_style == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Boolean_style ((Boolean_style*)pvalue->u.boolean_style);
         stat = asn1D_Boolean_style (pctxt, 
            (Boolean_style*)pvalue->u.boolean_style, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.text_style = rtxMemAllocType (pctxt, Text_style);

         if (pvalue->u.text_style == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Text_style ((Text_style*)pvalue->u.text_style);
         stat = asn1D_Text_style (pctxt, 
            (Text_style*)pvalue->u.text_style, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.page_layout = rtxMemAllocType (pctxt, Ns8_Page_layout);

         if (pvalue->u.page_layout == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns8_Page_layout ((Ns8_Page_layout*)pvalue->u.page_layout);
         stat = asn1D_Ns8_Page_layout (pctxt, 
            (Ns8_Page_layout*)pvalue->u.page_layout, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns13_Automatic_styles_element (OSCTXT* pctxt, 
   Ns13_Automatic_styles_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("style"), 5}, 0}, 0 },
      {{{OSUTF8("list-style"), 10}, 0}, 1 },
      {{{OSUTF8("number-style"), 12}, 0}, 2 },
      {{{OSUTF8("currency-style"), 14}, 0}, 3 },
      {{{OSUTF8("percentage-style"), 16}, 0}, 4 },
      {{{OSUTF8("date-style"), 10}, 0}, 5 },
      {{{OSUTF8("time-style"), 10}, 0}, 6 },
      {{{OSUTF8("boolean-style"), 13}, 0}, 7 },
      {{{OSUTF8("text-style"), 10}, 0}, 8 },
      {{{OSUTF8("page-layout"), 11}, 0}, 9 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 10, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* style */
      pvalue->u.style = rtxMemAllocType (pctxt, Ns8_Style);

      if (pvalue->u.style == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns8_Style ((Ns8_Style*)pvalue->u.style);

      stat = XmlDec_Ns8_Style (pctxt, pvalue->u.style);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* list-style */
      pvalue->u.list_style = rtxMemAllocType (pctxt, Odf_List_style);

      if (pvalue->u.list_style == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List_style ((Odf_List_style*)pvalue->u.list_style);

      stat = XmlDec_Odf_List_style (pctxt, pvalue->u.list_style);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* number-style */
      pvalue->u.number_style = rtxMemAllocType (pctxt, Number_style);

      if (pvalue->u.number_style == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Number_style ((Number_style*)pvalue->u.number_style);

      stat = XmlDec_Number_style (pctxt, pvalue->u.number_style);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* currency-style */
      pvalue->u.currency_style = rtxMemAllocType (pctxt, Currency_style);

      if (pvalue->u.currency_style == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Currency_style ((Currency_style*)pvalue->u.currency_style);

      stat = XmlDec_Currency_style (pctxt, pvalue->u.currency_style);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* percentage-style */
      pvalue->u.percentage_style = rtxMemAllocType (pctxt, Percentage_style);

      if (pvalue->u.percentage_style == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Percentage_style ((Percentage_style*)pvalue->u.percentage_style
         );

      stat = XmlDec_Percentage_style (pctxt, pvalue->u.percentage_style);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* date-style */
      pvalue->u.date_style = rtxMemAllocType (pctxt, Date_style);

      if (pvalue->u.date_style == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Date_style ((Date_style*)pvalue->u.date_style);

      stat = XmlDec_Date_style (pctxt, pvalue->u.date_style);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* time-style */
      pvalue->u.time_style = rtxMemAllocType (pctxt, Time_style);

      if (pvalue->u.time_style == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Time_style ((Time_style*)pvalue->u.time_style);

      stat = XmlDec_Time_style (pctxt, pvalue->u.time_style);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* boolean-style */
      pvalue->u.boolean_style = rtxMemAllocType (pctxt, Boolean_style);

      if (pvalue->u.boolean_style == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Boolean_style ((Boolean_style*)pvalue->u.boolean_style);

      stat = XmlDec_Boolean_style (pctxt, pvalue->u.boolean_style);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* text-style */
      pvalue->u.text_style = rtxMemAllocType (pctxt, Text_style);

      if (pvalue->u.text_style == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Text_style ((Text_style*)pvalue->u.text_style);

      stat = XmlDec_Text_style (pctxt, pvalue->u.text_style);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* page-layout */
      pvalue->u.page_layout = rtxMemAllocType (pctxt, Ns8_Page_layout);

      if (pvalue->u.page_layout == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns8_Page_layout ((Ns8_Page_layout*)pvalue->u.page_layout);

      stat = XmlDec_Ns8_Page_layout (pctxt, pvalue->u.page_layout);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Automatic_styles                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Automatic_styles (OSCTXT* pctxt, 
   Ns13_Automatic_styles *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   Ns13_Automatic_styles_element* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (XD_PEEKTAG (pctxt, 0x30)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_UNIV|TM_CONS|16));

   if (XD_PEEKTAG (pctxt, 0xa0)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_CTXT|TM_CONS|0));

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      rtxDListAllocNodeAndData (pctxt, Ns13_Automatic_styles_element, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns13_Automatic_styles_element (pdata1);

      stat = asn1D_Ns13_Automatic_styles_element (pctxt, 
         pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

int XmlDec_Ns13_Automatic_styles (OSCTXT* pctxt, Ns13_Automatic_styles* pvalue)
{
   int stat = 0;

   { int elemID;
   Ns13_Automatic_styles_element* pdata1;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("style"), 5}, 0}, 0 },
      {{{OSUTF8("list-style"), 10}, 0}, 0 },
      {{{OSUTF8("number-style"), 12}, 0}, 0 },
      {{{OSUTF8("currency-style"), 14}, 0}, 0 },
      {{{OSUTF8("percentage-style"), 16}, 0}, 0 },
      {{{OSUTF8("date-style"), 10}, 0}, 0 },
      {{{OSUTF8("time-style"), 10}, 0}, 0 },
      {{{OSUTF8("boolean-style"), 13}, 0}, 0 },
      {{{OSUTF8("text-style"), 10}, 0}, 0 },
      {{{OSUTF8("page-layout"), 11}, 0}, 0 }
   } ;

   rtxDListInit (pvalue);
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 10, -1, FALSE);
      if (elemID < 0 || elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0:
         rtXmlpMarkLastEventActive (pctxt);

         pdata1 = rtxMemAllocType (pctxt, Ns13_Automatic_styles_element);

         if (pdata1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Automatic_styles_element (pdata1);

         stat = XmlDec_Ns13_Automatic_styles_element (pctxt, pdata1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         break;

      }
   }

   if (elemID == RTERR_UNEXPELEM || elemID == XML_OK_EOB) {
      stat = 0;
   }
   else return LOG_RTERR (pctxt, elemID);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Master_styles_element                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Master_styles_element (OSCTXT* pctxt, 
   Ns13_Master_styles_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.master_page = rtxMemAllocType (pctxt, Ns8_Master_page);

         if (pvalue->u.master_page == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns8_Master_page ((Ns8_Master_page*)pvalue->u.master_page);
         stat = asn1D_Ns8_Master_page (pctxt, 
            (Ns8_Master_page*)pvalue->u.master_page, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.handout_master
             = rtxMemAllocType (pctxt, Ns8_Handout_master);

         if (pvalue->u.handout_master == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns8_Handout_master ((Ns8_Handout_master*)pvalue->u.handout_master);
         stat = asn1D_Ns8_Handout_master (pctxt, 
            (Ns8_Handout_master*)pvalue->u.handout_master, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.layer_set = rtxMemAllocType (pctxt, Ns3_Layer_set);

         if (pvalue->u.layer_set == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Layer_set ((Ns3_Layer_set*)pvalue->u.layer_set);
         stat = asn1D_Ns3_Layer_set (pctxt, 
            (Ns3_Layer_set*)pvalue->u.layer_set, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns13_Master_styles_element (OSCTXT* pctxt, 
   Ns13_Master_styles_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("master-page"), 11}, 0}, 0 },
      {{{OSUTF8("handout-master"), 14}, 0}, 1 },
      {{{OSUTF8("layer-set"), 9}, 0}, 2 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* master-page */
      pvalue->u.master_page = rtxMemAllocType (pctxt, Ns8_Master_page);

      if (pvalue->u.master_page == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns8_Master_page ((Ns8_Master_page*)pvalue->u.master_page);

      stat = XmlDec_Ns8_Master_page (pctxt, pvalue->u.master_page);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* handout-master */
      pvalue->u.handout_master = rtxMemAllocType (pctxt, Ns8_Handout_master);

      if (pvalue->u.handout_master == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns8_Handout_master ((Ns8_Handout_master*)pvalue->
         u.handout_master);

      stat = XmlDec_Ns8_Handout_master (pctxt, pvalue->u.handout_master);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* layer-set */
      pvalue->u.layer_set = rtxMemAllocType (pctxt, Ns3_Layer_set);

      if (pvalue->u.layer_set == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Layer_set ((Ns3_Layer_set*)pvalue->u.layer_set);

      stat = XmlDec_Ns3_Layer_set (pctxt, pvalue->u.layer_set);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Master_styles                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Master_styles (OSCTXT* pctxt, 
   Ns13_Master_styles *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   Ns13_Master_styles_element* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (XD_PEEKTAG (pctxt, 0x30)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_UNIV|TM_CONS|16));

   if (XD_PEEKTAG (pctxt, 0xa0)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_CTXT|TM_CONS|0));

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      rtxDListAllocNodeAndData (pctxt, Ns13_Master_styles_element, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns13_Master_styles_element (pdata1);

      stat = asn1D_Ns13_Master_styles_element (pctxt, 
         pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

int XmlDec_Ns13_Master_styles (OSCTXT* pctxt, Ns13_Master_styles* pvalue)
{
   int stat = 0;

   { int elemID;
   Ns13_Master_styles_element* pdata1;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("master-page"), 11}, 0}, 0 },
      {{{OSUTF8("handout-master"), 14}, 0}, 0 },
      {{{OSUTF8("layer-set"), 9}, 0}, 0 }
   } ;

   rtxDListInit (pvalue);
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, FALSE);
      if (elemID < 0 || elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0:
         rtXmlpMarkLastEventActive (pctxt);

         pdata1 = rtxMemAllocType (pctxt, Ns13_Master_styles_element);

         if (pdata1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Master_styles_element (pdata1);

         stat = XmlDec_Ns13_Master_styles_element (pctxt, pdata1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         break;

      }
   }

   if (elemID == RTERR_UNEXPELEM || elemID == XML_OK_EOB) {
      stat = 0;
   }
   else return LOG_RTERR (pctxt, elemID);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Text_element_element                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Text_element_element (OSCTXT* pctxt, 
   Ns13_Text_element_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

         if (pvalue->u.h == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_H ((Odf_H*)pvalue->u.h);
         stat = asn1D_Odf_H (pctxt, 
            (Odf_H*)pvalue->u.h, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P ((Odf_P*)pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            (Odf_P*)pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List ((Odf_List*)pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            (Odf_List*)pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.numbered_paragraph
             = rtxMemAllocType (pctxt, Odf_Numbered_paragraph);

         if (pvalue->u.numbered_paragraph == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Numbered_paragraph ((Odf_Numbered_paragraph*)pvalue->u.numbered_paragraph);
         stat = asn1D_Odf_Numbered_paragraph (pctxt, 
            (Odf_Numbered_paragraph*)pvalue->u.numbered_paragraph, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.table = rtxMemAllocType (pctxt, Table);

         if (pvalue->u.table == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table ((Table*)pvalue->u.table);
         stat = asn1D_Table (pctxt, 
            (Table*)pvalue->u.table, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.a = rtxMemAllocType (pctxt, Ns3_A);

         if (pvalue->u.a == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_A ((Ns3_A*)pvalue->u.a);
         stat = asn1D_Ns3_A (pctxt, 
            (Ns3_A*)pvalue->u.a, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.section = rtxMemAllocType (pctxt, Odf_Section);

         if (pvalue->u.section == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Section ((Odf_Section*)pvalue->u.section);
         stat = asn1D_Odf_Section (pctxt, 
            (Odf_Section*)pvalue->u.section, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.table_of_content
             = rtxMemAllocType (pctxt, Odf_Table_of_content);

         if (pvalue->u.table_of_content == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_of_content ((Odf_Table_of_content*)pvalue->u.table_of_content);
         stat = asn1D_Odf_Table_of_content (pctxt, 
            (Odf_Table_of_content*)pvalue->u.table_of_content, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.illustration_index
             = rtxMemAllocType (pctxt, Odf_Illustration_index);

         if (pvalue->u.illustration_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Illustration_index ((Odf_Illustration_index*)pvalue->u.illustration_index);
         stat = asn1D_Odf_Illustration_index (pctxt, 
            (Odf_Illustration_index*)pvalue->u.illustration_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.table_index = rtxMemAllocType (pctxt, Odf_Table_index);

         if (pvalue->u.table_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_index ((Odf_Table_index*)pvalue->u.table_index);
         stat = asn1D_Odf_Table_index (pctxt, 
            (Odf_Table_index*)pvalue->u.table_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.object_index = rtxMemAllocType (pctxt, Odf_Object_index);

         if (pvalue->u.object_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Object_index ((Odf_Object_index*)pvalue->u.object_index);
         stat = asn1D_Odf_Object_index (pctxt, 
            (Odf_Object_index*)pvalue->u.object_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.user_index = rtxMemAllocType (pctxt, Odf_User_index);

         if (pvalue->u.user_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index ((Odf_User_index*)pvalue->u.user_index);
         stat = asn1D_Odf_User_index (pctxt, 
            (Odf_User_index*)pvalue->u.user_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.alphabetical_index
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index);

         if (pvalue->u.alphabetical_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index ((Odf_Alphabetical_index*)pvalue->u.alphabetical_index);
         stat = asn1D_Odf_Alphabetical_index (pctxt, 
            (Odf_Alphabetical_index*)pvalue->u.alphabetical_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.bibliography = rtxMemAllocType (pctxt, Odf_Bibliography);

         if (pvalue->u.bibliography == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bibliography ((Odf_Bibliography*)pvalue->u.bibliography);
         stat = asn1D_Odf_Bibliography (pctxt, 
            (Odf_Bibliography*)pvalue->u.bibliography, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

         if (pvalue->u.rect == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);
         stat = asn1D_Ns3_Rect (pctxt, 
            (Ns3_Rect*)pvalue->u.rect, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

         if (pvalue->u.line == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);
         stat = asn1D_Ns3_Line (pctxt, 
            (Ns3_Line*)pvalue->u.line, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

         if (pvalue->u.polyline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);
         stat = asn1D_Ns3_Polyline (pctxt, 
            (Ns3_Polyline*)pvalue->u.polyline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      case (TM_CTXT|TM_CONS|17):
         pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

         if (pvalue->u.polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);
         stat = asn1D_Ns3_Polygon (pctxt, 
            (Ns3_Polygon*)pvalue->u.polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 18;
         break;

      case (TM_CTXT|TM_CONS|18):
         pvalue->u.regular_polygon
             = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

         if (pvalue->u.regular_polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->u.regular_polygon);
         stat = asn1D_Ns3_Regular_polygon (pctxt, 
            (Ns3_Regular_polygon*)pvalue->u.regular_polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 19;
         break;

      case (TM_CTXT|TM_CONS|19):
         pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

         if (pvalue->u.path == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);
         stat = asn1D_Ns3_Path (pctxt, 
            (Ns3_Path*)pvalue->u.path, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 20;
         break;

      case (TM_CTXT|TM_CONS|20):
         pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

         if (pvalue->u.circle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);
         stat = asn1D_Ns3_Circle (pctxt, 
            (Ns3_Circle*)pvalue->u.circle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 21;
         break;

      case (TM_CTXT|TM_CONS|21):
         pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

         if (pvalue->u.ellipse == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);
         stat = asn1D_Ns3_Ellipse (pctxt, 
            (Ns3_Ellipse*)pvalue->u.ellipse, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 22;
         break;

      case (TM_CTXT|TM_CONS|22):
         pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

         if (pvalue->u.g == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);
         stat = asn1D_Ns3_G (pctxt, 
            (Ns3_G*)pvalue->u.g, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 23;
         break;

      case (TM_CTXT|TM_CONS|23):
         pvalue->u.page_thumbnail
             = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

         if (pvalue->u.page_thumbnail == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->u.page_thumbnail);
         stat = asn1D_Ns3_Page_thumbnail (pctxt, 
            (Ns3_Page_thumbnail*)pvalue->u.page_thumbnail, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 24;
         break;

      case (TM_CTXT|TM_CONS|24):
         pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

         if (pvalue->u.frame == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);
         stat = asn1D_Ns3_Frame (pctxt, 
            (Ns3_Frame*)pvalue->u.frame, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 25;
         break;

      case (TM_CTXT|TM_CONS|25):
         pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

         if (pvalue->u.measure == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);
         stat = asn1D_Ns3_Measure (pctxt, 
            (Ns3_Measure*)pvalue->u.measure, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 26;
         break;

      case (TM_CTXT|TM_CONS|26):
         pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

         if (pvalue->u.caption == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);
         stat = asn1D_Ns3_Caption (pctxt, 
            (Ns3_Caption*)pvalue->u.caption, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 27;
         break;

      case (TM_CTXT|TM_CONS|27):
         pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

         if (pvalue->u.connector == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);
         stat = asn1D_Ns3_Connector (pctxt, 
            (Ns3_Connector*)pvalue->u.connector, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 28;
         break;

      case (TM_CTXT|TM_CONS|28):
         pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

         if (pvalue->u.control == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);
         stat = asn1D_Ns3_Control (pctxt, 
            (Ns3_Control*)pvalue->u.control, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 29;
         break;

      case (TM_CTXT|TM_CONS|29):
         pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

         if (pvalue->u.scene == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);
         stat = asn1D_Ns7_Scene (pctxt, 
            (Ns7_Scene*)pvalue->u.scene, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 30;
         break;

      case (TM_CTXT|TM_CONS|30):
         pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

         if (pvalue->u.custom_shape == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);
         stat = asn1D_Ns3_Custom_shape (pctxt, 
            (Ns3_Custom_shape*)pvalue->u.custom_shape, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 31;
         break;

      case (TM_CTXT|TM_CONS|31):
         pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

         if (pvalue->u.change == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change ((Odf_Change*)pvalue->u.change);
         stat = asn1D_Odf_Change (pctxt, 
            (Odf_Change*)pvalue->u.change, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 32;
         break;

      case (TM_CTXT|TM_CONS|32):
         pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

         if (pvalue->u.change_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_start ((Odf_Change_start*)pvalue->u.change_start);
         stat = asn1D_Odf_Change_start (pctxt, 
            (Odf_Change_start*)pvalue->u.change_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 33;
         break;

      case (TM_CTXT|TM_CONS|33):
         pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

         if (pvalue->u.change_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_end ((Odf_Change_end*)pvalue->u.change_end);
         stat = asn1D_Odf_Change_end (pctxt, 
            (Odf_Change_end*)pvalue->u.change_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 34;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns13_Text_element_element (OSCTXT* pctxt, 
   Ns13_Text_element_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("h"), 1}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 1 },
      {{{OSUTF8("list"), 4}, 0}, 2 },
      {{{OSUTF8("numbered-paragraph"), 18}, 0}, 3 },
      {{{OSUTF8("table"), 5}, 0}, 4 },
      {{{OSUTF8("a"), 1}, 0}, 5 },
      {{{OSUTF8("section"), 7}, 0}, 6 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 7 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 8 },
      {{{OSUTF8("table-index"), 11}, 0}, 9 },
      {{{OSUTF8("object-index"), 12}, 0}, 10 },
      {{{OSUTF8("user-index"), 10}, 0}, 11 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 12 },
      {{{OSUTF8("bibliography"), 12}, 0}, 13 },
      {{{OSUTF8("rect"), 4}, 0}, 14 },
      {{{OSUTF8("line"), 4}, 0}, 15 },
      {{{OSUTF8("polyline"), 8}, 0}, 16 },
      {{{OSUTF8("polygon"), 7}, 0}, 17 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 18 },
      {{{OSUTF8("path"), 4}, 0}, 19 },
      {{{OSUTF8("circle"), 6}, 0}, 20 },
      {{{OSUTF8("ellipse"), 7}, 0}, 21 },
      {{{OSUTF8("g"), 1}, 0}, 22 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 23 },
      {{{OSUTF8("frame"), 5}, 0}, 24 },
      {{{OSUTF8("measure"), 7}, 0}, 25 },
      {{{OSUTF8("caption"), 7}, 0}, 26 },
      {{{OSUTF8("connector"), 9}, 0}, 27 },
      {{{OSUTF8("control"), 7}, 0}, 28 },
      {{{OSUTF8("scene"), 5}, 0}, 29 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 30 },
      {{{OSUTF8("change"), 6}, 0}, 31 },
      {{{OSUTF8("change-start"), 12}, 0}, 32 },
      {{{OSUTF8("change-end"), 10}, 0}, 33 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 34, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* h */
      pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

      if (pvalue->u.h == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_H ((Odf_H*)pvalue->u.h);

      stat = XmlDec_Odf_H (pctxt, pvalue->u.h);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P ((Odf_P*)pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List ((Odf_List*)pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* numbered-paragraph */
      pvalue->u.numbered_paragraph
          = rtxMemAllocType (pctxt, Odf_Numbered_paragraph);

      if (pvalue->u.numbered_paragraph == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Numbered_paragraph ((Odf_Numbered_paragraph*)pvalue->
         u.numbered_paragraph);

      stat = XmlDec_Odf_Numbered_paragraph (pctxt, pvalue->u.numbered_paragraph
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* table */
      pvalue->u.table = rtxMemAllocType (pctxt, Table);

      if (pvalue->u.table == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table ((Table*)pvalue->u.table);

      stat = XmlDec_Table (pctxt, pvalue->u.table);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* a */
      pvalue->u.a = rtxMemAllocType (pctxt, Ns3_A);

      if (pvalue->u.a == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_A ((Ns3_A*)pvalue->u.a);

      stat = XmlDec_Ns3_A (pctxt, pvalue->u.a);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* section */
      pvalue->u.section = rtxMemAllocType (pctxt, Odf_Section);

      if (pvalue->u.section == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Section ((Odf_Section*)pvalue->u.section);

      stat = XmlDec_Odf_Section (pctxt, pvalue->u.section);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* table-of-content */
      pvalue->u.table_of_content
          = rtxMemAllocType (pctxt, Odf_Table_of_content);

      if (pvalue->u.table_of_content == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_of_content ((Odf_Table_of_content*)pvalue->
         u.table_of_content);

      stat = XmlDec_Odf_Table_of_content (pctxt, pvalue->u.table_of_content);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* illustration-index */
      pvalue->u.illustration_index
          = rtxMemAllocType (pctxt, Odf_Illustration_index);

      if (pvalue->u.illustration_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Illustration_index ((Odf_Illustration_index*)pvalue->
         u.illustration_index);

      stat = XmlDec_Odf_Illustration_index (pctxt, pvalue->u.illustration_index
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* table-index */
      pvalue->u.table_index = rtxMemAllocType (pctxt, Odf_Table_index);

      if (pvalue->u.table_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_index ((Odf_Table_index*)pvalue->u.table_index);

      stat = XmlDec_Odf_Table_index (pctxt, pvalue->u.table_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* object-index */
      pvalue->u.object_index = rtxMemAllocType (pctxt, Odf_Object_index);

      if (pvalue->u.object_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Object_index ((Odf_Object_index*)pvalue->u.object_index);

      stat = XmlDec_Odf_Object_index (pctxt, pvalue->u.object_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* user-index */
      pvalue->u.user_index = rtxMemAllocType (pctxt, Odf_User_index);

      if (pvalue->u.user_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index ((Odf_User_index*)pvalue->u.user_index);

      stat = XmlDec_Odf_User_index (pctxt, pvalue->u.user_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* alphabetical-index */
      pvalue->u.alphabetical_index
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index);

      if (pvalue->u.alphabetical_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index ((Odf_Alphabetical_index*)pvalue->
         u.alphabetical_index);

      stat = XmlDec_Odf_Alphabetical_index (pctxt, pvalue->u.alphabetical_index
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* bibliography */
      pvalue->u.bibliography = rtxMemAllocType (pctxt, Odf_Bibliography);

      if (pvalue->u.bibliography == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bibliography ((Odf_Bibliography*)pvalue->u.bibliography);

      stat = XmlDec_Odf_Bibliography (pctxt, pvalue->u.bibliography);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* rect */
      pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

      if (pvalue->u.rect == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);

      stat = XmlDec_Ns3_Rect (pctxt, pvalue->u.rect);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* line */
      pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

      if (pvalue->u.line == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);

      stat = XmlDec_Ns3_Line (pctxt, pvalue->u.line);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* polyline */
      pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

      if (pvalue->u.polyline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);

      stat = XmlDec_Ns3_Polyline (pctxt, pvalue->u.polyline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 17: { /* polygon */
      pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

      if (pvalue->u.polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);

      stat = XmlDec_Ns3_Polygon (pctxt, pvalue->u.polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 18: { /* regular-polygon */
      pvalue->u.regular_polygon
          = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

      if (pvalue->u.regular_polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->
         u.regular_polygon);

      stat = XmlDec_Ns3_Regular_polygon (pctxt, pvalue->u.regular_polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 19: { /* path */
      pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

      if (pvalue->u.path == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);

      stat = XmlDec_Ns3_Path (pctxt, pvalue->u.path);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 20: { /* circle */
      pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

      if (pvalue->u.circle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);

      stat = XmlDec_Ns3_Circle (pctxt, pvalue->u.circle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 21: { /* ellipse */
      pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

      if (pvalue->u.ellipse == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);

      stat = XmlDec_Ns3_Ellipse (pctxt, pvalue->u.ellipse);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 22: { /* g */
      pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

      if (pvalue->u.g == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);

      stat = XmlDec_Ns3_G (pctxt, pvalue->u.g);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 23: { /* page-thumbnail */
      pvalue->u.page_thumbnail = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

      if (pvalue->u.page_thumbnail == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->
         u.page_thumbnail);

      stat = XmlDec_Ns3_Page_thumbnail (pctxt, pvalue->u.page_thumbnail);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 24: { /* frame */
      pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

      if (pvalue->u.frame == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);

      stat = XmlDec_Ns3_Frame (pctxt, pvalue->u.frame);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 25: { /* measure */
      pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

      if (pvalue->u.measure == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);

      stat = XmlDec_Ns3_Measure (pctxt, pvalue->u.measure);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 26: { /* caption */
      pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

      if (pvalue->u.caption == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);

      stat = XmlDec_Ns3_Caption (pctxt, pvalue->u.caption);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 27: { /* connector */
      pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

      if (pvalue->u.connector == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);

      stat = XmlDec_Ns3_Connector (pctxt, pvalue->u.connector);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 28: { /* control */
      pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

      if (pvalue->u.control == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);

      stat = XmlDec_Ns3_Control (pctxt, pvalue->u.control);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 29: { /* scene */
      pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

      if (pvalue->u.scene == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);

      stat = XmlDec_Ns7_Scene (pctxt, pvalue->u.scene);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 30: { /* custom-shape */
      pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

      if (pvalue->u.custom_shape == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);

      stat = XmlDec_Ns3_Custom_shape (pctxt, pvalue->u.custom_shape);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 31: { /* change */
      pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

      if (pvalue->u.change == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change ((Odf_Change*)pvalue->u.change);

      stat = XmlDec_Odf_Change (pctxt, pvalue->u.change);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 32: { /* change-start */
      pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

      if (pvalue->u.change_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_start ((Odf_Change_start*)pvalue->u.change_start);

      stat = XmlDec_Odf_Change_start (pctxt, pvalue->u.change_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 33: { /* change-end */
      pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

      if (pvalue->u.change_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_end ((Odf_Change_end*)pvalue->u.change_end);

      stat = XmlDec_Odf_Change_end (pctxt, pvalue->u.change_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Text_element                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Text_element (OSCTXT* pctxt, Ns13_Text_element *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode page_sequence */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->page_sequence
                = rtxMemAllocType (pctxt, Odf_Page_sequence);

            if (pvalue->page_sequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Page_sequence ((Odf_Page_sequence*)pvalue->page_sequence);
            asn1Init_Odf_Page_sequence ((Odf_Page_sequence*)pvalue->page_sequence);

            stat = asn1D_Odf_Page_sequence (pctxt, 
               (Odf_Page_sequence*)pvalue->page_sequence, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.page_sequencePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns13_Text_element_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns13_Text_element_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns13_Text_element_element (pdata2);

                  stat = asn1D_Ns13_Text_element_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns13_Text_element (OSCTXT* pctxt, Ns13_Text_element* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("page-sequence"), 13}, 0}, 0 },
      {{{OSUTF8("h"), 1}, 0}, 1 },
      {{{OSUTF8("p"), 1}, 0}, 1 },
      {{{OSUTF8("list"), 4}, 0}, 1 },
      {{{OSUTF8("numbered-paragraph"), 18}, 0}, 1 },
      {{{OSUTF8("table"), 5}, 0}, 1 },
      {{{OSUTF8("a"), 1}, 0}, 1 },
      {{{OSUTF8("section"), 7}, 0}, 1 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 1 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 1 },
      {{{OSUTF8("table-index"), 11}, 0}, 1 },
      {{{OSUTF8("object-index"), 12}, 0}, 1 },
      {{{OSUTF8("user-index"), 10}, 0}, 1 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 1 },
      {{{OSUTF8("bibliography"), 12}, 0}, 1 },
      {{{OSUTF8("rect"), 4}, 0}, 1 },
      {{{OSUTF8("line"), 4}, 0}, 1 },
      {{{OSUTF8("polyline"), 8}, 0}, 1 },
      {{{OSUTF8("polygon"), 7}, 0}, 1 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 1 },
      {{{OSUTF8("path"), 4}, 0}, 1 },
      {{{OSUTF8("circle"), 6}, 0}, 1 },
      {{{OSUTF8("ellipse"), 7}, 0}, 1 },
      {{{OSUTF8("g"), 1}, 0}, 1 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 1 },
      {{{OSUTF8("frame"), 5}, 0}, 1 },
      {{{OSUTF8("measure"), 7}, 0}, 1 },
      {{{OSUTF8("caption"), 7}, 0}, 1 },
      {{{OSUTF8("connector"), 9}, 0}, 1 },
      {{{OSUTF8("control"), 7}, 0}, 1 },
      {{{OSUTF8("scene"), 5}, 0}, 1 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 1 },
      {{{OSUTF8("change"), 6}, 0}, 1 },
      {{{OSUTF8("change-start"), 12}, 0}, 1 },
      {{{OSUTF8("change-end"), 10}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 35, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* page-sequence */
         pvalue->page_sequence = rtxMemAllocType (pctxt, Odf_Page_sequence);

         if (pvalue->page_sequence == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Page_sequence ((Odf_Page_sequence*)pvalue->page_sequence
            );

         stat = XmlDec_Odf_Page_sequence (pctxt, pvalue->page_sequence);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.page_sequencePresent = TRUE;
         break;
      }
      case 1: {
         Ns13_Text_element_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns13_Text_element_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Text_element_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns13_Text_element_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 34, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Text                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Text (OSCTXT* pctxt, Ns13_Text *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode global */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Global (pctxt, 
               (Odf_Global*)&pvalue->global, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.globalPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode forms */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Forms (pctxt, 
               &pvalue->forms, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.formsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode tracked_changes */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->tracked_changes
                = rtxMemAllocType (pctxt, Odf_Tracked_changes);

            if (pvalue->tracked_changes == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Tracked_changes ((Odf_Tracked_changes*)pvalue->tracked_changes);
            asn1Init_Odf_Tracked_changes ((Odf_Tracked_changes*)pvalue->tracked_changes);

            stat = asn1D_Odf_Tracked_changes (pctxt, 
               (Odf_Tracked_changes*)pvalue->tracked_changes, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tracked_changesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode variable_decls */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->variable_decls
                = rtxMemAllocType (pctxt, Odf_Variable_decls);

            if (pvalue->variable_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->variable_decls);
            asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->variable_decls);

            stat = asn1D_Odf_Variable_decls (pctxt, 
               (Odf_Variable_decls*)pvalue->variable_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.variable_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode sequence_decls */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->sequence_decls
                = rtxMemAllocType (pctxt, Odf_Sequence_decls);

            if (pvalue->sequence_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->sequence_decls);
            asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->sequence_decls);

            stat = asn1D_Odf_Sequence_decls (pctxt, 
               (Odf_Sequence_decls*)pvalue->sequence_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sequence_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode user_field_decls */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->user_field_decls
                = rtxMemAllocType (pctxt, Odf_User_field_decls);

            if (pvalue->user_field_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->user_field_decls);
            asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->user_field_decls);

            stat = asn1D_Odf_User_field_decls (pctxt, 
               (Odf_User_field_decls*)pvalue->user_field_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.user_field_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode dde_connection_decls */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->dde_connection_decls
                = rtxMemAllocType (pctxt, Odf_Dde_connection_decls);

            if (pvalue->dde_connection_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->dde_connection_decls);
            asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->dde_connection_decls);

            stat = asn1D_Odf_Dde_connection_decls (pctxt, 
               (Odf_Dde_connection_decls*)pvalue->dde_connection_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dde_connection_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode alphabetical_index_auto_mark_file */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->alphabetical_index_auto_mark_file
                = rtxMemAllocType (pctxt, Odf_Alphabetical_index_auto_mark_file);

            if (pvalue->alphabetical_index_auto_mark_file == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Alphabetical_index_auto_mark_file ((Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file);
            asn1Init_Odf_Alphabetical_index_auto_mark_file ((Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file);

            stat = asn1D_Odf_Alphabetical_index_auto_mark_file (pctxt, 
               (Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.alphabetical_index_auto_mark_filePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode calculation_settings */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->calculation_settings
                = rtxMemAllocType (pctxt, Calculation_settings);

            if (pvalue->calculation_settings == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Calculation_settings ((Calculation_settings*)pvalue->calculation_settings);
            asn1Init_Calculation_settings ((Calculation_settings*)pvalue->calculation_settings);

            stat = asn1D_Calculation_settings (pctxt, 
               (Calculation_settings*)pvalue->calculation_settings, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.calculation_settingsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode content_validations */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->content_validations
                = rtxMemAllocType (pctxt, Content_validations);

            if (pvalue->content_validations == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Content_validations ((Content_validations*)pvalue->content_validations);
            asn1Init_Content_validations ((Content_validations*)pvalue->content_validations);

            stat = asn1D_Content_validations (pctxt, 
               (Content_validations*)pvalue->content_validations, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.content_validationsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 10:
         /* decode label_ranges */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->label_ranges = rtxMemAllocType (pctxt, Label_ranges);

            if (pvalue->label_ranges == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Label_ranges ((Label_ranges*)pvalue->label_ranges);
            asn1Init_Label_ranges ((Label_ranges*)pvalue->label_ranges);

            stat = asn1D_Label_ranges (pctxt, 
               (Label_ranges*)pvalue->label_ranges, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.label_rangesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 11:
         /* decode sequence_list */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns13_Text_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->sequence_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns13_Text_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns13_Text_element (pdata2);

                  stat = asn1D_Ns13_Text_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->sequence_list, pnode);
               }

            }
            if (stat == 0) {
               pvalue->m.sequence_listPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 12:
         /* decode named_expressions */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Named_expressions (pctxt, 
               (Named_expressions*)&pvalue->named_expressions, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.named_expressionsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 13:
         /* decode database_ranges */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->database_ranges
                = rtxMemAllocType (pctxt, Database_ranges);

            if (pvalue->database_ranges == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Database_ranges ((Database_ranges*)pvalue->database_ranges);
            asn1Init_Database_ranges ((Database_ranges*)pvalue->database_ranges);

            stat = asn1D_Database_ranges (pctxt, 
               (Database_ranges*)pvalue->database_ranges, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.database_rangesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 14:
         /* decode data_pilot_tables */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->data_pilot_tables
                = rtxMemAllocType (pctxt, Data_pilot_tables);

            if (pvalue->data_pilot_tables == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Data_pilot_tables ((Data_pilot_tables*)pvalue->data_pilot_tables);
            asn1Init_Data_pilot_tables ((Data_pilot_tables*)pvalue->data_pilot_tables);

            stat = asn1D_Data_pilot_tables (pctxt, 
               (Data_pilot_tables*)pvalue->data_pilot_tables, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_pilot_tablesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 15:
         /* decode consolidation */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->consolidation = rtxMemAllocType (pctxt, Consolidation);

            if (pvalue->consolidation == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Consolidation ((Consolidation*)pvalue->consolidation);
            asn1Init_Consolidation ((Consolidation*)pvalue->consolidation);

            stat = asn1D_Consolidation (pctxt, 
               (Consolidation*)pvalue->consolidation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.consolidationPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 16:
         /* decode dde_links */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->dde_links = rtxMemAllocType (pctxt, Dde_links);

            if (pvalue->dde_links == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Dde_links ((Dde_links*)pvalue->dde_links);
            asn1Init_Dde_links ((Dde_links*)pvalue->dde_links);

            stat = asn1D_Dde_links (pctxt, 
               (Dde_links*)pvalue->dde_links, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dde_linksPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns13_Text (OSCTXT* pctxt, Ns13_Text* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("global"), 6}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* global */
            stat = XmlDec_Odf_Global (pctxt, &pvalue->global);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.globalPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns13_Text");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns13_Text");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("forms"), 5}, 0}, 0 },
      {{{OSUTF8("tracked-changes"), 15}, 0}, 1 },
      {{{OSUTF8("variable-decls"), 14}, 0}, 2 },
      {{{OSUTF8("sequence-decls"), 14}, 0}, 3 },
      {{{OSUTF8("user-field-decls"), 16}, 0}, 4 },
      {{{OSUTF8("dde-connection-decls"), 20}, 0}, 5 },
      {{{OSUTF8("alphabetical-index-auto-mark-file"), 33}, 0}, 6 },
      {{{OSUTF8("calculation-settings"), 20}, 0}, 7 },
      {{{OSUTF8("content-validations"), 19}, 0}, 8 },
      {{{OSUTF8("label-ranges"), 12}, 0}, 9 },
      {{{OSUTF8("page-sequence"), 13}, 0}, 10 },
      {{{OSUTF8("h"), 1}, 0}, 10 },
      {{{OSUTF8("p"), 1}, 0}, 10 },
      {{{OSUTF8("list"), 4}, 0}, 10 },
      {{{OSUTF8("numbered-paragraph"), 18}, 0}, 10 },
      {{{OSUTF8("table"), 5}, 0}, 10 },
      {{{OSUTF8("a"), 1}, 0}, 10 },
      {{{OSUTF8("section"), 7}, 0}, 10 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 10 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 10 },
      {{{OSUTF8("table-index"), 11}, 0}, 10 },
      {{{OSUTF8("object-index"), 12}, 0}, 10 },
      {{{OSUTF8("user-index"), 10}, 0}, 10 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 10 },
      {{{OSUTF8("bibliography"), 12}, 0}, 10 },
      {{{OSUTF8("rect"), 4}, 0}, 10 },
      {{{OSUTF8("line"), 4}, 0}, 10 },
      {{{OSUTF8("polyline"), 8}, 0}, 10 },
      {{{OSUTF8("polygon"), 7}, 0}, 10 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 10 },
      {{{OSUTF8("path"), 4}, 0}, 10 },
      {{{OSUTF8("circle"), 6}, 0}, 10 },
      {{{OSUTF8("ellipse"), 7}, 0}, 10 },
      {{{OSUTF8("g"), 1}, 0}, 10 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 10 },
      {{{OSUTF8("frame"), 5}, 0}, 10 },
      {{{OSUTF8("measure"), 7}, 0}, 10 },
      {{{OSUTF8("caption"), 7}, 0}, 10 },
      {{{OSUTF8("connector"), 9}, 0}, 10 },
      {{{OSUTF8("control"), 7}, 0}, 10 },
      {{{OSUTF8("scene"), 5}, 0}, 10 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 10 },
      {{{OSUTF8("change"), 6}, 0}, 10 },
      {{{OSUTF8("change-start"), 12}, 0}, 10 },
      {{{OSUTF8("change-end"), 10}, 0}, 10 },
      {{{OSUTF8("named-expressions"), 17}, 0}, 11 },
      {{{OSUTF8("database-ranges"), 15}, 0}, 12 },
      {{{OSUTF8("data-pilot-tables"), 17}, 0}, 13 },
      {{{OSUTF8("consolidation"), 13}, 0}, 14 },
      {{{OSUTF8("dde-links"), 9}, 0}, 15 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 50, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 16; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* forms */
         stat = XmlDec_Ns13_Forms (pctxt, &pvalue->forms);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.formsPresent = TRUE;
         break;
      }
      case 1: { /* tracked-changes */
         pvalue->tracked_changes
             = rtxMemAllocType (pctxt, Odf_Tracked_changes);

         if (pvalue->tracked_changes == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Tracked_changes ((Odf_Tracked_changes*)pvalue->
            tracked_changes);

         stat = XmlDec_Odf_Tracked_changes (pctxt, pvalue->tracked_changes);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.tracked_changesPresent = TRUE;
         break;
      }
      case 2: { /* variable-decls */
         pvalue->variable_decls = rtxMemAllocType (pctxt, Odf_Variable_decls);

         if (pvalue->variable_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->
            variable_decls);

         stat = XmlDec_Odf_Variable_decls (pctxt, pvalue->variable_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.variable_declsPresent = TRUE;
         break;
      }
      case 3: { /* sequence-decls */
         pvalue->sequence_decls = rtxMemAllocType (pctxt, Odf_Sequence_decls);

         if (pvalue->sequence_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->
            sequence_decls);

         stat = XmlDec_Odf_Sequence_decls (pctxt, pvalue->sequence_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.sequence_declsPresent = TRUE;
         break;
      }
      case 4: { /* user-field-decls */
         pvalue->user_field_decls
             = rtxMemAllocType (pctxt, Odf_User_field_decls);

         if (pvalue->user_field_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->
            user_field_decls);

         stat = XmlDec_Odf_User_field_decls (pctxt, pvalue->user_field_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.user_field_declsPresent = TRUE;
         break;
      }
      case 5: { /* dde-connection-decls */
         pvalue->dde_connection_decls
             = rtxMemAllocType (pctxt, Odf_Dde_connection_decls);

         if (pvalue->dde_connection_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->
            dde_connection_decls);

         stat = XmlDec_Odf_Dde_connection_decls (pctxt, pvalue->
            dde_connection_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dde_connection_declsPresent = TRUE;
         break;
      }
      case 6: { /* alphabetical-index-auto-mark-file */
         pvalue->alphabetical_index_auto_mark_file
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index_auto_mark_file);

         if (pvalue->alphabetical_index_auto_mark_file == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index_auto_mark_file (
            (Odf_Alphabetical_index_auto_mark_file*)pvalue->
            alphabetical_index_auto_mark_file);

         stat = XmlDec_Odf_Alphabetical_index_auto_mark_file (pctxt, pvalue->
            alphabetical_index_auto_mark_file);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.alphabetical_index_auto_mark_filePresent = TRUE;
         break;
      }
      case 7: { /* calculation-settings */
         pvalue->calculation_settings
             = rtxMemAllocType (pctxt, Calculation_settings);

         if (pvalue->calculation_settings == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Calculation_settings ((Calculation_settings*)pvalue->
            calculation_settings);

         stat = XmlDec_Calculation_settings (pctxt, pvalue->
            calculation_settings);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.calculation_settingsPresent = TRUE;
         break;
      }
      case 8: { /* content-validations */
         pvalue->content_validations
             = rtxMemAllocType (pctxt, Content_validations);

         if (pvalue->content_validations == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Content_validations ((Content_validations*)pvalue->
            content_validations);

         stat = XmlDec_Content_validations (pctxt, pvalue->content_validations
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.content_validationsPresent = TRUE;
         break;
      }
      case 9: { /* label-ranges */
         pvalue->label_ranges = rtxMemAllocType (pctxt, Label_ranges);

         if (pvalue->label_ranges == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Label_ranges ((Label_ranges*)pvalue->label_ranges);

         stat = XmlDec_Label_ranges (pctxt, pvalue->label_ranges);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.label_rangesPresent = TRUE;
         break;
      }
      case 10: {
         Ns13_Text_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns13_Text_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Text_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns13_Text_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->sequence_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 10, 35, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 10);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;

         pvalue->m.sequence_listPresent = TRUE;
         break;
      }
      case 11: { /* named-expressions */
         stat = XmlDec_Named_expressions (pctxt, &pvalue->named_expressions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.named_expressionsPresent = TRUE;
         break;
      }
      case 12: { /* database-ranges */
         pvalue->database_ranges = rtxMemAllocType (pctxt, Database_ranges);

         if (pvalue->database_ranges == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Database_ranges ((Database_ranges*)pvalue->database_ranges);

         stat = XmlDec_Database_ranges (pctxt, pvalue->database_ranges);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.database_rangesPresent = TRUE;
         break;
      }
      case 13: { /* data-pilot-tables */
         pvalue->data_pilot_tables
             = rtxMemAllocType (pctxt, Data_pilot_tables);

         if (pvalue->data_pilot_tables == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Data_pilot_tables ((Data_pilot_tables*)pvalue->
            data_pilot_tables);

         stat = XmlDec_Data_pilot_tables (pctxt, pvalue->data_pilot_tables);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.data_pilot_tablesPresent = TRUE;
         break;
      }
      case 14: { /* consolidation */
         pvalue->consolidation = rtxMemAllocType (pctxt, Consolidation);

         if (pvalue->consolidation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Consolidation ((Consolidation*)pvalue->consolidation);

         stat = XmlDec_Consolidation (pctxt, pvalue->consolidation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.consolidationPresent = TRUE;
         break;
      }
      case 15: { /* dde-links */
         pvalue->dde_links = rtxMemAllocType (pctxt, Dde_links);

         if (pvalue->dde_links == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Dde_links ((Dde_links*)pvalue->dde_links);

         stat = XmlDec_Dde_links (pctxt, pvalue->dde_links);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dde_linksPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Drawing                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Drawing (OSCTXT* pctxt, Ns13_Drawing *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode variable_decls */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->variable_decls
                = rtxMemAllocType (pctxt, Odf_Variable_decls);

            if (pvalue->variable_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->variable_decls);
            asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->variable_decls);

            stat = asn1D_Odf_Variable_decls (pctxt, 
               (Odf_Variable_decls*)pvalue->variable_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.variable_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode sequence_decls */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->sequence_decls
                = rtxMemAllocType (pctxt, Odf_Sequence_decls);

            if (pvalue->sequence_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->sequence_decls);
            asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->sequence_decls);

            stat = asn1D_Odf_Sequence_decls (pctxt, 
               (Odf_Sequence_decls*)pvalue->sequence_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sequence_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode user_field_decls */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->user_field_decls
                = rtxMemAllocType (pctxt, Odf_User_field_decls);

            if (pvalue->user_field_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->user_field_decls);
            asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->user_field_decls);

            stat = asn1D_Odf_User_field_decls (pctxt, 
               (Odf_User_field_decls*)pvalue->user_field_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.user_field_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode dde_connection_decls */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->dde_connection_decls
                = rtxMemAllocType (pctxt, Odf_Dde_connection_decls);

            if (pvalue->dde_connection_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->dde_connection_decls);
            asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->dde_connection_decls);

            stat = asn1D_Odf_Dde_connection_decls (pctxt, 
               (Odf_Dde_connection_decls*)pvalue->dde_connection_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dde_connection_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode alphabetical_index_auto_mark_file */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->alphabetical_index_auto_mark_file
                = rtxMemAllocType (pctxt, Odf_Alphabetical_index_auto_mark_file);

            if (pvalue->alphabetical_index_auto_mark_file == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Alphabetical_index_auto_mark_file ((Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file);
            asn1Init_Odf_Alphabetical_index_auto_mark_file ((Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file);

            stat = asn1D_Odf_Alphabetical_index_auto_mark_file (pctxt, 
               (Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.alphabetical_index_auto_mark_filePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode calculation_settings */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->calculation_settings
                = rtxMemAllocType (pctxt, Calculation_settings);

            if (pvalue->calculation_settings == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Calculation_settings ((Calculation_settings*)pvalue->calculation_settings);
            asn1Init_Calculation_settings ((Calculation_settings*)pvalue->calculation_settings);

            stat = asn1D_Calculation_settings (pctxt, 
               (Calculation_settings*)pvalue->calculation_settings, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.calculation_settingsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode content_validations */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->content_validations
                = rtxMemAllocType (pctxt, Content_validations);

            if (pvalue->content_validations == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Content_validations ((Content_validations*)pvalue->content_validations);
            asn1Init_Content_validations ((Content_validations*)pvalue->content_validations);

            stat = asn1D_Content_validations (pctxt, 
               (Content_validations*)pvalue->content_validations, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.content_validationsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode label_ranges */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->label_ranges = rtxMemAllocType (pctxt, Label_ranges);

            if (pvalue->label_ranges == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Label_ranges ((Label_ranges*)pvalue->label_ranges);
            asn1Init_Label_ranges ((Label_ranges*)pvalue->label_ranges);

            stat = asn1D_Label_ranges (pctxt, 
               (Label_ranges*)pvalue->label_ranges, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.label_rangesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode page_list */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Page* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->page_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Page, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Page ((Ns3_Page*)pdata2);

                  stat = asn1D_Ns3_Page (pctxt, 
                     (Ns3_Page*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->page_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 9:
         /* decode named_expressions */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Named_expressions (pctxt, 
               (Named_expressions*)&pvalue->named_expressions, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.named_expressionsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 10:
         /* decode database_ranges */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->database_ranges
                = rtxMemAllocType (pctxt, Database_ranges);

            if (pvalue->database_ranges == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Database_ranges ((Database_ranges*)pvalue->database_ranges);
            asn1Init_Database_ranges ((Database_ranges*)pvalue->database_ranges);

            stat = asn1D_Database_ranges (pctxt, 
               (Database_ranges*)pvalue->database_ranges, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.database_rangesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 11:
         /* decode data_pilot_tables */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->data_pilot_tables
                = rtxMemAllocType (pctxt, Data_pilot_tables);

            if (pvalue->data_pilot_tables == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Data_pilot_tables ((Data_pilot_tables*)pvalue->data_pilot_tables);
            asn1Init_Data_pilot_tables ((Data_pilot_tables*)pvalue->data_pilot_tables);

            stat = asn1D_Data_pilot_tables (pctxt, 
               (Data_pilot_tables*)pvalue->data_pilot_tables, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_pilot_tablesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 12:
         /* decode consolidation */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->consolidation = rtxMemAllocType (pctxt, Consolidation);

            if (pvalue->consolidation == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Consolidation ((Consolidation*)pvalue->consolidation);
            asn1Init_Consolidation ((Consolidation*)pvalue->consolidation);

            stat = asn1D_Consolidation (pctxt, 
               (Consolidation*)pvalue->consolidation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.consolidationPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 13:
         /* decode dde_links */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->dde_links = rtxMemAllocType (pctxt, Dde_links);

            if (pvalue->dde_links == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Dde_links ((Dde_links*)pvalue->dde_links);
            asn1Init_Dde_links ((Dde_links*)pvalue->dde_links);

            stat = asn1D_Dde_links (pctxt, 
               (Dde_links*)pvalue->dde_links, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dde_linksPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_CONS|13):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns13_Drawing (OSCTXT* pctxt, Ns13_Drawing* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("variable-decls"), 14}, 0}, 0 },
      {{{OSUTF8("sequence-decls"), 14}, 0}, 1 },
      {{{OSUTF8("user-field-decls"), 16}, 0}, 2 },
      {{{OSUTF8("dde-connection-decls"), 20}, 0}, 3 },
      {{{OSUTF8("alphabetical-index-auto-mark-file"), 33}, 0}, 4 },
      {{{OSUTF8("calculation-settings"), 20}, 0}, 5 },
      {{{OSUTF8("content-validations"), 19}, 0}, 6 },
      {{{OSUTF8("label-ranges"), 12}, 0}, 7 },
      {{{OSUTF8("page"), 4}, 0}, 8 },
      {{{OSUTF8("named-expressions"), 17}, 0}, 9 },
      {{{OSUTF8("database-ranges"), 15}, 0}, 10 },
      {{{OSUTF8("data-pilot-tables"), 17}, 0}, 11 },
      {{{OSUTF8("consolidation"), 13}, 0}, 12 },
      {{{OSUTF8("dde-links"), 9}, 0}, 13 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 14, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 14; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* variable-decls */
         pvalue->variable_decls = rtxMemAllocType (pctxt, Odf_Variable_decls);

         if (pvalue->variable_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->
            variable_decls);

         stat = XmlDec_Odf_Variable_decls (pctxt, pvalue->variable_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.variable_declsPresent = TRUE;
         break;
      }
      case 1: { /* sequence-decls */
         pvalue->sequence_decls = rtxMemAllocType (pctxt, Odf_Sequence_decls);

         if (pvalue->sequence_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->
            sequence_decls);

         stat = XmlDec_Odf_Sequence_decls (pctxt, pvalue->sequence_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.sequence_declsPresent = TRUE;
         break;
      }
      case 2: { /* user-field-decls */
         pvalue->user_field_decls
             = rtxMemAllocType (pctxt, Odf_User_field_decls);

         if (pvalue->user_field_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->
            user_field_decls);

         stat = XmlDec_Odf_User_field_decls (pctxt, pvalue->user_field_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.user_field_declsPresent = TRUE;
         break;
      }
      case 3: { /* dde-connection-decls */
         pvalue->dde_connection_decls
             = rtxMemAllocType (pctxt, Odf_Dde_connection_decls);

         if (pvalue->dde_connection_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->
            dde_connection_decls);

         stat = XmlDec_Odf_Dde_connection_decls (pctxt, pvalue->
            dde_connection_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dde_connection_declsPresent = TRUE;
         break;
      }
      case 4: { /* alphabetical-index-auto-mark-file */
         pvalue->alphabetical_index_auto_mark_file
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index_auto_mark_file);

         if (pvalue->alphabetical_index_auto_mark_file == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index_auto_mark_file (
            (Odf_Alphabetical_index_auto_mark_file*)pvalue->
            alphabetical_index_auto_mark_file);

         stat = XmlDec_Odf_Alphabetical_index_auto_mark_file (pctxt, pvalue->
            alphabetical_index_auto_mark_file);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.alphabetical_index_auto_mark_filePresent = TRUE;
         break;
      }
      case 5: { /* calculation-settings */
         pvalue->calculation_settings
             = rtxMemAllocType (pctxt, Calculation_settings);

         if (pvalue->calculation_settings == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Calculation_settings ((Calculation_settings*)pvalue->
            calculation_settings);

         stat = XmlDec_Calculation_settings (pctxt, pvalue->
            calculation_settings);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.calculation_settingsPresent = TRUE;
         break;
      }
      case 6: { /* content-validations */
         pvalue->content_validations
             = rtxMemAllocType (pctxt, Content_validations);

         if (pvalue->content_validations == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Content_validations ((Content_validations*)pvalue->
            content_validations);

         stat = XmlDec_Content_validations (pctxt, pvalue->content_validations
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.content_validationsPresent = TRUE;
         break;
      }
      case 7: { /* label-ranges */
         pvalue->label_ranges = rtxMemAllocType (pctxt, Label_ranges);

         if (pvalue->label_ranges == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Label_ranges ((Label_ranges*)pvalue->label_ranges);

         stat = XmlDec_Label_ranges (pctxt, pvalue->label_ranges);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.label_rangesPresent = TRUE;
         break;
      }
      case 8: {
         Ns3_Page* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Page);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Page ((Ns3_Page*)pdata1);

            stat = XmlDec_Ns3_Page (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->page_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 8, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 8);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 9: { /* named-expressions */
         stat = XmlDec_Named_expressions (pctxt, &pvalue->named_expressions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.named_expressionsPresent = TRUE;
         break;
      }
      case 10: { /* database-ranges */
         pvalue->database_ranges = rtxMemAllocType (pctxt, Database_ranges);

         if (pvalue->database_ranges == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Database_ranges ((Database_ranges*)pvalue->database_ranges);

         stat = XmlDec_Database_ranges (pctxt, pvalue->database_ranges);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.database_rangesPresent = TRUE;
         break;
      }
      case 11: { /* data-pilot-tables */
         pvalue->data_pilot_tables
             = rtxMemAllocType (pctxt, Data_pilot_tables);

         if (pvalue->data_pilot_tables == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Data_pilot_tables ((Data_pilot_tables*)pvalue->
            data_pilot_tables);

         stat = XmlDec_Data_pilot_tables (pctxt, pvalue->data_pilot_tables);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.data_pilot_tablesPresent = TRUE;
         break;
      }
      case 12: { /* consolidation */
         pvalue->consolidation = rtxMemAllocType (pctxt, Consolidation);

         if (pvalue->consolidation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Consolidation ((Consolidation*)pvalue->consolidation);

         stat = XmlDec_Consolidation (pctxt, pvalue->consolidation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.consolidationPresent = TRUE;
         break;
      }
      case 13: { /* dde-links */
         pvalue->dde_links = rtxMemAllocType (pctxt, Dde_links);

         if (pvalue->dde_links == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Dde_links ((Dde_links*)pvalue->dde_links);

         stat = XmlDec_Dde_links (pctxt, pvalue->dde_links);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dde_linksPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Presentation_element                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Presentation_element (OSCTXT* pctxt, 
   Ns13_Presentation_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.header_decl = rtxMemAllocType (pctxt, Ns10_Header_decl);

         if (pvalue->u.header_decl == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns10_Header_decl ((Ns10_Header_decl*)pvalue->u.header_decl);
         stat = asn1D_Ns10_Header_decl (pctxt, 
            (Ns10_Header_decl*)pvalue->u.header_decl, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.footer_decl = rtxMemAllocType (pctxt, Ns10_Footer_decl);

         if (pvalue->u.footer_decl == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns10_Footer_decl ((Ns10_Footer_decl*)pvalue->u.footer_decl);
         stat = asn1D_Ns10_Footer_decl (pctxt, 
            (Ns10_Footer_decl*)pvalue->u.footer_decl, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.date_time_decl
             = rtxMemAllocType (pctxt, Ns10_Date_time_decl);

         if (pvalue->u.date_time_decl == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns10_Date_time_decl ((Ns10_Date_time_decl*)pvalue->u.date_time_decl);
         stat = asn1D_Ns10_Date_time_decl (pctxt, 
            (Ns10_Date_time_decl*)pvalue->u.date_time_decl, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns13_Presentation_element (OSCTXT* pctxt, 
   Ns13_Presentation_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("header-decl"), 11}, 0}, 0 },
      {{{OSUTF8("footer-decl"), 11}, 0}, 1 },
      {{{OSUTF8("date-time-decl"), 14}, 0}, 2 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* header-decl */
      pvalue->u.header_decl = rtxMemAllocType (pctxt, Ns10_Header_decl);

      if (pvalue->u.header_decl == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns10_Header_decl ((Ns10_Header_decl*)pvalue->u.header_decl);

      stat = XmlDec_Ns10_Header_decl (pctxt, pvalue->u.header_decl);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* footer-decl */
      pvalue->u.footer_decl = rtxMemAllocType (pctxt, Ns10_Footer_decl);

      if (pvalue->u.footer_decl == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns10_Footer_decl ((Ns10_Footer_decl*)pvalue->u.footer_decl);

      stat = XmlDec_Ns10_Footer_decl (pctxt, pvalue->u.footer_decl);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* date-time-decl */
      pvalue->u.date_time_decl = rtxMemAllocType (pctxt, Ns10_Date_time_decl);

      if (pvalue->u.date_time_decl == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns10_Date_time_decl ((Ns10_Date_time_decl*)pvalue->
         u.date_time_decl);

      stat = XmlDec_Ns10_Date_time_decl (pctxt, pvalue->u.date_time_decl);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Presentation                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Presentation (OSCTXT* pctxt, Ns13_Presentation *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode variable_decls */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->variable_decls
                = rtxMemAllocType (pctxt, Odf_Variable_decls);

            if (pvalue->variable_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->variable_decls);
            asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->variable_decls);

            stat = asn1D_Odf_Variable_decls (pctxt, 
               (Odf_Variable_decls*)pvalue->variable_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.variable_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode sequence_decls */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->sequence_decls
                = rtxMemAllocType (pctxt, Odf_Sequence_decls);

            if (pvalue->sequence_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->sequence_decls);
            asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->sequence_decls);

            stat = asn1D_Odf_Sequence_decls (pctxt, 
               (Odf_Sequence_decls*)pvalue->sequence_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sequence_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode user_field_decls */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->user_field_decls
                = rtxMemAllocType (pctxt, Odf_User_field_decls);

            if (pvalue->user_field_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->user_field_decls);
            asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->user_field_decls);

            stat = asn1D_Odf_User_field_decls (pctxt, 
               (Odf_User_field_decls*)pvalue->user_field_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.user_field_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode dde_connection_decls */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->dde_connection_decls
                = rtxMemAllocType (pctxt, Odf_Dde_connection_decls);

            if (pvalue->dde_connection_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->dde_connection_decls);
            asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->dde_connection_decls);

            stat = asn1D_Odf_Dde_connection_decls (pctxt, 
               (Odf_Dde_connection_decls*)pvalue->dde_connection_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dde_connection_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode alphabetical_index_auto_mark_file */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->alphabetical_index_auto_mark_file
                = rtxMemAllocType (pctxt, Odf_Alphabetical_index_auto_mark_file);

            if (pvalue->alphabetical_index_auto_mark_file == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Alphabetical_index_auto_mark_file ((Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file);
            asn1Init_Odf_Alphabetical_index_auto_mark_file ((Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file);

            stat = asn1D_Odf_Alphabetical_index_auto_mark_file (pctxt, 
               (Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.alphabetical_index_auto_mark_filePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode calculation_settings */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->calculation_settings
                = rtxMemAllocType (pctxt, Calculation_settings);

            if (pvalue->calculation_settings == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Calculation_settings ((Calculation_settings*)pvalue->calculation_settings);
            asn1Init_Calculation_settings ((Calculation_settings*)pvalue->calculation_settings);

            stat = asn1D_Calculation_settings (pctxt, 
               (Calculation_settings*)pvalue->calculation_settings, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.calculation_settingsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode content_validations */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->content_validations
                = rtxMemAllocType (pctxt, Content_validations);

            if (pvalue->content_validations == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Content_validations ((Content_validations*)pvalue->content_validations);
            asn1Init_Content_validations ((Content_validations*)pvalue->content_validations);

            stat = asn1D_Content_validations (pctxt, 
               (Content_validations*)pvalue->content_validations, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.content_validationsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode label_ranges */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->label_ranges = rtxMemAllocType (pctxt, Label_ranges);

            if (pvalue->label_ranges == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Label_ranges ((Label_ranges*)pvalue->label_ranges);
            asn1Init_Label_ranges ((Label_ranges*)pvalue->label_ranges);

            stat = asn1D_Label_ranges (pctxt, 
               (Label_ranges*)pvalue->label_ranges, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.label_rangesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns13_Presentation_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns13_Presentation_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns13_Presentation_element (pdata2);

                  stat = asn1D_Ns13_Presentation_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 9:
         /* decode page_list */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Page* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->page_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Page, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Page ((Ns3_Page*)pdata2);

                  stat = asn1D_Ns3_Page (pctxt, 
                     (Ns3_Page*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->page_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 10:
         /* decode settings */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->settings = rtxMemAllocType (pctxt, Ns10_Settings);

            if (pvalue->settings == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns10_Settings ((Ns10_Settings*)pvalue->settings);
            asn1Init_Ns10_Settings ((Ns10_Settings*)pvalue->settings);

            stat = asn1D_Ns10_Settings (pctxt, 
               (Ns10_Settings*)pvalue->settings, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.settingsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 11:
         /* decode named_expressions */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Named_expressions (pctxt, 
               (Named_expressions*)&pvalue->named_expressions, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.named_expressionsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 12:
         /* decode database_ranges */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->database_ranges
                = rtxMemAllocType (pctxt, Database_ranges);

            if (pvalue->database_ranges == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Database_ranges ((Database_ranges*)pvalue->database_ranges);
            asn1Init_Database_ranges ((Database_ranges*)pvalue->database_ranges);

            stat = asn1D_Database_ranges (pctxt, 
               (Database_ranges*)pvalue->database_ranges, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.database_rangesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 13:
         /* decode data_pilot_tables */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->data_pilot_tables
                = rtxMemAllocType (pctxt, Data_pilot_tables);

            if (pvalue->data_pilot_tables == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Data_pilot_tables ((Data_pilot_tables*)pvalue->data_pilot_tables);
            asn1Init_Data_pilot_tables ((Data_pilot_tables*)pvalue->data_pilot_tables);

            stat = asn1D_Data_pilot_tables (pctxt, 
               (Data_pilot_tables*)pvalue->data_pilot_tables, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_pilot_tablesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 14:
         /* decode consolidation */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->consolidation = rtxMemAllocType (pctxt, Consolidation);

            if (pvalue->consolidation == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Consolidation ((Consolidation*)pvalue->consolidation);
            asn1Init_Consolidation ((Consolidation*)pvalue->consolidation);

            stat = asn1D_Consolidation (pctxt, 
               (Consolidation*)pvalue->consolidation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.consolidationPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 15:
         /* decode dde_links */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->dde_links = rtxMemAllocType (pctxt, Dde_links);

            if (pvalue->dde_links == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Dde_links ((Dde_links*)pvalue->dde_links);
            asn1Init_Dde_links ((Dde_links*)pvalue->dde_links);

            stat = asn1D_Dde_links (pctxt, 
               (Dde_links*)pvalue->dde_links, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dde_linksPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_CONS|15):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns13_Presentation (OSCTXT* pctxt, Ns13_Presentation* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("variable-decls"), 14}, 0}, 0 },
      {{{OSUTF8("sequence-decls"), 14}, 0}, 1 },
      {{{OSUTF8("user-field-decls"), 16}, 0}, 2 },
      {{{OSUTF8("dde-connection-decls"), 20}, 0}, 3 },
      {{{OSUTF8("alphabetical-index-auto-mark-file"), 33}, 0}, 4 },
      {{{OSUTF8("calculation-settings"), 20}, 0}, 5 },
      {{{OSUTF8("content-validations"), 19}, 0}, 6 },
      {{{OSUTF8("label-ranges"), 12}, 0}, 7 },
      {{{OSUTF8("header-decl"), 11}, 0}, 8 },
      {{{OSUTF8("footer-decl"), 11}, 0}, 8 },
      {{{OSUTF8("date-time-decl"), 14}, 0}, 8 },
      {{{OSUTF8("page"), 4}, 0}, 9 },
      {{{OSUTF8("settings"), 8}, 0}, 10 },
      {{{OSUTF8("named-expressions"), 17}, 0}, 11 },
      {{{OSUTF8("database-ranges"), 15}, 0}, 12 },
      {{{OSUTF8("data-pilot-tables"), 17}, 0}, 13 },
      {{{OSUTF8("consolidation"), 13}, 0}, 14 },
      {{{OSUTF8("dde-links"), 9}, 0}, 15 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 18, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 16; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* variable-decls */
         pvalue->variable_decls = rtxMemAllocType (pctxt, Odf_Variable_decls);

         if (pvalue->variable_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->
            variable_decls);

         stat = XmlDec_Odf_Variable_decls (pctxt, pvalue->variable_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.variable_declsPresent = TRUE;
         break;
      }
      case 1: { /* sequence-decls */
         pvalue->sequence_decls = rtxMemAllocType (pctxt, Odf_Sequence_decls);

         if (pvalue->sequence_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->
            sequence_decls);

         stat = XmlDec_Odf_Sequence_decls (pctxt, pvalue->sequence_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.sequence_declsPresent = TRUE;
         break;
      }
      case 2: { /* user-field-decls */
         pvalue->user_field_decls
             = rtxMemAllocType (pctxt, Odf_User_field_decls);

         if (pvalue->user_field_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->
            user_field_decls);

         stat = XmlDec_Odf_User_field_decls (pctxt, pvalue->user_field_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.user_field_declsPresent = TRUE;
         break;
      }
      case 3: { /* dde-connection-decls */
         pvalue->dde_connection_decls
             = rtxMemAllocType (pctxt, Odf_Dde_connection_decls);

         if (pvalue->dde_connection_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->
            dde_connection_decls);

         stat = XmlDec_Odf_Dde_connection_decls (pctxt, pvalue->
            dde_connection_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dde_connection_declsPresent = TRUE;
         break;
      }
      case 4: { /* alphabetical-index-auto-mark-file */
         pvalue->alphabetical_index_auto_mark_file
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index_auto_mark_file);

         if (pvalue->alphabetical_index_auto_mark_file == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index_auto_mark_file (
            (Odf_Alphabetical_index_auto_mark_file*)pvalue->
            alphabetical_index_auto_mark_file);

         stat = XmlDec_Odf_Alphabetical_index_auto_mark_file (pctxt, pvalue->
            alphabetical_index_auto_mark_file);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.alphabetical_index_auto_mark_filePresent = TRUE;
         break;
      }
      case 5: { /* calculation-settings */
         pvalue->calculation_settings
             = rtxMemAllocType (pctxt, Calculation_settings);

         if (pvalue->calculation_settings == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Calculation_settings ((Calculation_settings*)pvalue->
            calculation_settings);

         stat = XmlDec_Calculation_settings (pctxt, pvalue->
            calculation_settings);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.calculation_settingsPresent = TRUE;
         break;
      }
      case 6: { /* content-validations */
         pvalue->content_validations
             = rtxMemAllocType (pctxt, Content_validations);

         if (pvalue->content_validations == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Content_validations ((Content_validations*)pvalue->
            content_validations);

         stat = XmlDec_Content_validations (pctxt, pvalue->content_validations
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.content_validationsPresent = TRUE;
         break;
      }
      case 7: { /* label-ranges */
         pvalue->label_ranges = rtxMemAllocType (pctxt, Label_ranges);

         if (pvalue->label_ranges == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Label_ranges ((Label_ranges*)pvalue->label_ranges);

         stat = XmlDec_Label_ranges (pctxt, pvalue->label_ranges);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.label_rangesPresent = TRUE;
         break;
      }
      case 8: {
         Ns13_Presentation_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns13_Presentation_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Presentation_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns13_Presentation_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 8, 3, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 8);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 9: {
         Ns3_Page* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Page);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Page ((Ns3_Page*)pdata1);

            stat = XmlDec_Ns3_Page (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->page_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 11, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 9);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 10: { /* settings */
         pvalue->settings = rtxMemAllocType (pctxt, Ns10_Settings);

         if (pvalue->settings == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns10_Settings ((Ns10_Settings*)pvalue->settings);

         stat = XmlDec_Ns10_Settings (pctxt, pvalue->settings);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.settingsPresent = TRUE;
         break;
      }
      case 11: { /* named-expressions */
         stat = XmlDec_Named_expressions (pctxt, &pvalue->named_expressions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.named_expressionsPresent = TRUE;
         break;
      }
      case 12: { /* database-ranges */
         pvalue->database_ranges = rtxMemAllocType (pctxt, Database_ranges);

         if (pvalue->database_ranges == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Database_ranges ((Database_ranges*)pvalue->database_ranges);

         stat = XmlDec_Database_ranges (pctxt, pvalue->database_ranges);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.database_rangesPresent = TRUE;
         break;
      }
      case 13: { /* data-pilot-tables */
         pvalue->data_pilot_tables
             = rtxMemAllocType (pctxt, Data_pilot_tables);

         if (pvalue->data_pilot_tables == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Data_pilot_tables ((Data_pilot_tables*)pvalue->
            data_pilot_tables);

         stat = XmlDec_Data_pilot_tables (pctxt, pvalue->data_pilot_tables);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.data_pilot_tablesPresent = TRUE;
         break;
      }
      case 14: { /* consolidation */
         pvalue->consolidation = rtxMemAllocType (pctxt, Consolidation);

         if (pvalue->consolidation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Consolidation ((Consolidation*)pvalue->consolidation);

         stat = XmlDec_Consolidation (pctxt, pvalue->consolidation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.consolidationPresent = TRUE;
         break;
      }
      case 15: { /* dde-links */
         pvalue->dde_links = rtxMemAllocType (pctxt, Dde_links);

         if (pvalue->dde_links == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Dde_links ((Dde_links*)pvalue->dde_links);

         stat = XmlDec_Dde_links (pctxt, pvalue->dde_links);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dde_linksPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Spreadsheet                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Spreadsheet (OSCTXT* pctxt, Ns13_Spreadsheet *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode protection_key */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Protection_key (pctxt, 
               (Protection_key*)&pvalue->protection_key, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.protection_keyPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode structure_protected */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Structure_protected (pctxt, 
               (Structure_protected*)&pvalue->structure_protected, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.structure_protectedPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode tracked_changes */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->tracked_changes
                = rtxMemAllocType (pctxt, Odf_Tracked_changes);

            if (pvalue->tracked_changes == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Tracked_changes ((Odf_Tracked_changes*)pvalue->tracked_changes);
            asn1Init_Odf_Tracked_changes ((Odf_Tracked_changes*)pvalue->tracked_changes);

            stat = asn1D_Odf_Tracked_changes (pctxt, 
               (Odf_Tracked_changes*)pvalue->tracked_changes, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tracked_changesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode variable_decls */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->variable_decls
                = rtxMemAllocType (pctxt, Odf_Variable_decls);

            if (pvalue->variable_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->variable_decls);
            asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->variable_decls);

            stat = asn1D_Odf_Variable_decls (pctxt, 
               (Odf_Variable_decls*)pvalue->variable_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.variable_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode sequence_decls */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->sequence_decls
                = rtxMemAllocType (pctxt, Odf_Sequence_decls);

            if (pvalue->sequence_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->sequence_decls);
            asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->sequence_decls);

            stat = asn1D_Odf_Sequence_decls (pctxt, 
               (Odf_Sequence_decls*)pvalue->sequence_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sequence_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode user_field_decls */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->user_field_decls
                = rtxMemAllocType (pctxt, Odf_User_field_decls);

            if (pvalue->user_field_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->user_field_decls);
            asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->user_field_decls);

            stat = asn1D_Odf_User_field_decls (pctxt, 
               (Odf_User_field_decls*)pvalue->user_field_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.user_field_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode dde_connection_decls */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->dde_connection_decls
                = rtxMemAllocType (pctxt, Odf_Dde_connection_decls);

            if (pvalue->dde_connection_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->dde_connection_decls);
            asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->dde_connection_decls);

            stat = asn1D_Odf_Dde_connection_decls (pctxt, 
               (Odf_Dde_connection_decls*)pvalue->dde_connection_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dde_connection_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode alphabetical_index_auto_mark_file */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->alphabetical_index_auto_mark_file
                = rtxMemAllocType (pctxt, Odf_Alphabetical_index_auto_mark_file);

            if (pvalue->alphabetical_index_auto_mark_file == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Alphabetical_index_auto_mark_file ((Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file);
            asn1Init_Odf_Alphabetical_index_auto_mark_file ((Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file);

            stat = asn1D_Odf_Alphabetical_index_auto_mark_file (pctxt, 
               (Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.alphabetical_index_auto_mark_filePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode calculation_settings */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->calculation_settings
                = rtxMemAllocType (pctxt, Calculation_settings);

            if (pvalue->calculation_settings == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Calculation_settings ((Calculation_settings*)pvalue->calculation_settings);
            asn1Init_Calculation_settings ((Calculation_settings*)pvalue->calculation_settings);

            stat = asn1D_Calculation_settings (pctxt, 
               (Calculation_settings*)pvalue->calculation_settings, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.calculation_settingsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode content_validations */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->content_validations
                = rtxMemAllocType (pctxt, Content_validations);

            if (pvalue->content_validations == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Content_validations ((Content_validations*)pvalue->content_validations);
            asn1Init_Content_validations ((Content_validations*)pvalue->content_validations);

            stat = asn1D_Content_validations (pctxt, 
               (Content_validations*)pvalue->content_validations, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.content_validationsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 10:
         /* decode label_ranges */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->label_ranges = rtxMemAllocType (pctxt, Label_ranges);

            if (pvalue->label_ranges == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Label_ranges ((Label_ranges*)pvalue->label_ranges);
            asn1Init_Label_ranges ((Label_ranges*)pvalue->label_ranges);

            stat = asn1D_Label_ranges (pctxt, 
               (Label_ranges*)pvalue->label_ranges, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.label_rangesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 11:
         /* decode table_list */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Table* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->table_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Table, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Table ((Table*)pdata2);

                  stat = asn1D_Table (pctxt, 
                     (Table*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->table_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 12:
         /* decode named_expressions */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Named_expressions (pctxt, 
               (Named_expressions*)&pvalue->named_expressions, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.named_expressionsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 13:
         /* decode database_ranges */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->database_ranges
                = rtxMemAllocType (pctxt, Database_ranges);

            if (pvalue->database_ranges == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Database_ranges ((Database_ranges*)pvalue->database_ranges);
            asn1Init_Database_ranges ((Database_ranges*)pvalue->database_ranges);

            stat = asn1D_Database_ranges (pctxt, 
               (Database_ranges*)pvalue->database_ranges, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.database_rangesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 14:
         /* decode data_pilot_tables */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->data_pilot_tables
                = rtxMemAllocType (pctxt, Data_pilot_tables);

            if (pvalue->data_pilot_tables == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Data_pilot_tables ((Data_pilot_tables*)pvalue->data_pilot_tables);
            asn1Init_Data_pilot_tables ((Data_pilot_tables*)pvalue->data_pilot_tables);

            stat = asn1D_Data_pilot_tables (pctxt, 
               (Data_pilot_tables*)pvalue->data_pilot_tables, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_pilot_tablesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 15:
         /* decode consolidation */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->consolidation = rtxMemAllocType (pctxt, Consolidation);

            if (pvalue->consolidation == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Consolidation ((Consolidation*)pvalue->consolidation);
            asn1Init_Consolidation ((Consolidation*)pvalue->consolidation);

            stat = asn1D_Consolidation (pctxt, 
               (Consolidation*)pvalue->consolidation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.consolidationPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 16:
         /* decode dde_links */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->dde_links = rtxMemAllocType (pctxt, Dde_links);

            if (pvalue->dde_links == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Dde_links ((Dde_links*)pvalue->dde_links);
            asn1Init_Dde_links ((Dde_links*)pvalue->dde_links);

            stat = asn1D_Dde_links (pctxt, 
               (Dde_links*)pvalue->dde_links, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dde_linksPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns13_Spreadsheet (OSCTXT* pctxt, Ns13_Spreadsheet* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("protection-key"), 14}, 0 },
         { {OSUTF8("structure-protected"), 19}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* protection-key */
            stat = XmlDec_Protection_key (pctxt, &pvalue->protection_key);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.protection_keyPresent = TRUE;
            break;

         case 1: /* structure-protected */
            stat = XmlDec_Structure_protected (pctxt, &pvalue->
               structure_protected);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.structure_protectedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns13_Spreadsheet");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns13_Spreadsheet");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("tracked-changes"), 15}, 0}, 0 },
      {{{OSUTF8("variable-decls"), 14}, 0}, 1 },
      {{{OSUTF8("sequence-decls"), 14}, 0}, 2 },
      {{{OSUTF8("user-field-decls"), 16}, 0}, 3 },
      {{{OSUTF8("dde-connection-decls"), 20}, 0}, 4 },
      {{{OSUTF8("alphabetical-index-auto-mark-file"), 33}, 0}, 5 },
      {{{OSUTF8("calculation-settings"), 20}, 0}, 6 },
      {{{OSUTF8("content-validations"), 19}, 0}, 7 },
      {{{OSUTF8("label-ranges"), 12}, 0}, 8 },
      {{{OSUTF8("table"), 5}, 0}, 9 },
      {{{OSUTF8("named-expressions"), 17}, 0}, 10 },
      {{{OSUTF8("database-ranges"), 15}, 0}, 11 },
      {{{OSUTF8("data-pilot-tables"), 17}, 0}, 12 },
      {{{OSUTF8("consolidation"), 13}, 0}, 13 },
      {{{OSUTF8("dde-links"), 9}, 0}, 14 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 15, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 15; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* tracked-changes */
         pvalue->tracked_changes
             = rtxMemAllocType (pctxt, Odf_Tracked_changes);

         if (pvalue->tracked_changes == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Tracked_changes ((Odf_Tracked_changes*)pvalue->
            tracked_changes);

         stat = XmlDec_Odf_Tracked_changes (pctxt, pvalue->tracked_changes);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.tracked_changesPresent = TRUE;
         break;
      }
      case 1: { /* variable-decls */
         pvalue->variable_decls = rtxMemAllocType (pctxt, Odf_Variable_decls);

         if (pvalue->variable_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->
            variable_decls);

         stat = XmlDec_Odf_Variable_decls (pctxt, pvalue->variable_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.variable_declsPresent = TRUE;
         break;
      }
      case 2: { /* sequence-decls */
         pvalue->sequence_decls = rtxMemAllocType (pctxt, Odf_Sequence_decls);

         if (pvalue->sequence_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->
            sequence_decls);

         stat = XmlDec_Odf_Sequence_decls (pctxt, pvalue->sequence_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.sequence_declsPresent = TRUE;
         break;
      }
      case 3: { /* user-field-decls */
         pvalue->user_field_decls
             = rtxMemAllocType (pctxt, Odf_User_field_decls);

         if (pvalue->user_field_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->
            user_field_decls);

         stat = XmlDec_Odf_User_field_decls (pctxt, pvalue->user_field_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.user_field_declsPresent = TRUE;
         break;
      }
      case 4: { /* dde-connection-decls */
         pvalue->dde_connection_decls
             = rtxMemAllocType (pctxt, Odf_Dde_connection_decls);

         if (pvalue->dde_connection_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->
            dde_connection_decls);

         stat = XmlDec_Odf_Dde_connection_decls (pctxt, pvalue->
            dde_connection_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dde_connection_declsPresent = TRUE;
         break;
      }
      case 5: { /* alphabetical-index-auto-mark-file */
         pvalue->alphabetical_index_auto_mark_file
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index_auto_mark_file);

         if (pvalue->alphabetical_index_auto_mark_file == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index_auto_mark_file (
            (Odf_Alphabetical_index_auto_mark_file*)pvalue->
            alphabetical_index_auto_mark_file);

         stat = XmlDec_Odf_Alphabetical_index_auto_mark_file (pctxt, pvalue->
            alphabetical_index_auto_mark_file);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.alphabetical_index_auto_mark_filePresent = TRUE;
         break;
      }
      case 6: { /* calculation-settings */
         pvalue->calculation_settings
             = rtxMemAllocType (pctxt, Calculation_settings);

         if (pvalue->calculation_settings == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Calculation_settings ((Calculation_settings*)pvalue->
            calculation_settings);

         stat = XmlDec_Calculation_settings (pctxt, pvalue->
            calculation_settings);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.calculation_settingsPresent = TRUE;
         break;
      }
      case 7: { /* content-validations */
         pvalue->content_validations
             = rtxMemAllocType (pctxt, Content_validations);

         if (pvalue->content_validations == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Content_validations ((Content_validations*)pvalue->
            content_validations);

         stat = XmlDec_Content_validations (pctxt, pvalue->content_validations
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.content_validationsPresent = TRUE;
         break;
      }
      case 8: { /* label-ranges */
         pvalue->label_ranges = rtxMemAllocType (pctxt, Label_ranges);

         if (pvalue->label_ranges == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Label_ranges ((Label_ranges*)pvalue->label_ranges);

         stat = XmlDec_Label_ranges (pctxt, pvalue->label_ranges);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.label_rangesPresent = TRUE;
         break;
      }
      case 9: {
         Table* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Table);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Table ((Table*)pdata1);

            stat = XmlDec_Table (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->table_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 9, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 9);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 10: { /* named-expressions */
         stat = XmlDec_Named_expressions (pctxt, &pvalue->named_expressions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.named_expressionsPresent = TRUE;
         break;
      }
      case 11: { /* database-ranges */
         pvalue->database_ranges = rtxMemAllocType (pctxt, Database_ranges);

         if (pvalue->database_ranges == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Database_ranges ((Database_ranges*)pvalue->database_ranges);

         stat = XmlDec_Database_ranges (pctxt, pvalue->database_ranges);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.database_rangesPresent = TRUE;
         break;
      }
      case 12: { /* data-pilot-tables */
         pvalue->data_pilot_tables
             = rtxMemAllocType (pctxt, Data_pilot_tables);

         if (pvalue->data_pilot_tables == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Data_pilot_tables ((Data_pilot_tables*)pvalue->
            data_pilot_tables);

         stat = XmlDec_Data_pilot_tables (pctxt, pvalue->data_pilot_tables);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.data_pilot_tablesPresent = TRUE;
         break;
      }
      case 13: { /* consolidation */
         pvalue->consolidation = rtxMemAllocType (pctxt, Consolidation);

         if (pvalue->consolidation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Consolidation ((Consolidation*)pvalue->consolidation);

         stat = XmlDec_Consolidation (pctxt, pvalue->consolidation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.consolidationPresent = TRUE;
         break;
      }
      case 14: { /* dde-links */
         pvalue->dde_links = rtxMemAllocType (pctxt, Dde_links);

         if (pvalue->dde_links == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Dde_links ((Dde_links*)pvalue->dde_links);

         stat = XmlDec_Dde_links (pctxt, pvalue->dde_links);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dde_linksPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Chart                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Chart (OSCTXT* pctxt, Ns13_Chart *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode variable_decls */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->variable_decls
                = rtxMemAllocType (pctxt, Odf_Variable_decls);

            if (pvalue->variable_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->variable_decls);
            asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->variable_decls);

            stat = asn1D_Odf_Variable_decls (pctxt, 
               (Odf_Variable_decls*)pvalue->variable_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.variable_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode sequence_decls */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->sequence_decls
                = rtxMemAllocType (pctxt, Odf_Sequence_decls);

            if (pvalue->sequence_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->sequence_decls);
            asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->sequence_decls);

            stat = asn1D_Odf_Sequence_decls (pctxt, 
               (Odf_Sequence_decls*)pvalue->sequence_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sequence_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode user_field_decls */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->user_field_decls
                = rtxMemAllocType (pctxt, Odf_User_field_decls);

            if (pvalue->user_field_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->user_field_decls);
            asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->user_field_decls);

            stat = asn1D_Odf_User_field_decls (pctxt, 
               (Odf_User_field_decls*)pvalue->user_field_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.user_field_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode dde_connection_decls */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->dde_connection_decls
                = rtxMemAllocType (pctxt, Odf_Dde_connection_decls);

            if (pvalue->dde_connection_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->dde_connection_decls);
            asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->dde_connection_decls);

            stat = asn1D_Odf_Dde_connection_decls (pctxt, 
               (Odf_Dde_connection_decls*)pvalue->dde_connection_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dde_connection_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode alphabetical_index_auto_mark_file */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->alphabetical_index_auto_mark_file
                = rtxMemAllocType (pctxt, Odf_Alphabetical_index_auto_mark_file);

            if (pvalue->alphabetical_index_auto_mark_file == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Alphabetical_index_auto_mark_file ((Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file);
            asn1Init_Odf_Alphabetical_index_auto_mark_file ((Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file);

            stat = asn1D_Odf_Alphabetical_index_auto_mark_file (pctxt, 
               (Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.alphabetical_index_auto_mark_filePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode calculation_settings */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->calculation_settings
                = rtxMemAllocType (pctxt, Calculation_settings);

            if (pvalue->calculation_settings == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Calculation_settings ((Calculation_settings*)pvalue->calculation_settings);
            asn1Init_Calculation_settings ((Calculation_settings*)pvalue->calculation_settings);

            stat = asn1D_Calculation_settings (pctxt, 
               (Calculation_settings*)pvalue->calculation_settings, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.calculation_settingsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode content_validations */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->content_validations
                = rtxMemAllocType (pctxt, Content_validations);

            if (pvalue->content_validations == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Content_validations ((Content_validations*)pvalue->content_validations);
            asn1Init_Content_validations ((Content_validations*)pvalue->content_validations);

            stat = asn1D_Content_validations (pctxt, 
               (Content_validations*)pvalue->content_validations, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.content_validationsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode label_ranges */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->label_ranges = rtxMemAllocType (pctxt, Label_ranges);

            if (pvalue->label_ranges == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Label_ranges ((Label_ranges*)pvalue->label_ranges);
            asn1Init_Label_ranges ((Label_ranges*)pvalue->label_ranges);

            stat = asn1D_Label_ranges (pctxt, 
               (Label_ranges*)pvalue->label_ranges, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.label_rangesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode chart */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->chart = rtxMemAllocType (pctxt, Chart);

            if (pvalue->chart == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Chart ((Chart*)pvalue->chart);
            asn1Init_Chart ((Chart*)pvalue->chart);

            stat = asn1D_Chart (pctxt, 
               (Chart*)pvalue->chart, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 9:
         /* decode named_expressions */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Named_expressions (pctxt, 
               (Named_expressions*)&pvalue->named_expressions, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.named_expressionsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 10:
         /* decode database_ranges */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->database_ranges
                = rtxMemAllocType (pctxt, Database_ranges);

            if (pvalue->database_ranges == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Database_ranges ((Database_ranges*)pvalue->database_ranges);
            asn1Init_Database_ranges ((Database_ranges*)pvalue->database_ranges);

            stat = asn1D_Database_ranges (pctxt, 
               (Database_ranges*)pvalue->database_ranges, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.database_rangesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 11:
         /* decode data_pilot_tables */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->data_pilot_tables
                = rtxMemAllocType (pctxt, Data_pilot_tables);

            if (pvalue->data_pilot_tables == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Data_pilot_tables ((Data_pilot_tables*)pvalue->data_pilot_tables);
            asn1Init_Data_pilot_tables ((Data_pilot_tables*)pvalue->data_pilot_tables);

            stat = asn1D_Data_pilot_tables (pctxt, 
               (Data_pilot_tables*)pvalue->data_pilot_tables, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_pilot_tablesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 12:
         /* decode consolidation */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->consolidation = rtxMemAllocType (pctxt, Consolidation);

            if (pvalue->consolidation == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Consolidation ((Consolidation*)pvalue->consolidation);
            asn1Init_Consolidation ((Consolidation*)pvalue->consolidation);

            stat = asn1D_Consolidation (pctxt, 
               (Consolidation*)pvalue->consolidation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.consolidationPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 13:
         /* decode dde_links */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->dde_links = rtxMemAllocType (pctxt, Dde_links);

            if (pvalue->dde_links == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Dde_links ((Dde_links*)pvalue->dde_links);
            asn1Init_Dde_links ((Dde_links*)pvalue->dde_links);

            stat = asn1D_Dde_links (pctxt, 
               (Dde_links*)pvalue->dde_links, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dde_linksPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_CONS|13):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns13_Chart (OSCTXT* pctxt, Ns13_Chart* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("variable-decls"), 14}, 0}, 0 },
      {{{OSUTF8("sequence-decls"), 14}, 0}, 1 },
      {{{OSUTF8("user-field-decls"), 16}, 0}, 2 },
      {{{OSUTF8("dde-connection-decls"), 20}, 0}, 3 },
      {{{OSUTF8("alphabetical-index-auto-mark-file"), 33}, 0}, 4 },
      {{{OSUTF8("calculation-settings"), 20}, 0}, 5 },
      {{{OSUTF8("content-validations"), 19}, 0}, 6 },
      {{{OSUTF8("label-ranges"), 12}, 0}, 7 },
      {{{OSUTF8("chart"), 5}, 0}, 8 },
      {{{OSUTF8("named-expressions"), 17}, 0}, 9 },
      {{{OSUTF8("database-ranges"), 15}, 0}, 10 },
      {{{OSUTF8("data-pilot-tables"), 17}, 0}, 11 },
      {{{OSUTF8("consolidation"), 13}, 0}, 12 },
      {{{OSUTF8("dde-links"), 9}, 0}, 13 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 9, -1}, {9, 5, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 14; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* variable-decls */
         pvalue->variable_decls = rtxMemAllocType (pctxt, Odf_Variable_decls);

         if (pvalue->variable_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->
            variable_decls);

         stat = XmlDec_Odf_Variable_decls (pctxt, pvalue->variable_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.variable_declsPresent = TRUE;
         break;
      }
      case 1: { /* sequence-decls */
         pvalue->sequence_decls = rtxMemAllocType (pctxt, Odf_Sequence_decls);

         if (pvalue->sequence_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->
            sequence_decls);

         stat = XmlDec_Odf_Sequence_decls (pctxt, pvalue->sequence_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.sequence_declsPresent = TRUE;
         break;
      }
      case 2: { /* user-field-decls */
         pvalue->user_field_decls
             = rtxMemAllocType (pctxt, Odf_User_field_decls);

         if (pvalue->user_field_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->
            user_field_decls);

         stat = XmlDec_Odf_User_field_decls (pctxt, pvalue->user_field_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.user_field_declsPresent = TRUE;
         break;
      }
      case 3: { /* dde-connection-decls */
         pvalue->dde_connection_decls
             = rtxMemAllocType (pctxt, Odf_Dde_connection_decls);

         if (pvalue->dde_connection_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->
            dde_connection_decls);

         stat = XmlDec_Odf_Dde_connection_decls (pctxt, pvalue->
            dde_connection_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dde_connection_declsPresent = TRUE;
         break;
      }
      case 4: { /* alphabetical-index-auto-mark-file */
         pvalue->alphabetical_index_auto_mark_file
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index_auto_mark_file);

         if (pvalue->alphabetical_index_auto_mark_file == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index_auto_mark_file (
            (Odf_Alphabetical_index_auto_mark_file*)pvalue->
            alphabetical_index_auto_mark_file);

         stat = XmlDec_Odf_Alphabetical_index_auto_mark_file (pctxt, pvalue->
            alphabetical_index_auto_mark_file);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.alphabetical_index_auto_mark_filePresent = TRUE;
         break;
      }
      case 5: { /* calculation-settings */
         pvalue->calculation_settings
             = rtxMemAllocType (pctxt, Calculation_settings);

         if (pvalue->calculation_settings == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Calculation_settings ((Calculation_settings*)pvalue->
            calculation_settings);

         stat = XmlDec_Calculation_settings (pctxt, pvalue->
            calculation_settings);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.calculation_settingsPresent = TRUE;
         break;
      }
      case 6: { /* content-validations */
         pvalue->content_validations
             = rtxMemAllocType (pctxt, Content_validations);

         if (pvalue->content_validations == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Content_validations ((Content_validations*)pvalue->
            content_validations);

         stat = XmlDec_Content_validations (pctxt, pvalue->content_validations
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.content_validationsPresent = TRUE;
         break;
      }
      case 7: { /* label-ranges */
         pvalue->label_ranges = rtxMemAllocType (pctxt, Label_ranges);

         if (pvalue->label_ranges == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Label_ranges ((Label_ranges*)pvalue->label_ranges);

         stat = XmlDec_Label_ranges (pctxt, pvalue->label_ranges);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.label_rangesPresent = TRUE;
         break;
      }
      case 8: { /* chart */
         pvalue->chart = rtxMemAllocType (pctxt, Chart);

         if (pvalue->chart == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Chart ((Chart*)pvalue->chart);

         stat = XmlDec_Chart (pctxt, pvalue->chart);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 9: { /* named-expressions */
         stat = XmlDec_Named_expressions (pctxt, &pvalue->named_expressions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.named_expressionsPresent = TRUE;
         break;
      }
      case 10: { /* database-ranges */
         pvalue->database_ranges = rtxMemAllocType (pctxt, Database_ranges);

         if (pvalue->database_ranges == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Database_ranges ((Database_ranges*)pvalue->database_ranges);

         stat = XmlDec_Database_ranges (pctxt, pvalue->database_ranges);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.database_rangesPresent = TRUE;
         break;
      }
      case 11: { /* data-pilot-tables */
         pvalue->data_pilot_tables
             = rtxMemAllocType (pctxt, Data_pilot_tables);

         if (pvalue->data_pilot_tables == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Data_pilot_tables ((Data_pilot_tables*)pvalue->
            data_pilot_tables);

         stat = XmlDec_Data_pilot_tables (pctxt, pvalue->data_pilot_tables);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.data_pilot_tablesPresent = TRUE;
         break;
      }
      case 12: { /* consolidation */
         pvalue->consolidation = rtxMemAllocType (pctxt, Consolidation);

         if (pvalue->consolidation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Consolidation ((Consolidation*)pvalue->consolidation);

         stat = XmlDec_Consolidation (pctxt, pvalue->consolidation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.consolidationPresent = TRUE;
         break;
      }
      case 13: { /* dde-links */
         pvalue->dde_links = rtxMemAllocType (pctxt, Dde_links);

         if (pvalue->dde_links == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Dde_links ((Dde_links*)pvalue->dde_links);

         stat = XmlDec_Dde_links (pctxt, pvalue->dde_links);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dde_linksPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Image                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Image (OSCTXT* pctxt, Ns13_Image *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode frame */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->frame = rtxMemAllocType (pctxt, Ns3_Frame);

            if (pvalue->frame == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->frame);
            asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->frame);

            stat = asn1D_Ns3_Frame (pctxt, 
               (Ns3_Frame*)pvalue->frame, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns13_Image (OSCTXT* pctxt, Ns13_Image* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("frame"), 5}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* frame */
         pvalue->frame = rtxMemAllocType (pctxt, Ns3_Frame);

         if (pvalue->frame == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->frame);

         stat = XmlDec_Ns3_Frame (pctxt, pvalue->frame);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Body                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Body (OSCTXT* pctxt, Ns13_Body *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   if (tagging == ASN1EXPL) {
      if (XD_PEEKTAG (pctxt, 0x30)) {
         stat = xd_Tag1AndLen (pctxt, &length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else return LOG_RTERR (pctxt,
         berErrUnexpTag(pctxt, TM_UNIV|TM_CONS|16));
   }

   if (XD_PEEKTAG (pctxt, 0xa0)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_CTXT|TM_CONS|0));

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.text = rtxMemAllocType (pctxt, Ns13_Text);

         if (pvalue->u.text == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Text (pvalue->u.text);
         stat = asn1D_Ns13_Text (pctxt, 
            pvalue->u.text, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.drawing = rtxMemAllocType (pctxt, Ns13_Drawing);

         if (pvalue->u.drawing == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Drawing (pvalue->u.drawing);
         stat = asn1D_Ns13_Drawing (pctxt, 
            pvalue->u.drawing, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.presentation = rtxMemAllocType (pctxt, Ns13_Presentation);

         if (pvalue->u.presentation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Presentation (pvalue->u.presentation);
         stat = asn1D_Ns13_Presentation (pctxt, 
            pvalue->u.presentation, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.spreadsheet = rtxMemAllocType (pctxt, Ns13_Spreadsheet);

         if (pvalue->u.spreadsheet == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Spreadsheet (pvalue->u.spreadsheet);
         stat = asn1D_Ns13_Spreadsheet (pctxt, 
            pvalue->u.spreadsheet, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.chart = rtxMemAllocType (pctxt, Ns13_Chart);

         if (pvalue->u.chart == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Chart (pvalue->u.chart);
         stat = asn1D_Ns13_Chart (pctxt, 
            pvalue->u.chart, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.image = rtxMemAllocType (pctxt, Ns13_Image);

         if (pvalue->u.image == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Image (pvalue->u.image);
         stat = asn1D_Ns13_Image (pctxt, 
            pvalue->u.image, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns13_Body (OSCTXT* pctxt, Ns13_Body* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("text"), 4}, 0}, 0 },
      {{{OSUTF8("drawing"), 7}, 0}, 1 },
      {{{OSUTF8("presentation"), 12}, 0}, 2 },
      {{{OSUTF8("spreadsheet"), 11}, 0}, 3 },
      {{{OSUTF8("chart"), 5}, 0}, 4 },
      {{{OSUTF8("image"), 5}, 0}, 5 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 6, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* text */
      pvalue->u.text = rtxMemAllocType (pctxt, Ns13_Text);

      if (pvalue->u.text == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns13_Text (pvalue->u.text);

      stat = XmlDec_Ns13_Text (pctxt, pvalue->u.text);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* drawing */
      pvalue->u.drawing = rtxMemAllocType (pctxt, Ns13_Drawing);

      if (pvalue->u.drawing == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns13_Drawing (pvalue->u.drawing);

      stat = XmlDec_Ns13_Drawing (pctxt, pvalue->u.drawing);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* presentation */
      pvalue->u.presentation = rtxMemAllocType (pctxt, Ns13_Presentation);

      if (pvalue->u.presentation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns13_Presentation (pvalue->u.presentation);

      stat = XmlDec_Ns13_Presentation (pctxt, pvalue->u.presentation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* spreadsheet */
      pvalue->u.spreadsheet = rtxMemAllocType (pctxt, Ns13_Spreadsheet);

      if (pvalue->u.spreadsheet == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns13_Spreadsheet (pvalue->u.spreadsheet);

      stat = XmlDec_Ns13_Spreadsheet (pctxt, pvalue->u.spreadsheet);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* chart */
      pvalue->u.chart = rtxMemAllocType (pctxt, Ns13_Chart);

      if (pvalue->u.chart == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns13_Chart (pvalue->u.chart);

      stat = XmlDec_Ns13_Chart (pctxt, pvalue->u.chart);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* image */
      pvalue->u.image = rtxMemAllocType (pctxt, Ns13_Image);

      if (pvalue->u.image == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns13_Image (pvalue->u.image);

      stat = XmlDec_Ns13_Image (pctxt, pvalue->u.image);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Document                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Document (OSCTXT* pctxt, Ns13_Document *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode mimetype */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->mimetype, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode version */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->version, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.versionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode meta */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Meta (pctxt, 
               &pvalue->meta, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.metaPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode settings */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Settings (pctxt, 
               &pvalue->settings, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.settingsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode scripts */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Scripts (pctxt, 
               &pvalue->scripts, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.scriptsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode font_face_decls */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Font_face_decls (pctxt, 
               &pvalue->font_face_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.font_face_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode styles */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Styles (pctxt, 
               &pvalue->styles, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.stylesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode automatic_styles */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Automatic_styles (pctxt, 
               &pvalue->automatic_styles, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.automatic_stylesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode master_styles */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Master_styles (pctxt, 
               &pvalue->master_styles, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.master_stylesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode body */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Body (pctxt, 
               &pvalue->body, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns13_Document (OSCTXT* pctxt, Ns13_Document* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("mimetype"), 8}, 0 },
         { {OSUTF8("version"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* mimetype */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->mimetype);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* version */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->version);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.versionPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns13_Document");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns13_Document");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("meta"), 4}, 0}, 0 },
      {{{OSUTF8("settings"), 8}, 0}, 1 },
      {{{OSUTF8("scripts"), 7}, 0}, 2 },
      {{{OSUTF8("font-face-decls"), 15}, 0}, 3 },
      {{{OSUTF8("styles"), 6}, 0}, 4 },
      {{{OSUTF8("automatic-styles"), 16}, 0}, 5 },
      {{{OSUTF8("master-styles"), 13}, 0}, 6 },
      {{{OSUTF8("body"), 4}, 0}, 7 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 8, -1}, {8, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 8; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* meta */
         stat = XmlDec_Ns13_Meta (pctxt, &pvalue->meta);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.metaPresent = TRUE;
         break;
      }
      case 1: { /* settings */
         stat = XmlDec_Ns13_Settings (pctxt, &pvalue->settings);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.settingsPresent = TRUE;
         break;
      }
      case 2: { /* scripts */
         stat = XmlDec_Ns13_Scripts (pctxt, &pvalue->scripts);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.scriptsPresent = TRUE;
         break;
      }
      case 3: { /* font-face-decls */
         stat = XmlDec_Ns13_Font_face_decls (pctxt, &pvalue->font_face_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.font_face_declsPresent = TRUE;
         break;
      }
      case 4: { /* styles */
         stat = XmlDec_Ns13_Styles (pctxt, &pvalue->styles);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.stylesPresent = TRUE;
         break;
      }
      case 5: { /* automatic-styles */
         stat = XmlDec_Ns13_Automatic_styles (pctxt, &pvalue->automatic_styles
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.automatic_stylesPresent = TRUE;
         break;
      }
      case 6: { /* master-styles */
         stat = XmlDec_Ns13_Master_styles (pctxt, &pvalue->master_styles);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.master_stylesPresent = TRUE;
         break;
      }
      case 7: { /* body */
         stat = XmlDec_Ns13_Body (pctxt, &pvalue->body);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Change_info                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Change_info (OSCTXT* pctxt, Ns13_Change_info *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode creator */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Creator (pctxt, 
               &pvalue->creator, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode date */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Elements_Date (pctxt, 
               &pvalue->date, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode p_list */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_P* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->p_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_P, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_P ((Odf_P*)pdata2);

                  stat = asn1D_Odf_P (pctxt, 
                     (Odf_P*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->p_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns13_Change_info (OSCTXT* pctxt, Ns13_Change_info* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("creator"), 7}, 0}, 0 },
      {{{OSUTF8("date"), 4}, 0}, 1 },
      {{{OSUTF8("p"), 1}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 1, -1}, {2, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* creator */
         stat = XmlDec_Creator (pctxt, &pvalue->creator);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* date */
         stat = XmlDec_Elements_Date (pctxt, &pvalue->date);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 2: {
         Odf_P* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_P);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_P ((Odf_P*)pdata1);

            stat = XmlDec_Odf_P (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->p_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 2, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Document_content                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Document_content (OSCTXT* pctxt, 
   Ns13_Document_content *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode version */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->version, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.versionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode scripts */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Scripts (pctxt, 
               &pvalue->scripts, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.scriptsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode font_face_decls */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Font_face_decls (pctxt, 
               &pvalue->font_face_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.font_face_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode automatic_styles */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Automatic_styles (pctxt, 
               &pvalue->automatic_styles, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.automatic_stylesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode body */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Body (pctxt, 
               &pvalue->body, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns13_Document_content (OSCTXT* pctxt, Ns13_Document_content* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("version"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* version */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->version);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.versionPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns13_Document_content");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns13_Document_content");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("scripts"), 7}, 0}, 0 },
      {{{OSUTF8("font-face-decls"), 15}, 0}, 1 },
      {{{OSUTF8("automatic-styles"), 16}, 0}, 2 },
      {{{OSUTF8("body"), 4}, 0}, 3 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}, {4, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 4; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* scripts */
         stat = XmlDec_Ns13_Scripts (pctxt, &pvalue->scripts);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.scriptsPresent = TRUE;
         break;
      }
      case 1: { /* font-face-decls */
         stat = XmlDec_Ns13_Font_face_decls (pctxt, &pvalue->font_face_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.font_face_declsPresent = TRUE;
         break;
      }
      case 2: { /* automatic-styles */
         stat = XmlDec_Ns13_Automatic_styles (pctxt, &pvalue->automatic_styles
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.automatic_stylesPresent = TRUE;
         break;
      }
      case 3: { /* body */
         stat = XmlDec_Ns13_Body (pctxt, &pvalue->body);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Document_styles                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Document_styles (OSCTXT* pctxt, 
   Ns13_Document_styles *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode version */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->version, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.versionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode font_face_decls */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Font_face_decls (pctxt, 
               &pvalue->font_face_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.font_face_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode styles */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Styles (pctxt, 
               &pvalue->styles, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.stylesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode automatic_styles */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Automatic_styles (pctxt, 
               &pvalue->automatic_styles, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.automatic_stylesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode master_styles */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Master_styles (pctxt, 
               &pvalue->master_styles, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.master_stylesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns13_Document_styles (OSCTXT* pctxt, Ns13_Document_styles* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("version"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* version */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->version);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.versionPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns13_Document_styles");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns13_Document_styles");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("font-face-decls"), 15}, 0}, 0 },
      {{{OSUTF8("styles"), 6}, 0}, 1 },
      {{{OSUTF8("automatic-styles"), 16}, 0}, 2 },
      {{{OSUTF8("master-styles"), 13}, 0}, 3 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 4; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* font-face-decls */
         stat = XmlDec_Ns13_Font_face_decls (pctxt, &pvalue->font_face_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.font_face_declsPresent = TRUE;
         break;
      }
      case 1: { /* styles */
         stat = XmlDec_Ns13_Styles (pctxt, &pvalue->styles);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.stylesPresent = TRUE;
         break;
      }
      case 2: { /* automatic-styles */
         stat = XmlDec_Ns13_Automatic_styles (pctxt, &pvalue->automatic_styles
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.automatic_stylesPresent = TRUE;
         break;
      }
      case 3: { /* master-styles */
         stat = XmlDec_Ns13_Master_styles (pctxt, &pvalue->master_styles);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.master_stylesPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Document_meta                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Document_meta (OSCTXT* pctxt, 
   Ns13_Document_meta *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode version */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->version, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.versionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode meta */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Meta (pctxt, 
               &pvalue->meta, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.metaPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns13_Document_meta (OSCTXT* pctxt, Ns13_Document_meta* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("version"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* version */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->version);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.versionPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns13_Document_meta");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns13_Document_meta");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("meta"), 4}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* meta */
         stat = XmlDec_Ns13_Meta (pctxt, &pvalue->meta);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.metaPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Document_settings                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns13_Document_settings (OSCTXT* pctxt, 
   Ns13_Document_settings *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode version */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->version, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.versionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode settings */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Settings (pctxt, 
               &pvalue->settings, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.settingsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns13_Document_settings (OSCTXT* pctxt, 
   Ns13_Document_settings* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("version"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* version */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->version);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.versionPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns13_Document_settings");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns13_Document_settings");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("settings"), 8}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* settings */
         stat = XmlDec_Ns13_Settings (pctxt, &pvalue->settings);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.settingsPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

int XmlDec_Ns13_Document_PDU (OSCTXT* pctxt, Ns13_Document* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   asn1Init_Ns13_Document (pvalue);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("document"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_Ns13_Document (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_Ns13_Document_content_PDU (OSCTXT* pctxt, Ns13_Document_content* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   asn1Init_Ns13_Document_content (pvalue);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("document-content"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_Ns13_Document_content (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_Ns13_Document_styles_PDU (OSCTXT* pctxt, Ns13_Document_styles* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   asn1Init_Ns13_Document_styles (pvalue);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("document-styles"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_Ns13_Document_styles (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_Ns13_Document_meta_PDU (OSCTXT* pctxt, Ns13_Document_meta* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   asn1Init_Ns13_Document_meta (pvalue);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("document-meta"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_Ns13_Document_meta (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_Ns13_Document_settings_PDU (OSCTXT* pctxt, Ns13_Document_settings* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   asn1Init_Ns13_Document_settings (pvalue);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("document-settings"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_Ns13_Document_settings (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
