/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "Gaml100.h"
#include "libxml/parser.h"
#include "rtxmlsrc/osrtxml.h"
#include "rtxsrc/rtxCommon.h"

int DOMTest_GAML_integrity (OSCTXT* pctxt, GAML_integrity* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("algorithm"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               GAML_integrity_algorithm_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->algorithm);
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      OSUTF8CHAR* pcontent = pXmlNode->children->content;
      rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
      rtXmlDecDynHexStr (pctxt, &pvalue->base);
   }

   return 0;
}

int DOMTest_Parameter (OSCTXT* pctxt, Parameter* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("group"))) {
            pvalue->m.groupPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->group = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->group = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("label"))) {
            pvalue->m.labelPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->label = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->label = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("name"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->name = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->name = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_Link (OSCTXT* pctxt, Link* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("linkref"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->linkref = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->linkref = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_Values (OSCTXT* pctxt, Values* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("byteorder"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               Values_byteorder_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->byteorder);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("format"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               Values_format_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->format);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("numvalues"))) {
            pvalue->m.numvaluesPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->numvalues = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      OSUTF8CHAR* pcontent = pXmlNode->children->content;
      rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
      rtXmlDecDynBase64Str (pctxt, &pvalue->base);
   }

   return 0;
}

int DOMTest_Coordinates (OSCTXT* pctxt, Coordinates* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("label"))) {
            pvalue->m.labelPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->label = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->label = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("linkid"))) {
            pvalue->m.linkidPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->linkid = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->linkid = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("units"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               Units_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->units);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("valueorder"))) {
            pvalue->m.valueorderPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               Valueorder_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->valueorder);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("link"))) {
            { Link* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Link);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Link (pdata2);
            DOMTest_Link (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->link_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("parameter"))) {
            { Parameter* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Parameter);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Parameter (pdata2);
            DOMTest_Parameter (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->parameter_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("values"))) {
            DOMTest_Values (pctxt, &pvalue->values, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_AltXdata (OSCTXT* pctxt, AltXdata* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("label"))) {
            pvalue->m.labelPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->label = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->label = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("linkid"))) {
            pvalue->m.linkidPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->linkid = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->linkid = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("units"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               Units_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->units);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("valueorder"))) {
            pvalue->m.valueorderPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               Valueorder_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->valueorder);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("link"))) {
            { Link* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Link);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Link (pdata2);
            DOMTest_Link (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->link_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("parameter"))) {
            { Parameter* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Parameter);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Parameter (pdata2);
            DOMTest_Parameter (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->parameter_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("values"))) {
            DOMTest_Values (pctxt, &pvalue->values, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Peaktable_peak_baseline_basecurve_baseXdata (OSCTXT* pctxt, 
   Peaktable_peak_baseline_basecurve_baseXdata* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("values"))) {
            DOMTest_Values (pctxt, &pvalue->values, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Peaktable_peak_baseline_basecurve_baseYdata (OSCTXT* pctxt, 
   Peaktable_peak_baseline_basecurve_baseYdata* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("values"))) {
            DOMTest_Values (pctxt, &pvalue->values, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Peaktable_peak_baseline_basecurve (OSCTXT* pctxt, 
   Peaktable_peak_baseline_basecurve* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("baseXdata"))) {
            DOMTest_Peaktable_peak_baseline_basecurve_baseXdata (pctxt, &pvalue->baseXdata, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("baseYdata"))) {
            DOMTest_Peaktable_peak_baseline_basecurve_baseYdata (pctxt, &pvalue->baseYdata, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Peaktable_peak_baseline (OSCTXT* pctxt, 
   Peaktable_peak_baseline* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("parameter"))) {
            { Parameter* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Parameter);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Parameter (pdata2);
            DOMTest_Parameter (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->parameter_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("startXvalue"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->startXvalue);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("startYvalue"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->startYvalue);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("endXvalue"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->endXvalue);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("endYvalue"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->endYvalue);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("basecurve"))) {
            pvalue->m.basecurvePresent = 1;
            DOMTest_Peaktable_peak_baseline_basecurve (pctxt, &pvalue->basecurve, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Peaktable_peak (OSCTXT* pctxt, Peaktable_peak* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("group"))) {
            pvalue->m.groupPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->group = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->group = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("name"))) {
            pvalue->m.namePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->name = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->name = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("number"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->number = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("parameter"))) {
            { Parameter* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Parameter);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Parameter (pdata2);
            DOMTest_Parameter (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->parameter_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("peakXvalue"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->peakXvalue);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("peakYvalue"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->peakYvalue);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("baseline"))) {
            pvalue->m.baselinePresent = 1;
            DOMTest_Peaktable_peak_baseline (pctxt, &pvalue->baseline, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Peaktable (OSCTXT* pctxt, Peaktable* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("name"))) {
            pvalue->m.namePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->name = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->name = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("parameter"))) {
            { Parameter* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Parameter);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Parameter (pdata2);
            DOMTest_Parameter (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->parameter_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("peak"))) {
            { Peaktable_peak* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Peaktable_peak);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Peaktable_peak (pdata2);
            DOMTest_Peaktable_peak (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->peak_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Ydata (OSCTXT* pctxt, Ydata* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("label"))) {
            pvalue->m.labelPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->label = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->label = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("units"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               Units_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->units);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("parameter"))) {
            { Parameter* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Parameter);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Parameter (pdata2);
            DOMTest_Parameter (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->parameter_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("values"))) {
            DOMTest_Values (pctxt, &pvalue->values, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("peaktable"))) {
            { Peaktable* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Peaktable);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Peaktable (pdata2);
            DOMTest_Peaktable (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->peaktable_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Xdata (OSCTXT* pctxt, Xdata* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("label"))) {
            pvalue->m.labelPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->label = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->label = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("linkid"))) {
            pvalue->m.linkidPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->linkid = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->linkid = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("units"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               Units_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->units);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("valueorder"))) {
            pvalue->m.valueorderPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               Valueorder_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->valueorder);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("link"))) {
            { Link* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Link);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Link (pdata2);
            DOMTest_Link (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->link_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("parameter"))) {
            { Parameter* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Parameter);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Parameter (pdata2);
            DOMTest_Parameter (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->parameter_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("values"))) {
            DOMTest_Values (pctxt, &pvalue->values, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("altXdata"))) {
            { AltXdata* pdata2;
            pdata2 = rtxMemAllocType (pctxt, AltXdata);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AltXdata (pdata2);
            DOMTest_AltXdata (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->altXdata_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Ydata"))) {
            { Ydata* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Ydata);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ydata (pdata2);
            DOMTest_Ydata (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->ydata_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Trace (OSCTXT* pctxt, Trace* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("name"))) {
            pvalue->m.namePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->name = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->name = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("technique"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               Technique_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->technique);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("parameter"))) {
            { Parameter* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Parameter);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Parameter (pdata2);
            DOMTest_Parameter (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->parameter_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("coordinates"))) {
            { Coordinates* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Coordinates);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Coordinates (pdata2);
            DOMTest_Coordinates (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->coordinates_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Xdata"))) {
            { Xdata* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Xdata);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Xdata (pdata2);
            DOMTest_Xdata (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->xdata_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Experiment (OSCTXT* pctxt, Experiment* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("name"))) {
            pvalue->m.namePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->name = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->name = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("collectdate"))) {
            pvalue->m.collectdatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->collectdate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->collectdate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("parameter"))) {
            { Parameter* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Parameter);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Parameter (pdata2);
            DOMTest_Parameter (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->parameter_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("trace"))) {
            { Trace* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Trace);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Trace (pdata2);
            DOMTest_Trace (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->trace_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_GAML (OSCTXT* pctxt, GAML* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("name"))) {
            pvalue->m.namePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->name = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->name = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->version = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->version = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("integrity"))) {
            pvalue->m.integrityPresent = 1;
            DOMTest_GAML_integrity (pctxt, &pvalue->integrity, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("parameter"))) {
            { Parameter* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Parameter);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Parameter (pdata2);
            DOMTest_Parameter (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->parameter_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("experiment"))) {
            { Experiment* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Experiment);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Experiment (pdata2);
            DOMTest_Experiment (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->experiment_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

