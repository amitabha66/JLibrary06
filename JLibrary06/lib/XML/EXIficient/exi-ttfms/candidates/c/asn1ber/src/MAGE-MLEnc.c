/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "MAGE-ML.h"
#include "rtxsrc/rtxCommon.h"

/**************************************************************/
/*                                                            */
/*  SpecializedQuantitationType_ref                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SpecializedQuantitationType_ref (OSCTXT* pctxt,
   SpecializedQuantitationType_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SpecializedQuantitationType_ref (OSCTXT* pctxt, 
   SpecializedQuantitationType_ref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DerivedSignal_ref                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DerivedSignal_ref (OSCTXT* pctxt,
   DerivedSignal_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DerivedSignal_ref (OSCTXT* pctxt, DerivedSignal_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasuredSignal_ref                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MeasuredSignal_ref (OSCTXT* pctxt,
   MeasuredSignal_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MeasuredSignal_ref (OSCTXT* pctxt, MeasuredSignal_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Error_ref                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Error_ref (OSCTXT* pctxt,
   Error_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Error_ref (OSCTXT* pctxt, Error_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PValue_ref                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PValue_ref (OSCTXT* pctxt,
   PValue_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PValue_ref (OSCTXT* pctxt, PValue_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExpectedValue_ref                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExpectedValue_ref (OSCTXT* pctxt,
   ExpectedValue_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ExpectedValue_ref (OSCTXT* pctxt, ExpectedValue_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ratio_ref                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Ratio_ref (OSCTXT* pctxt,
   Ratio_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Ratio_ref (OSCTXT* pctxt, Ratio_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PresentAbsent_ref                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PresentAbsent_ref (OSCTXT* pctxt,
   PresentAbsent_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PresentAbsent_ref (OSCTXT* pctxt, PresentAbsent_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Failed_ref                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Failed_ref (OSCTXT* pctxt,
   Failed_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Failed_ref (OSCTXT* pctxt, Failed_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantitationType_ref_1                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantitationType_ref_1 (OSCTXT* pctxt,
   QuantitationType_ref_1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_SpecializedQuantitationType_ref (pctxt, pvalue->u.specializedQuantitationType_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_DerivedSignal_ref (pctxt, pvalue->u.derivedSignal_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_MeasuredSignal_ref (pctxt, pvalue->u.measuredSignal_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 4:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
            asn1E_Error_ref (pctxt, pvalue->u.error_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 5:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
            asn1E_PValue_ref (pctxt, pvalue->u.pValue_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 6:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
            asn1E_ExpectedValue_ref (pctxt, pvalue->u.expectedValue_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 7:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
            asn1E_Ratio_ref (pctxt, pvalue->u.ratio_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 8:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
            asn1E_PresentAbsent_ref (pctxt, pvalue->u.presentAbsent_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 9:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
            asn1E_Failed_ref (pctxt, pvalue->u.failed_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_QuantitationType_ref_1 (OSCTXT* pctxt, 
   QuantitationType_ref_1* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode specializedQuantitationType_ref */

         stat = XmlEnc_SpecializedQuantitationType_ref (pctxt, pvalue->
            u.specializedQuantitationType_ref
            , OSUTF8("SpecializedQuantitationType_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode derivedSignal_ref */

         stat = XmlEnc_DerivedSignal_ref (pctxt, pvalue->u.derivedSignal_ref
            , OSUTF8("DerivedSignal_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode measuredSignal_ref */

         stat = XmlEnc_MeasuredSignal_ref (pctxt, pvalue->u.measuredSignal_ref
            , OSUTF8("MeasuredSignal_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 4:
         /* encode error_ref */

         stat = XmlEnc_Error_ref (pctxt, pvalue->u.error_ref
            , OSUTF8("Error_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 5:
         /* encode pValue_ref */

         stat = XmlEnc_PValue_ref (pctxt, pvalue->u.pValue_ref
            , OSUTF8("PValue_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 6:
         /* encode expectedValue_ref */

         stat = XmlEnc_ExpectedValue_ref (pctxt, pvalue->u.expectedValue_ref
            , OSUTF8("ExpectedValue_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 7:
         /* encode ratio_ref */

         stat = XmlEnc_Ratio_ref (pctxt, pvalue->u.ratio_ref
            , OSUTF8("Ratio_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 8:
         /* encode presentAbsent_ref */

         stat = XmlEnc_PresentAbsent_ref (pctxt, pvalue->u.presentAbsent_ref
            , OSUTF8("PresentAbsent_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 9:
         /* encode failed_ref */

         stat = XmlEnc_Failed_ref (pctxt, pvalue->u.failed_ref
            , OSUTF8("Failed_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantitationType_assnref                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantitationType_assnref (OSCTXT* pctxt,
   QuantitationType_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_QuantitationType_ref_1 (pctxt, pvalue, ASN1IMPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   if (tagging == ASN1EXPL) {
      ll = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
   }
   ll0 += ll;

   return (ll0);
}

int XmlEnc_QuantitationType_assnref (OSCTXT* pctxt, 
   QuantitationType_assnref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_QuantitationType_ref_1 (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetQuantitationType_assnref                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TargetQuantitationType_assnref (OSCTXT* pctxt,
   TargetQuantitationType_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_QuantitationType_ref_1 (pctxt, pvalue, ASN1IMPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   if (tagging == ASN1EXPL) {
      ll = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
   }
   ll0 += ll;

   return (ll0);
}

int XmlEnc_TargetQuantitationType_assnref (OSCTXT* pctxt, 
   TargetQuantitationType_assnref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_QuantitationType_ref_1 (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_ref                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Database_ref (OSCTXT* pctxt,
   Database_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Database_ref (OSCTXT* pctxt, Database_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_ref_element                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Database_ref_element (OSCTXT* pctxt,
   Database_ref_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode database_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Database_ref (pctxt, &pvalue->database_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Database_ref_element (OSCTXT* pctxt, Database_ref_element* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode database_ref */

   stat = XmlEnc_Database_ref (pctxt, &pvalue->database_ref
      , OSUTF8("Database_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_assnref                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Database_assnref (OSCTXT* pctxt,
   Database_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_Database_ref_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Database_assnref (OSCTXT* pctxt, Database_assnref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_Database_ref_element (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NameValueType                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_NameValueType (OSCTXT* pctxt,
   NameValueType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode propertySets_assnlist */

   if (pvalue->m.propertySets_assnlistPresent) {
      if (pvalue->propertySets_assnlist == NULL) {
         rtxErrAddStrParm (pctxt, "pvalue->propertySets_assnlist");
         return LOG_RTERR (pctxt, RTERR_NULLPTR);
      }
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_PropertySets_assnlist (pctxt, (PropertySets_assnlist*)pvalue->propertySets_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode value */

   if (pvalue->m.valuePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->value, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode type */

   if (pvalue->m.typePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->type, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_NameValueType (OSCTXT* pctxt, NameValueType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.typePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" type=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->type, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.valuePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" value=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->value, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode propertySets_assnlist */

   if (pvalue->m.propertySets_assnlistPresent) {
      stat = XmlEnc_PropertySets_assnlist (pctxt, pvalue->propertySets_assnlist
         , OSUTF8("PropertySets_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PropertySets_assnlist                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PropertySets_assnlist (OSCTXT* pctxt,
   PropertySets_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode nameValueType_list */

   if (!(pvalue->nameValueType_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "PropertySets_assnlist.nameValueType_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->nameValueType_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->nameValueType_list.tail;
   while (0 != pnode2) {
      ll = asn1E_NameValueType (pctxt, ((NameValueType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PropertySets_assnlist (OSCTXT* pctxt, 
   PropertySets_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode nameValueType_list */

   if (!(pvalue->nameValueType_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "PropertySets_assnlist.nameValueType_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->nameValueType_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->nameValueType_list.head;
   while (0 != pnode) {
      stat = XmlEnc_NameValueType (pctxt, ((NameValueType*)pnode->data)
         , OSUTF8("NameValueType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Extendable_content                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Extendable_content (OSCTXT* pctxt,
   Extendable_content *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode propertySets_assnlist */

   if (pvalue->m.propertySets_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_PropertySets_assnlist (pctxt, &pvalue->propertySets_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Extendable_content (OSCTXT* pctxt, Extendable_content* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode propertySets_assnlist */

   if (pvalue->m.propertySets_assnlistPresent) {
      stat = XmlEnc_PropertySets_assnlist (pctxt, &pvalue->
         propertySets_assnlist, OSUTF8("PropertySets_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExternalReference                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExternalReference (OSCTXT* pctxt,
   ExternalReference *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode exportedFromServer */

   if (pvalue->m.exportedFromServerPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_utf8str (pctxt, pvalue->exportedFromServer, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode exportedFromDB */

   if (pvalue->m.exportedFromDBPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->exportedFromDB, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode exportName */

   if (pvalue->m.exportNamePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->exportName, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode exportID */

   if (pvalue->m.exportIDPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->exportID, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ExternalReference (OSCTXT* pctxt, ExternalReference* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.exportIDPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" exportID=\""), 11);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->exportID, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.exportNamePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" exportName=\""), 13);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->exportName, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.exportedFromDBPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" exportedFromDB=\""), 17);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->exportedFromDB, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.exportedFromServerPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" exportedFromServer=\""), 21);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->exportedFromServer, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExternalReference_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExternalReference_element (OSCTXT* pctxt,
   ExternalReference_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode externalReference */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_ExternalReference (pctxt, &pvalue->externalReference, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ExternalReference_element (OSCTXT* pctxt, 
   ExternalReference_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode externalReference */

   stat = XmlEnc_ExternalReference (pctxt, &pvalue->externalReference
      , OSUTF8("ExternalReference"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExternalReference_assn                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExternalReference_assn (OSCTXT* pctxt,
   ExternalReference_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_ExternalReference_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ExternalReference_assn (OSCTXT* pctxt, 
   ExternalReference_assn* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_ExternalReference_element (pctxt, pvalue
      , elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ArrayDesign_ref                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ArrayDesign_ref (OSCTXT* pctxt,
   ArrayDesign_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ArrayDesign_ref (OSCTXT* pctxt, ArrayDesign_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PhysicalArrayDesign_ref                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PhysicalArrayDesign_ref (OSCTXT* pctxt,
   PhysicalArrayDesign_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PhysicalArrayDesign_ref (OSCTXT* pctxt, 
   PhysicalArrayDesign_ref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ArrayDesign_ref_1                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ArrayDesign_ref_1 (OSCTXT* pctxt,
   ArrayDesign_ref_1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_ArrayDesign_ref (pctxt, pvalue->u.arrayDesign_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_PhysicalArrayDesign_ref (pctxt, pvalue->u.physicalArrayDesign_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   if (tagging == ASN1EXPL) {
      ll1 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll1);
      if (ll1 < 0) return LOG_RTERR (pctxt, ll1);
   }

   ll0 += ll1;

   return (ll0);
}

int XmlEnc_ArrayDesign_ref_1 (OSCTXT* pctxt, ArrayDesign_ref_1* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode arrayDesign_ref */

         stat = XmlEnc_ArrayDesign_ref (pctxt, pvalue->u.arrayDesign_ref
            , OSUTF8("ArrayDesign_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode physicalArrayDesign_ref */

         stat = XmlEnc_PhysicalArrayDesign_ref (pctxt, pvalue->
            u.physicalArrayDesign_ref
            , OSUTF8("PhysicalArrayDesign_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ArrayDesign_assnref                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ArrayDesign_assnref (OSCTXT* pctxt,
   ArrayDesign_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_ArrayDesign_ref_1 (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ArrayDesign_assnref (OSCTXT* pctxt, ArrayDesign_assnref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_ArrayDesign_ref_1 (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeatureGroup_ref                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FeatureGroup_ref (OSCTXT* pctxt,
   FeatureGroup_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FeatureGroup_ref (OSCTXT* pctxt, FeatureGroup_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeatureGroup_ref_element                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FeatureGroup_ref_element (OSCTXT* pctxt,
   FeatureGroup_ref_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode featureGroup_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_FeatureGroup_ref (pctxt, &pvalue->featureGroup_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FeatureGroup_ref_element (OSCTXT* pctxt, 
   FeatureGroup_ref_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode featureGroup_ref */

   stat = XmlEnc_FeatureGroup_ref (pctxt, &pvalue->featureGroup_ref
      , OSUTF8("FeatureGroup_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeatureGroup_assnref                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FeatureGroup_assnref (OSCTXT* pctxt,
   FeatureGroup_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_FeatureGroup_ref_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_FeatureGroup_assnref (OSCTXT* pctxt, FeatureGroup_assnref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_FeatureGroup_ref_element (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Zone_ref                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Zone_ref (OSCTXT* pctxt,
   Zone_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Zone_ref (OSCTXT* pctxt, Zone_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Zone_ref_element                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Zone_ref_element (OSCTXT* pctxt,
   Zone_ref_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode zone_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Zone_ref (pctxt, &pvalue->zone_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Zone_ref_element (OSCTXT* pctxt, Zone_ref_element* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode zone_ref */

   stat = XmlEnc_Zone_ref (pctxt, &pvalue->zone_ref
      , OSUTF8("Zone_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Zone_assnref                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Zone_assnref (OSCTXT* pctxt,
   Zone_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_Zone_ref_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Zone_assnref (OSCTXT* pctxt, Zone_assnref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_Zone_ref_element (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DistanceUnit_unitNameCV                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DistanceUnit_unitNameCV (OSCTXT* pctxt,
   DistanceUnit_unitNameCV *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 7)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_DistanceUnit_unitNameCV (OSCTXT* pctxt, 
   DistanceUnit_unitNameCV value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      DistanceUnit_unitNameCV_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DistanceUnit                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DistanceUnit (OSCTXT* pctxt,
   DistanceUnit *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode unitNameCV */

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 7)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_DistanceUnit_unitNameCV (pctxt, &pvalue->unitNameCV, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode unitName */

   if (pvalue->m.unitNamePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->unitName, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DistanceUnit (OSCTXT* pctxt, DistanceUnit* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.unitNamePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitName=\""), 11);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->unitName, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitNameCV=\""), 13);

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 7)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_DistanceUnit_unitNameCV (pctxt, pvalue->unitNameCV, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DistanceUnit_assn                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DistanceUnit_assn (OSCTXT* pctxt,
   DistanceUnit_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode distanceUnit */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_DistanceUnit (pctxt, &pvalue->distanceUnit, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DistanceUnit_assn (OSCTXT* pctxt, DistanceUnit_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode distanceUnit */

   stat = XmlEnc_DistanceUnit (pctxt, &pvalue->distanceUnit
      , OSUTF8("DistanceUnit"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ZoneLayout                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ZoneLayout (OSCTXT* pctxt,
   ZoneLayout *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode distanceUnit_assn */

   if (pvalue->m.distanceUnit_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_DistanceUnit_assn (pctxt, &pvalue->distanceUnit_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode spacingBetweenRows */

   if (pvalue->m.spacingBetweenRowsPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_utf8str (pctxt, pvalue->spacingBetweenRows, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode spacingBetweenCols */

   if (pvalue->m.spacingBetweenColsPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->spacingBetweenCols, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode numFeaturesPerRow */

   if (pvalue->m.numFeaturesPerRowPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->numFeaturesPerRow, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode numFeaturesPerCol */

   if (pvalue->m.numFeaturesPerColPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->numFeaturesPerCol, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ZoneLayout (OSCTXT* pctxt, ZoneLayout* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.numFeaturesPerColPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" numFeaturesPerCol=\""), 20);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->numFeaturesPerCol, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.numFeaturesPerRowPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" numFeaturesPerRow=\""), 20);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->numFeaturesPerRow, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.spacingBetweenColsPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" spacingBetweenCols=\""), 21);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->spacingBetweenCols, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.spacingBetweenRowsPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" spacingBetweenRows=\""), 21);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->spacingBetweenRows, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode distanceUnit_assn */

   if (pvalue->m.distanceUnit_assnPresent) {
      stat = XmlEnc_DistanceUnit_assn (pctxt, &pvalue->distanceUnit_assn
         , OSUTF8("DistanceUnit_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ZoneLayout_element                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ZoneLayout_element (OSCTXT* pctxt,
   ZoneLayout_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode zoneLayout */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_ZoneLayout (pctxt, &pvalue->zoneLayout, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ZoneLayout_element (OSCTXT* pctxt, ZoneLayout_element* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode zoneLayout */

   stat = XmlEnc_ZoneLayout (pctxt, &pvalue->zoneLayout
      , OSUTF8("ZoneLayout"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ZoneLayout_assn                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ZoneLayout_assn (OSCTXT* pctxt,
   ZoneLayout_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_ZoneLayout_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ZoneLayout_assn (OSCTXT* pctxt, ZoneLayout_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_ZoneLayout_element (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Person_ref                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Person_ref (OSCTXT* pctxt,
   Person_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Person_ref (OSCTXT* pctxt, Person_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Organization_ref                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Organization_ref (OSCTXT* pctxt,
   Organization_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Organization_ref (OSCTXT* pctxt, Organization_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Contact_ref_1                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Contact_ref_1 (OSCTXT* pctxt,
   Contact_ref_1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_Person_ref (pctxt, pvalue->u.person_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_Organization_ref (pctxt, pvalue->u.organization_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Contact_ref_1 (OSCTXT* pctxt, Contact_ref_1* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode person_ref */

         stat = XmlEnc_Person_ref (pctxt, pvalue->u.person_ref
            , OSUTF8("Person_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode organization_ref */

         stat = XmlEnc_Organization_ref (pctxt, pvalue->u.organization_ref
            , OSUTF8("Organization_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Performer_assnref                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Performer_assnref (OSCTXT* pctxt,
   Performer_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_Contact_ref_1 (pctxt, pvalue, ASN1IMPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   if (tagging == ASN1EXPL) {
      ll = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
   }
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Performer_assnref (OSCTXT* pctxt, Performer_assnref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_Contact_ref_1 (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Security_ref                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Security_ref (OSCTXT* pctxt,
   Security_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Security_ref (OSCTXT* pctxt, Security_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Security_ref_element                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Security_ref_element (OSCTXT* pctxt,
   Security_ref_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode security_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Security_ref (pctxt, &pvalue->security_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Security_ref_element (OSCTXT* pctxt, Security_ref_element* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode security_ref */

   stat = XmlEnc_Security_ref (pctxt, &pvalue->security_ref
      , OSUTF8("Security_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Security_assnref                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Security_assnref (OSCTXT* pctxt,
   Security_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_Security_ref_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Security_assnref (OSCTXT* pctxt, Security_assnref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_Security_ref_element (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Measurement_kindCV                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Measurement_kindCV (OSCTXT* pctxt,
   Measurement_kindCV *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 7)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Measurement_kindCV (OSCTXT* pctxt, Measurement_kindCV value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      Measurement_kindCV_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Measurement_type                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Measurement_type (OSCTXT* pctxt,
   Measurement_type *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Measurement_type (OSCTXT* pctxt, Measurement_type value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      Measurement_type_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConcentrationUnit_unitNameCV                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ConcentrationUnit_unitNameCV (OSCTXT* pctxt,
   ConcentrationUnit_unitNameCV *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 12)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ConcentrationUnit_unitNameCV (OSCTXT* pctxt, 
   ConcentrationUnit_unitNameCV value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      ConcentrationUnit_unitNameCV_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConcentrationUnit                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ConcentrationUnit (OSCTXT* pctxt,
   ConcentrationUnit *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode unitNameCV */

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 12)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_ConcentrationUnit_unitNameCV (pctxt, &pvalue->unitNameCV, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode unitName */

   if (pvalue->m.unitNamePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->unitName, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ConcentrationUnit (OSCTXT* pctxt, ConcentrationUnit* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.unitNamePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitName=\""), 11);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->unitName, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitNameCV=\""), 13);

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 12)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_ConcentrationUnit_unitNameCV (pctxt, pvalue->unitNameCV
      , 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MassUnit_unitNameCV                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MassUnit_unitNameCV (OSCTXT* pctxt,
   MassUnit_unitNameCV *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 7)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_MassUnit_unitNameCV (OSCTXT* pctxt, MassUnit_unitNameCV value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      MassUnit_unitNameCV_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MassUnit                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MassUnit (OSCTXT* pctxt,
   MassUnit *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode unitNameCV */

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 7)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_MassUnit_unitNameCV (pctxt, &pvalue->unitNameCV, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode unitName */

   if (pvalue->m.unitNamePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->unitName, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MassUnit (OSCTXT* pctxt, MassUnit* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.unitNamePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitName=\""), 11);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->unitName, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitNameCV=\""), 13);

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 7)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_MassUnit_unitNameCV (pctxt, pvalue->unitNameCV, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantityUnit_unitNameCV                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantityUnit_unitNameCV (OSCTXT* pctxt,
   QuantityUnit_unitNameCV *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 8)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_QuantityUnit_unitNameCV (OSCTXT* pctxt, 
   QuantityUnit_unitNameCV value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      QuantityUnit_unitNameCV_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantityUnit                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantityUnit (OSCTXT* pctxt,
   QuantityUnit *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode unitNameCV */

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 8)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_QuantityUnit_unitNameCV (pctxt, &pvalue->unitNameCV, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode unitName */

   if (pvalue->m.unitNamePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->unitName, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuantityUnit (OSCTXT* pctxt, QuantityUnit* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.unitNamePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitName=\""), 11);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->unitName, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitNameCV=\""), 13);

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 8)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_QuantityUnit_unitNameCV (pctxt, pvalue->unitNameCV, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TemperatureUnit_unitNameCV                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TemperatureUnit_unitNameCV (OSCTXT* pctxt,
   TemperatureUnit_unitNameCV *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_TemperatureUnit_unitNameCV (OSCTXT* pctxt, 
   TemperatureUnit_unitNameCV value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      TemperatureUnit_unitNameCV_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TemperatureUnit                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TemperatureUnit (OSCTXT* pctxt,
   TemperatureUnit *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode unitNameCV */

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_TemperatureUnit_unitNameCV (pctxt, &pvalue->unitNameCV, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode unitName */

   if (pvalue->m.unitNamePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->unitName, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TemperatureUnit (OSCTXT* pctxt, TemperatureUnit* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.unitNamePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitName=\""), 11);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->unitName, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitNameCV=\""), 13);

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TemperatureUnit_unitNameCV (pctxt, pvalue->unitNameCV, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeUnit_unitNameCV                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TimeUnit_unitNameCV (OSCTXT* pctxt,
   TimeUnit_unitNameCV *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 8)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_TimeUnit_unitNameCV (OSCTXT* pctxt, TimeUnit_unitNameCV value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      TimeUnit_unitNameCV_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeUnit                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TimeUnit (OSCTXT* pctxt,
   TimeUnit *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode unitNameCV */

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 8)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_TimeUnit_unitNameCV (pctxt, &pvalue->unitNameCV, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode unitName */

   if (pvalue->m.unitNamePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->unitName, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TimeUnit (OSCTXT* pctxt, TimeUnit* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.unitNamePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitName=\""), 11);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->unitName, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitNameCV=\""), 13);

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 8)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_TimeUnit_unitNameCV (pctxt, pvalue->unitNameCV, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VolumeUnit_unitNameCV                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_VolumeUnit_unitNameCV (OSCTXT* pctxt,
   VolumeUnit_unitNameCV *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 8)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_VolumeUnit_unitNameCV (OSCTXT* pctxt, VolumeUnit_unitNameCV value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      VolumeUnit_unitNameCV_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VolumeUnit                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_VolumeUnit (OSCTXT* pctxt,
   VolumeUnit *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode unitNameCV */

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 8)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_VolumeUnit_unitNameCV (pctxt, &pvalue->unitNameCV, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode unitName */

   if (pvalue->m.unitNamePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->unitName, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_VolumeUnit (OSCTXT* pctxt, VolumeUnit* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.unitNamePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitName=\""), 11);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->unitName, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitNameCV=\""), 13);

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 8)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_VolumeUnit_unitNameCV (pctxt, pvalue->unitNameCV, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unit_classes_group                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Unit_classes_group (OSCTXT* pctxt,
   Unit_classes_group *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_ConcentrationUnit (pctxt, pvalue->u.concentrationUnit, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_DistanceUnit (pctxt, pvalue->u.distanceUnit, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_MassUnit (pctxt, pvalue->u.massUnit, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 4:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
            asn1E_QuantityUnit (pctxt, pvalue->u.quantityUnit, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 5:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
            asn1E_TemperatureUnit (pctxt, pvalue->u.temperatureUnit, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 6:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
            asn1E_TimeUnit (pctxt, pvalue->u.timeUnit, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 7:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
            asn1E_VolumeUnit (pctxt, pvalue->u.volumeUnit, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Unit_classes_group (OSCTXT* pctxt, Unit_classes_group* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode concentrationUnit */

         stat = XmlEnc_ConcentrationUnit (pctxt, pvalue->u.concentrationUnit
            , OSUTF8("ConcentrationUnit"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode distanceUnit */

         stat = XmlEnc_DistanceUnit (pctxt, pvalue->u.distanceUnit
            , OSUTF8("DistanceUnit"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode massUnit */

         stat = XmlEnc_MassUnit (pctxt, pvalue->u.massUnit
            , OSUTF8("MassUnit"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 4:
         /* encode quantityUnit */

         stat = XmlEnc_QuantityUnit (pctxt, pvalue->u.quantityUnit
            , OSUTF8("QuantityUnit"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 5:
         /* encode temperatureUnit */

         stat = XmlEnc_TemperatureUnit (pctxt, pvalue->u.temperatureUnit
            , OSUTF8("TemperatureUnit"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 6:
         /* encode timeUnit */

         stat = XmlEnc_TimeUnit (pctxt, pvalue->u.timeUnit
            , OSUTF8("TimeUnit"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 7:
         /* encode volumeUnit */

         stat = XmlEnc_VolumeUnit (pctxt, pvalue->u.volumeUnit
            , OSUTF8("VolumeUnit"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unit_classes_1                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Unit_classes_1 (OSCTXT* pctxt,
   Unit_classes_1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode unit_classes */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Unit_classes_group (pctxt, &pvalue->unit_classes, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Unit_classes_1 (OSCTXT* pctxt, Unit_classes_1* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode unit_classes */

   stat = XmlEnc_Unit_classes_group (pctxt, &pvalue->unit_classes
      , OSUTF8(""), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unit_assn                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Unit_assn (OSCTXT* pctxt,
   Unit_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_Unit_classes_1 (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Unit_assn (OSCTXT* pctxt, Unit_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_Unit_classes_1 (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Measurement                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Measurement (OSCTXT* pctxt,
   Measurement *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode unit_assn */

   if (pvalue->m.unit_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_Unit_assn (pctxt, &pvalue->unit_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode value */

   if (pvalue->m.valuePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_utf8str (pctxt, pvalue->value, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode type */

   if (pvalue->m.typePresent) {
      if(pvalue->type < 0 || pvalue->type > 1)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         asn1E_Measurement_type (pctxt, &pvalue->type, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode otherKind */

   if (pvalue->m.otherKindPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->otherKind, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode kindCV */

   if (pvalue->m.kindCVPresent) {
      if(pvalue->kindCV < 0 || pvalue->kindCV > 7)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         asn1E_Measurement_kindCV (pctxt, &pvalue->kindCV, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Measurement (OSCTXT* pctxt, Measurement* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.kindCVPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" kindCV=\""), 9);

      if(pvalue->kindCV < 0 || pvalue->kindCV > 7)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_Measurement_kindCV (pctxt, pvalue->kindCV, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');
   }

   if (pvalue->m.otherKindPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" otherKind=\""), 12);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->otherKind, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.typePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" type=\""), 7);

      if(pvalue->type < 0 || pvalue->type > 1)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_Measurement_type (pctxt, pvalue->type, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');
   }

   if (pvalue->m.valuePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" value=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->value, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode unit_assn */

   if (pvalue->m.unit_assnPresent) {
      stat = XmlEnc_Unit_assn (pctxt, &pvalue->unit_assn
         , OSUTF8("Unit_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Measurement_element                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Measurement_element (OSCTXT* pctxt,
   Measurement_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode measurement */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Measurement (pctxt, &pvalue->measurement, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Measurement_element (OSCTXT* pctxt, Measurement_element* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode measurement */

   stat = XmlEnc_Measurement (pctxt, &pvalue->measurement
      , OSUTF8("Measurement"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ActionMeasurement_assn                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ActionMeasurement_assn (OSCTXT* pctxt,
   ActionMeasurement_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_Measurement_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ActionMeasurement_assn (OSCTXT* pctxt, 
   ActionMeasurement_assn* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_Measurement_element (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DefaultValue_assn                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DefaultValue_assn (OSCTXT* pctxt,
   DefaultValue_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_Measurement_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_DefaultValue_assn (OSCTXT* pctxt, DefaultValue_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_Measurement_element (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Measurement_assn                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Measurement_assn (OSCTXT* pctxt,
   Measurement_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_Measurement_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Measurement_assn (OSCTXT* pctxt, Measurement_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_Measurement_element (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Type_assn                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Type_assn (OSCTXT* pctxt,
   Type_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode ontologyEntry */

   if (pvalue->ontologyEntry == NULL) {
      rtxErrAddStrParm (pctxt, "pvalue->ontologyEntry");
      return LOG_RTERR (pctxt, RTERR_NULLPTR);
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_OntologyEntry (pctxt, (OntologyEntry*)pvalue->ontologyEntry, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Type_assn (OSCTXT* pctxt, Type_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry */

   stat = XmlEnc_OntologyEntry (pctxt, pvalue->ontologyEntry
      , OSUTF8("OntologyEntry"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DatabaseEntry                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DatabaseEntry (OSCTXT* pctxt,
   DatabaseEntry *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode database_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_Database_assnref (pctxt, &pvalue->database_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode type_assn */

   if (pvalue->m.type_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Type_assn (pctxt, &pvalue->type_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode accessionVersion */

   if (pvalue->m.accessionVersionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->accessionVersion, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode accession */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->accession, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode uRI */

   if (pvalue->m.uRIPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->uRI, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DatabaseEntry (OSCTXT* pctxt, DatabaseEntry* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.uRIPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" URI=\""), 6);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->uRI, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" accession=\""), 12);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->accession, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.accessionVersionPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" accessionVersion=\""), 19);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->accessionVersion, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode type_assn */

   if (pvalue->m.type_assnPresent) {
      stat = XmlEnc_Type_assn (pctxt, &pvalue->type_assn
         , OSUTF8("Type_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode database_assnref */

   stat = XmlEnc_Database_assnref (pctxt, &pvalue->database_assnref
      , OSUTF8("Database_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  OntologyReference_assn                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_OntologyReference_assn (OSCTXT* pctxt,
   OntologyReference_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode databaseEntry */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_DatabaseEntry (pctxt, &pvalue->databaseEntry, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_OntologyReference_assn (OSCTXT* pctxt, 
   OntologyReference_assn* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode databaseEntry */

   stat = XmlEnc_DatabaseEntry (pctxt, &pvalue->databaseEntry
      , OSUTF8("DatabaseEntry"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Associations_assnlist                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Associations_assnlist (OSCTXT* pctxt,
   Associations_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode ontologyEntry_list */

   if (!(pvalue->ontologyEntry_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Associations_assnlist.ontologyEntry_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->ontologyEntry_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->ontologyEntry_list.tail;
   while (0 != pnode2) {
      ll = asn1E_OntologyEntry (pctxt, (OntologyEntry*)((OntologyEntry*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Associations_assnlist (OSCTXT* pctxt, 
   Associations_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry_list */

   if (!(pvalue->ontologyEntry_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Associations_assnlist.ontologyEntry_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->ontologyEntry_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->ontologyEntry_list.head;
   while (0 != pnode) {
      stat = XmlEnc_OntologyEntry (pctxt, ((OntologyEntry*)pnode->data)
         , OSUTF8("OntologyEntry"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  OntologyEntry                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_OntologyEntry (OSCTXT* pctxt,
   OntologyEntry *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode associations_assnlist */

   if (pvalue->m.associations_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_Associations_assnlist (pctxt, &pvalue->associations_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode ontologyReference_assn */

   if (pvalue->m.ontologyReference_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_OntologyReference_assn (pctxt, &pvalue->ontologyReference_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode value */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_utf8str (pctxt, pvalue->value, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode description */

   if (pvalue->m.descriptionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->description, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode category */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->category, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_OntologyEntry (OSCTXT* pctxt, OntologyEntry* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" category=\""), 11);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->category, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.descriptionPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" description=\""), 14);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->description, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" value=\""), 8);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->value, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode ontologyReference_assn */

   if (pvalue->m.ontologyReference_assnPresent) {
      stat = XmlEnc_OntologyReference_assn (pctxt, &pvalue->
         ontologyReference_assn, OSUTF8("OntologyReference_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode associations_assnlist */

   if (pvalue->m.associations_assnlistPresent) {
      stat = XmlEnc_Associations_assnlist (pctxt, &pvalue->
         associations_assnlist, OSUTF8("Associations_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Annotations_assnlist                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Annotations_assnlist (OSCTXT* pctxt,
   Annotations_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode ontologyEntry_list */

   if (!(pvalue->ontologyEntry_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Annotations_assnlist.ontologyEntry_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->ontologyEntry_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->ontologyEntry_list.tail;
   while (0 != pnode2) {
      ll = asn1E_OntologyEntry (pctxt, ((OntologyEntry*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Annotations_assnlist (OSCTXT* pctxt, Annotations_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry_list */

   if (!(pvalue->ontologyEntry_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Annotations_assnlist.ontologyEntry_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->ontologyEntry_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->ontologyEntry_list.head;
   while (0 != pnode) {
      stat = XmlEnc_OntologyEntry (pctxt, ((OntologyEntry*)pnode->data)
         , OSUTF8("OntologyEntry"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DatabaseReferences_assnlist                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DatabaseReferences_assnlist (OSCTXT* pctxt,
   DatabaseReferences_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode databaseEntry_list */

   if (!(pvalue->databaseEntry_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DatabaseReferences_assnlist.databaseEntry_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->databaseEntry_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->databaseEntry_list.tail;
   while (0 != pnode2) {
      ll = asn1E_DatabaseEntry (pctxt, ((DatabaseEntry*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DatabaseReferences_assnlist (OSCTXT* pctxt, 
   DatabaseReferences_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode databaseEntry_list */

   if (!(pvalue->databaseEntry_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DatabaseReferences_assnlist.databaseEntry_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->databaseEntry_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->databaseEntry_list.head;
   while (0 != pnode) {
      stat = XmlEnc_DatabaseEntry (pctxt, ((DatabaseEntry*)pnode->data)
         , OSUTF8("DatabaseEntry"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Parameters_assnlist                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Parameters_assnlist (OSCTXT* pctxt,
   Parameters_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode ontologyEntry_list */

   if (!(pvalue->ontologyEntry_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Parameters_assnlist.ontologyEntry_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->ontologyEntry_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->ontologyEntry_list.tail;
   while (0 != pnode2) {
      ll = asn1E_OntologyEntry (pctxt, ((OntologyEntry*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Parameters_assnlist (OSCTXT* pctxt, Parameters_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry_list */

   if (!(pvalue->ontologyEntry_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Parameters_assnlist.ontologyEntry_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->ontologyEntry_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->ontologyEntry_list.head;
   while (0 != pnode) {
      stat = XmlEnc_OntologyEntry (pctxt, ((OntologyEntry*)pnode->data)
         , OSUTF8("OntologyEntry"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BibliographicReference                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BibliographicReference (OSCTXT* pctxt,
   BibliographicReference *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode parameters_assnlist */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|11,
      asn1E_Parameters_assnlist (pctxt, &pvalue->parameters_assnlist, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      if (pvalue->describable_content == NULL) {
         rtxErrAddStrParm (pctxt, "pvalue->describable_content");
         return LOG_RTERR (pctxt, RTERR_NULLPTR);
      }
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10,
         asn1E_Describable_content (pctxt, (Describable_content*)pvalue->describable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode year */

   if (pvalue->m.yearPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|9,
         xe_utf8str (pctxt, pvalue->year, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode volume */

   if (pvalue->m.volumePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|8,
         xe_utf8str (pctxt, pvalue->volume, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode title */

   if (pvalue->m.titlePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
         xe_utf8str (pctxt, pvalue->title, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode publisher */

   if (pvalue->m.publisherPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
         xe_utf8str (pctxt, pvalue->publisher, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode publication */

   if (pvalue->m.publicationPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         xe_utf8str (pctxt, pvalue->publication, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode pages */

   if (pvalue->m.pagesPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_utf8str (pctxt, pvalue->pages, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode issue */

   if (pvalue->m.issuePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_utf8str (pctxt, pvalue->issue, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode editor */

   if (pvalue->m.editorPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->editor, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode authors */

   if (pvalue->m.authorsPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->authors, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode uRI */

   if (pvalue->m.uRIPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->uRI, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BibliographicReference (OSCTXT* pctxt, 
   BibliographicReference* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.uRIPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" URI=\""), 6);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->uRI, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.authorsPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" authors=\""), 10);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->authors, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.editorPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" editor=\""), 9);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->editor, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.issuePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" issue=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->issue, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.pagesPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" pages=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->pages, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.publicationPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" publication=\""), 14);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->publication, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.publisherPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" publisher=\""), 12);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->publisher, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.titlePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" title=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->title, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.volumePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" volume=\""), 9);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->volume, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.yearPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" year=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->year, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      stat = XmlEnc_Describable_content (pctxt, pvalue->describable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode parameters_assnlist */

   stat = XmlEnc_Parameters_assnlist (pctxt, &pvalue->parameters_assnlist
      , OSUTF8("Parameters_assnlist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BibliographicReferences_assnlist                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BibliographicReferences_assnlist (OSCTXT* pctxt,
   BibliographicReferences_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode bibliographicReference_list */

   if (!(pvalue->bibliographicReference_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BibliographicReferences_assnlist.bibliographicReference_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bibliographicReference_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->bibliographicReference_list.tail;
   while (0 != pnode2) {
      ll = asn1E_BibliographicReference (pctxt, ((BibliographicReference*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BibliographicReferences_assnlist (OSCTXT* pctxt, 
   BibliographicReferences_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bibliographicReference_list */

   if (!(pvalue->bibliographicReference_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BibliographicReferences_assnlist.bibliographicReference_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bibliographicReference_list.count
         );
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->bibliographicReference_list.head;
   while (0 != pnode) {
      stat = XmlEnc_BibliographicReference (pctxt, 
         ((BibliographicReference*)pnode->data)
         , OSUTF8("BibliographicReference"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Description                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Description (OSCTXT* pctxt,
   Description *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode bibliographicReferences_assnlist */

   if (pvalue->m.bibliographicReferences_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_BibliographicReferences_assnlist (pctxt, &pvalue->bibliographicReferences_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode databaseReferences_assnlist */

   if (pvalue->m.databaseReferences_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_DatabaseReferences_assnlist (pctxt, &pvalue->databaseReferences_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode annotations_assnlist */

   if (pvalue->m.annotations_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Annotations_assnlist (pctxt, &pvalue->annotations_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode externalReference_assn */

   if (pvalue->m.externalReference_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_ExternalReference_assn (pctxt, &pvalue->externalReference_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      if (pvalue->describable_content == NULL) {
         rtxErrAddStrParm (pctxt, "pvalue->describable_content");
         return LOG_RTERR (pctxt, RTERR_NULLPTR);
      }
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Describable_content (pctxt, (Describable_content*)pvalue->describable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode text */

   if (pvalue->m.textPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->text, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode uRI */

   if (pvalue->m.uRIPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->uRI, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Description (OSCTXT* pctxt, Description* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.uRIPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" URI=\""), 6);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->uRI, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.textPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" text=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->text, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      stat = XmlEnc_Describable_content (pctxt, pvalue->describable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode externalReference_assn */

   if (pvalue->m.externalReference_assnPresent) {
      stat = XmlEnc_ExternalReference_assn (pctxt, &pvalue->
         externalReference_assn, OSUTF8("ExternalReference_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode annotations_assnlist */

   if (pvalue->m.annotations_assnlistPresent) {
      stat = XmlEnc_Annotations_assnlist (pctxt, &pvalue->annotations_assnlist
         , OSUTF8("Annotations_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode databaseReferences_assnlist */

   if (pvalue->m.databaseReferences_assnlistPresent) {
      stat = XmlEnc_DatabaseReferences_assnlist (pctxt, &pvalue->
         databaseReferences_assnlist
         , OSUTF8("DatabaseReferences_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bibliographicReferences_assnlist */

   if (pvalue->m.bibliographicReferences_assnlistPresent) {
      stat = XmlEnc_BibliographicReferences_assnlist (pctxt, &pvalue->
         bibliographicReferences_assnlist
         , OSUTF8("BibliographicReferences_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Descriptions_assnlist                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Descriptions_assnlist (OSCTXT* pctxt,
   Descriptions_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode description_list */

   if (!(pvalue->description_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Descriptions_assnlist.description_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->description_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->description_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Description (pctxt, ((Description*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Descriptions_assnlist (OSCTXT* pctxt, 
   Descriptions_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode description_list */

   if (!(pvalue->description_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Descriptions_assnlist.description_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->description_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->description_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Description (pctxt, ((Description*)pnode->data)
         , OSUTF8("Description"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Audit_action                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Audit_action (OSCTXT* pctxt,
   Audit_action *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Audit_action (OSCTXT* pctxt, Audit_action value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      Audit_action_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Audit                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Audit (OSCTXT* pctxt,
   Audit *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode performer_assnref */

   if (pvalue->m.performer_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Performer_assnref (pctxt, &pvalue->performer_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      if (pvalue->describable_content == NULL) {
         rtxErrAddStrParm (pctxt, "pvalue->describable_content");
         return LOG_RTERR (pctxt, RTERR_NULLPTR);
      }
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Describable_content (pctxt, (Describable_content*)pvalue->describable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode date */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->date, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode action */

   if(pvalue->action < 0 || pvalue->action > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_Audit_action (pctxt, &pvalue->action, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Audit (OSCTXT* pctxt, Audit* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" action=\""), 9);

   if(pvalue->action < 0 || pvalue->action > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_Audit_action (pctxt, pvalue->action, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" date=\""), 7);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->date, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      stat = XmlEnc_Describable_content (pctxt, pvalue->describable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode performer_assnref */

   if (pvalue->m.performer_assnrefPresent) {
      stat = XmlEnc_Performer_assnref (pctxt, &pvalue->performer_assnref
         , OSUTF8("Performer_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuditTrail_assnlist                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AuditTrail_assnlist (OSCTXT* pctxt,
   AuditTrail_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode audit_list */

   if (!(pvalue->audit_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "AuditTrail_assnlist.audit_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->audit_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->audit_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Audit (pctxt, ((Audit*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_AuditTrail_assnlist (OSCTXT* pctxt, AuditTrail_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode audit_list */

   if (!(pvalue->audit_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "AuditTrail_assnlist.audit_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->audit_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->audit_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Audit (pctxt, ((Audit*)pnode->data)
         , OSUTF8("Audit"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Describable_content                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Describable_content (OSCTXT* pctxt,
   Describable_content *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode security_assnref */

   if (pvalue->m.security_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Security_assnref (pctxt, &pvalue->security_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode auditTrail_assnlist */

   if (pvalue->m.auditTrail_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_AuditTrail_assnlist (pctxt, &pvalue->auditTrail_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode descriptions_assnlist */

   if (pvalue->m.descriptions_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Descriptions_assnlist (pctxt, &pvalue->descriptions_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Describable_content (OSCTXT* pctxt, Describable_content* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode descriptions_assnlist */

   if (pvalue->m.descriptions_assnlistPresent) {
      stat = XmlEnc_Descriptions_assnlist (pctxt, &pvalue->
         descriptions_assnlist, OSUTF8("Descriptions_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode auditTrail_assnlist */

   if (pvalue->m.auditTrail_assnlistPresent) {
      stat = XmlEnc_AuditTrail_assnlist (pctxt, &pvalue->auditTrail_assnlist
         , OSUTF8("AuditTrail_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode security_assnref */

   if (pvalue->m.security_assnrefPresent) {
      stat = XmlEnc_Security_assnref (pctxt, &pvalue->security_assnref
         , OSUTF8("Security_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Types_assnlist                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Types_assnlist (OSCTXT* pctxt,
   Types_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode ontologyEntry_list */

   if (!(pvalue->ontologyEntry_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Types_assnlist.ontologyEntry_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->ontologyEntry_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->ontologyEntry_list.tail;
   while (0 != pnode2) {
      ll = asn1E_OntologyEntry (pctxt, ((OntologyEntry*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Types_assnlist (OSCTXT* pctxt, Types_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry_list */

   if (!(pvalue->ontologyEntry_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Types_assnlist.ontologyEntry_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->ontologyEntry_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->ontologyEntry_list.head;
   while (0 != pnode) {
      stat = XmlEnc_OntologyEntry (pctxt, ((OntologyEntry*)pnode->data)
         , OSUTF8("OntologyEntry"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PhysicalBioAssay_ref                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PhysicalBioAssay_ref (OSCTXT* pctxt,
   PhysicalBioAssay_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PhysicalBioAssay_ref (OSCTXT* pctxt, PhysicalBioAssay_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DerivedBioAssay_ref                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DerivedBioAssay_ref (OSCTXT* pctxt,
   DerivedBioAssay_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DerivedBioAssay_ref (OSCTXT* pctxt, DerivedBioAssay_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasuredBioAssay_ref                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MeasuredBioAssay_ref (OSCTXT* pctxt,
   MeasuredBioAssay_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MeasuredBioAssay_ref (OSCTXT* pctxt, MeasuredBioAssay_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssay_ref_1                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssay_ref_1 (OSCTXT* pctxt,
   BioAssay_ref_1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_PhysicalBioAssay_ref (pctxt, pvalue->u.physicalBioAssay_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_DerivedBioAssay_ref (pctxt, pvalue->u.derivedBioAssay_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_MeasuredBioAssay_ref (pctxt, pvalue->u.measuredBioAssay_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_BioAssay_ref_1 (OSCTXT* pctxt, BioAssay_ref_1* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode physicalBioAssay_ref */

         stat = XmlEnc_PhysicalBioAssay_ref (pctxt, pvalue->
            u.physicalBioAssay_ref, OSUTF8("PhysicalBioAssay_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode derivedBioAssay_ref */

         stat = XmlEnc_DerivedBioAssay_ref (pctxt, pvalue->
            u.derivedBioAssay_ref, OSUTF8("DerivedBioAssay_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode measuredBioAssay_ref */

         stat = XmlEnc_MeasuredBioAssay_ref (pctxt, pvalue->
            u.measuredBioAssay_ref, OSUTF8("MeasuredBioAssay_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TopLevelBioAssays_assnreflist                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TopLevelBioAssays_assnreflist (OSCTXT* pctxt,
   TopLevelBioAssays_assnreflist *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TopLevelBioAssays_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_BioAssay_ref_1 (pctxt, ((BioAssay_ref_1*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TopLevelBioAssays_assnreflist (OSCTXT* pctxt, 
   TopLevelBioAssays_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TopLevelBioAssays_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_BioAssay_ref_1 (pctxt, ((BioAssay_ref_1*)pnode->data)
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Identifiable_content                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Identifiable_content (OSCTXT* pctxt,
   Identifiable_content *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_Describable_content (pctxt, pvalue, ASN1IMPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   if (tagging == ASN1EXPL) {
      ll = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
   }
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Identifiable_content (OSCTXT* pctxt, Identifiable_content* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_Describable_content (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Category_assn                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Category_assn (OSCTXT* pctxt,
   Category_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode ontologyEntry */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_OntologyEntry (pctxt, &pvalue->ontologyEntry, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Category_assn (OSCTXT* pctxt, Category_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry */

   stat = XmlEnc_OntologyEntry (pctxt, &pvalue->ontologyEntry
      , OSUTF8("OntologyEntry"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Value_assn                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Value_assn (OSCTXT* pctxt,
   Value_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode ontologyEntry */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_OntologyEntry (pctxt, &pvalue->ontologyEntry, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Value_assn (OSCTXT* pctxt, Value_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry */

   stat = XmlEnc_OntologyEntry (pctxt, &pvalue->ontologyEntry
      , OSUTF8("OntologyEntry"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FactorValue_choice                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FactorValue_choice (OSCTXT* pctxt,
   FactorValue_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_Measurement_assn (pctxt, pvalue->u.measurement_assn, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_Value_assn (pctxt, pvalue->u.value_assn, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_FactorValue_choice (OSCTXT* pctxt, FactorValue_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode measurement_assn */

         stat = XmlEnc_Measurement_assn (pctxt, pvalue->u.measurement_assn
            , OSUTF8("Measurement_assn"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode value_assn */

         stat = XmlEnc_Value_assn (pctxt, pvalue->u.value_assn
            , OSUTF8("Value_assn"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FactorValue                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FactorValue (OSCTXT* pctxt,
   FactorValue *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode choice */

   if (pvalue->m.choicePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_FactorValue_choice (pctxt, &pvalue->choice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FactorValue (OSCTXT* pctxt, FactorValue* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode choice */

   if (pvalue->m.choicePresent) {
      stat = XmlEnc_FactorValue_choice (pctxt, &pvalue->choice
         , OSUTF8(""), 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FactorValues_assnlist                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FactorValues_assnlist (OSCTXT* pctxt,
   FactorValues_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode factorValue_list */

   if (!(pvalue->factorValue_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FactorValues_assnlist.factorValue_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->factorValue_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->factorValue_list.tail;
   while (0 != pnode2) {
      ll = asn1E_FactorValue (pctxt, ((FactorValue*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FactorValues_assnlist (OSCTXT* pctxt, 
   FactorValues_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode factorValue_list */

   if (!(pvalue->factorValue_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FactorValues_assnlist.factorValue_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->factorValue_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->factorValue_list.head;
   while (0 != pnode) {
      stat = XmlEnc_FactorValue (pctxt, ((FactorValue*)pnode->data)
         , OSUTF8("FactorValue"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExperimentalFactor                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExperimentalFactor (OSCTXT* pctxt,
   ExperimentalFactor *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode annotations_assnlist */

   if (pvalue->m.annotations_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_Annotations_assnlist (pctxt, &pvalue->annotations_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode factorValues_assnlist */

   if (pvalue->m.factorValues_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_FactorValues_assnlist (pctxt, &pvalue->factorValues_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode category_assn */

   if (pvalue->m.category_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Category_assn (pctxt, &pvalue->category_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ExperimentalFactor (OSCTXT* pctxt, ExperimentalFactor* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode category_assn */

   if (pvalue->m.category_assnPresent) {
      stat = XmlEnc_Category_assn (pctxt, &pvalue->category_assn
         , OSUTF8("Category_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode factorValues_assnlist */

   if (pvalue->m.factorValues_assnlistPresent) {
      stat = XmlEnc_FactorValues_assnlist (pctxt, &pvalue->
         factorValues_assnlist, OSUTF8("FactorValues_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode annotations_assnlist */

   if (pvalue->m.annotations_assnlistPresent) {
      stat = XmlEnc_Annotations_assnlist (pctxt, &pvalue->annotations_assnlist
         , OSUTF8("Annotations_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExperimentalFactors_assnlist                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExperimentalFactors_assnlist (OSCTXT* pctxt,
   ExperimentalFactors_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode experimentalFactor_list */

   if (!(pvalue->experimentalFactor_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ExperimentalFactors_assnlist.experimentalFactor_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->experimentalFactor_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->experimentalFactor_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ExperimentalFactor (pctxt, ((ExperimentalFactor*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ExperimentalFactors_assnlist (OSCTXT* pctxt, 
   ExperimentalFactors_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode experimentalFactor_list */

   if (!(pvalue->experimentalFactor_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ExperimentalFactors_assnlist.experimentalFactor_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->experimentalFactor_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->experimentalFactor_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ExperimentalFactor (pctxt, 
         ((ExperimentalFactor*)pnode->data)
         , OSUTF8("ExperimentalFactor"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QualityControlDescription_assn                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QualityControlDescription_assn (OSCTXT* pctxt,
   QualityControlDescription_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode description */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Description (pctxt, &pvalue->description, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QualityControlDescription_assn (OSCTXT* pctxt, 
   QualityControlDescription_assn* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode description */

   stat = XmlEnc_Description (pctxt, &pvalue->description
      , OSUTF8("Description"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NormalizationDescription_assn                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_NormalizationDescription_assn (OSCTXT* pctxt,
   NormalizationDescription_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode description */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Description (pctxt, &pvalue->description, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_NormalizationDescription_assn (OSCTXT* pctxt, 
   NormalizationDescription_assn* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode description */

   stat = XmlEnc_Description (pctxt, &pvalue->description
      , OSUTF8("Description"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReplicateDescription_assn                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ReplicateDescription_assn (OSCTXT* pctxt,
   ReplicateDescription_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode description */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Description (pctxt, &pvalue->description, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ReplicateDescription_assn (OSCTXT* pctxt, 
   ReplicateDescription_assn* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode description */

   stat = XmlEnc_Description (pctxt, &pvalue->description
      , OSUTF8("Description"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExperimentDesign                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExperimentDesign (OSCTXT* pctxt,
   ExperimentDesign *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode replicateDescription_assn */

   if (pvalue->m.replicateDescription_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_ReplicateDescription_assn (pctxt, &pvalue->replicateDescription_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode normalizationDescription_assn */

   if (pvalue->m.normalizationDescription_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_NormalizationDescription_assn (pctxt, &pvalue->normalizationDescription_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode qualityControlDescription_assn */

   if (pvalue->m.qualityControlDescription_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_QualityControlDescription_assn (pctxt, &pvalue->qualityControlDescription_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode experimentalFactors_assnlist */

   if (pvalue->m.experimentalFactors_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_ExperimentalFactors_assnlist (pctxt, &pvalue->experimentalFactors_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode topLevelBioAssays_assnreflist */

   if (pvalue->m.topLevelBioAssays_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_TopLevelBioAssays_assnreflist (pctxt, &pvalue->topLevelBioAssays_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode types_assnlist */

   if (pvalue->m.types_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Types_assnlist (pctxt, &pvalue->types_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Describable_content (pctxt, &pvalue->describable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ExperimentDesign (OSCTXT* pctxt, ExperimentDesign* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      stat = XmlEnc_Describable_content (pctxt, &pvalue->describable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode types_assnlist */

   if (pvalue->m.types_assnlistPresent) {
      stat = XmlEnc_Types_assnlist (pctxt, &pvalue->types_assnlist
         , OSUTF8("Types_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode topLevelBioAssays_assnreflist */

   if (pvalue->m.topLevelBioAssays_assnreflistPresent) {
      stat = XmlEnc_TopLevelBioAssays_assnreflist (pctxt, &pvalue->
         topLevelBioAssays_assnreflist
         , OSUTF8("TopLevelBioAssays_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode experimentalFactors_assnlist */

   if (pvalue->m.experimentalFactors_assnlistPresent) {
      stat = XmlEnc_ExperimentalFactors_assnlist (pctxt, &pvalue->
         experimentalFactors_assnlist
         , OSUTF8("ExperimentalFactors_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode qualityControlDescription_assn */

   if (pvalue->m.qualityControlDescription_assnPresent) {
      stat = XmlEnc_QualityControlDescription_assn (pctxt, &pvalue->
         qualityControlDescription_assn
         , OSUTF8("QualityControlDescription_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode normalizationDescription_assn */

   if (pvalue->m.normalizationDescription_assnPresent) {
      stat = XmlEnc_NormalizationDescription_assn (pctxt, &pvalue->
         normalizationDescription_assn
         , OSUTF8("NormalizationDescription_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode replicateDescription_assn */

   if (pvalue->m.replicateDescription_assnPresent) {
      stat = XmlEnc_ReplicateDescription_assn (pctxt, &pvalue->
         replicateDescription_assn
         , OSUTF8("ReplicateDescription_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExperimentDesign_element                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExperimentDesign_element (OSCTXT* pctxt,
   ExperimentDesign_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode experimentDesign */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_ExperimentDesign (pctxt, &pvalue->experimentDesign, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ExperimentDesign_element (OSCTXT* pctxt, 
   ExperimentDesign_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode experimentDesign */

   stat = XmlEnc_ExperimentDesign (pctxt, &pvalue->experimentDesign
      , OSUTF8("ExperimentDesign"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExperimentDesign_assn                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExperimentDesign_assn (OSCTXT* pctxt,
   ExperimentDesign_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_ExperimentDesign_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ExperimentDesign_assn (OSCTXT* pctxt, 
   ExperimentDesign_assn* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_ExperimentDesign_element (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExperimentalFactor_ref                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExperimentalFactor_ref (OSCTXT* pctxt,
   ExperimentalFactor_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ExperimentalFactor_ref (OSCTXT* pctxt, 
   ExperimentalFactor_ref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExperimentalFactor_ref_element                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExperimentalFactor_ref_element (OSCTXT* pctxt,
   ExperimentalFactor_ref_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode experimentalFactor_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_ExperimentalFactor_ref (pctxt, &pvalue->experimentalFactor_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ExperimentalFactor_ref_element (OSCTXT* pctxt, 
   ExperimentalFactor_ref_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode experimentalFactor_ref */

   stat = XmlEnc_ExperimentalFactor_ref (pctxt, &pvalue->experimentalFactor_ref
      , OSUTF8("ExperimentalFactor_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExperimentalFactor_assnref                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExperimentalFactor_assnref (OSCTXT* pctxt,
   ExperimentalFactor_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_ExperimentalFactor_ref_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ExperimentalFactor_assnref (OSCTXT* pctxt, 
   ExperimentalFactor_assnref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_ExperimentalFactor_ref_element (pctxt, pvalue
      , elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ArrayGroup_ref                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ArrayGroup_ref (OSCTXT* pctxt,
   ArrayGroup_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ArrayGroup_ref (OSCTXT* pctxt, ArrayGroup_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ArrayGroup_ref_element                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ArrayGroup_ref_element (OSCTXT* pctxt,
   ArrayGroup_ref_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode arrayGroup_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_ArrayGroup_ref (pctxt, &pvalue->arrayGroup_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ArrayGroup_ref_element (OSCTXT* pctxt, 
   ArrayGroup_ref_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode arrayGroup_ref */

   stat = XmlEnc_ArrayGroup_ref (pctxt, &pvalue->arrayGroup_ref
      , OSUTF8("ArrayGroup_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ArrayGroup_assnref                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ArrayGroup_assnref (OSCTXT* pctxt,
   ArrayGroup_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_ArrayGroup_ref_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ArrayGroup_assnref (OSCTXT* pctxt, ArrayGroup_assnref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_ArrayGroup_ref_element (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ArrayManufacture_ref                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ArrayManufacture_ref (OSCTXT* pctxt,
   ArrayManufacture_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ArrayManufacture_ref (OSCTXT* pctxt, ArrayManufacture_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ArrayManufacture_ref_element                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ArrayManufacture_ref_element (OSCTXT* pctxt,
   ArrayManufacture_ref_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode arrayManufacture_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_ArrayManufacture_ref (pctxt, &pvalue->arrayManufacture_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ArrayManufacture_ref_element (OSCTXT* pctxt, 
   ArrayManufacture_ref_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode arrayManufacture_ref */

   stat = XmlEnc_ArrayManufacture_ref (pctxt, &pvalue->arrayManufacture_ref
      , OSUTF8("ArrayManufacture_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Information_assnref                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Information_assnref (OSCTXT* pctxt,
   Information_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_ArrayManufacture_ref_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Information_assnref (OSCTXT* pctxt, Information_assnref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_ArrayManufacture_ref_element (pctxt, pvalue
      , elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositionDelta                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PositionDelta (OSCTXT* pctxt,
   PositionDelta *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode distanceUnit_assn */

   if (pvalue->m.distanceUnit_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_DistanceUnit_assn (pctxt, &pvalue->distanceUnit_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode deltaY */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->deltaY, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode deltaX */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->deltaX, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PositionDelta (OSCTXT* pctxt, PositionDelta* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" deltaX=\""), 9);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->deltaX, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" deltaY=\""), 9);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->deltaY, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode distanceUnit_assn */

   if (pvalue->m.distanceUnit_assnPresent) {
      stat = XmlEnc_DistanceUnit_assn (pctxt, &pvalue->distanceUnit_assn
         , OSUTF8("DistanceUnit_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositionDelta_element                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PositionDelta_element (OSCTXT* pctxt,
   PositionDelta_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode positionDelta */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_PositionDelta (pctxt, &pvalue->positionDelta, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PositionDelta_element (OSCTXT* pctxt, 
   PositionDelta_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode positionDelta */

   stat = XmlEnc_PositionDelta (pctxt, &pvalue->positionDelta
      , OSUTF8("PositionDelta"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositionDelta_assn                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PositionDelta_assn (OSCTXT* pctxt,
   PositionDelta_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_PositionDelta_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_PositionDelta_assn (OSCTXT* pctxt, PositionDelta_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_PositionDelta_element (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Parameter_ref                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Parameter_ref (OSCTXT* pctxt,
   Parameter_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Parameter_ref (OSCTXT* pctxt, Parameter_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Parameter_ref_element                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Parameter_ref_element (OSCTXT* pctxt,
   Parameter_ref_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode parameter_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Parameter_ref (pctxt, &pvalue->parameter_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Parameter_ref_element (OSCTXT* pctxt, 
   Parameter_ref_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode parameter_ref */

   stat = XmlEnc_Parameter_ref (pctxt, &pvalue->parameter_ref
      , OSUTF8("Parameter_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ParameterType_assnref                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ParameterType_assnref (OSCTXT* pctxt,
   ParameterType_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_Parameter_ref_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ParameterType_assnref (OSCTXT* pctxt, 
   ParameterType_assnref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_Parameter_ref_element (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Protocol_ref                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Protocol_ref (OSCTXT* pctxt,
   Protocol_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Protocol_ref (OSCTXT* pctxt, Protocol_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Protocol_ref_element                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Protocol_ref_element (OSCTXT* pctxt,
   Protocol_ref_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode protocol_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Protocol_ref (pctxt, &pvalue->protocol_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Protocol_ref_element (OSCTXT* pctxt, Protocol_ref_element* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode protocol_ref */

   stat = XmlEnc_Protocol_ref (pctxt, &pvalue->protocol_ref
      , OSUTF8("Protocol_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Protocol_assnref                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Protocol_assnref (OSCTXT* pctxt,
   Protocol_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_Protocol_ref_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Protocol_assnref (OSCTXT* pctxt, Protocol_assnref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_Protocol_ref_element (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SequencePosition                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SequencePosition (OSCTXT* pctxt,
   SequencePosition *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode start */

   if (pvalue->m.startPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->start, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode end */

   if (pvalue->m.endPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->end, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SequencePosition (OSCTXT* pctxt, SequencePosition* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.endPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" end=\""), 6);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->end, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.startPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" start=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->start, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CompositeSequence_ref                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CompositeSequence_ref (OSCTXT* pctxt,
   CompositeSequence_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CompositeSequence_ref (OSCTXT* pctxt, 
   CompositeSequence_ref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Composite_assnref                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Composite_assnref (OSCTXT* pctxt,
   Composite_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode compositeSequence_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_CompositeSequence_ref (pctxt, &pvalue->compositeSequence_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Composite_assnref (OSCTXT* pctxt, Composite_assnref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode compositeSequence_ref */

   stat = XmlEnc_CompositeSequence_ref (pctxt, &pvalue->compositeSequence_ref
      , OSUTF8("CompositeSequence_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MismatchInformation                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MismatchInformation (OSCTXT* pctxt,
   MismatchInformation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode startCoord */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_utf8str (pctxt, pvalue->startCoord, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode replacedLength */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->replacedLength, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode newSequence */

   if (pvalue->m.newSequencePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->newSequence, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MismatchInformation (OSCTXT* pctxt, MismatchInformation* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.newSequencePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" newSequence=\""), 14);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->newSequence, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" replacedLength=\""), 17);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->replacedLength, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" startCoord=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->startCoord, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MismatchInformation_assnlist                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MismatchInformation_assnlist (OSCTXT* pctxt,
   MismatchInformation_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode mismatchInformation_list */

   if (!(pvalue->mismatchInformation_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "MismatchInformation_assnlist.mismatchInformation_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->mismatchInformation_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->mismatchInformation_list.tail;
   while (0 != pnode2) {
      ll = asn1E_MismatchInformation (pctxt, ((MismatchInformation*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MismatchInformation_assnlist (OSCTXT* pctxt, 
   MismatchInformation_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode mismatchInformation_list */

   if (!(pvalue->mismatchInformation_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "MismatchInformation_assnlist.mismatchInformation_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->mismatchInformation_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->mismatchInformation_list.head;
   while (0 != pnode) {
      stat = XmlEnc_MismatchInformation (pctxt, 
         ((MismatchInformation*)pnode->data)
         , OSUTF8("MismatchInformation"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CompositePosition                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CompositePosition (OSCTXT* pctxt,
   CompositePosition *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode mismatchInformation_assnlist */

   if (pvalue->m.mismatchInformation_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_MismatchInformation_assnlist (pctxt, &pvalue->mismatchInformation_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode composite_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_Composite_assnref (pctxt, &pvalue->composite_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode start */

   if (pvalue->m.startPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->start, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode end */

   if (pvalue->m.endPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->end, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CompositePosition (OSCTXT* pctxt, CompositePosition* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.endPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" end=\""), 6);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->end, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.startPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" start=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->start, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode composite_assnref */

   stat = XmlEnc_Composite_assnref (pctxt, &pvalue->composite_assnref
      , OSUTF8("Composite_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode mismatchInformation_assnlist */

   if (pvalue->m.mismatchInformation_assnlistPresent) {
      stat = XmlEnc_MismatchInformation_assnlist (pctxt, &pvalue->
         mismatchInformation_assnlist
         , OSUTF8("MismatchInformation_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reporter_ref                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Reporter_ref (OSCTXT* pctxt,
   Reporter_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Reporter_ref (OSCTXT* pctxt, Reporter_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reporter_assnref                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Reporter_assnref (OSCTXT* pctxt,
   Reporter_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode reporter_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Reporter_ref (pctxt, &pvalue->reporter_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Reporter_assnref (OSCTXT* pctxt, Reporter_assnref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode reporter_ref */

   stat = XmlEnc_Reporter_ref (pctxt, &pvalue->reporter_ref
      , OSUTF8("Reporter_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReporterPosition                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ReporterPosition (OSCTXT* pctxt,
   ReporterPosition *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode mismatchInformation_assnlist */

   if (pvalue->m.mismatchInformation_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_MismatchInformation_assnlist (pctxt, &pvalue->mismatchInformation_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode reporter_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_Reporter_assnref (pctxt, &pvalue->reporter_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode start */

   if (pvalue->m.startPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->start, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode end */

   if (pvalue->m.endPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->end, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ReporterPosition (OSCTXT* pctxt, ReporterPosition* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.endPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" end=\""), 6);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->end, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.startPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" start=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->start, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode reporter_assnref */

   stat = XmlEnc_Reporter_assnref (pctxt, &pvalue->reporter_assnref
      , OSUTF8("Reporter_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode mismatchInformation_assnlist */

   if (pvalue->m.mismatchInformation_assnlistPresent) {
      stat = XmlEnc_MismatchInformation_assnlist (pctxt, &pvalue->
         mismatchInformation_assnlist
         , OSUTF8("MismatchInformation_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SequencePosition_classes_group                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SequencePosition_classes_group (OSCTXT* pctxt,
   SequencePosition_classes_group *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_SequencePosition (pctxt, pvalue->u.sequencePosition, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_CompositePosition (pctxt, pvalue->u.compositePosition, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_ReporterPosition (pctxt, pvalue->u.reporterPosition, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_SequencePosition_classes_group (OSCTXT* pctxt, 
   SequencePosition_classes_group* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode sequencePosition */

         stat = XmlEnc_SequencePosition (pctxt, pvalue->u.sequencePosition
            , OSUTF8("SequencePosition"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode compositePosition */

         stat = XmlEnc_CompositePosition (pctxt, pvalue->u.compositePosition
            , OSUTF8("CompositePosition"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode reporterPosition */

         stat = XmlEnc_ReporterPosition (pctxt, pvalue->u.reporterPosition
            , OSUTF8("ReporterPosition"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SequencePosition_classes_1                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SequencePosition_classes_1 (OSCTXT* pctxt,
   SequencePosition_classes_1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode sequencePosition_classes */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_SequencePosition_classes_group (pctxt, &pvalue->sequencePosition_classes, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SequencePosition_classes_1 (OSCTXT* pctxt, 
   SequencePosition_classes_1* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode sequencePosition_classes */

   stat = XmlEnc_SequencePosition_classes_group (pctxt, &pvalue->
      sequencePosition_classes, OSUTF8(""), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Coordinate_assn                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Coordinate_assn (OSCTXT* pctxt,
   Coordinate_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_SequencePosition_classes_1 (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Coordinate_assn (OSCTXT* pctxt, Coordinate_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_SequencePosition_classes_1 (pctxt, pvalue
      , elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioSource_ref                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioSource_ref (OSCTXT* pctxt,
   BioSource_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioSource_ref (OSCTXT* pctxt, BioSource_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LabeledExtract_ref                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_LabeledExtract_ref (OSCTXT* pctxt,
   LabeledExtract_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_LabeledExtract_ref (OSCTXT* pctxt, LabeledExtract_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioSample_ref                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioSample_ref (OSCTXT* pctxt,
   BioSample_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioSample_ref (OSCTXT* pctxt, BioSample_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioMaterial_ref_1                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioMaterial_ref_1 (OSCTXT* pctxt,
   BioMaterial_ref_1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_BioSource_ref (pctxt, pvalue->u.bioSource_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_LabeledExtract_ref (pctxt, pvalue->u.labeledExtract_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_BioSample_ref (pctxt, pvalue->u.bioSample_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   if (tagging == ASN1EXPL) {
      ll1 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll1);
      if (ll1 < 0) return LOG_RTERR (pctxt, ll1);
   }

   ll0 += ll1;

   return (ll0);
}

int XmlEnc_BioMaterial_ref_1 (OSCTXT* pctxt, BioMaterial_ref_1* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode bioSource_ref */

         stat = XmlEnc_BioSource_ref (pctxt, pvalue->u.bioSource_ref
            , OSUTF8("BioSource_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode labeledExtract_ref */

         stat = XmlEnc_LabeledExtract_ref (pctxt, pvalue->u.labeledExtract_ref
            , OSUTF8("LabeledExtract_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode bioSample_ref */

         stat = XmlEnc_BioSample_ref (pctxt, pvalue->u.bioSample_ref
            , OSUTF8("BioSample_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioMaterial_assnref                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioMaterial_assnref (OSCTXT* pctxt,
   BioMaterial_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_BioMaterial_ref_1 (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_BioMaterial_assnref (OSCTXT* pctxt, BioMaterial_assnref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_BioMaterial_ref_1 (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssay_assnref                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssay_assnref (OSCTXT* pctxt,
   BioAssay_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_BioAssay_ref_1 (pctxt, pvalue, ASN1IMPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   if (tagging == ASN1EXPL) {
      ll = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
   }
   ll0 += ll;

   return (ll0);
}

int XmlEnc_BioAssay_assnref (OSCTXT* pctxt, BioAssay_assnref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_BioAssay_ref_1 (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayCreation                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayCreation (OSCTXT* pctxt,
   BioAssayCreation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   switch (pvalue->t) {
   case OSXSDAny_binary:
      ll = xe_OpenType (pctxt, pvalue->u.binary->data, pvalue->
         u.binary->numocts);
      break;
   case OSXSDAny_xmlText:
      ll = xe_utf8str (pctxt, pvalue->u.xmlText, tagging);
      break;
   }
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else ll0 += ll;

   return (ll0);
}

int XmlEnc_BioAssayCreation (OSCTXT* pctxt, BioAssayCreation value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (value.t == OSXSDAny_xmlText) {
      stat = rtXmlEncAnyStr (pctxt, value.u.xmlText, elemName, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      char buf[40];
      os_snprintf (buf, 40, "%d", value.t);
      rtxErrAddStrParm (pctxt, buf);
      return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Hybridization                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Hybridization (OSCTXT* pctxt,
   Hybridization *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   switch (pvalue->t) {
   case OSXSDAny_binary:
      ll = xe_OpenType (pctxt, pvalue->u.binary->data, pvalue->
         u.binary->numocts);
      break;
   case OSXSDAny_xmlText:
      ll = xe_utf8str (pctxt, pvalue->u.xmlText, tagging);
      break;
   }
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else ll0 += ll;

   return (ll0);
}

int XmlEnc_Hybridization (OSCTXT* pctxt, Hybridization value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (value.t == OSXSDAny_xmlText) {
      stat = rtXmlEncAnyStr (pctxt, value.u.xmlText, elemName, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      char buf[40];
      os_snprintf (buf, 40, "%d", value.t);
      rtxErrAddStrParm (pctxt, buf);
      return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayCreation_classes_group                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayCreation_classes_group (OSCTXT* pctxt,
   BioAssayCreation_classes_group *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_BioAssayCreation (pctxt, &pvalue->u.bioAssayCreation, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_Hybridization (pctxt, &pvalue->u.hybridization, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_BioAssayCreation_classes_group (OSCTXT* pctxt, 
   BioAssayCreation_classes_group* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode bioAssayCreation */

         stat = XmlEnc_BioAssayCreation (pctxt, pvalue->u.bioAssayCreation
            , OSUTF8("BioAssayCreation"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode hybridization */

         stat = XmlEnc_Hybridization (pctxt, pvalue->u.hybridization
            , OSUTF8("Hybridization"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayCreation_classes_1                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayCreation_classes_1 (OSCTXT* pctxt,
   BioAssayCreation_classes_1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode bioAssayCreation_classes */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_BioAssayCreation_classes_group (pctxt, &pvalue->bioAssayCreation_classes, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayCreation_classes_1 (OSCTXT* pctxt, 
   BioAssayCreation_classes_1* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bioAssayCreation_classes */

   stat = XmlEnc_BioAssayCreation_classes_group (pctxt, &pvalue->
      bioAssayCreation_classes, OSUTF8(""), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayCreation_assn                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayCreation_assn (OSCTXT* pctxt,
   BioAssayCreation_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_BioAssayCreation_classes_1 (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_BioAssayCreation_assn (OSCTXT* pctxt, 
   BioAssayCreation_assn* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_BioAssayCreation_classes_1 (pctxt, pvalue
      , elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ParameterValue                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ParameterValue (OSCTXT* pctxt,
   ParameterValue *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode parameterType_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_ParameterType_assnref (pctxt, &pvalue->parameterType_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode value */

   if (pvalue->m.valuePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->value, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ParameterValue (OSCTXT* pctxt, ParameterValue* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.valuePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" value=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->value, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode parameterType_assnref */

   stat = XmlEnc_ParameterType_assnref (pctxt, &pvalue->parameterType_assnref
      , OSUTF8("ParameterType_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ParameterValues_assnlist                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ParameterValues_assnlist (OSCTXT* pctxt,
   ParameterValues_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode parameterValue_list */

   if (!(pvalue->parameterValue_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ParameterValues_assnlist.parameterValue_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->parameterValue_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->parameterValue_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ParameterValue (pctxt, ((ParameterValue*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ParameterValues_assnlist (OSCTXT* pctxt, 
   ParameterValues_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode parameterValue_list */

   if (!(pvalue->parameterValue_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ParameterValues_assnlist.parameterValue_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->parameterValue_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->parameterValue_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ParameterValue (pctxt, ((ParameterValue*)pnode->data)
         , OSUTF8("ParameterValue"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ParameterizableApplication_content                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ParameterizableApplication_content (OSCTXT* pctxt,
   ParameterizableApplication_content *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode parameterValues_assnlist */

   if (pvalue->m.parameterValues_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ParameterValues_assnlist (pctxt, &pvalue->parameterValues_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Describable_content (pctxt, &pvalue->describable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ParameterizableApplication_content (OSCTXT* pctxt, 
   ParameterizableApplication_content* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      stat = XmlEnc_Describable_content (pctxt, &pvalue->describable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode parameterValues_assnlist */

   if (pvalue->m.parameterValues_assnlistPresent) {
      stat = XmlEnc_ParameterValues_assnlist (pctxt, &pvalue->
         parameterValues_assnlist
         , OSUTF8("ParameterValues_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Hardware_ref                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Hardware_ref (OSCTXT* pctxt,
   Hardware_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Hardware_ref (OSCTXT* pctxt, Hardware_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Hardware_assnref                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Hardware_assnref (OSCTXT* pctxt,
   Hardware_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode hardware_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Hardware_ref (pctxt, &pvalue->hardware_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Hardware_assnref (OSCTXT* pctxt, Hardware_assnref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode hardware_ref */

   stat = XmlEnc_Hardware_ref (pctxt, &pvalue->hardware_ref
      , OSUTF8("Hardware_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HardwareApplication                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_HardwareApplication (OSCTXT* pctxt,
   HardwareApplication *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode hardware_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_Hardware_assnref (pctxt, &pvalue->hardware_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode parameterizableApplication_content */

   if (pvalue->m.parameterizableApplication_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ParameterizableApplication_content (pctxt, &pvalue->parameterizableApplication_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode serialNumber */

   if (pvalue->m.serialNumberPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->serialNumber, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_HardwareApplication (OSCTXT* pctxt, HardwareApplication* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.serialNumberPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" serialNumber=\""), 15);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->serialNumber, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode parameterizableApplication_content */

   if (pvalue->m.parameterizableApplication_contentPresent) {
      stat = XmlEnc_ParameterizableApplication_content (pctxt, &pvalue->
         parameterizableApplication_content, 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode hardware_assnref */

   stat = XmlEnc_Hardware_assnref (pctxt, &pvalue->hardware_assnref
      , OSUTF8("Hardware_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HardwareApplications_assnlist                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_HardwareApplications_assnlist (OSCTXT* pctxt,
   HardwareApplications_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode hardwareApplication_list */

   if (!(pvalue->hardwareApplication_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "HardwareApplications_assnlist.hardwareApplication_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->hardwareApplication_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->hardwareApplication_list.tail;
   while (0 != pnode2) {
      ll = asn1E_HardwareApplication (pctxt, ((HardwareApplication*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_HardwareApplications_assnlist (OSCTXT* pctxt, 
   HardwareApplications_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode hardwareApplication_list */

   if (!(pvalue->hardwareApplication_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "HardwareApplications_assnlist.hardwareApplication_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->hardwareApplication_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->hardwareApplication_list.head;
   while (0 != pnode) {
      stat = XmlEnc_HardwareApplication (pctxt, 
         ((HardwareApplication*)pnode->data)
         , OSUTF8("HardwareApplication"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Software_ref                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Software_ref (OSCTXT* pctxt,
   Software_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Software_ref (OSCTXT* pctxt, Software_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Software_assnref                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Software_assnref (OSCTXT* pctxt,
   Software_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode software_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Software_ref (pctxt, &pvalue->software_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Software_assnref (OSCTXT* pctxt, Software_assnref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode software_ref */

   stat = XmlEnc_Software_ref (pctxt, &pvalue->software_ref
      , OSUTF8("Software_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SoftwareApplication                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SoftwareApplication (OSCTXT* pctxt,
   SoftwareApplication *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode software_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_Software_assnref (pctxt, &pvalue->software_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode parameterizableApplication_content */

   if (pvalue->m.parameterizableApplication_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_ParameterizableApplication_content (pctxt, &pvalue->parameterizableApplication_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode version */

   if (pvalue->m.versionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->version, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode releaseDate */

   if (pvalue->m.releaseDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->releaseDate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SoftwareApplication (OSCTXT* pctxt, SoftwareApplication* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.releaseDatePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" releaseDate=\""), 14);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->releaseDate, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.versionPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->version, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode parameterizableApplication_content */

   if (pvalue->m.parameterizableApplication_contentPresent) {
      stat = XmlEnc_ParameterizableApplication_content (pctxt, &pvalue->
         parameterizableApplication_content, 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode software_assnref */

   stat = XmlEnc_Software_assnref (pctxt, &pvalue->software_assnref
      , OSUTF8("Software_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SoftwareApplications_assnlist                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SoftwareApplications_assnlist (OSCTXT* pctxt,
   SoftwareApplications_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode softwareApplication_list */

   if (!(pvalue->softwareApplication_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SoftwareApplications_assnlist.softwareApplication_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->softwareApplication_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->softwareApplication_list.tail;
   while (0 != pnode2) {
      ll = asn1E_SoftwareApplication (pctxt, ((SoftwareApplication*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SoftwareApplications_assnlist (OSCTXT* pctxt, 
   SoftwareApplications_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode softwareApplication_list */

   if (!(pvalue->softwareApplication_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SoftwareApplications_assnlist.softwareApplication_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->softwareApplication_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->softwareApplication_list.head;
   while (0 != pnode) {
      stat = XmlEnc_SoftwareApplication (pctxt, 
         ((SoftwareApplication*)pnode->data)
         , OSUTF8("SoftwareApplication"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Performers_assnreflist                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Performers_assnreflist (OSCTXT* pctxt,
   Performers_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode person_ref_list */

   if (!(pvalue->person_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Performers_assnreflist.person_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->person_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->person_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Person_ref (pctxt, ((Person_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Performers_assnreflist (OSCTXT* pctxt, 
   Performers_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode person_ref_list */

   if (!(pvalue->person_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Performers_assnreflist.person_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->person_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->person_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Person_ref (pctxt, ((Person_ref*)pnode->data)
         , OSUTF8("Person_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ProtocolApplication                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ProtocolApplication (OSCTXT* pctxt,
   ProtocolApplication *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode protocol_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_Protocol_assnref (pctxt, &pvalue->protocol_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode performers_assnreflist */

   if (pvalue->m.performers_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Performers_assnreflist (pctxt, &pvalue->performers_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode softwareApplications_assnlist */

   if (pvalue->m.softwareApplications_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_SoftwareApplications_assnlist (pctxt, &pvalue->softwareApplications_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode hardwareApplications_assnlist */

   if (pvalue->m.hardwareApplications_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_HardwareApplications_assnlist (pctxt, &pvalue->hardwareApplications_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode parameterizableApplication_content */

   if (pvalue->m.parameterizableApplication_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ParameterizableApplication_content (pctxt, &pvalue->parameterizableApplication_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode activityDate */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->activityDate, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ProtocolApplication (OSCTXT* pctxt, ProtocolApplication* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" activityDate=\""), 15);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->activityDate, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode parameterizableApplication_content */

   if (pvalue->m.parameterizableApplication_contentPresent) {
      stat = XmlEnc_ParameterizableApplication_content (pctxt, &pvalue->
         parameterizableApplication_content, 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode hardwareApplications_assnlist */

   if (pvalue->m.hardwareApplications_assnlistPresent) {
      stat = XmlEnc_HardwareApplications_assnlist (pctxt, &pvalue->
         hardwareApplications_assnlist
         , OSUTF8("HardwareApplications_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode softwareApplications_assnlist */

   if (pvalue->m.softwareApplications_assnlistPresent) {
      stat = XmlEnc_SoftwareApplications_assnlist (pctxt, &pvalue->
         softwareApplications_assnlist
         , OSUTF8("SoftwareApplications_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode performers_assnreflist */

   if (pvalue->m.performers_assnreflistPresent) {
      stat = XmlEnc_Performers_assnreflist (pctxt, &pvalue->
         performers_assnreflist, OSUTF8("Performers_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode protocol_assnref */

   stat = XmlEnc_Protocol_assnref (pctxt, &pvalue->protocol_assnref
      , OSUTF8("Protocol_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ProtocolApplications_assnlist                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ProtocolApplications_assnlist (OSCTXT* pctxt,
   ProtocolApplications_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode protocolApplication_list */

   if (!(pvalue->protocolApplication_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ProtocolApplications_assnlist.protocolApplication_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->protocolApplication_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->protocolApplication_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ProtocolApplication (pctxt, ((ProtocolApplication*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ProtocolApplications_assnlist (OSCTXT* pctxt, 
   ProtocolApplications_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode protocolApplication_list */

   if (!(pvalue->protocolApplication_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ProtocolApplications_assnlist.protocolApplication_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->protocolApplication_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->protocolApplication_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ProtocolApplication (pctxt, 
         ((ProtocolApplication*)pnode->data)
         , OSUTF8("ProtocolApplication"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioEvent_content                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioEvent_content (OSCTXT* pctxt,
   BioEvent_content *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode protocolApplications_assnlist */

   if (pvalue->m.protocolApplications_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ProtocolApplications_assnlist (pctxt, &pvalue->protocolApplications_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioEvent_content (OSCTXT* pctxt, BioEvent_content* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode protocolApplications_assnlist */

   if (pvalue->m.protocolApplications_assnlistPresent) {
      stat = XmlEnc_ProtocolApplications_assnlist (pctxt, &pvalue->
         protocolApplications_assnlist
         , OSUTF8("ProtocolApplications_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PhysicalBioAssaySource_assnref                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PhysicalBioAssaySource_assnref (OSCTXT* pctxt,
   PhysicalBioAssaySource_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode physicalBioAssay_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_PhysicalBioAssay_ref (pctxt, &pvalue->physicalBioAssay_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PhysicalBioAssaySource_assnref (OSCTXT* pctxt, 
   PhysicalBioAssaySource_assnref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode physicalBioAssay_ref */

   stat = XmlEnc_PhysicalBioAssay_ref (pctxt, &pvalue->physicalBioAssay_ref
      , OSUTF8("PhysicalBioAssay_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeatureExtraction                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FeatureExtraction (OSCTXT* pctxt,
   FeatureExtraction *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode physicalBioAssaySource_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_PhysicalBioAssaySource_assnref (pctxt, &pvalue->physicalBioAssaySource_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode bioEvent_content */

   if (pvalue->m.bioEvent_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_BioEvent_content (pctxt, &pvalue->bioEvent_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FeatureExtraction (OSCTXT* pctxt, FeatureExtraction* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode bioEvent_content */

   if (pvalue->m.bioEvent_contentPresent) {
      stat = XmlEnc_BioEvent_content (pctxt, &pvalue->bioEvent_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode physicalBioAssaySource_assnref */

   stat = XmlEnc_PhysicalBioAssaySource_assnref (pctxt, &pvalue->
      physicalBioAssaySource_assnref
      , OSUTF8("PhysicalBioAssaySource_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeatureExtraction_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FeatureExtraction_element (OSCTXT* pctxt,
   FeatureExtraction_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode featureExtraction */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_FeatureExtraction (pctxt, &pvalue->featureExtraction, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FeatureExtraction_element (OSCTXT* pctxt, 
   FeatureExtraction_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode featureExtraction */

   stat = XmlEnc_FeatureExtraction (pctxt, &pvalue->featureExtraction
      , OSUTF8("FeatureExtraction"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeatureExtraction_assn                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FeatureExtraction_assn (OSCTXT* pctxt,
   FeatureExtraction_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_FeatureExtraction_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_FeatureExtraction_assn (OSCTXT* pctxt, 
   FeatureExtraction_assn* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_FeatureExtraction_element (pctxt, pvalue
      , elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DerivedBioAssayData_ref                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DerivedBioAssayData_ref (OSCTXT* pctxt,
   DerivedBioAssayData_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DerivedBioAssayData_ref (OSCTXT* pctxt, 
   DerivedBioAssayData_ref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasuredBioAssayData_ref                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MeasuredBioAssayData_ref (OSCTXT* pctxt,
   MeasuredBioAssayData_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MeasuredBioAssayData_ref (OSCTXT* pctxt, 
   MeasuredBioAssayData_ref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayData_ref_1                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayData_ref_1 (OSCTXT* pctxt,
   BioAssayData_ref_1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_DerivedBioAssayData_ref (pctxt, pvalue->u.derivedBioAssayData_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_MeasuredBioAssayData_ref (pctxt, pvalue->u.measuredBioAssayData_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_BioAssayData_ref_1 (OSCTXT* pctxt, BioAssayData_ref_1* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode derivedBioAssayData_ref */

         stat = XmlEnc_DerivedBioAssayData_ref (pctxt, pvalue->
            u.derivedBioAssayData_ref
            , OSUTF8("DerivedBioAssayData_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode measuredBioAssayData_ref */

         stat = XmlEnc_MeasuredBioAssayData_ref (pctxt, pvalue->
            u.measuredBioAssayData_ref
            , OSUTF8("MeasuredBioAssayData_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ClusterBioAssayData_assnref                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ClusterBioAssayData_assnref (OSCTXT* pctxt,
   ClusterBioAssayData_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_BioAssayData_ref_1 (pctxt, pvalue, ASN1IMPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   if (tagging == ASN1EXPL) {
      ll = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
   }
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ClusterBioAssayData_assnref (OSCTXT* pctxt, 
   ClusterBioAssayData_assnref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_BioAssayData_ref_1 (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayDimension_ref                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayDimension_ref (OSCTXT* pctxt,
   BioAssayDimension_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayDimension_ref (OSCTXT* pctxt, 
   BioAssayDimension_ref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayDimension_ref_element                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayDimension_ref_element (OSCTXT* pctxt,
   BioAssayDimension_ref_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode bioAssayDimension_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_BioAssayDimension_ref (pctxt, &pvalue->bioAssayDimension_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayDimension_ref_element (OSCTXT* pctxt, 
   BioAssayDimension_ref_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bioAssayDimension_ref */

   stat = XmlEnc_BioAssayDimension_ref (pctxt, &pvalue->bioAssayDimension_ref
      , OSUTF8("BioAssayDimension_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayDimension_assnref                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayDimension_assnref (OSCTXT* pctxt,
   BioAssayDimension_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_BioAssayDimension_ref_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_BioAssayDimension_assnref (OSCTXT* pctxt, 
   BioAssayDimension_assnref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_BioAssayDimension_ref_element (pctxt, pvalue
      , elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayMap_ref                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayMap_ref (OSCTXT* pctxt,
   BioAssayMap_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayMap_ref (OSCTXT* pctxt, BioAssayMap_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayMaps_assnreflist                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayMaps_assnreflist (OSCTXT* pctxt,
   BioAssayMaps_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode bioAssayMap_ref_list */

   if (!(pvalue->bioAssayMap_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioAssayMaps_assnreflist.bioAssayMap_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioAssayMap_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->bioAssayMap_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_BioAssayMap_ref (pctxt, ((BioAssayMap_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayMaps_assnreflist (OSCTXT* pctxt, 
   BioAssayMaps_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bioAssayMap_ref_list */

   if (!(pvalue->bioAssayMap_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioAssayMaps_assnreflist.bioAssayMap_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioAssayMap_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->bioAssayMap_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_BioAssayMap_ref (pctxt, ((BioAssayMap_ref*)pnode->data)
         , OSUTF8("BioAssayMap_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayMapping                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayMapping (OSCTXT* pctxt,
   BioAssayMapping *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode bioAssayMaps_assnreflist */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_BioAssayMaps_assnreflist (pctxt, &pvalue->bioAssayMaps_assnreflist, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayMapping (OSCTXT* pctxt, BioAssayMapping* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioAssayMaps_assnreflist */

   stat = XmlEnc_BioAssayMaps_assnreflist (pctxt, &pvalue->
      bioAssayMaps_assnreflist, OSUTF8("BioAssayMaps_assnreflist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayMapping_element                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayMapping_element (OSCTXT* pctxt,
   BioAssayMapping_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode bioAssayMapping */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_BioAssayMapping (pctxt, &pvalue->bioAssayMapping, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayMapping_element (OSCTXT* pctxt, 
   BioAssayMapping_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bioAssayMapping */

   stat = XmlEnc_BioAssayMapping (pctxt, &pvalue->bioAssayMapping
      , OSUTF8("BioAssayMapping"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayMapping_assn                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayMapping_assn (OSCTXT* pctxt,
   BioAssayMapping_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_BioAssayMapping_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_BioAssayMapping_assn (OSCTXT* pctxt, BioAssayMapping_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_BioAssayMapping_element (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioDataCube_order                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioDataCube_order (OSCTXT* pctxt,
   BioDataCube_order *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 5)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_BioDataCube_order (OSCTXT* pctxt, BioDataCube_order value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      BioDataCube_order_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioDataValues_content                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioDataValues_content (OSCTXT* pctxt,
   BioDataValues_content *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_Extendable_content (pctxt, pvalue, ASN1IMPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   if (tagging == ASN1EXPL) {
      ll = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
   }
   ll0 += ll;

   return (ll0);
}

int XmlEnc_BioDataValues_content (OSCTXT* pctxt, 
   BioDataValues_content* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_Extendable_content (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataInternal                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DataInternal (OSCTXT* pctxt,
   DataInternal pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_utf8str (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_DataInternal (OSCTXT* pctxt, DataInternal value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt, value, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataInternal_element                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DataInternal_element (OSCTXT* pctxt,
   DataInternal_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode dataInternal */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_DataInternal (pctxt, pvalue->dataInternal, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DataInternal_element (OSCTXT* pctxt, DataInternal_element* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode dataInternal */

   stat = XmlEnc_DataInternal (pctxt, pvalue->dataInternal
      , OSUTF8("DataInternal"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataInternal_assn                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DataInternal_assn (OSCTXT* pctxt,
   DataInternal_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_DataInternal_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_DataInternal_assn (OSCTXT* pctxt, DataInternal_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_DataInternal_element (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataExternal                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DataExternal (OSCTXT* pctxt,
   DataExternal *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode filenameURI */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_utf8str (pctxt, pvalue->filenameURI, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode dataFormatInfoURI */

   if (pvalue->m.dataFormatInfoURIPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->dataFormatInfoURI, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dataFormat */

   if (pvalue->m.dataFormatPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->dataFormat, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DataExternal (OSCTXT* pctxt, DataExternal* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.dataFormatPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" dataFormat=\""), 13);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->dataFormat, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.dataFormatInfoURIPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" dataFormatInfoURI=\""), 20);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->dataFormatInfoURI, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" filenameURI=\""), 14);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->filenameURI, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataExternal_element                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DataExternal_element (OSCTXT* pctxt,
   DataExternal_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode dataExternal */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_DataExternal (pctxt, &pvalue->dataExternal, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DataExternal_element (OSCTXT* pctxt, DataExternal_element* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode dataExternal */

   stat = XmlEnc_DataExternal (pctxt, &pvalue->dataExternal
      , OSUTF8("DataExternal"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataExternal_assn                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DataExternal_assn (OSCTXT* pctxt,
   DataExternal_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_DataExternal_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_DataExternal_assn (OSCTXT* pctxt, DataExternal_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_DataExternal_element (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioDataCube_choice                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioDataCube_choice (OSCTXT* pctxt,
   BioDataCube_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_DataInternal_assn (pctxt, pvalue->u.dataInternal_assn, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_DataExternal_assn (pctxt, pvalue->u.dataExternal_assn, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_BioDataCube_choice (OSCTXT* pctxt, BioDataCube_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode dataInternal_assn */

         stat = XmlEnc_DataInternal_assn (pctxt, pvalue->u.dataInternal_assn
            , OSUTF8("DataInternal_assn"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode dataExternal_assn */

         stat = XmlEnc_DataExternal_assn (pctxt, pvalue->u.dataExternal_assn
            , OSUTF8("DataExternal_assn"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioDataCube                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioDataCube (OSCTXT* pctxt,
   BioDataCube *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_BioDataCube_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode bioDataValues_content */

   if (pvalue->m.bioDataValues_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_BioDataValues_content (pctxt, &pvalue->bioDataValues_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode order */

   if (pvalue->m.orderPresent) {
      if(pvalue->order < 0 || pvalue->order > 5)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         asn1E_BioDataCube_order (pctxt, &pvalue->order, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioDataCube (OSCTXT* pctxt, BioDataCube* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.orderPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" order=\""), 8);

      if(pvalue->order < 0 || pvalue->order > 5)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_BioDataCube_order (pctxt, pvalue->order, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode bioDataValues_content */

   if (pvalue->m.bioDataValues_contentPresent) {
      stat = XmlEnc_BioDataValues_content (pctxt, &pvalue->
         bioDataValues_content, 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode choice */

   stat = XmlEnc_BioDataCube_choice (pctxt, &pvalue->choice, OSUTF8(""), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Feature_ref                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Feature_ref (OSCTXT* pctxt,
   Feature_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Feature_ref (OSCTXT* pctxt, Feature_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElement_ref_1                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElement_ref_1 (OSCTXT* pctxt,
   DesignElement_ref_1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_Reporter_ref (pctxt, pvalue->u.reporter_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_CompositeSequence_ref (pctxt, pvalue->u.compositeSequence_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_Feature_ref (pctxt, pvalue->u.feature_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   if (tagging == ASN1EXPL) {
      ll1 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll1);
      if (ll1 < 0) return LOG_RTERR (pctxt, ll1);
   }

   ll0 += ll1;

   return (ll0);
}

int XmlEnc_DesignElement_ref_1 (OSCTXT* pctxt, DesignElement_ref_1* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode reporter_ref */

         stat = XmlEnc_Reporter_ref (pctxt, pvalue->u.reporter_ref
            , OSUTF8("Reporter_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode compositeSequence_ref */

         stat = XmlEnc_CompositeSequence_ref (pctxt, pvalue->
            u.compositeSequence_ref
            , OSUTF8("CompositeSequence_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode feature_ref */

         stat = XmlEnc_Feature_ref (pctxt, pvalue->u.feature_ref
            , OSUTF8("Feature_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElement_assnref                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElement_assnref (OSCTXT* pctxt,
   DesignElement_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_DesignElement_ref_1 (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_DesignElement_assnref (OSCTXT* pctxt, 
   DesignElement_assnref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_DesignElement_ref_1 (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Datum                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Datum (OSCTXT* pctxt,
   Datum *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode value */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->value, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Datum (OSCTXT* pctxt, Datum* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" value=\""), 8);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->value, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Datum_element                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Datum_element (OSCTXT* pctxt,
   Datum_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode datum */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Datum (pctxt, &pvalue->datum, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Datum_element (OSCTXT* pctxt, Datum_element* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode datum */

   stat = XmlEnc_Datum (pctxt, &pvalue->datum, OSUTF8("Datum"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Datum_assn                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Datum_assn (OSCTXT* pctxt,
   Datum_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_Datum_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Datum_assn (OSCTXT* pctxt, Datum_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_Datum_element (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantitationTypeTuple                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantitationTypeTuple (OSCTXT* pctxt,
   QuantitationTypeTuple *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode datum_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Datum_assn (pctxt, &pvalue->datum_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode quantitationType_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_QuantitationType_assnref (pctxt, &pvalue->quantitationType_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuantitationTypeTuple (OSCTXT* pctxt, 
   QuantitationTypeTuple* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode quantitationType_assnref */

   stat = XmlEnc_QuantitationType_assnref (pctxt, &pvalue->
      quantitationType_assnref, OSUTF8("QuantitationType_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode datum_assn */

   stat = XmlEnc_Datum_assn (pctxt, &pvalue->datum_assn
      , OSUTF8("Datum_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantitationTypeTuples_assnlist                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantitationTypeTuples_assnlist (OSCTXT* pctxt,
   QuantitationTypeTuples_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode quantitationTypeTuple_list */

   if (!(pvalue->quantitationTypeTuple_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "QuantitationTypeTuples_assnlist.quantitationTypeTuple_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->quantitationTypeTuple_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->quantitationTypeTuple_list.tail;
   while (0 != pnode2) {
      ll = asn1E_QuantitationTypeTuple (pctxt, ((QuantitationTypeTuple*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuantitationTypeTuples_assnlist (OSCTXT* pctxt, 
   QuantitationTypeTuples_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode quantitationTypeTuple_list */

   if (!(pvalue->quantitationTypeTuple_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "QuantitationTypeTuples_assnlist.quantitationTypeTuple_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->quantitationTypeTuple_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->quantitationTypeTuple_list.head;
   while (0 != pnode) {
      stat = XmlEnc_QuantitationTypeTuple (pctxt, 
         ((QuantitationTypeTuple*)pnode->data)
         , OSUTF8("QuantitationTypeTuple"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElementTuple                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElementTuple (OSCTXT* pctxt,
   DesignElementTuple *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationTypeTuples_assnlist */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_QuantitationTypeTuples_assnlist (pctxt, &pvalue->quantitationTypeTuples_assnlist, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode designElement_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_DesignElement_assnref (pctxt, &pvalue->designElement_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DesignElementTuple (OSCTXT* pctxt, DesignElementTuple* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode designElement_assnref */

   stat = XmlEnc_DesignElement_assnref (pctxt, &pvalue->designElement_assnref
      , OSUTF8("DesignElement_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode quantitationTypeTuples_assnlist */

   stat = XmlEnc_QuantitationTypeTuples_assnlist (pctxt, &pvalue->
      quantitationTypeTuples_assnlist
      , OSUTF8("QuantitationTypeTuples_assnlist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElementTuples_assnlist                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElementTuples_assnlist (OSCTXT* pctxt,
   DesignElementTuples_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode designElementTuple_list */

   if (!(pvalue->designElementTuple_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DesignElementTuples_assnlist.designElementTuple_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->designElementTuple_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->designElementTuple_list.tail;
   while (0 != pnode2) {
      ll = asn1E_DesignElementTuple (pctxt, ((DesignElementTuple*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DesignElementTuples_assnlist (OSCTXT* pctxt, 
   DesignElementTuples_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode designElementTuple_list */

   if (!(pvalue->designElementTuple_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DesignElementTuples_assnlist.designElementTuple_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->designElementTuple_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->designElementTuple_list.head;
   while (0 != pnode) {
      stat = XmlEnc_DesignElementTuple (pctxt, 
         ((DesignElementTuple*)pnode->data)
         , OSUTF8("DesignElementTuple"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayTuple                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayTuple (OSCTXT* pctxt,
   BioAssayTuple *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode designElementTuples_assnlist */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_DesignElementTuples_assnlist (pctxt, &pvalue->designElementTuples_assnlist, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode bioAssay_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_BioAssay_assnref (pctxt, &pvalue->bioAssay_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayTuple (OSCTXT* pctxt, BioAssayTuple* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bioAssay_assnref */

   stat = XmlEnc_BioAssay_assnref (pctxt, &pvalue->bioAssay_assnref
      , OSUTF8("BioAssay_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode designElementTuples_assnlist */

   stat = XmlEnc_DesignElementTuples_assnlist (pctxt, &pvalue->
      designElementTuples_assnlist
      , OSUTF8("DesignElementTuples_assnlist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayTuples_assnlist                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayTuples_assnlist (OSCTXT* pctxt,
   BioAssayTuples_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode bioAssayTuple_list */

   if (!(pvalue->bioAssayTuple_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioAssayTuples_assnlist.bioAssayTuple_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioAssayTuple_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->bioAssayTuple_list.tail;
   while (0 != pnode2) {
      ll = asn1E_BioAssayTuple (pctxt, ((BioAssayTuple*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayTuples_assnlist (OSCTXT* pctxt, 
   BioAssayTuples_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bioAssayTuple_list */

   if (!(pvalue->bioAssayTuple_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioAssayTuples_assnlist.bioAssayTuple_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioAssayTuple_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->bioAssayTuple_list.head;
   while (0 != pnode) {
      stat = XmlEnc_BioAssayTuple (pctxt, ((BioAssayTuple*)pnode->data)
         , OSUTF8("BioAssayTuple"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioDataTuples                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioDataTuples (OSCTXT* pctxt,
   BioDataTuples *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode bioAssayTuples_assnlist */

   if (pvalue->m.bioAssayTuples_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_BioAssayTuples_assnlist (pctxt, &pvalue->bioAssayTuples_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioDataValues_content */

   if (pvalue->m.bioDataValues_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_BioDataValues_content (pctxt, &pvalue->bioDataValues_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioDataTuples (OSCTXT* pctxt, BioDataTuples* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bioDataValues_content */

   if (pvalue->m.bioDataValues_contentPresent) {
      stat = XmlEnc_BioDataValues_content (pctxt, &pvalue->
         bioDataValues_content, 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioAssayTuples_assnlist */

   if (pvalue->m.bioAssayTuples_assnlistPresent) {
      stat = XmlEnc_BioAssayTuples_assnlist (pctxt, &pvalue->
         bioAssayTuples_assnlist
         , OSUTF8("BioAssayTuples_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioDataValues_classes_group                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioDataValues_classes_group (OSCTXT* pctxt,
   BioDataValues_classes_group *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_BioDataCube (pctxt, pvalue->u.bioDataCube, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_BioDataTuples (pctxt, pvalue->u.bioDataTuples, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_BioDataValues_classes_group (OSCTXT* pctxt, 
   BioDataValues_classes_group* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode bioDataCube */

         stat = XmlEnc_BioDataCube (pctxt, pvalue->u.bioDataCube
            , OSUTF8("BioDataCube"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode bioDataTuples */

         stat = XmlEnc_BioDataTuples (pctxt, pvalue->u.bioDataTuples
            , OSUTF8("BioDataTuples"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioDataValues_classes_1                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioDataValues_classes_1 (OSCTXT* pctxt,
   BioDataValues_classes_1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode bioDataValues_classes */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_BioDataValues_classes_group (pctxt, &pvalue->bioDataValues_classes, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioDataValues_classes_1 (OSCTXT* pctxt, 
   BioDataValues_classes_1* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bioDataValues_classes */

   stat = XmlEnc_BioDataValues_classes_group (pctxt, &pvalue->
      bioDataValues_classes, OSUTF8(""), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioDataValues_assn                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioDataValues_assn (OSCTXT* pctxt,
   BioDataValues_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_BioDataValues_classes_1 (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_BioDataValues_assn (OSCTXT* pctxt, BioDataValues_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_BioDataValues_classes_1 (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CompositeSequenceDimension_ref                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CompositeSequenceDimension_ref (OSCTXT* pctxt,
   CompositeSequenceDimension_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CompositeSequenceDimension_ref (OSCTXT* pctxt, 
   CompositeSequenceDimension_ref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReporterDimension_ref                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ReporterDimension_ref (OSCTXT* pctxt,
   ReporterDimension_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ReporterDimension_ref (OSCTXT* pctxt, 
   ReporterDimension_ref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeatureDimension_ref                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FeatureDimension_ref (OSCTXT* pctxt,
   FeatureDimension_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FeatureDimension_ref (OSCTXT* pctxt, FeatureDimension_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElementDimension_ref_1                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElementDimension_ref_1 (OSCTXT* pctxt,
   DesignElementDimension_ref_1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_CompositeSequenceDimension_ref (pctxt, pvalue->u.compositeSequenceDimension_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_ReporterDimension_ref (pctxt, pvalue->u.reporterDimension_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_FeatureDimension_ref (pctxt, pvalue->u.featureDimension_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   if (tagging == ASN1EXPL) {
      ll1 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll1);
      if (ll1 < 0) return LOG_RTERR (pctxt, ll1);
   }

   ll0 += ll1;

   return (ll0);
}

int XmlEnc_DesignElementDimension_ref_1 (OSCTXT* pctxt, 
   DesignElementDimension_ref_1* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode compositeSequenceDimension_ref */

         stat = XmlEnc_CompositeSequenceDimension_ref (pctxt, pvalue->
            u.compositeSequenceDimension_ref
            , OSUTF8("CompositeSequenceDimension_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode reporterDimension_ref */

         stat = XmlEnc_ReporterDimension_ref (pctxt, pvalue->
            u.reporterDimension_ref
            , OSUTF8("ReporterDimension_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode featureDimension_ref */

         stat = XmlEnc_FeatureDimension_ref (pctxt, pvalue->
            u.featureDimension_ref, OSUTF8("FeatureDimension_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElementDimension_assnref                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElementDimension_assnref (OSCTXT* pctxt,
   DesignElementDimension_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_DesignElementDimension_ref_1 (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_DesignElementDimension_assnref (OSCTXT* pctxt, 
   DesignElementDimension_assnref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_DesignElementDimension_ref_1 (pctxt, pvalue
      , elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CompositeCompositeMap_ref                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CompositeCompositeMap_ref (OSCTXT* pctxt,
   CompositeCompositeMap_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CompositeCompositeMap_ref (OSCTXT* pctxt, 
   CompositeCompositeMap_ref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeatureReporterMap_ref                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FeatureReporterMap_ref (OSCTXT* pctxt,
   FeatureReporterMap_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FeatureReporterMap_ref (OSCTXT* pctxt, 
   FeatureReporterMap_ref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReporterCompositeMap_ref                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ReporterCompositeMap_ref (OSCTXT* pctxt,
   ReporterCompositeMap_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ReporterCompositeMap_ref (OSCTXT* pctxt, 
   ReporterCompositeMap_ref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElementMap_ref_1                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElementMap_ref_1 (OSCTXT* pctxt,
   DesignElementMap_ref_1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_CompositeCompositeMap_ref (pctxt, pvalue->u.compositeCompositeMap_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_FeatureReporterMap_ref (pctxt, pvalue->u.featureReporterMap_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_ReporterCompositeMap_ref (pctxt, pvalue->u.reporterCompositeMap_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_DesignElementMap_ref_1 (OSCTXT* pctxt, 
   DesignElementMap_ref_1* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode compositeCompositeMap_ref */

         stat = XmlEnc_CompositeCompositeMap_ref (pctxt, pvalue->
            u.compositeCompositeMap_ref
            , OSUTF8("CompositeCompositeMap_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode featureReporterMap_ref */

         stat = XmlEnc_FeatureReporterMap_ref (pctxt, pvalue->
            u.featureReporterMap_ref
            , OSUTF8("FeatureReporterMap_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode reporterCompositeMap_ref */

         stat = XmlEnc_ReporterCompositeMap_ref (pctxt, pvalue->
            u.reporterCompositeMap_ref
            , OSUTF8("ReporterCompositeMap_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElementMaps_assnreflist                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElementMaps_assnreflist (OSCTXT* pctxt,
   DesignElementMaps_assnreflist *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DesignElementMaps_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_DesignElementMap_ref_1 (pctxt, ((DesignElementMap_ref_1*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DesignElementMaps_assnreflist (OSCTXT* pctxt, 
   DesignElementMaps_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DesignElementMaps_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_DesignElementMap_ref_1 (pctxt, 
         ((DesignElementMap_ref_1*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElementMapping                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElementMapping (OSCTXT* pctxt,
   DesignElementMapping *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode designElementMaps_assnreflist */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_DesignElementMaps_assnreflist (pctxt, &pvalue->designElementMaps_assnreflist, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DesignElementMapping (OSCTXT* pctxt, DesignElementMapping* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode designElementMaps_assnreflist */

   stat = XmlEnc_DesignElementMaps_assnreflist (pctxt, &pvalue->
      designElementMaps_assnreflist
      , OSUTF8("DesignElementMaps_assnreflist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElementMapping_element                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElementMapping_element (OSCTXT* pctxt,
   DesignElementMapping_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode designElementMapping */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_DesignElementMapping (pctxt, &pvalue->designElementMapping, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DesignElementMapping_element (OSCTXT* pctxt, 
   DesignElementMapping_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode designElementMapping */

   stat = XmlEnc_DesignElementMapping (pctxt, &pvalue->designElementMapping
      , OSUTF8("DesignElementMapping"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElementMapping_assn                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElementMapping_assn (OSCTXT* pctxt,
   DesignElementMapping_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_DesignElementMapping_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_DesignElementMapping_assn (OSCTXT* pctxt, 
   DesignElementMapping_assn* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_DesignElementMapping_element (pctxt, pvalue
      , elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantitationTypeDimension_ref                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantitationTypeDimension_ref (OSCTXT* pctxt,
   QuantitationTypeDimension_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuantitationTypeDimension_ref (OSCTXT* pctxt, 
   QuantitationTypeDimension_ref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantitationTypeDimension_ref_element                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantitationTypeDimension_ref_element (OSCTXT* pctxt,
   QuantitationTypeDimension_ref_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationTypeDimension_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_QuantitationTypeDimension_ref (pctxt, &pvalue->quantitationTypeDimension_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuantitationTypeDimension_ref_element (OSCTXT* pctxt, 
   QuantitationTypeDimension_ref_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode quantitationTypeDimension_ref */

   stat = XmlEnc_QuantitationTypeDimension_ref (pctxt, &pvalue->
      quantitationTypeDimension_ref
      , OSUTF8("QuantitationTypeDimension_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantitationDimension_assnref                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantitationDimension_assnref (OSCTXT* pctxt,
   QuantitationDimension_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_QuantitationTypeDimension_ref_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_QuantitationDimension_assnref (OSCTXT* pctxt, 
   QuantitationDimension_assnref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_QuantitationTypeDimension_ref_element (pctxt, pvalue
      , elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantitationTypeDimension_assnref                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantitationTypeDimension_assnref (OSCTXT* pctxt,
   QuantitationTypeDimension_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_QuantitationTypeDimension_ref_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_QuantitationTypeDimension_assnref (OSCTXT* pctxt, 
   QuantitationTypeDimension_assnref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_QuantitationTypeDimension_ref_element (pctxt, pvalue
      , elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantitationTypeMap_ref                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantitationTypeMap_ref (OSCTXT* pctxt,
   QuantitationTypeMap_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuantitationTypeMap_ref (OSCTXT* pctxt, 
   QuantitationTypeMap_ref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantitationTypeMaps_assnreflist                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantitationTypeMaps_assnreflist (OSCTXT* pctxt,
   QuantitationTypeMaps_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode quantitationTypeMap_ref_list */

   if (!(pvalue->quantitationTypeMap_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "QuantitationTypeMaps_assnreflist.quantitationTypeMap_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->quantitationTypeMap_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->quantitationTypeMap_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_QuantitationTypeMap_ref (pctxt, ((QuantitationTypeMap_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuantitationTypeMaps_assnreflist (OSCTXT* pctxt, 
   QuantitationTypeMaps_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode quantitationTypeMap_ref_list */

   if (!(pvalue->quantitationTypeMap_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "QuantitationTypeMaps_assnreflist.quantitationTypeMap_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->quantitationTypeMap_ref_list.count
         );
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->quantitationTypeMap_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_QuantitationTypeMap_ref (pctxt, 
         ((QuantitationTypeMap_ref*)pnode->data)
         , OSUTF8("QuantitationTypeMap_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantitationTypeMapping                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantitationTypeMapping (OSCTXT* pctxt,
   QuantitationTypeMapping *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationTypeMaps_assnreflist */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->quantitationTypeMaps_assnreflist, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuantitationTypeMapping (OSCTXT* pctxt, 
   QuantitationTypeMapping* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeMaps_assnreflist */

   stat = XmlEnc_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->
      quantitationTypeMaps_assnreflist
      , OSUTF8("QuantitationTypeMaps_assnreflist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantitationTypeMapping_element                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantitationTypeMapping_element (OSCTXT* pctxt,
   QuantitationTypeMapping_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationTypeMapping */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_QuantitationTypeMapping (pctxt, &pvalue->quantitationTypeMapping, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuantitationTypeMapping_element (OSCTXT* pctxt, 
   QuantitationTypeMapping_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode quantitationTypeMapping */

   stat = XmlEnc_QuantitationTypeMapping (pctxt, &pvalue->
      quantitationTypeMapping, OSUTF8("QuantitationTypeMapping"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantitationTypeMapping_assn                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantitationTypeMapping_assn (OSCTXT* pctxt,
   QuantitationTypeMapping_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_QuantitationTypeMapping_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_QuantitationTypeMapping_assn (OSCTXT* pctxt, 
   QuantitationTypeMapping_assn* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_QuantitationTypeMapping_element (pctxt, pvalue
      , elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayDataSources_assnreflist                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayDataSources_assnreflist (OSCTXT* pctxt,
   BioAssayDataSources_assnreflist *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioAssayDataSources_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_BioAssayData_ref_1 (pctxt, ((BioAssayData_ref_1*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayDataSources_assnreflist (OSCTXT* pctxt, 
   BioAssayDataSources_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioAssayDataSources_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_BioAssayData_ref_1 (pctxt, 
         ((BioAssayData_ref_1*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Transformation                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Transformation (OSCTXT* pctxt,
   Transformation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode bioAssayMapping_assn */

   if (pvalue->m.bioAssayMapping_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_BioAssayMapping_assn (pctxt, &pvalue->bioAssayMapping_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode designElementMapping_assn */

   if (pvalue->m.designElementMapping_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_DesignElementMapping_assn (pctxt, &pvalue->designElementMapping_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode quantitationTypeMapping_assn */

   if (pvalue->m.quantitationTypeMapping_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_QuantitationTypeMapping_assn (pctxt, &pvalue->quantitationTypeMapping_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioAssayDataSources_assnreflist */

   if (pvalue->m.bioAssayDataSources_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_BioAssayDataSources_assnreflist (pctxt, &pvalue->bioAssayDataSources_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioEvent_content */

   if (pvalue->m.bioEvent_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_BioEvent_content (pctxt, &pvalue->bioEvent_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Transformation (OSCTXT* pctxt, Transformation* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode bioEvent_content */

   if (pvalue->m.bioEvent_contentPresent) {
      stat = XmlEnc_BioEvent_content (pctxt, &pvalue->bioEvent_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioAssayDataSources_assnreflist */

   if (pvalue->m.bioAssayDataSources_assnreflistPresent) {
      stat = XmlEnc_BioAssayDataSources_assnreflist (pctxt, &pvalue->
         bioAssayDataSources_assnreflist
         , OSUTF8("BioAssayDataSources_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeMapping_assn */

   if (pvalue->m.quantitationTypeMapping_assnPresent) {
      stat = XmlEnc_QuantitationTypeMapping_assn (pctxt, &pvalue->
         quantitationTypeMapping_assn
         , OSUTF8("QuantitationTypeMapping_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode designElementMapping_assn */

   if (pvalue->m.designElementMapping_assnPresent) {
      stat = XmlEnc_DesignElementMapping_assn (pctxt, &pvalue->
         designElementMapping_assn
         , OSUTF8("DesignElementMapping_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioAssayMapping_assn */

   if (pvalue->m.bioAssayMapping_assnPresent) {
      stat = XmlEnc_BioAssayMapping_assn (pctxt, &pvalue->bioAssayMapping_assn
         , OSUTF8("BioAssayMapping_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Transformation_element                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Transformation_element (OSCTXT* pctxt,
   Transformation_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode transformation */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Transformation (pctxt, &pvalue->transformation, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Transformation_element (OSCTXT* pctxt, 
   Transformation_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode transformation */

   stat = XmlEnc_Transformation (pctxt, &pvalue->transformation
      , OSUTF8("Transformation"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ProducerTransformation_assn                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ProducerTransformation_assn (OSCTXT* pctxt,
   ProducerTransformation_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_Transformation_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ProducerTransformation_assn (OSCTXT* pctxt, 
   ProducerTransformation_assn* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_Transformation_element (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeatureLocation                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FeatureLocation (OSCTXT* pctxt,
   FeatureLocation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode row */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->row, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode column */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->column, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FeatureLocation (OSCTXT* pctxt, FeatureLocation* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" column=\""), 9);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->column, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" row=\""), 6);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->row, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeatureLocation_element                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FeatureLocation_element (OSCTXT* pctxt,
   FeatureLocation_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode featureLocation */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_FeatureLocation (pctxt, &pvalue->featureLocation, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FeatureLocation_element (OSCTXT* pctxt, 
   FeatureLocation_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode featureLocation */

   stat = XmlEnc_FeatureLocation (pctxt, &pvalue->featureLocation
      , OSUTF8("FeatureLocation"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeatureLocation_assn                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FeatureLocation_assn (OSCTXT* pctxt,
   FeatureLocation_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_FeatureLocation_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_FeatureLocation_assn (OSCTXT* pctxt, FeatureLocation_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_FeatureLocation_element (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Position                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Position (OSCTXT* pctxt,
   Position *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode distanceUnit_assn */

   if (pvalue->m.distanceUnit_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_DistanceUnit_assn (pctxt, &pvalue->distanceUnit_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode y */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->y, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode x */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->x, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Position (OSCTXT* pctxt, Position* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" x=\""), 4);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->x, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" y=\""), 4);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->y, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode distanceUnit_assn */

   if (pvalue->m.distanceUnit_assnPresent) {
      stat = XmlEnc_DistanceUnit_assn (pctxt, &pvalue->distanceUnit_assn
         , OSUTF8("DistanceUnit_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Position_element                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Position_element (OSCTXT* pctxt,
   Position_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode position */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Position (pctxt, &pvalue->position, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Position_element (OSCTXT* pctxt, Position_element* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode position */

   stat = XmlEnc_Position (pctxt, &pvalue->position
      , OSUTF8("Position"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Position_assn                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Position_assn (OSCTXT* pctxt,
   Position_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_Position_element (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Position_assn (OSCTXT* pctxt, Position_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_Position_element (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ArrayDesign_classes                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ArrayDesign_classes (OSCTXT* pctxt,
   ArrayDesign_classes *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   switch (pvalue->t) {
   case OSXSDAny_binary:
      ll = xe_OpenType (pctxt, pvalue->u.binary->data, pvalue->
         u.binary->numocts);
      break;
   case OSXSDAny_xmlText:
      ll = xe_utf8str (pctxt, pvalue->u.xmlText, tagging);
      break;
   }
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else ll0 += ll;

   return (ll0);
}

int XmlEnc_ArrayDesign_classes (OSCTXT* pctxt, ArrayDesign_classes value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (value.t == OSXSDAny_xmlText) {
      stat = rtXmlEncAnyStr (pctxt, value.u.xmlText, elemName, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      char buf[40];
      os_snprintf (buf, 40, "%d", value.t);
      rtxErrAddStrParm (pctxt, buf);
      return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Contact_classes                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Contact_classes (OSCTXT* pctxt,
   Contact_classes *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   switch (pvalue->t) {
   case OSXSDAny_binary:
      ll = xe_OpenType (pctxt, pvalue->u.binary->data, pvalue->
         u.binary->numocts);
      break;
   case OSXSDAny_xmlText:
      ll = xe_utf8str (pctxt, pvalue->u.xmlText, tagging);
      break;
   }
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else ll0 += ll;

   return (ll0);
}

int XmlEnc_Contact_classes (OSCTXT* pctxt, Contact_classes value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (value.t == OSXSDAny_xmlText) {
      stat = rtXmlEncAnyStr (pctxt, value.u.xmlText, elemName, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      char buf[40];
      os_snprintf (buf, 40, "%d", value.t);
      rtxErrAddStrParm (pctxt, buf);
      return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unit_classes                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Unit_classes (OSCTXT* pctxt,
   Unit_classes *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   switch (pvalue->t) {
   case OSXSDAny_binary:
      ll = xe_OpenType (pctxt, pvalue->u.binary->data, pvalue->
         u.binary->numocts);
      break;
   case OSXSDAny_xmlText:
      ll = xe_utf8str (pctxt, pvalue->u.xmlText, tagging);
      break;
   }
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else ll0 += ll;

   return (ll0);
}

int XmlEnc_Unit_classes (OSCTXT* pctxt, Unit_classes value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (value.t == OSXSDAny_xmlText) {
      stat = rtXmlEncAnyStr (pctxt, value.u.xmlText, elemName, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      char buf[40];
      os_snprintf (buf, 40, "%d", value.t);
      rtxErrAddStrParm (pctxt, buf);
      return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ManufactureLIMS_classes                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ManufactureLIMS_classes (OSCTXT* pctxt,
   ManufactureLIMS_classes *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   switch (pvalue->t) {
   case OSXSDAny_binary:
      ll = xe_OpenType (pctxt, pvalue->u.binary->data, pvalue->
         u.binary->numocts);
      break;
   case OSXSDAny_xmlText:
      ll = xe_utf8str (pctxt, pvalue->u.xmlText, tagging);
      break;
   }
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else ll0 += ll;

   return (ll0);
}

int XmlEnc_ManufactureLIMS_classes (OSCTXT* pctxt, 
   ManufactureLIMS_classes value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (value.t == OSXSDAny_xmlText) {
      stat = rtXmlEncAnyStr (pctxt, value.u.xmlText, elemName, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      char buf[40];
      os_snprintf (buf, 40, "%d", value.t);
      rtxErrAddStrParm (pctxt, buf);
      return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SequencePosition_classes                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SequencePosition_classes (OSCTXT* pctxt,
   SequencePosition_classes *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   switch (pvalue->t) {
   case OSXSDAny_binary:
      ll = xe_OpenType (pctxt, pvalue->u.binary->data, pvalue->
         u.binary->numocts);
      break;
   case OSXSDAny_xmlText:
      ll = xe_utf8str (pctxt, pvalue->u.xmlText, tagging);
      break;
   }
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else ll0 += ll;

   return (ll0);
}

int XmlEnc_SequencePosition_classes (OSCTXT* pctxt, 
   SequencePosition_classes value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (value.t == OSXSDAny_xmlText) {
      stat = rtXmlEncAnyStr (pctxt, value.u.xmlText, elemName, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      char buf[40];
      os_snprintf (buf, 40, "%d", value.t);
      rtxErrAddStrParm (pctxt, buf);
      return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioMaterial_classes                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioMaterial_classes (OSCTXT* pctxt,
   BioMaterial_classes *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   switch (pvalue->t) {
   case OSXSDAny_binary:
      ll = xe_OpenType (pctxt, pvalue->u.binary->data, pvalue->
         u.binary->numocts);
      break;
   case OSXSDAny_xmlText:
      ll = xe_utf8str (pctxt, pvalue->u.xmlText, tagging);
      break;
   }
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else ll0 += ll;

   return (ll0);
}

int XmlEnc_BioMaterial_classes (OSCTXT* pctxt, BioMaterial_classes value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (value.t == OSXSDAny_xmlText) {
      stat = rtXmlEncAnyStr (pctxt, value.u.xmlText, elemName, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      char buf[40];
      os_snprintf (buf, 40, "%d", value.t);
      rtxErrAddStrParm (pctxt, buf);
      return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayTreatment_classes                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayTreatment_classes (OSCTXT* pctxt,
   BioAssayTreatment_classes *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   switch (pvalue->t) {
   case OSXSDAny_binary:
      ll = xe_OpenType (pctxt, pvalue->u.binary->data, pvalue->
         u.binary->numocts);
      break;
   case OSXSDAny_xmlText:
      ll = xe_utf8str (pctxt, pvalue->u.xmlText, tagging);
      break;
   }
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else ll0 += ll;

   return (ll0);
}

int XmlEnc_BioAssayTreatment_classes (OSCTXT* pctxt, 
   BioAssayTreatment_classes value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (value.t == OSXSDAny_xmlText) {
      stat = rtXmlEncAnyStr (pctxt, value.u.xmlText, elemName, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      char buf[40];
      os_snprintf (buf, 40, "%d", value.t);
      rtxErrAddStrParm (pctxt, buf);
      return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssay_classes                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssay_classes (OSCTXT* pctxt,
   BioAssay_classes *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   switch (pvalue->t) {
   case OSXSDAny_binary:
      ll = xe_OpenType (pctxt, pvalue->u.binary->data, pvalue->
         u.binary->numocts);
      break;
   case OSXSDAny_xmlText:
      ll = xe_utf8str (pctxt, pvalue->u.xmlText, tagging);
      break;
   }
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else ll0 += ll;

   return (ll0);
}

int XmlEnc_BioAssay_classes (OSCTXT* pctxt, BioAssay_classes value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (value.t == OSXSDAny_xmlText) {
      stat = rtXmlEncAnyStr (pctxt, value.u.xmlText, elemName, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      char buf[40];
      os_snprintf (buf, 40, "%d", value.t);
      rtxErrAddStrParm (pctxt, buf);
      return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioDataValues_classes                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioDataValues_classes (OSCTXT* pctxt,
   BioDataValues_classes *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   switch (pvalue->t) {
   case OSXSDAny_binary:
      ll = xe_OpenType (pctxt, pvalue->u.binary->data, pvalue->
         u.binary->numocts);
      break;
   case OSXSDAny_xmlText:
      ll = xe_utf8str (pctxt, pvalue->u.xmlText, tagging);
      break;
   }
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else ll0 += ll;

   return (ll0);
}

int XmlEnc_BioDataValues_classes (OSCTXT* pctxt, BioDataValues_classes value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (value.t == OSXSDAny_xmlText) {
      stat = rtXmlEncAnyStr (pctxt, value.u.xmlText, elemName, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      char buf[40];
      os_snprintf (buf, 40, "%d", value.t);
      rtxErrAddStrParm (pctxt, buf);
      return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayData_classes                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayData_classes (OSCTXT* pctxt,
   BioAssayData_classes *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   switch (pvalue->t) {
   case OSXSDAny_binary:
      ll = xe_OpenType (pctxt, pvalue->u.binary->data, pvalue->
         u.binary->numocts);
      break;
   case OSXSDAny_xmlText:
      ll = xe_utf8str (pctxt, pvalue->u.xmlText, tagging);
      break;
   }
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else ll0 += ll;

   return (ll0);
}

int XmlEnc_BioAssayData_classes (OSCTXT* pctxt, BioAssayData_classes value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (value.t == OSXSDAny_xmlText) {
      stat = rtXmlEncAnyStr (pctxt, value.u.xmlText, elemName, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      char buf[40];
      os_snprintf (buf, 40, "%d", value.t);
      rtxErrAddStrParm (pctxt, buf);
      return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElementDimension_classes                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElementDimension_classes (OSCTXT* pctxt,
   DesignElementDimension_classes *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   switch (pvalue->t) {
   case OSXSDAny_binary:
      ll = xe_OpenType (pctxt, pvalue->u.binary->data, pvalue->
         u.binary->numocts);
      break;
   case OSXSDAny_xmlText:
      ll = xe_utf8str (pctxt, pvalue->u.xmlText, tagging);
      break;
   }
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else ll0 += ll;

   return (ll0);
}

int XmlEnc_DesignElementDimension_classes (OSCTXT* pctxt, 
   DesignElementDimension_classes value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (value.t == OSXSDAny_xmlText) {
      stat = rtXmlEncAnyStr (pctxt, value.u.xmlText, elemName, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      char buf[40];
      os_snprintf (buf, 40, "%d", value.t);
      rtxErrAddStrParm (pctxt, buf);
      return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElementMap_classes                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElementMap_classes (OSCTXT* pctxt,
   DesignElementMap_classes *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   switch (pvalue->t) {
   case OSXSDAny_binary:
      ll = xe_OpenType (pctxt, pvalue->u.binary->data, pvalue->
         u.binary->numocts);
      break;
   case OSXSDAny_xmlText:
      ll = xe_utf8str (pctxt, pvalue->u.xmlText, tagging);
      break;
   }
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else ll0 += ll;

   return (ll0);
}

int XmlEnc_DesignElementMap_classes (OSCTXT* pctxt, 
   DesignElementMap_classes value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (value.t == OSXSDAny_xmlText) {
      stat = rtXmlEncAnyStr (pctxt, value.u.xmlText, elemName, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      char buf[40];
      os_snprintf (buf, 40, "%d", value.t);
      rtxErrAddStrParm (pctxt, buf);
      return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElement_classes                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElement_classes (OSCTXT* pctxt,
   DesignElement_classes *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   switch (pvalue->t) {
   case OSXSDAny_binary:
      ll = xe_OpenType (pctxt, pvalue->u.binary->data, pvalue->
         u.binary->numocts);
      break;
   case OSXSDAny_xmlText:
      ll = xe_utf8str (pctxt, pvalue->u.xmlText, tagging);
      break;
   }
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else ll0 += ll;

   return (ll0);
}

int XmlEnc_DesignElement_classes (OSCTXT* pctxt, DesignElement_classes value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (value.t == OSXSDAny_xmlText) {
      stat = rtXmlEncAnyStr (pctxt, value.u.xmlText, elemName, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      char buf[40];
      os_snprintf (buf, 40, "%d", value.t);
      rtxErrAddStrParm (pctxt, buf);
      return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unit_content                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Unit_content (OSCTXT* pctxt,
   Unit_content *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_Extendable_content (pctxt, pvalue, ASN1IMPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   if (tagging == ASN1EXPL) {
      ll = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
   }
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Unit_content (OSCTXT* pctxt, Unit_content* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_Extendable_content (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SequencePosition_content                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SequencePosition_content (OSCTXT* pctxt,
   SequencePosition_content *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_Extendable_content (pctxt, pvalue, ASN1IMPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   if (tagging == ASN1EXPL) {
      ll = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
   }
   ll0 += ll;

   return (ll0);
}

int XmlEnc_SequencePosition_content (OSCTXT* pctxt, 
   SequencePosition_content* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_Extendable_content (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Map_content                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Map_content (OSCTXT* pctxt,
   Map_content *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_BioEvent_content (pctxt, pvalue, ASN1IMPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   if (tagging == ASN1EXPL) {
      ll = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
   }
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Map_content (OSCTXT* pctxt, Map_content* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_BioEvent_content (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElementDimension_content                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElementDimension_content (OSCTXT* pctxt,
   DesignElementDimension_content *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_Identifiable_content (pctxt, pvalue, ASN1IMPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   if (tagging == ASN1EXPL) {
      ll = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
   }
   ll0 += ll;

   return (ll0);
}

int XmlEnc_DesignElementDimension_content (OSCTXT* pctxt, 
   DesignElementDimension_content* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_Identifiable_content (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElementMap_content                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElementMap_content (OSCTXT* pctxt,
   DesignElementMap_content *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_Map_content (pctxt, pvalue, ASN1IMPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll);
   if (ll < 0) return LOG_RTERR (pctxt, ll);

   if (tagging == ASN1EXPL) {
      ll = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
   }
   ll0 += ll;

   return (ll0);
}

int XmlEnc_DesignElementMap_content (OSCTXT* pctxt, 
   DesignElementMap_content* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_Map_content (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ArrayGroup_orientationMarkPosition                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ArrayGroup_orientationMarkPosition (OSCTXT* pctxt,
   ArrayGroup_orientationMarkPosition *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 3)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ArrayGroup_orientationMarkPosition (OSCTXT* pctxt, 
   ArrayGroup_orientationMarkPosition value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      ArrayGroup_orientationMarkPosition_ToString (value)
         , elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SeqFeature_basis                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SeqFeature_basis (OSCTXT* pctxt,
   SeqFeature_basis *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_SeqFeature_basis (OSCTXT* pctxt, SeqFeature_basis value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      SeqFeature_basis_ToString (value), elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unit_content_derivations_distanceUnit_unitNameCV          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Unit_content_derivations_distanceUnit_unitNameCV (OSCTXT* pctxt,
   Unit_content_derivations_distanceUnit_unitNameCV *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 7)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Unit_content_derivations_distanceUnit_unitNameCV (OSCTXT* pctxt, 
   Unit_content_derivations_distanceUnit_unitNameCV value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      Unit_content_derivations_distanceUnit_unitNameCV_ToString (value)
         , elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unit_content_derivations_concentrationUnit_unitNameCV     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Unit_content_derivations_concentrationUnit_unitNameCV (OSCTXT* pctxt,
   Unit_content_derivations_concentrationUnit_unitNameCV *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 12)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Unit_content_derivations_concentrationUnit_unitNameCV 
   (OSCTXT* pctxt, 
   Unit_content_derivations_concentrationUnit_unitNameCV value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      Unit_content_derivations_concentrationUnit_unitNameCV_ToString (value)
         , elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unit_content_derivations_massUnit_unitNameCV              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Unit_content_derivations_massUnit_unitNameCV (OSCTXT* pctxt,
   Unit_content_derivations_massUnit_unitNameCV *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 7)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Unit_content_derivations_massUnit_unitNameCV (OSCTXT* pctxt, 
   Unit_content_derivations_massUnit_unitNameCV value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      Unit_content_derivations_massUnit_unitNameCV_ToString (value)
         , elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unit_content_derivations_quantityUnit_unitNameCV          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Unit_content_derivations_quantityUnit_unitNameCV (OSCTXT* pctxt,
   Unit_content_derivations_quantityUnit_unitNameCV *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 8)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Unit_content_derivations_quantityUnit_unitNameCV (OSCTXT* pctxt, 
   Unit_content_derivations_quantityUnit_unitNameCV value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      Unit_content_derivations_quantityUnit_unitNameCV_ToString (value)
         , elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unit_content_derivations_temperatureUnit_unitNameCV       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Unit_content_derivations_temperatureUnit_unitNameCV (OSCTXT* pctxt,
   Unit_content_derivations_temperatureUnit_unitNameCV *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Unit_content_derivations_temperatureUnit_unitNameCV (OSCTXT* pctxt, 
   Unit_content_derivations_temperatureUnit_unitNameCV value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      Unit_content_derivations_temperatureUnit_unitNameCV_ToString (value)
         , elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unit_content_derivations_timeUnit_unitNameCV              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Unit_content_derivations_timeUnit_unitNameCV (OSCTXT* pctxt,
   Unit_content_derivations_timeUnit_unitNameCV *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 8)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Unit_content_derivations_timeUnit_unitNameCV (OSCTXT* pctxt, 
   Unit_content_derivations_timeUnit_unitNameCV value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      Unit_content_derivations_timeUnit_unitNameCV_ToString (value)
         , elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unit_content_derivations_volumeUnit_unitNameCV            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Unit_content_derivations_volumeUnit_unitNameCV (OSCTXT* pctxt,
   Unit_content_derivations_volumeUnit_unitNameCV *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue < 0 || *pvalue > 8)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enum (pctxt, (OSINT32*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Unit_content_derivations_volumeUnit_unitNameCV (OSCTXT* pctxt, 
   Unit_content_derivations_volumeUnit_unitNameCV value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt,
      Unit_content_derivations_volumeUnit_unitNameCV_ToString (value)
         , elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Roles_assnlist                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Roles_assnlist (OSCTXT* pctxt,
   Roles_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode ontologyEntry_list */

   if (!(pvalue->ontologyEntry_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Roles_assnlist.ontologyEntry_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->ontologyEntry_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->ontologyEntry_list.tail;
   while (0 != pnode2) {
      ll = asn1E_OntologyEntry (pctxt, ((OntologyEntry*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Roles_assnlist (OSCTXT* pctxt, Roles_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry_list */

   if (!(pvalue->ontologyEntry_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Roles_assnlist.ontologyEntry_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->ontologyEntry_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->ontologyEntry_list.head;
   while (0 != pnode) {
      stat = XmlEnc_OntologyEntry (pctxt, ((OntologyEntry*)pnode->data)
         , OSUTF8("OntologyEntry"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Contact_content                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Contact_content (OSCTXT* pctxt,
   Contact_content *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode roles_assnlist */

   if (pvalue->m.roles_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Roles_assnlist (pctxt, &pvalue->roles_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Contact_content (OSCTXT* pctxt, Contact_content* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode roles_assnlist */

   if (pvalue->m.roles_assnlistPresent) {
      stat = XmlEnc_Roles_assnlist (pctxt, &pvalue->roles_assnlist
         , OSUTF8("Roles_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Parent_assnref                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Parent_assnref (OSCTXT* pctxt,
   Parent_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode organization_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Organization_ref (pctxt, &pvalue->organization_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Parent_assnref (OSCTXT* pctxt, Parent_assnref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode organization_ref */

   stat = XmlEnc_Organization_ref (pctxt, &pvalue->organization_ref
      , OSUTF8("Organization_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Organization                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Organization (OSCTXT* pctxt,
   Organization *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode parent_assnref */

   if (pvalue->m.parent_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9,
         asn1E_Parent_assnref (pctxt, &pvalue->parent_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode contact_content */

   if (pvalue->m.contact_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_Contact_content (pctxt, &pvalue->contact_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode tollFreePhone */

   if (pvalue->m.tollFreePhonePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
         xe_utf8str (pctxt, pvalue->tollFreePhone, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode phone */

   if (pvalue->m.phonePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
         xe_utf8str (pctxt, pvalue->phone, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode fax */

   if (pvalue->m.faxPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_utf8str (pctxt, pvalue->fax, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode email */

   if (pvalue->m.emailPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->email, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode address */

   if (pvalue->m.addressPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->address, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode uRI */

   if (pvalue->m.uRIPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->uRI, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Organization (OSCTXT* pctxt, Organization* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.uRIPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" URI=\""), 6);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->uRI, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.addressPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" address=\""), 10);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->address, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.emailPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" email=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->email, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.faxPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" fax=\""), 6);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->fax, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.phonePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" phone=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->phone, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.tollFreePhonePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" tollFreePhone=\""), 16);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->tollFreePhone, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode contact_content */

   if (pvalue->m.contact_contentPresent) {
      stat = XmlEnc_Contact_content (pctxt, &pvalue->contact_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode parent_assnref */

   if (pvalue->m.parent_assnrefPresent) {
      stat = XmlEnc_Parent_assnref (pctxt, &pvalue->parent_assnref
         , OSUTF8("Parent_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Affiliation_assnref                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Affiliation_assnref (OSCTXT* pctxt,
   Affiliation_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode organization_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Organization_ref (pctxt, &pvalue->organization_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Affiliation_assnref (OSCTXT* pctxt, Affiliation_assnref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode organization_ref */

   stat = XmlEnc_Organization_ref (pctxt, &pvalue->organization_ref
      , OSUTF8("Organization_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Person                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Person (OSCTXT* pctxt,
   Person *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode affiliation_assnref */

   if (pvalue->m.affiliation_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|12,
         asn1E_Affiliation_assnref (pctxt, &pvalue->affiliation_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode contact_content */

   if (pvalue->m.contact_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|11,
         asn1E_Contact_content (pctxt, &pvalue->contact_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode tollFreePhone */

   if (pvalue->m.tollFreePhonePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|10,
         xe_utf8str (pctxt, pvalue->tollFreePhone, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode phone */

   if (pvalue->m.phonePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|9,
         xe_utf8str (pctxt, pvalue->phone, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|8,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode midInitials */

   if (pvalue->m.midInitialsPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
         xe_utf8str (pctxt, pvalue->midInitials, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode lastName */

   if (pvalue->m.lastNamePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
         xe_utf8str (pctxt, pvalue->lastName, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode firstName */

   if (pvalue->m.firstNamePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_utf8str (pctxt, pvalue->firstName, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode fax */

   if (pvalue->m.faxPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_utf8str (pctxt, pvalue->fax, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode email */

   if (pvalue->m.emailPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->email, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode address */

   if (pvalue->m.addressPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->address, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode uRI */

   if (pvalue->m.uRIPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->uRI, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Person (OSCTXT* pctxt, Person* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.uRIPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" URI=\""), 6);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->uRI, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.addressPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" address=\""), 10);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->address, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.emailPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" email=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->email, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.faxPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" fax=\""), 6);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->fax, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.firstNamePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" firstName=\""), 12);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->firstName, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.lastNamePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" lastName=\""), 11);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->lastName, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.midInitialsPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" midInitials=\""), 14);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->midInitials, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.phonePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" phone=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->phone, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.tollFreePhonePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" tollFreePhone=\""), 16);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->tollFreePhone, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode contact_content */

   if (pvalue->m.contact_contentPresent) {
      stat = XmlEnc_Contact_content (pctxt, &pvalue->contact_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode affiliation_assnref */

   if (pvalue->m.affiliation_assnrefPresent) {
      stat = XmlEnc_Affiliation_assnref (pctxt, &pvalue->affiliation_assnref
         , OSUTF8("Affiliation_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Contact_classes_group                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Contact_classes_group (OSCTXT* pctxt,
   Contact_classes_group *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_Organization (pctxt, pvalue->u.organization, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_Person (pctxt, pvalue->u.person, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Contact_classes_group (OSCTXT* pctxt, 
   Contact_classes_group* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode organization */

         stat = XmlEnc_Organization (pctxt, pvalue->u.organization
            , OSUTF8("Organization"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode person */

         stat = XmlEnc_Person (pctxt, pvalue->u.person
            , OSUTF8("Person"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Contact_assnlist                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Contact_assnlist (OSCTXT* pctxt,
   Contact_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode contact_classes_list */

   if (!(pvalue->contact_classes_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Contact_assnlist.contact_classes_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->contact_classes_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->contact_classes_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Contact_classes_group (pctxt, ((Contact_classes_group*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Contact_assnlist (OSCTXT* pctxt, Contact_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode contact_classes_list */

   if (!(pvalue->contact_classes_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Contact_assnlist.contact_classes_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->contact_classes_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->contact_classes_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Contact_classes_group (pctxt, 
         ((Contact_classes_group*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Members_assnreflist                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Members_assnreflist (OSCTXT* pctxt,
   Members_assnreflist *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Members_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_Contact_ref_1 (pctxt, ((Contact_ref_1*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Members_assnreflist (OSCTXT* pctxt, Members_assnreflist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Members_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_Contact_ref_1 (pctxt, ((Contact_ref_1*)pnode->data)
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityGroup                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SecurityGroup (OSCTXT* pctxt,
   SecurityGroup *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode members_assnreflist */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_Members_assnreflist (pctxt, &pvalue->members_assnreflist, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SecurityGroup (OSCTXT* pctxt, SecurityGroup* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode members_assnreflist */

   stat = XmlEnc_Members_assnreflist (pctxt, &pvalue->members_assnreflist
      , OSUTF8("Members_assnreflist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityGroup_assnlist                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SecurityGroup_assnlist (OSCTXT* pctxt,
   SecurityGroup_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode securityGroup_list */

   if (!(pvalue->securityGroup_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SecurityGroup_assnlist.securityGroup_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->securityGroup_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->securityGroup_list.tail;
   while (0 != pnode2) {
      ll = asn1E_SecurityGroup (pctxt, ((SecurityGroup*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SecurityGroup_assnlist (OSCTXT* pctxt, 
   SecurityGroup_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode securityGroup_list */

   if (!(pvalue->securityGroup_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SecurityGroup_assnlist.securityGroup_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->securityGroup_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->securityGroup_list.head;
   while (0 != pnode) {
      stat = XmlEnc_SecurityGroup (pctxt, ((SecurityGroup*)pnode->data)
         , OSUTF8("SecurityGroup"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Owner_assnreflist                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Owner_assnreflist (OSCTXT* pctxt,
   Owner_assnreflist *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Owner_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_Contact_ref_1 (pctxt, ((Contact_ref_1*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Owner_assnreflist (OSCTXT* pctxt, Owner_assnreflist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Owner_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_Contact_ref_1 (pctxt, ((Contact_ref_1*)pnode->data)
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityGroup_ref                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SecurityGroup_ref (OSCTXT* pctxt,
   SecurityGroup_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SecurityGroup_ref (OSCTXT* pctxt, SecurityGroup_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityGroups_assnreflist                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SecurityGroups_assnreflist (OSCTXT* pctxt,
   SecurityGroups_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode securityGroup_ref_list */

   if (!(pvalue->securityGroup_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SecurityGroups_assnreflist.securityGroup_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->securityGroup_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->securityGroup_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_SecurityGroup_ref (pctxt, ((SecurityGroup_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SecurityGroups_assnreflist (OSCTXT* pctxt, 
   SecurityGroups_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode securityGroup_ref_list */

   if (!(pvalue->securityGroup_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SecurityGroups_assnreflist.securityGroup_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->securityGroup_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->securityGroup_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_SecurityGroup_ref (pctxt, ((SecurityGroup_ref*)pnode->data)
         , OSUTF8("SecurityGroup_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Security                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Security (OSCTXT* pctxt,
   Security *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode securityGroups_assnreflist */

   if (pvalue->m.securityGroups_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_SecurityGroups_assnreflist (pctxt, &pvalue->securityGroups_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode owner_assnreflist */

   if (pvalue->m.owner_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Owner_assnreflist (pctxt, &pvalue->owner_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Security (OSCTXT* pctxt, Security* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode owner_assnreflist */

   if (pvalue->m.owner_assnreflistPresent) {
      stat = XmlEnc_Owner_assnreflist (pctxt, &pvalue->owner_assnreflist
         , OSUTF8("Owner_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode securityGroups_assnreflist */

   if (pvalue->m.securityGroups_assnreflistPresent) {
      stat = XmlEnc_SecurityGroups_assnreflist (pctxt, &pvalue->
         securityGroups_assnreflist
         , OSUTF8("SecurityGroups_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Security_assnlist                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Security_assnlist (OSCTXT* pctxt,
   Security_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode security_list */

   if (!(pvalue->security_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Security_assnlist.security_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->security_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->security_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Security (pctxt, ((Security*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Security_assnlist (OSCTXT* pctxt, Security_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode security_list */

   if (!(pvalue->security_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Security_assnlist.security_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->security_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->security_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Security (pctxt, ((Security*)pnode->data)
         , OSUTF8("Security"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuditAndSecurity_package                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AuditAndSecurity_package (OSCTXT* pctxt,
   AuditAndSecurity_package *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode security_assnlist */

   if (pvalue->m.security_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Security_assnlist (pctxt, &pvalue->security_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode securityGroup_assnlist */

   if (pvalue->m.securityGroup_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_SecurityGroup_assnlist (pctxt, &pvalue->securityGroup_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode contact_assnlist */

   if (pvalue->m.contact_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Contact_assnlist (pctxt, &pvalue->contact_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_AuditAndSecurity_package (OSCTXT* pctxt, 
   AuditAndSecurity_package* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode contact_assnlist */

   if (pvalue->m.contact_assnlistPresent) {
      stat = XmlEnc_Contact_assnlist (pctxt, &pvalue->contact_assnlist
         , OSUTF8("Contact_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode securityGroup_assnlist */

   if (pvalue->m.securityGroup_assnlistPresent) {
      stat = XmlEnc_SecurityGroup_assnlist (pctxt, &pvalue->
         securityGroup_assnlist, OSUTF8("SecurityGroup_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode security_assnlist */

   if (pvalue->m.security_assnlistPresent) {
      stat = XmlEnc_Security_assnlist (pctxt, &pvalue->security_assnlist
         , OSUTF8("Security_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Contacts_assnreflist                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Contacts_assnreflist (OSCTXT* pctxt,
   Contacts_assnreflist *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Contacts_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_Contact_ref_1 (pctxt, ((Contact_ref_1*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Contacts_assnreflist (OSCTXT* pctxt, Contacts_assnreflist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Contacts_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_Contact_ref_1 (pctxt, ((Contact_ref_1*)pnode->data)
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Database (OSCTXT* pctxt,
   Database *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode contacts_assnreflist */

   if (pvalue->m.contacts_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_Contacts_assnreflist (pctxt, &pvalue->contacts_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode version */

   if (pvalue->m.versionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_utf8str (pctxt, pvalue->version, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode uRI */

   if (pvalue->m.uRIPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->uRI, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Database (OSCTXT* pctxt, Database* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.uRIPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" URI=\""), 6);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->uRI, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.versionPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->version, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode contacts_assnreflist */

   if (pvalue->m.contacts_assnreflistPresent) {
      stat = XmlEnc_Contacts_assnreflist (pctxt, &pvalue->contacts_assnreflist
         , OSUTF8("Contacts_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Database_assnlist                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Database_assnlist (OSCTXT* pctxt,
   Database_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode database_list */

   if (!(pvalue->database_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Database_assnlist.database_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->database_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->database_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Database (pctxt, ((Database*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Database_assnlist (OSCTXT* pctxt, Database_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode database_list */

   if (!(pvalue->database_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Database_assnlist.database_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->database_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->database_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Database (pctxt, ((Database*)pnode->data)
         , OSUTF8("Database"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Description_package                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Description_package (OSCTXT* pctxt,
   Description_package *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode database_assnlist */

   if (pvalue->m.database_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Database_assnlist (pctxt, &pvalue->database_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Description_package (OSCTXT* pctxt, Description_package* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode database_assnlist */

   if (pvalue->m.database_assnlistPresent) {
      stat = XmlEnc_Database_assnlist (pctxt, &pvalue->database_assnlist
         , OSUTF8("Database_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Measurement_package                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Measurement_package (OSCTXT* pctxt,
   Measurement_package *pvalue, ASN1TagType tagging)
{
   int ll0 = 0;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Measurement_package (OSCTXT* pctxt, Measurement_package* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BQS_package                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BQS_package (OSCTXT* pctxt,
   BQS_package *pvalue, ASN1TagType tagging)
{
   int ll0 = 0;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BQS_package (OSCTXT* pctxt, BQS_package* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioEvent_package                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioEvent_package (OSCTXT* pctxt,
   BioEvent_package *pvalue, ASN1TagType tagging)
{
   int ll0 = 0;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioEvent_package (OSCTXT* pctxt, BioEvent_package* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataType_assn                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DataType_assn (OSCTXT* pctxt,
   DataType_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode ontologyEntry */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_OntologyEntry (pctxt, &pvalue->ontologyEntry, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DataType_assn (OSCTXT* pctxt, DataType_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry */

   stat = XmlEnc_OntologyEntry (pctxt, &pvalue->ontologyEntry
      , OSUTF8("OntologyEntry"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Parameter                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MAGE_Parameter (OSCTXT* pctxt,
   MAGE_Parameter *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode dataType_assn */

   if (pvalue->m.dataType_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_DataType_assn (pctxt, &pvalue->dataType_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode defaultValue_assn */

   if (pvalue->m.defaultValue_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_DefaultValue_assn (pctxt, &pvalue->defaultValue_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MAGE_Parameter (OSCTXT* pctxt, MAGE_Parameter* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode defaultValue_assn */

   if (pvalue->m.defaultValue_assnPresent) {
      stat = XmlEnc_DefaultValue_assn (pctxt, &pvalue->defaultValue_assn
         , OSUTF8("DefaultValue_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode dataType_assn */

   if (pvalue->m.dataType_assnPresent) {
      stat = XmlEnc_DataType_assn (pctxt, &pvalue->dataType_assn
         , OSUTF8("DataType_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ParameterTypes_assnlist                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ParameterTypes_assnlist (OSCTXT* pctxt,
   ParameterTypes_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode parameter_list */

   if (!(pvalue->parameter_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ParameterTypes_assnlist.parameter_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->parameter_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->parameter_list.tail;
   while (0 != pnode2) {
      ll = asn1E_MAGE_Parameter (pctxt, ((MAGE_Parameter*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ParameterTypes_assnlist (OSCTXT* pctxt, 
   ParameterTypes_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode parameter_list */

   if (!(pvalue->parameter_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ParameterTypes_assnlist.parameter_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->parameter_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->parameter_list.head;
   while (0 != pnode) {
      stat = XmlEnc_MAGE_Parameter (pctxt, ((MAGE_Parameter*)pnode->data)
         , OSUTF8("Parameter"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Parameterizable_content                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Parameterizable_content (OSCTXT* pctxt,
   Parameterizable_content *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode parameterTypes_assnlist */

   if (pvalue->m.parameterTypes_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ParameterTypes_assnlist (pctxt, &pvalue->parameterTypes_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Parameterizable_content (OSCTXT* pctxt, 
   Parameterizable_content* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode parameterTypes_assnlist */

   if (pvalue->m.parameterTypes_assnlistPresent) {
      stat = XmlEnc_ParameterTypes_assnlist (pctxt, &pvalue->
         parameterTypes_assnlist
         , OSUTF8("ParameterTypes_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Softwares_assnreflist                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Softwares_assnreflist (OSCTXT* pctxt,
   Softwares_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode software_ref_list */

   if (!(pvalue->software_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Softwares_assnreflist.software_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->software_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->software_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Software_ref (pctxt, ((Software_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Softwares_assnreflist (OSCTXT* pctxt, 
   Softwares_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode software_ref_list */

   if (!(pvalue->software_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Softwares_assnreflist.software_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->software_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->software_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Software_ref (pctxt, ((Software_ref*)pnode->data)
         , OSUTF8("Software_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HardwareManufacturers_assnreflist                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_HardwareManufacturers_assnreflist (OSCTXT* pctxt,
   HardwareManufacturers_assnreflist *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "HardwareManufacturers_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_Contact_ref_1 (pctxt, ((Contact_ref_1*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_HardwareManufacturers_assnreflist (OSCTXT* pctxt, 
   HardwareManufacturers_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "HardwareManufacturers_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_Contact_ref_1 (pctxt, ((Contact_ref_1*)pnode->data)
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Hardware                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Hardware (OSCTXT* pctxt,
   Hardware *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode hardwareManufacturers_assnreflist */

   if (pvalue->m.hardwareManufacturers_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_HardwareManufacturers_assnreflist (pctxt, &pvalue->hardwareManufacturers_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode softwares_assnreflist */

   if (pvalue->m.softwares_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_Softwares_assnreflist (pctxt, &pvalue->softwares_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode type_assn */

   if (pvalue->m.type_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_Type_assn (pctxt, &pvalue->type_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode parameterizable_content */

   if (pvalue->m.parameterizable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_Parameterizable_content (pctxt, &pvalue->parameterizable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode model */

   if (pvalue->m.modelPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_utf8str (pctxt, pvalue->model, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode make */

   if (pvalue->m.makePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->make, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode uRI */

   if (pvalue->m.uRIPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->uRI, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Hardware (OSCTXT* pctxt, Hardware* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.uRIPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" URI=\""), 6);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->uRI, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.makePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" make=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->make, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.modelPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" model=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->model, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode parameterizable_content */

   if (pvalue->m.parameterizable_contentPresent) {
      stat = XmlEnc_Parameterizable_content (pctxt, &pvalue->
         parameterizable_content, 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode type_assn */

   if (pvalue->m.type_assnPresent) {
      stat = XmlEnc_Type_assn (pctxt, &pvalue->type_assn
         , OSUTF8("Type_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode softwares_assnreflist */

   if (pvalue->m.softwares_assnreflistPresent) {
      stat = XmlEnc_Softwares_assnreflist (pctxt, &pvalue->
         softwares_assnreflist, OSUTF8("Softwares_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode hardwareManufacturers_assnreflist */

   if (pvalue->m.hardwareManufacturers_assnreflistPresent) {
      stat = XmlEnc_HardwareManufacturers_assnreflist (pctxt, &pvalue->
         hardwareManufacturers_assnreflist
         , OSUTF8("HardwareManufacturers_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Hardware_assnlist                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Hardware_assnlist (OSCTXT* pctxt,
   Hardware_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode hardware_list */

   if (!(pvalue->hardware_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Hardware_assnlist.hardware_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->hardware_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->hardware_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Hardware (pctxt, ((Hardware*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Hardware_assnlist (OSCTXT* pctxt, Hardware_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode hardware_list */

   if (!(pvalue->hardware_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Hardware_assnlist.hardware_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->hardware_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->hardware_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Hardware (pctxt, ((Hardware*)pnode->data)
         , OSUTF8("Hardware"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SoftwareManufacturers_assnreflist                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SoftwareManufacturers_assnreflist (OSCTXT* pctxt,
   SoftwareManufacturers_assnreflist *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SoftwareManufacturers_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_Contact_ref_1 (pctxt, ((Contact_ref_1*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SoftwareManufacturers_assnreflist (OSCTXT* pctxt, 
   SoftwareManufacturers_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SoftwareManufacturers_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_Contact_ref_1 (pctxt, ((Contact_ref_1*)pnode->data)
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Software                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Software (OSCTXT* pctxt,
   Software *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode softwareManufacturers_assnreflist */

   if (pvalue->m.softwareManufacturers_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_SoftwareManufacturers_assnreflist (pctxt, &pvalue->softwareManufacturers_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode softwares_assnreflist */

   if (pvalue->m.softwares_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_Softwares_assnreflist (pctxt, &pvalue->softwares_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode hardware_assnref */

   if (pvalue->m.hardware_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_Hardware_assnref (pctxt, &pvalue->hardware_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode type_assn */

   if (pvalue->m.type_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Type_assn (pctxt, &pvalue->type_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode parameterizable_content */

   if (pvalue->m.parameterizable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Parameterizable_content (pctxt, &pvalue->parameterizable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode uRI */

   if (pvalue->m.uRIPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->uRI, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Software (OSCTXT* pctxt, Software* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.uRIPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" URI=\""), 6);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->uRI, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode parameterizable_content */

   if (pvalue->m.parameterizable_contentPresent) {
      stat = XmlEnc_Parameterizable_content (pctxt, &pvalue->
         parameterizable_content, 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode type_assn */

   if (pvalue->m.type_assnPresent) {
      stat = XmlEnc_Type_assn (pctxt, &pvalue->type_assn
         , OSUTF8("Type_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode hardware_assnref */

   if (pvalue->m.hardware_assnrefPresent) {
      stat = XmlEnc_Hardware_assnref (pctxt, &pvalue->hardware_assnref
         , OSUTF8("Hardware_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode softwares_assnreflist */

   if (pvalue->m.softwares_assnreflistPresent) {
      stat = XmlEnc_Softwares_assnreflist (pctxt, &pvalue->
         softwares_assnreflist, OSUTF8("Softwares_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode softwareManufacturers_assnreflist */

   if (pvalue->m.softwareManufacturers_assnreflistPresent) {
      stat = XmlEnc_SoftwareManufacturers_assnreflist (pctxt, &pvalue->
         softwareManufacturers_assnreflist
         , OSUTF8("SoftwareManufacturers_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Software_assnlist                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Software_assnlist (OSCTXT* pctxt,
   Software_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode software_list */

   if (!(pvalue->software_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Software_assnlist.software_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->software_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->software_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Software (pctxt, ((Software*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Software_assnlist (OSCTXT* pctxt, Software_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode software_list */

   if (!(pvalue->software_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Software_assnlist.software_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->software_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->software_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Software (pctxt, ((Software*)pnode->data)
         , OSUTF8("Software"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Hardwares_assnreflist                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Hardwares_assnreflist (OSCTXT* pctxt,
   Hardwares_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode hardware_ref_list */

   if (!(pvalue->hardware_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Hardwares_assnreflist.hardware_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->hardware_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->hardware_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Hardware_ref (pctxt, ((Hardware_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Hardwares_assnreflist (OSCTXT* pctxt, 
   Hardwares_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode hardware_ref_list */

   if (!(pvalue->hardware_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Hardwares_assnreflist.hardware_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->hardware_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->hardware_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Hardware_ref (pctxt, ((Hardware_ref*)pnode->data)
         , OSUTF8("Hardware_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Protocol                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Protocol (OSCTXT* pctxt,
   Protocol *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode softwares_assnreflist */

   if (pvalue->m.softwares_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_Softwares_assnreflist (pctxt, &pvalue->softwares_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode hardwares_assnreflist */

   if (pvalue->m.hardwares_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_Hardwares_assnreflist (pctxt, &pvalue->hardwares_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode type_assn */

   if (pvalue->m.type_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_Type_assn (pctxt, &pvalue->type_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode parameterizable_content */

   if (pvalue->m.parameterizable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_Parameterizable_content (pctxt, &pvalue->parameterizable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode title */

   if (pvalue->m.titlePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_utf8str (pctxt, pvalue->title, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode text */

   if (pvalue->m.textPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_utf8str (pctxt, pvalue->text, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode uRI */

   if (pvalue->m.uRIPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->uRI, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Protocol (OSCTXT* pctxt, Protocol* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.uRIPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" URI=\""), 6);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->uRI, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.textPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" text=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->text, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.titlePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" title=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->title, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode parameterizable_content */

   if (pvalue->m.parameterizable_contentPresent) {
      stat = XmlEnc_Parameterizable_content (pctxt, &pvalue->
         parameterizable_content, 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode type_assn */

   if (pvalue->m.type_assnPresent) {
      stat = XmlEnc_Type_assn (pctxt, &pvalue->type_assn
         , OSUTF8("Type_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode hardwares_assnreflist */

   if (pvalue->m.hardwares_assnreflistPresent) {
      stat = XmlEnc_Hardwares_assnreflist (pctxt, &pvalue->
         hardwares_assnreflist, OSUTF8("Hardwares_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode softwares_assnreflist */

   if (pvalue->m.softwares_assnreflistPresent) {
      stat = XmlEnc_Softwares_assnreflist (pctxt, &pvalue->
         softwares_assnreflist, OSUTF8("Softwares_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Protocol_assnlist                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Protocol_assnlist (OSCTXT* pctxt,
   Protocol_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode protocol_list */

   if (!(pvalue->protocol_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Protocol_assnlist.protocol_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->protocol_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->protocol_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Protocol (pctxt, ((Protocol*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Protocol_assnlist (OSCTXT* pctxt, Protocol_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode protocol_list */

   if (!(pvalue->protocol_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Protocol_assnlist.protocol_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->protocol_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->protocol_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Protocol (pctxt, ((Protocol*)pnode->data)
         , OSUTF8("Protocol"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Protocol_package                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Protocol_package (OSCTXT* pctxt,
   Protocol_package *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode protocol_assnlist */

   if (pvalue->m.protocol_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Protocol_assnlist (pctxt, &pvalue->protocol_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode software_assnlist */

   if (pvalue->m.software_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Software_assnlist (pctxt, &pvalue->software_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode hardware_assnlist */

   if (pvalue->m.hardware_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Hardware_assnlist (pctxt, &pvalue->hardware_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Protocol_package (OSCTXT* pctxt, Protocol_package* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode hardware_assnlist */

   if (pvalue->m.hardware_assnlistPresent) {
      stat = XmlEnc_Hardware_assnlist (pctxt, &pvalue->hardware_assnlist
         , OSUTF8("Hardware_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode software_assnlist */

   if (pvalue->m.software_assnlistPresent) {
      stat = XmlEnc_Software_assnlist (pctxt, &pvalue->software_assnlist
         , OSUTF8("Software_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode protocol_assnlist */

   if (pvalue->m.protocol_assnlistPresent) {
      stat = XmlEnc_Protocol_assnlist (pctxt, &pvalue->protocol_assnlist
         , OSUTF8("Protocol_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MerckIndex_assn                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MerckIndex_assn (OSCTXT* pctxt,
   MerckIndex_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode ontologyEntry */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_OntologyEntry (pctxt, &pvalue->ontologyEntry, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MerckIndex_assn (OSCTXT* pctxt, MerckIndex_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry */

   stat = XmlEnc_OntologyEntry (pctxt, &pvalue->ontologyEntry
      , OSUTF8("OntologyEntry"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Compound_ref                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Compound_ref (OSCTXT* pctxt,
   Compound_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Compound_ref (OSCTXT* pctxt, Compound_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Compound_assnref                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Compound_assnref (OSCTXT* pctxt,
   Compound_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode compound_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Compound_ref (pctxt, &pvalue->compound_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Compound_assnref (OSCTXT* pctxt, Compound_assnref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode compound_ref */

   stat = XmlEnc_Compound_ref (pctxt, &pvalue->compound_ref
      , OSUTF8("Compound_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CompoundMeasurement                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CompoundMeasurement (OSCTXT* pctxt,
   CompoundMeasurement *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode measurement_assn */

   if (pvalue->m.measurement_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Measurement_assn (pctxt, &pvalue->measurement_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode compound_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Compound_assnref (pctxt, &pvalue->compound_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CompoundMeasurement (OSCTXT* pctxt, CompoundMeasurement* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode compound_assnref */

   stat = XmlEnc_Compound_assnref (pctxt, &pvalue->compound_assnref
      , OSUTF8("Compound_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode measurement_assn */

   if (pvalue->m.measurement_assnPresent) {
      stat = XmlEnc_Measurement_assn (pctxt, &pvalue->measurement_assn
         , OSUTF8("Measurement_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ComponentCompounds_assnlist                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ComponentCompounds_assnlist (OSCTXT* pctxt,
   ComponentCompounds_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode compoundMeasurement_list */

   if (!(pvalue->compoundMeasurement_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ComponentCompounds_assnlist.compoundMeasurement_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->compoundMeasurement_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->compoundMeasurement_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CompoundMeasurement (pctxt, ((CompoundMeasurement*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ComponentCompounds_assnlist (OSCTXT* pctxt, 
   ComponentCompounds_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode compoundMeasurement_list */

   if (!(pvalue->compoundMeasurement_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ComponentCompounds_assnlist.compoundMeasurement_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->compoundMeasurement_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->compoundMeasurement_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CompoundMeasurement (pctxt, 
         ((CompoundMeasurement*)pnode->data)
         , OSUTF8("CompoundMeasurement"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExternalLIMS_assn                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExternalLIMS_assn (OSCTXT* pctxt,
   ExternalLIMS_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode databaseEntry */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_DatabaseEntry (pctxt, &pvalue->databaseEntry, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ExternalLIMS_assn (OSCTXT* pctxt, ExternalLIMS_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode databaseEntry */

   stat = XmlEnc_DatabaseEntry (pctxt, &pvalue->databaseEntry
      , OSUTF8("DatabaseEntry"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Compound                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Compound (OSCTXT* pctxt,
   Compound *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode externalLIMS_assn */

   if (pvalue->m.externalLIMS_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_ExternalLIMS_assn (pctxt, &pvalue->externalLIMS_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode componentCompounds_assnlist */

   if (pvalue->m.componentCompounds_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_ComponentCompounds_assnlist (pctxt, &pvalue->componentCompounds_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode merckIndex_assn */

   if (pvalue->m.merckIndex_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_MerckIndex_assn (pctxt, &pvalue->merckIndex_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode isSolvent */

   if (pvalue->m.isSolventPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->isSolvent, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Compound (OSCTXT* pctxt, Compound* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.isSolventPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" isSolvent=\""), 12);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->isSolvent, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode merckIndex_assn */

   if (pvalue->m.merckIndex_assnPresent) {
      stat = XmlEnc_MerckIndex_assn (pctxt, &pvalue->merckIndex_assn
         , OSUTF8("MerckIndex_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode componentCompounds_assnlist */

   if (pvalue->m.componentCompounds_assnlistPresent) {
      stat = XmlEnc_ComponentCompounds_assnlist (pctxt, &pvalue->
         componentCompounds_assnlist
         , OSUTF8("ComponentCompounds_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode externalLIMS_assn */

   if (pvalue->m.externalLIMS_assnPresent) {
      stat = XmlEnc_ExternalLIMS_assn (pctxt, &pvalue->externalLIMS_assn
         , OSUTF8("ExternalLIMS_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Compound_assnlist                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Compound_assnlist (OSCTXT* pctxt,
   Compound_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode compound_list */

   if (!(pvalue->compound_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Compound_assnlist.compound_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->compound_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->compound_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Compound (pctxt, ((Compound*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Compound_assnlist (OSCTXT* pctxt, Compound_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode compound_list */

   if (!(pvalue->compound_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Compound_assnlist.compound_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->compound_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->compound_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Compound (pctxt, ((Compound*)pnode->data)
         , OSUTF8("Compound"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QualityControlStatistics_assnlist                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QualityControlStatistics_assnlist (OSCTXT* pctxt,
   QualityControlStatistics_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode nameValueType_list */

   if (!(pvalue->nameValueType_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "QualityControlStatistics_assnlist.nameValueType_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->nameValueType_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->nameValueType_list.tail;
   while (0 != pnode2) {
      ll = asn1E_NameValueType (pctxt, ((NameValueType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QualityControlStatistics_assnlist (OSCTXT* pctxt, 
   QualityControlStatistics_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode nameValueType_list */

   if (!(pvalue->nameValueType_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "QualityControlStatistics_assnlist.nameValueType_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->nameValueType_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->nameValueType_list.head;
   while (0 != pnode) {
      stat = XmlEnc_NameValueType (pctxt, ((NameValueType*)pnode->data)
         , OSUTF8("NameValueType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Characteristics_assnlist                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Characteristics_assnlist (OSCTXT* pctxt,
   Characteristics_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode ontologyEntry_list */

   if (!(pvalue->ontologyEntry_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Characteristics_assnlist.ontologyEntry_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->ontologyEntry_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->ontologyEntry_list.tail;
   while (0 != pnode2) {
      ll = asn1E_OntologyEntry (pctxt, ((OntologyEntry*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Characteristics_assnlist (OSCTXT* pctxt, 
   Characteristics_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry_list */

   if (!(pvalue->ontologyEntry_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Characteristics_assnlist.ontologyEntry_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->ontologyEntry_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->ontologyEntry_list.head;
   while (0 != pnode) {
      stat = XmlEnc_OntologyEntry (pctxt, ((OntologyEntry*)pnode->data)
         , OSUTF8("OntologyEntry"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MaterialType_assn                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MaterialType_assn (OSCTXT* pctxt,
   MaterialType_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode ontologyEntry */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_OntologyEntry (pctxt, &pvalue->ontologyEntry, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MaterialType_assn (OSCTXT* pctxt, MaterialType_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry */

   stat = XmlEnc_OntologyEntry (pctxt, &pvalue->ontologyEntry
      , OSUTF8("OntologyEntry"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Action_assn                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Action_assn (OSCTXT* pctxt,
   Action_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode ontologyEntry */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_OntologyEntry (pctxt, &pvalue->ontologyEntry, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Action_assn (OSCTXT* pctxt, Action_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry */

   stat = XmlEnc_OntologyEntry (pctxt, &pvalue->ontologyEntry
      , OSUTF8("OntologyEntry"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CompoundMeasurements_assnlist                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CompoundMeasurements_assnlist (OSCTXT* pctxt,
   CompoundMeasurements_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode compoundMeasurement_list */

   if (!(pvalue->compoundMeasurement_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "CompoundMeasurements_assnlist.compoundMeasurement_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->compoundMeasurement_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->compoundMeasurement_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CompoundMeasurement (pctxt, ((CompoundMeasurement*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CompoundMeasurements_assnlist (OSCTXT* pctxt, 
   CompoundMeasurements_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode compoundMeasurement_list */

   if (!(pvalue->compoundMeasurement_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "CompoundMeasurements_assnlist.compoundMeasurement_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->compoundMeasurement_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->compoundMeasurement_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CompoundMeasurement (pctxt, 
         ((CompoundMeasurement*)pnode->data)
         , OSUTF8("CompoundMeasurement"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioMaterialMeasurement                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioMaterialMeasurement (OSCTXT* pctxt,
   BioMaterialMeasurement *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode measurement_assn */

   if (pvalue->m.measurement_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Measurement_assn (pctxt, &pvalue->measurement_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioMaterial_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_BioMaterial_assnref (pctxt, &pvalue->bioMaterial_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioMaterialMeasurement (OSCTXT* pctxt, 
   BioMaterialMeasurement* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioMaterial_assnref */

   stat = XmlEnc_BioMaterial_assnref (pctxt, &pvalue->bioMaterial_assnref
      , OSUTF8("BioMaterial_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode measurement_assn */

   if (pvalue->m.measurement_assnPresent) {
      stat = XmlEnc_Measurement_assn (pctxt, &pvalue->measurement_assn
         , OSUTF8("Measurement_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceBioMaterialMeasurements_assnlist                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SourceBioMaterialMeasurements_assnlist (OSCTXT* pctxt,
   SourceBioMaterialMeasurements_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode bioMaterialMeasurement_list */

   if (!(pvalue->bioMaterialMeasurement_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SourceBioMaterialMeasurements_assnlist.bioMaterialMeasurement_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioMaterialMeasurement_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->bioMaterialMeasurement_list.tail;
   while (0 != pnode2) {
      ll = asn1E_BioMaterialMeasurement (pctxt, ((BioMaterialMeasurement*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SourceBioMaterialMeasurements_assnlist (OSCTXT* pctxt, 
   SourceBioMaterialMeasurements_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bioMaterialMeasurement_list */

   if (!(pvalue->bioMaterialMeasurement_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SourceBioMaterialMeasurements_assnlist.bioMaterialMeasurement_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioMaterialMeasurement_list.count
         );
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->bioMaterialMeasurement_list.head;
   while (0 != pnode) {
      stat = XmlEnc_BioMaterialMeasurement (pctxt, 
         ((BioMaterialMeasurement*)pnode->data)
         , OSUTF8("BioMaterialMeasurement"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Treatment                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Treatment (OSCTXT* pctxt,
   Treatment *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode sourceBioMaterialMeasurements_assnlist */

   if (pvalue->m.sourceBioMaterialMeasurements_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_SourceBioMaterialMeasurements_assnlist (pctxt, &pvalue->sourceBioMaterialMeasurements_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode compoundMeasurements_assnlist */

   if (pvalue->m.compoundMeasurements_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_CompoundMeasurements_assnlist (pctxt, &pvalue->compoundMeasurements_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode actionMeasurement_assn */

   if (pvalue->m.actionMeasurement_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_ActionMeasurement_assn (pctxt, &pvalue->actionMeasurement_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode action_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_Action_assn (pctxt, &pvalue->action_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode bioEvent_content */

   if (pvalue->m.bioEvent_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_BioEvent_content (pctxt, &pvalue->bioEvent_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode order */

   if (pvalue->m.orderPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->order, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Treatment (OSCTXT* pctxt, Treatment* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.orderPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" order=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->order, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode bioEvent_content */

   if (pvalue->m.bioEvent_contentPresent) {
      stat = XmlEnc_BioEvent_content (pctxt, &pvalue->bioEvent_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode action_assn */

   stat = XmlEnc_Action_assn (pctxt, &pvalue->action_assn
      , OSUTF8("Action_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode actionMeasurement_assn */

   if (pvalue->m.actionMeasurement_assnPresent) {
      stat = XmlEnc_ActionMeasurement_assn (pctxt, &pvalue->
         actionMeasurement_assn, OSUTF8("ActionMeasurement_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode compoundMeasurements_assnlist */

   if (pvalue->m.compoundMeasurements_assnlistPresent) {
      stat = XmlEnc_CompoundMeasurements_assnlist (pctxt, &pvalue->
         compoundMeasurements_assnlist
         , OSUTF8("CompoundMeasurements_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode sourceBioMaterialMeasurements_assnlist */

   if (pvalue->m.sourceBioMaterialMeasurements_assnlistPresent) {
      stat = XmlEnc_SourceBioMaterialMeasurements_assnlist (pctxt, &pvalue->
         sourceBioMaterialMeasurements_assnlist
         , OSUTF8("SourceBioMaterialMeasurements_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Treatments_assnlist                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Treatments_assnlist (OSCTXT* pctxt,
   Treatments_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode treatment_list */

   if (!(pvalue->treatment_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Treatments_assnlist.treatment_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->treatment_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->treatment_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Treatment (pctxt, ((Treatment*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Treatments_assnlist (OSCTXT* pctxt, Treatments_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode treatment_list */

   if (!(pvalue->treatment_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Treatments_assnlist.treatment_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->treatment_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->treatment_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Treatment (pctxt, ((Treatment*)pnode->data)
         , OSUTF8("Treatment"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioMaterial_content                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioMaterial_content (OSCTXT* pctxt,
   BioMaterial_content *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode treatments_assnlist */

   if (pvalue->m.treatments_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Treatments_assnlist (pctxt, &pvalue->treatments_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode materialType_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_MaterialType_assn (pctxt, &pvalue->materialType_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode characteristics_assnlist */

   if (pvalue->m.characteristics_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Characteristics_assnlist (pctxt, &pvalue->characteristics_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode qualityControlStatistics_assnlist */

   if (pvalue->m.qualityControlStatistics_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_QualityControlStatistics_assnlist (pctxt, &pvalue->qualityControlStatistics_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioMaterial_content (OSCTXT* pctxt, BioMaterial_content* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode qualityControlStatistics_assnlist */

   if (pvalue->m.qualityControlStatistics_assnlistPresent) {
      stat = XmlEnc_QualityControlStatistics_assnlist (pctxt, &pvalue->
         qualityControlStatistics_assnlist
         , OSUTF8("QualityControlStatistics_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode characteristics_assnlist */

   if (pvalue->m.characteristics_assnlistPresent) {
      stat = XmlEnc_Characteristics_assnlist (pctxt, &pvalue->
         characteristics_assnlist
         , OSUTF8("Characteristics_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode materialType_assn */

   stat = XmlEnc_MaterialType_assn (pctxt, &pvalue->materialType_assn
      , OSUTF8("MaterialType_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode treatments_assnlist */

   if (pvalue->m.treatments_assnlistPresent) {
      stat = XmlEnc_Treatments_assnlist (pctxt, &pvalue->treatments_assnlist
         , OSUTF8("Treatments_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioSample                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioSample (OSCTXT* pctxt,
   BioSample *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode type_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_Type_assn (pctxt, &pvalue->type_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode bioMaterial_content */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_BioMaterial_content (pctxt, &pvalue->bioMaterial_content, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioSample (OSCTXT* pctxt, BioSample* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode bioMaterial_content */

   stat = XmlEnc_BioMaterial_content (pctxt, &pvalue->bioMaterial_content
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode type_assn */

   stat = XmlEnc_Type_assn (pctxt, &pvalue->type_assn
      , OSUTF8("Type_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceContact_assnreflist                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SourceContact_assnreflist (OSCTXT* pctxt,
   SourceContact_assnreflist *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SourceContact_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_Contact_ref_1 (pctxt, ((Contact_ref_1*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SourceContact_assnreflist (OSCTXT* pctxt, 
   SourceContact_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SourceContact_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_Contact_ref_1 (pctxt, ((Contact_ref_1*)pnode->data)
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioSource                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioSource (OSCTXT* pctxt,
   BioSource *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode sourceContact_assnreflist */

   if (pvalue->m.sourceContact_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_SourceContact_assnreflist (pctxt, &pvalue->sourceContact_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioMaterial_content */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_BioMaterial_content (pctxt, &pvalue->bioMaterial_content, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioSource (OSCTXT* pctxt, BioSource* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode bioMaterial_content */

   stat = XmlEnc_BioMaterial_content (pctxt, &pvalue->bioMaterial_content
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode sourceContact_assnreflist */

   if (pvalue->m.sourceContact_assnreflistPresent) {
      stat = XmlEnc_SourceContact_assnreflist (pctxt, &pvalue->
         sourceContact_assnreflist
         , OSUTF8("SourceContact_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Labels_assnreflist                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Labels_assnreflist (OSCTXT* pctxt,
   Labels_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode compound_ref_list */

   if (!(pvalue->compound_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Labels_assnreflist.compound_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->compound_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->compound_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Compound_ref (pctxt, ((Compound_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Labels_assnreflist (OSCTXT* pctxt, Labels_assnreflist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode compound_ref_list */

   if (!(pvalue->compound_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Labels_assnreflist.compound_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->compound_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->compound_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Compound_ref (pctxt, ((Compound_ref*)pnode->data)
         , OSUTF8("Compound_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LabeledExtract                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_LabeledExtract (OSCTXT* pctxt,
   LabeledExtract *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode labels_assnreflist */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_Labels_assnreflist (pctxt, &pvalue->labels_assnreflist, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode bioMaterial_content */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_BioMaterial_content (pctxt, &pvalue->bioMaterial_content, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_LabeledExtract (OSCTXT* pctxt, LabeledExtract* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode bioMaterial_content */

   stat = XmlEnc_BioMaterial_content (pctxt, &pvalue->bioMaterial_content
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode labels_assnreflist */

   stat = XmlEnc_Labels_assnreflist (pctxt, &pvalue->labels_assnreflist
      , OSUTF8("Labels_assnreflist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioMaterial_classes_group                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioMaterial_classes_group (OSCTXT* pctxt,
   BioMaterial_classes_group *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_BioSample (pctxt, pvalue->u.bioSample, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_BioSource (pctxt, pvalue->u.bioSource, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_LabeledExtract (pctxt, pvalue->u.labeledExtract, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_BioMaterial_classes_group (OSCTXT* pctxt, 
   BioMaterial_classes_group* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode bioSample */

         stat = XmlEnc_BioSample (pctxt, pvalue->u.bioSample
            , OSUTF8("BioSample"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode bioSource */

         stat = XmlEnc_BioSource (pctxt, pvalue->u.bioSource
            , OSUTF8("BioSource"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode labeledExtract */

         stat = XmlEnc_LabeledExtract (pctxt, pvalue->u.labeledExtract
            , OSUTF8("LabeledExtract"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioMaterial_assnlist                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioMaterial_assnlist (OSCTXT* pctxt,
   BioMaterial_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode bioMaterial_classes_list */

   if (!(pvalue->bioMaterial_classes_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioMaterial_assnlist.bioMaterial_classes_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioMaterial_classes_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->bioMaterial_classes_list.tail;
   while (0 != pnode2) {
      ll = asn1E_BioMaterial_classes_group (pctxt, ((BioMaterial_classes_group*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioMaterial_assnlist (OSCTXT* pctxt, BioMaterial_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bioMaterial_classes_list */

   if (!(pvalue->bioMaterial_classes_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioMaterial_assnlist.bioMaterial_classes_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioMaterial_classes_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->bioMaterial_classes_list.head;
   while (0 != pnode) {
      stat = XmlEnc_BioMaterial_classes_group (pctxt, 
         ((BioMaterial_classes_group*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioMaterial_package                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioMaterial_package (OSCTXT* pctxt,
   BioMaterial_package *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode bioMaterial_assnlist */

   if (pvalue->m.bioMaterial_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_BioMaterial_assnlist (pctxt, &pvalue->bioMaterial_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode compound_assnlist */

   if (pvalue->m.compound_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Compound_assnlist (pctxt, &pvalue->compound_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioMaterial_package (OSCTXT* pctxt, BioMaterial_package* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode compound_assnlist */

   if (pvalue->m.compound_assnlistPresent) {
      stat = XmlEnc_Compound_assnlist (pctxt, &pvalue->compound_assnlist
         , OSUTF8("Compound_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioMaterial_assnlist */

   if (pvalue->m.bioMaterial_assnlistPresent) {
      stat = XmlEnc_BioMaterial_assnlist (pctxt, &pvalue->bioMaterial_assnlist
         , OSUTF8("BioMaterial_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SequenceDatabases_assnlist                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SequenceDatabases_assnlist (OSCTXT* pctxt,
   SequenceDatabases_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode databaseEntry_list */

   if (!(pvalue->databaseEntry_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SequenceDatabases_assnlist.databaseEntry_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->databaseEntry_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->databaseEntry_list.tail;
   while (0 != pnode2) {
      ll = asn1E_DatabaseEntry (pctxt, ((DatabaseEntry*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SequenceDatabases_assnlist (OSCTXT* pctxt, 
   SequenceDatabases_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode databaseEntry_list */

   if (!(pvalue->databaseEntry_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SequenceDatabases_assnlist.databaseEntry_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->databaseEntry_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->databaseEntry_list.head;
   while (0 != pnode) {
      stat = XmlEnc_DatabaseEntry (pctxt, ((DatabaseEntry*)pnode->data)
         , OSUTF8("DatabaseEntry"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  OntologyEntries_assnlist                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_OntologyEntries_assnlist (OSCTXT* pctxt,
   OntologyEntries_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode ontologyEntry_list */

   if (!(pvalue->ontologyEntry_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "OntologyEntries_assnlist.ontologyEntry_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->ontologyEntry_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->ontologyEntry_list.tail;
   while (0 != pnode2) {
      ll = asn1E_OntologyEntry (pctxt, ((OntologyEntry*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_OntologyEntries_assnlist (OSCTXT* pctxt, 
   OntologyEntries_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry_list */

   if (!(pvalue->ontologyEntry_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "OntologyEntries_assnlist.ontologyEntry_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->ontologyEntry_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->ontologyEntry_list.head;
   while (0 != pnode) {
      stat = XmlEnc_OntologyEntry (pctxt, ((OntologyEntry*)pnode->data)
         , OSUTF8("OntologyEntry"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PolymerType_assn                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PolymerType_assn (OSCTXT* pctxt,
   PolymerType_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode ontologyEntry */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_OntologyEntry (pctxt, &pvalue->ontologyEntry, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PolymerType_assn (OSCTXT* pctxt, PolymerType_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry */

   stat = XmlEnc_OntologyEntry (pctxt, &pvalue->ontologyEntry
      , OSUTF8("OntologyEntry"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Species_assn                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Species_assn (OSCTXT* pctxt,
   Species_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode ontologyEntry */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_OntologyEntry (pctxt, &pvalue->ontologyEntry, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Species_assn (OSCTXT* pctxt, Species_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry */

   stat = XmlEnc_OntologyEntry (pctxt, &pvalue->ontologyEntry
      , OSUTF8("OntologyEntry"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Subregions_assnlist                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Subregions_assnlist (OSCTXT* pctxt,
   Subregions_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode seqFeatureLocation_list */

   if (!(pvalue->seqFeatureLocation_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Subregions_assnlist.seqFeatureLocation_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->seqFeatureLocation_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->seqFeatureLocation_list.tail;
   while (0 != pnode2) {
      ll = asn1E_SeqFeatureLocation (pctxt, (SeqFeatureLocation*)((SeqFeatureLocation*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Subregions_assnlist (OSCTXT* pctxt, Subregions_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode seqFeatureLocation_list */

   if (!(pvalue->seqFeatureLocation_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Subregions_assnlist.seqFeatureLocation_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->seqFeatureLocation_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->seqFeatureLocation_list.head;
   while (0 != pnode) {
      stat = XmlEnc_SeqFeatureLocation (pctxt, 
         ((SeqFeatureLocation*)pnode->data)
         , OSUTF8("SeqFeatureLocation"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SeqFeatureLocation                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SeqFeatureLocation (OSCTXT* pctxt,
   SeqFeatureLocation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode coordinate_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_Coordinate_assn (pctxt, &pvalue->coordinate_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode subregions_assnlist */

   if (pvalue->m.subregions_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Subregions_assnlist (pctxt, &pvalue->subregions_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode strandType */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->strandType, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SeqFeatureLocation (OSCTXT* pctxt, SeqFeatureLocation* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" strandType=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->strandType, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode subregions_assnlist */

   if (pvalue->m.subregions_assnlistPresent) {
      stat = XmlEnc_Subregions_assnlist (pctxt, &pvalue->subregions_assnlist
         , OSUTF8("Subregions_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode coordinate_assn */

   stat = XmlEnc_Coordinate_assn (pctxt, &pvalue->coordinate_assn
      , OSUTF8("Coordinate_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Regions_assnlist                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Regions_assnlist (OSCTXT* pctxt,
   Regions_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode seqFeatureLocation_list */

   if (!(pvalue->seqFeatureLocation_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Regions_assnlist.seqFeatureLocation_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->seqFeatureLocation_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->seqFeatureLocation_list.tail;
   while (0 != pnode2) {
      ll = asn1E_SeqFeatureLocation (pctxt, ((SeqFeatureLocation*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Regions_assnlist (OSCTXT* pctxt, Regions_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode seqFeatureLocation_list */

   if (!(pvalue->seqFeatureLocation_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Regions_assnlist.seqFeatureLocation_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->seqFeatureLocation_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->seqFeatureLocation_list.head;
   while (0 != pnode) {
      stat = XmlEnc_SeqFeatureLocation (pctxt, 
         ((SeqFeatureLocation*)pnode->data)
         , OSUTF8("SeqFeatureLocation"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SeqFeature                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SeqFeature (OSCTXT* pctxt,
   SeqFeature *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode regions_assnlist */

   if (pvalue->m.regions_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Regions_assnlist (pctxt, &pvalue->regions_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Describable_content (pctxt, &pvalue->describable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode basis */

   if(pvalue->basis < 0 || pvalue->basis > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_SeqFeature_basis (pctxt, &pvalue->basis, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SeqFeature (OSCTXT* pctxt, SeqFeature* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" basis=\""), 8);

   if(pvalue->basis < 0 || pvalue->basis > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_SeqFeature_basis (pctxt, pvalue->basis, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      stat = XmlEnc_Describable_content (pctxt, &pvalue->describable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode regions_assnlist */

   if (pvalue->m.regions_assnlistPresent) {
      stat = XmlEnc_Regions_assnlist (pctxt, &pvalue->regions_assnlist
         , OSUTF8("Regions_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SeqFeatures_assnlist                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SeqFeatures_assnlist (OSCTXT* pctxt,
   SeqFeatures_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode seqFeature_list */

   if (!(pvalue->seqFeature_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SeqFeatures_assnlist.seqFeature_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->seqFeature_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->seqFeature_list.tail;
   while (0 != pnode2) {
      ll = asn1E_SeqFeature (pctxt, ((SeqFeature*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SeqFeatures_assnlist (OSCTXT* pctxt, SeqFeatures_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode seqFeature_list */

   if (!(pvalue->seqFeature_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SeqFeatures_assnlist.seqFeature_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->seqFeature_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->seqFeature_list.head;
   while (0 != pnode) {
      stat = XmlEnc_SeqFeature (pctxt, ((SeqFeature*)pnode->data)
         , OSUTF8("SeqFeature"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioSequence                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioSequence (OSCTXT* pctxt,
   BioSequence *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode seqFeatures_assnlist */

   if (pvalue->m.seqFeatures_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|12,
         asn1E_SeqFeatures_assnlist (pctxt, &pvalue->seqFeatures_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode species_assn */

   if (pvalue->m.species_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|11,
         asn1E_Species_assn (pctxt, &pvalue->species_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode type_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10,
      asn1E_Type_assn (pctxt, &pvalue->type_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode polymerType_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9,
      asn1E_PolymerType_assn (pctxt, &pvalue->polymerType_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode ontologyEntries_assnlist */

   if (pvalue->m.ontologyEntries_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_OntologyEntries_assnlist (pctxt, &pvalue->ontologyEntries_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode sequenceDatabases_assnlist */

   if (pvalue->m.sequenceDatabases_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_SequenceDatabases_assnlist (pctxt, &pvalue->sequenceDatabases_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode sequence */

   if (pvalue->m.sequencePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         xe_utf8str (pctxt, pvalue->sequence, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode length */

   if (pvalue->m.lengthPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_utf8str (pctxt, pvalue->length, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode isCircular */

   if (pvalue->m.isCircularPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->isCircular, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode isApproximateLength */

   if (pvalue->m.isApproximateLengthPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->isApproximateLength, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioSequence (OSCTXT* pctxt, BioSequence* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.isApproximateLengthPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" isApproximateLength=\""), 22);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->isApproximateLength, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.isCircularPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" isCircular=\""), 13);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->isCircular, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.lengthPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" length=\""), 9);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->length, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.sequencePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" sequence=\""), 11);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->sequence, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode sequenceDatabases_assnlist */

   if (pvalue->m.sequenceDatabases_assnlistPresent) {
      stat = XmlEnc_SequenceDatabases_assnlist (pctxt, &pvalue->
         sequenceDatabases_assnlist
         , OSUTF8("SequenceDatabases_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode ontologyEntries_assnlist */

   if (pvalue->m.ontologyEntries_assnlistPresent) {
      stat = XmlEnc_OntologyEntries_assnlist (pctxt, &pvalue->
         ontologyEntries_assnlist
         , OSUTF8("OntologyEntries_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode polymerType_assn */

   stat = XmlEnc_PolymerType_assn (pctxt, &pvalue->polymerType_assn
      , OSUTF8("PolymerType_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode type_assn */

   stat = XmlEnc_Type_assn (pctxt, &pvalue->type_assn
      , OSUTF8("Type_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode species_assn */

   if (pvalue->m.species_assnPresent) {
      stat = XmlEnc_Species_assn (pctxt, &pvalue->species_assn
         , OSUTF8("Species_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode seqFeatures_assnlist */

   if (pvalue->m.seqFeatures_assnlistPresent) {
      stat = XmlEnc_SeqFeatures_assnlist (pctxt, &pvalue->seqFeatures_assnlist
         , OSUTF8("SeqFeatures_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioSequence_assnlist                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioSequence_assnlist (OSCTXT* pctxt,
   BioSequence_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode bioSequence_list */

   if (!(pvalue->bioSequence_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioSequence_assnlist.bioSequence_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioSequence_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->bioSequence_list.tail;
   while (0 != pnode2) {
      ll = asn1E_BioSequence (pctxt, ((BioSequence*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioSequence_assnlist (OSCTXT* pctxt, BioSequence_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bioSequence_list */

   if (!(pvalue->bioSequence_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioSequence_assnlist.bioSequence_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioSequence_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->bioSequence_list.head;
   while (0 != pnode) {
      stat = XmlEnc_BioSequence (pctxt, ((BioSequence*)pnode->data)
         , OSUTF8("BioSequence"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioSequence_package                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioSequence_package (OSCTXT* pctxt,
   BioSequence_package *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode bioSequence_assnlist */

   if (pvalue->m.bioSequence_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_BioSequence_assnlist (pctxt, &pvalue->bioSequence_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioSequence_package (OSCTXT* pctxt, BioSequence_package* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bioSequence_assnlist */

   if (pvalue->m.bioSequence_assnlistPresent) {
      stat = XmlEnc_BioSequence_assnlist (pctxt, &pvalue->bioSequence_assnlist
         , OSUTF8("BioSequence_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ControlType_assn                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ControlType_assn (OSCTXT* pctxt,
   ControlType_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode ontologyEntry */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_OntologyEntry (pctxt, &pvalue->ontologyEntry, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ControlType_assn (OSCTXT* pctxt, ControlType_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry */

   stat = XmlEnc_OntologyEntry (pctxt, &pvalue->ontologyEntry
      , OSUTF8("OntologyEntry"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElement_content                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElement_content (OSCTXT* pctxt,
   DesignElement_content *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode controlType_assn */

   if (pvalue->m.controlType_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ControlType_assn (pctxt, &pvalue->controlType_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DesignElement_content (OSCTXT* pctxt, 
   DesignElement_content* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode controlType_assn */

   if (pvalue->m.controlType_assnPresent) {
      stat = XmlEnc_ControlType_assn (pctxt, &pvalue->controlType_assn
         , OSUTF8("ControlType_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioSequence_ref                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioSequence_ref (OSCTXT* pctxt,
   BioSequence_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioSequence_ref (OSCTXT* pctxt, BioSequence_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BiologicalCharacteristics_assnreflist                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BiologicalCharacteristics_assnreflist (OSCTXT* pctxt,
   BiologicalCharacteristics_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode bioSequence_ref_list */

   if (!(pvalue->bioSequence_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BiologicalCharacteristics_assnreflist.bioSequence_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioSequence_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->bioSequence_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_BioSequence_ref (pctxt, ((BioSequence_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BiologicalCharacteristics_assnreflist (OSCTXT* pctxt, 
   BiologicalCharacteristics_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bioSequence_ref_list */

   if (!(pvalue->bioSequence_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BiologicalCharacteristics_assnreflist.bioSequence_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioSequence_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->bioSequence_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_BioSequence_ref (pctxt, ((BioSequence_ref*)pnode->data)
         , OSUTF8("BioSequence_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReporterCompositeMaps_assnreflist                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ReporterCompositeMaps_assnreflist (OSCTXT* pctxt,
   ReporterCompositeMaps_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode reporterCompositeMap_ref_list */

   if (!(pvalue->reporterCompositeMap_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ReporterCompositeMaps_assnreflist.reporterCompositeMap_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->reporterCompositeMap_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->reporterCompositeMap_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ReporterCompositeMap_ref (pctxt, ((ReporterCompositeMap_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ReporterCompositeMaps_assnreflist (OSCTXT* pctxt, 
   ReporterCompositeMaps_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode reporterCompositeMap_ref_list */

   if (!(pvalue->reporterCompositeMap_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ReporterCompositeMaps_assnreflist.reporterCompositeMap_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->reporterCompositeMap_ref_list.count
         );
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->reporterCompositeMap_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ReporterCompositeMap_ref (pctxt, 
         ((ReporterCompositeMap_ref*)pnode->data)
         , OSUTF8("ReporterCompositeMap_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CompositeCompositeMaps_assnreflist                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CompositeCompositeMaps_assnreflist (OSCTXT* pctxt,
   CompositeCompositeMaps_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode compositeCompositeMap_ref_list */

   if (!(pvalue->compositeCompositeMap_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "CompositeCompositeMaps_assnreflist.compositeCompositeMap_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->compositeCompositeMap_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->compositeCompositeMap_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CompositeCompositeMap_ref (pctxt, ((CompositeCompositeMap_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CompositeCompositeMaps_assnreflist (OSCTXT* pctxt, 
   CompositeCompositeMaps_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode compositeCompositeMap_ref_list */

   if (!(pvalue->compositeCompositeMap_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "CompositeCompositeMaps_assnreflist.compositeCompositeMap_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->compositeCompositeMap_ref_list.
         count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->compositeCompositeMap_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CompositeCompositeMap_ref (pctxt, 
         ((CompositeCompositeMap_ref*)pnode->data)
         , OSUTF8("CompositeCompositeMap_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CompositeSequence_choice                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CompositeSequence_choice (OSCTXT* pctxt,
   CompositeSequence_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_ReporterCompositeMaps_assnreflist (pctxt, pvalue->u.reporterCompositeMaps_assnreflist, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_CompositeCompositeMaps_assnreflist (pctxt, pvalue->u.compositeCompositeMaps_assnreflist, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_CompositeSequence_choice (OSCTXT* pctxt, 
   CompositeSequence_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode reporterCompositeMaps_assnreflist */

         stat = XmlEnc_ReporterCompositeMaps_assnreflist (pctxt, pvalue->
            u.reporterCompositeMaps_assnreflist
            , OSUTF8("ReporterCompositeMaps_assnreflist"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode compositeCompositeMaps_assnreflist */

         stat = XmlEnc_CompositeCompositeMaps_assnreflist (pctxt, pvalue->
            u.compositeCompositeMaps_assnreflist
            , OSUTF8("CompositeCompositeMaps_assnreflist"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CompositeSequence                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CompositeSequence (OSCTXT* pctxt,
   CompositeSequence *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode choice */

   if (pvalue->m.choicePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_CompositeSequence_choice (pctxt, &pvalue->choice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode biologicalCharacteristics_assnreflist */

   if (pvalue->m.biologicalCharacteristics_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_BiologicalCharacteristics_assnreflist (pctxt, &pvalue->biologicalCharacteristics_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode designElement_content */

   if (pvalue->m.designElement_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_DesignElement_content (pctxt, &pvalue->designElement_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CompositeSequence (OSCTXT* pctxt, CompositeSequence* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode designElement_content */

   if (pvalue->m.designElement_contentPresent) {
      stat = XmlEnc_DesignElement_content (pctxt, &pvalue->
         designElement_content, 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode biologicalCharacteristics_assnreflist */

   if (pvalue->m.biologicalCharacteristics_assnreflistPresent) {
      stat = XmlEnc_BiologicalCharacteristics_assnreflist (pctxt, &pvalue->
         biologicalCharacteristics_assnreflist
         , OSUTF8("BiologicalCharacteristics_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode choice */

   if (pvalue->m.choicePresent) {
      stat = XmlEnc_CompositeSequence_choice (pctxt, &pvalue->choice
         , OSUTF8(""), 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CompositeSequence_assnlist                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CompositeSequence_assnlist (OSCTXT* pctxt,
   CompositeSequence_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode compositeSequence_list */

   if (!(pvalue->compositeSequence_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "CompositeSequence_assnlist.compositeSequence_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->compositeSequence_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->compositeSequence_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CompositeSequence (pctxt, ((CompositeSequence*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CompositeSequence_assnlist (OSCTXT* pctxt, 
   CompositeSequence_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode compositeSequence_list */

   if (!(pvalue->compositeSequence_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "CompositeSequence_assnlist.compositeSequence_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->compositeSequence_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->compositeSequence_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CompositeSequence (pctxt, ((CompositeSequence*)pnode->data)
         , OSUTF8("CompositeSequence"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ImmobilizedCharacteristics_assnreflist                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ImmobilizedCharacteristics_assnreflist (OSCTXT* pctxt,
   ImmobilizedCharacteristics_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode bioSequence_ref_list */

   if (!(pvalue->bioSequence_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ImmobilizedCharacteristics_assnreflist.bioSequence_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioSequence_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->bioSequence_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_BioSequence_ref (pctxt, ((BioSequence_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ImmobilizedCharacteristics_assnreflist (OSCTXT* pctxt, 
   ImmobilizedCharacteristics_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bioSequence_ref_list */

   if (!(pvalue->bioSequence_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ImmobilizedCharacteristics_assnreflist.bioSequence_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioSequence_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->bioSequence_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_BioSequence_ref (pctxt, ((BioSequence_ref*)pnode->data)
         , OSUTF8("BioSequence_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  WarningType_assn                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_WarningType_assn (OSCTXT* pctxt,
   WarningType_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode ontologyEntry */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_OntologyEntry (pctxt, &pvalue->ontologyEntry, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_WarningType_assn (OSCTXT* pctxt, WarningType_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry */

   stat = XmlEnc_OntologyEntry (pctxt, &pvalue->ontologyEntry
      , OSUTF8("OntologyEntry"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FailTypes_assnlist                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FailTypes_assnlist (OSCTXT* pctxt,
   FailTypes_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode ontologyEntry_list */

   if (!(pvalue->ontologyEntry_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FailTypes_assnlist.ontologyEntry_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->ontologyEntry_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->ontologyEntry_list.tail;
   while (0 != pnode2) {
      ll = asn1E_OntologyEntry (pctxt, ((OntologyEntry*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FailTypes_assnlist (OSCTXT* pctxt, FailTypes_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry_list */

   if (!(pvalue->ontologyEntry_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FailTypes_assnlist.ontologyEntry_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->ontologyEntry_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->ontologyEntry_list.head;
   while (0 != pnode) {
      stat = XmlEnc_OntologyEntry (pctxt, ((OntologyEntry*)pnode->data)
         , OSUTF8("OntologyEntry"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeatureReporterMaps_assnreflist                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FeatureReporterMaps_assnreflist (OSCTXT* pctxt,
   FeatureReporterMaps_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode featureReporterMap_ref_list */

   if (!(pvalue->featureReporterMap_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FeatureReporterMaps_assnreflist.featureReporterMap_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->featureReporterMap_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->featureReporterMap_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_FeatureReporterMap_ref (pctxt, ((FeatureReporterMap_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FeatureReporterMaps_assnreflist (OSCTXT* pctxt, 
   FeatureReporterMaps_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode featureReporterMap_ref_list */

   if (!(pvalue->featureReporterMap_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FeatureReporterMaps_assnreflist.featureReporterMap_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->featureReporterMap_ref_list.count
         );
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->featureReporterMap_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_FeatureReporterMap_ref (pctxt, 
         ((FeatureReporterMap_ref*)pnode->data)
         , OSUTF8("FeatureReporterMap_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reporter                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Reporter (OSCTXT* pctxt,
   Reporter *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode featureReporterMaps_assnreflist */

   if (pvalue->m.featureReporterMaps_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_FeatureReporterMaps_assnreflist (pctxt, &pvalue->featureReporterMaps_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode failTypes_assnlist */

   if (pvalue->m.failTypes_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_FailTypes_assnlist (pctxt, &pvalue->failTypes_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode warningType_assn */

   if (pvalue->m.warningType_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_WarningType_assn (pctxt, &pvalue->warningType_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode immobilizedCharacteristics_assnreflist */

   if (pvalue->m.immobilizedCharacteristics_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_ImmobilizedCharacteristics_assnreflist (pctxt, &pvalue->immobilizedCharacteristics_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode designElement_content */

   if (pvalue->m.designElement_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_DesignElement_content (pctxt, &pvalue->designElement_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Reporter (OSCTXT* pctxt, Reporter* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode designElement_content */

   if (pvalue->m.designElement_contentPresent) {
      stat = XmlEnc_DesignElement_content (pctxt, &pvalue->
         designElement_content, 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode immobilizedCharacteristics_assnreflist */

   if (pvalue->m.immobilizedCharacteristics_assnreflistPresent) {
      stat = XmlEnc_ImmobilizedCharacteristics_assnreflist (pctxt, &pvalue->
         immobilizedCharacteristics_assnreflist
         , OSUTF8("ImmobilizedCharacteristics_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode warningType_assn */

   if (pvalue->m.warningType_assnPresent) {
      stat = XmlEnc_WarningType_assn (pctxt, &pvalue->warningType_assn
         , OSUTF8("WarningType_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode failTypes_assnlist */

   if (pvalue->m.failTypes_assnlistPresent) {
      stat = XmlEnc_FailTypes_assnlist (pctxt, &pvalue->failTypes_assnlist
         , OSUTF8("FailTypes_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode featureReporterMaps_assnreflist */

   if (pvalue->m.featureReporterMaps_assnreflistPresent) {
      stat = XmlEnc_FeatureReporterMaps_assnreflist (pctxt, &pvalue->
         featureReporterMaps_assnreflist
         , OSUTF8("FeatureReporterMaps_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reporter_assnlist                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Reporter_assnlist (OSCTXT* pctxt,
   Reporter_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode reporter_list */

   if (!(pvalue->reporter_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Reporter_assnlist.reporter_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->reporter_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->reporter_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Reporter (pctxt, ((Reporter*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Reporter_assnlist (OSCTXT* pctxt, Reporter_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode reporter_list */

   if (!(pvalue->reporter_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Reporter_assnlist.reporter_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->reporter_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->reporter_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Reporter (pctxt, ((Reporter*)pnode->data)
         , OSUTF8("Reporter"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CompositeSequence_assnref                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CompositeSequence_assnref (OSCTXT* pctxt,
   CompositeSequence_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode compositeSequence_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_CompositeSequence_ref (pctxt, &pvalue->compositeSequence_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CompositeSequence_assnref (OSCTXT* pctxt, 
   CompositeSequence_assnref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode compositeSequence_ref */

   stat = XmlEnc_CompositeSequence_ref (pctxt, &pvalue->compositeSequence_ref
      , OSUTF8("CompositeSequence_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CompositePositionSources_assnlist                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CompositePositionSources_assnlist (OSCTXT* pctxt,
   CompositePositionSources_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode compositePosition_list */

   if (!(pvalue->compositePosition_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "CompositePositionSources_assnlist.compositePosition_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->compositePosition_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->compositePosition_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CompositePosition (pctxt, ((CompositePosition*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CompositePositionSources_assnlist (OSCTXT* pctxt, 
   CompositePositionSources_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode compositePosition_list */

   if (!(pvalue->compositePosition_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "CompositePositionSources_assnlist.compositePosition_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->compositePosition_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->compositePosition_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CompositePosition (pctxt, ((CompositePosition*)pnode->data)
         , OSUTF8("CompositePosition"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CompositeCompositeMap                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CompositeCompositeMap (OSCTXT* pctxt,
   CompositeCompositeMap *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode compositePositionSources_assnlist */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_CompositePositionSources_assnlist (pctxt, &pvalue->compositePositionSources_assnlist, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode compositeSequence_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_CompositeSequence_assnref (pctxt, &pvalue->compositeSequence_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode designElementMap_content */

   if (pvalue->m.designElementMap_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_DesignElementMap_content (pctxt, &pvalue->designElementMap_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CompositeCompositeMap (OSCTXT* pctxt, 
   CompositeCompositeMap* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode designElementMap_content */

   if (pvalue->m.designElementMap_contentPresent) {
      stat = XmlEnc_DesignElementMap_content (pctxt, &pvalue->
         designElementMap_content, 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode compositeSequence_assnref */

   stat = XmlEnc_CompositeSequence_assnref (pctxt, &pvalue->
      compositeSequence_assnref
      , OSUTF8("CompositeSequence_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode compositePositionSources_assnlist */

   stat = XmlEnc_CompositePositionSources_assnlist (pctxt, &pvalue->
      compositePositionSources_assnlist
      , OSUTF8("CompositePositionSources_assnlist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CompositeCompositeMap_assnlist                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CompositeCompositeMap_assnlist (OSCTXT* pctxt,
   CompositeCompositeMap_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode compositeCompositeMap_list */

   if (!(pvalue->compositeCompositeMap_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "CompositeCompositeMap_assnlist.compositeCompositeMap_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->compositeCompositeMap_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->compositeCompositeMap_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CompositeCompositeMap (pctxt, ((CompositeCompositeMap*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CompositeCompositeMap_assnlist (OSCTXT* pctxt, 
   CompositeCompositeMap_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode compositeCompositeMap_list */

   if (!(pvalue->compositeCompositeMap_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "CompositeCompositeMap_assnlist.compositeCompositeMap_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->compositeCompositeMap_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->compositeCompositeMap_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CompositeCompositeMap (pctxt, 
         ((CompositeCompositeMap*)pnode->data)
         , OSUTF8("CompositeCompositeMap"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReporterPositionSources_assnlist                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ReporterPositionSources_assnlist (OSCTXT* pctxt,
   ReporterPositionSources_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode reporterPosition_list */

   if (!(pvalue->reporterPosition_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ReporterPositionSources_assnlist.reporterPosition_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->reporterPosition_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->reporterPosition_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ReporterPosition (pctxt, ((ReporterPosition*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ReporterPositionSources_assnlist (OSCTXT* pctxt, 
   ReporterPositionSources_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode reporterPosition_list */

   if (!(pvalue->reporterPosition_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ReporterPositionSources_assnlist.reporterPosition_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->reporterPosition_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->reporterPosition_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ReporterPosition (pctxt, ((ReporterPosition*)pnode->data)
         , OSUTF8("ReporterPosition"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReporterCompositeMap                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ReporterCompositeMap (OSCTXT* pctxt,
   ReporterCompositeMap *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode reporterPositionSources_assnlist */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_ReporterPositionSources_assnlist (pctxt, &pvalue->reporterPositionSources_assnlist, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode compositeSequence_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_CompositeSequence_assnref (pctxt, &pvalue->compositeSequence_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode designElementMap_content */

   if (pvalue->m.designElementMap_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_DesignElementMap_content (pctxt, &pvalue->designElementMap_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ReporterCompositeMap (OSCTXT* pctxt, ReporterCompositeMap* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode designElementMap_content */

   if (pvalue->m.designElementMap_contentPresent) {
      stat = XmlEnc_DesignElementMap_content (pctxt, &pvalue->
         designElementMap_content, 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode compositeSequence_assnref */

   stat = XmlEnc_CompositeSequence_assnref (pctxt, &pvalue->
      compositeSequence_assnref
      , OSUTF8("CompositeSequence_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode reporterPositionSources_assnlist */

   stat = XmlEnc_ReporterPositionSources_assnlist (pctxt, &pvalue->
      reporterPositionSources_assnlist
      , OSUTF8("ReporterPositionSources_assnlist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReporterCompositeMap_assnlist                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ReporterCompositeMap_assnlist (OSCTXT* pctxt,
   ReporterCompositeMap_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode reporterCompositeMap_list */

   if (!(pvalue->reporterCompositeMap_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ReporterCompositeMap_assnlist.reporterCompositeMap_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->reporterCompositeMap_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->reporterCompositeMap_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ReporterCompositeMap (pctxt, ((ReporterCompositeMap*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ReporterCompositeMap_assnlist (OSCTXT* pctxt, 
   ReporterCompositeMap_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode reporterCompositeMap_list */

   if (!(pvalue->reporterCompositeMap_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ReporterCompositeMap_assnlist.reporterCompositeMap_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->reporterCompositeMap_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->reporterCompositeMap_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ReporterCompositeMap (pctxt, 
         ((ReporterCompositeMap*)pnode->data)
         , OSUTF8("ReporterCompositeMap"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Feature_assnref                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Feature_assnref (OSCTXT* pctxt,
   Feature_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode feature_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Feature_ref (pctxt, &pvalue->feature_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Feature_assnref (OSCTXT* pctxt, Feature_assnref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode feature_ref */

   stat = XmlEnc_Feature_ref (pctxt, &pvalue->feature_ref
      , OSUTF8("Feature_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeatureInformation                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FeatureInformation (OSCTXT* pctxt,
   FeatureInformation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode mismatchInformation_assnlist */

   if (pvalue->m.mismatchInformation_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_MismatchInformation_assnlist (pctxt, &pvalue->mismatchInformation_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode feature_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Feature_assnref (pctxt, &pvalue->feature_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FeatureInformation (OSCTXT* pctxt, FeatureInformation* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode feature_assnref */

   stat = XmlEnc_Feature_assnref (pctxt, &pvalue->feature_assnref
      , OSUTF8("Feature_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode mismatchInformation_assnlist */

   if (pvalue->m.mismatchInformation_assnlistPresent) {
      stat = XmlEnc_MismatchInformation_assnlist (pctxt, &pvalue->
         mismatchInformation_assnlist
         , OSUTF8("MismatchInformation_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeatureInformationSources_assnlist                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FeatureInformationSources_assnlist (OSCTXT* pctxt,
   FeatureInformationSources_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode featureInformation_list */

   if (!(pvalue->featureInformation_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FeatureInformationSources_assnlist.featureInformation_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->featureInformation_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->featureInformation_list.tail;
   while (0 != pnode2) {
      ll = asn1E_FeatureInformation (pctxt, ((FeatureInformation*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FeatureInformationSources_assnlist (OSCTXT* pctxt, 
   FeatureInformationSources_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode featureInformation_list */

   if (!(pvalue->featureInformation_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FeatureInformationSources_assnlist.featureInformation_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->featureInformation_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->featureInformation_list.head;
   while (0 != pnode) {
      stat = XmlEnc_FeatureInformation (pctxt, 
         ((FeatureInformation*)pnode->data)
         , OSUTF8("FeatureInformation"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeatureReporterMap                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FeatureReporterMap (OSCTXT* pctxt,
   FeatureReporterMap *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode featureInformationSources_assnlist */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_FeatureInformationSources_assnlist (pctxt, &pvalue->featureInformationSources_assnlist, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode reporter_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_Reporter_assnref (pctxt, &pvalue->reporter_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode designElementMap_content */

   if (pvalue->m.designElementMap_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_DesignElementMap_content (pctxt, &pvalue->designElementMap_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FeatureReporterMap (OSCTXT* pctxt, FeatureReporterMap* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode designElementMap_content */

   if (pvalue->m.designElementMap_contentPresent) {
      stat = XmlEnc_DesignElementMap_content (pctxt, &pvalue->
         designElementMap_content, 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode reporter_assnref */

   stat = XmlEnc_Reporter_assnref (pctxt, &pvalue->reporter_assnref
      , OSUTF8("Reporter_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode featureInformationSources_assnlist */

   stat = XmlEnc_FeatureInformationSources_assnlist (pctxt, &pvalue->
      featureInformationSources_assnlist
      , OSUTF8("FeatureInformationSources_assnlist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeatureReporterMap_assnlist                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FeatureReporterMap_assnlist (OSCTXT* pctxt,
   FeatureReporterMap_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode featureReporterMap_list */

   if (!(pvalue->featureReporterMap_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FeatureReporterMap_assnlist.featureReporterMap_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->featureReporterMap_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->featureReporterMap_list.tail;
   while (0 != pnode2) {
      ll = asn1E_FeatureReporterMap (pctxt, ((FeatureReporterMap*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FeatureReporterMap_assnlist (OSCTXT* pctxt, 
   FeatureReporterMap_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode featureReporterMap_list */

   if (!(pvalue->featureReporterMap_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FeatureReporterMap_assnlist.featureReporterMap_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->featureReporterMap_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->featureReporterMap_list.head;
   while (0 != pnode) {
      stat = XmlEnc_FeatureReporterMap (pctxt, 
         ((FeatureReporterMap*)pnode->data)
         , OSUTF8("FeatureReporterMap"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElement_package                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElement_package (OSCTXT* pctxt,
   DesignElement_package *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode featureReporterMap_assnlist */

   if (pvalue->m.featureReporterMap_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_FeatureReporterMap_assnlist (pctxt, &pvalue->featureReporterMap_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode reporterCompositeMap_assnlist */

   if (pvalue->m.reporterCompositeMap_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_ReporterCompositeMap_assnlist (pctxt, &pvalue->reporterCompositeMap_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode compositeCompositeMap_assnlist */

   if (pvalue->m.compositeCompositeMap_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_CompositeCompositeMap_assnlist (pctxt, &pvalue->compositeCompositeMap_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode reporter_assnlist */

   if (pvalue->m.reporter_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Reporter_assnlist (pctxt, &pvalue->reporter_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode compositeSequence_assnlist */

   if (pvalue->m.compositeSequence_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_CompositeSequence_assnlist (pctxt, &pvalue->compositeSequence_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DesignElement_package (OSCTXT* pctxt, 
   DesignElement_package* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode compositeSequence_assnlist */

   if (pvalue->m.compositeSequence_assnlistPresent) {
      stat = XmlEnc_CompositeSequence_assnlist (pctxt, &pvalue->
         compositeSequence_assnlist
         , OSUTF8("CompositeSequence_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode reporter_assnlist */

   if (pvalue->m.reporter_assnlistPresent) {
      stat = XmlEnc_Reporter_assnlist (pctxt, &pvalue->reporter_assnlist
         , OSUTF8("Reporter_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode compositeCompositeMap_assnlist */

   if (pvalue->m.compositeCompositeMap_assnlistPresent) {
      stat = XmlEnc_CompositeCompositeMap_assnlist (pctxt, &pvalue->
         compositeCompositeMap_assnlist
         , OSUTF8("CompositeCompositeMap_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode reporterCompositeMap_assnlist */

   if (pvalue->m.reporterCompositeMap_assnlistPresent) {
      stat = XmlEnc_ReporterCompositeMap_assnlist (pctxt, &pvalue->
         reporterCompositeMap_assnlist
         , OSUTF8("ReporterCompositeMap_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode featureReporterMap_assnlist */

   if (pvalue->m.featureReporterMap_assnlistPresent) {
      stat = XmlEnc_FeatureReporterMap_assnlist (pctxt, &pvalue->
         featureReporterMap_assnlist
         , OSUTF8("FeatureReporterMap_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElementGroup_content                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElementGroup_content (OSCTXT* pctxt,
   DesignElementGroup_content *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode species_assn */

   if (pvalue->m.species_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Species_assn (pctxt, &pvalue->species_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode types_assnlist */

   if (pvalue->m.types_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Types_assnlist (pctxt, &pvalue->types_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DesignElementGroup_content (OSCTXT* pctxt, 
   DesignElementGroup_content* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode types_assnlist */

   if (pvalue->m.types_assnlistPresent) {
      stat = XmlEnc_Types_assnlist (pctxt, &pvalue->types_assnlist
         , OSUTF8("Types_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode species_assn */

   if (pvalue->m.species_assnPresent) {
      stat = XmlEnc_Species_assn (pctxt, &pvalue->species_assn
         , OSUTF8("Species_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reporters_assnreflist                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Reporters_assnreflist (OSCTXT* pctxt,
   Reporters_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode reporter_ref_list */

   if (!(pvalue->reporter_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Reporters_assnreflist.reporter_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->reporter_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->reporter_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Reporter_ref (pctxt, ((Reporter_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Reporters_assnreflist (OSCTXT* pctxt, 
   Reporters_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode reporter_ref_list */

   if (!(pvalue->reporter_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Reporters_assnreflist.reporter_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->reporter_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->reporter_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Reporter_ref (pctxt, ((Reporter_ref*)pnode->data)
         , OSUTF8("Reporter_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReporterGroup                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ReporterGroup (OSCTXT* pctxt,
   ReporterGroup *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode reporters_assnreflist */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_Reporters_assnreflist (pctxt, &pvalue->reporters_assnreflist, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode designElementGroup_content */

   if (pvalue->m.designElementGroup_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_DesignElementGroup_content (pctxt, &pvalue->designElementGroup_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ReporterGroup (OSCTXT* pctxt, ReporterGroup* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode designElementGroup_content */

   if (pvalue->m.designElementGroup_contentPresent) {
      stat = XmlEnc_DesignElementGroup_content (pctxt, &pvalue->
         designElementGroup_content, 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode reporters_assnreflist */

   stat = XmlEnc_Reporters_assnreflist (pctxt, &pvalue->reporters_assnreflist
      , OSUTF8("Reporters_assnreflist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReporterGroup_assnlist                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ReporterGroup_assnlist (OSCTXT* pctxt,
   ReporterGroup_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode reporterGroup_list */

   if (!(pvalue->reporterGroup_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ReporterGroup_assnlist.reporterGroup_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->reporterGroup_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->reporterGroup_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ReporterGroup (pctxt, ((ReporterGroup*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ReporterGroup_assnlist (OSCTXT* pctxt, 
   ReporterGroup_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode reporterGroup_list */

   if (!(pvalue->reporterGroup_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ReporterGroup_assnlist.reporterGroup_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->reporterGroup_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->reporterGroup_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ReporterGroup (pctxt, ((ReporterGroup*)pnode->data)
         , OSUTF8("ReporterGroup"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CompositeSequences_assnreflist                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CompositeSequences_assnreflist (OSCTXT* pctxt,
   CompositeSequences_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode compositeSequence_ref_list */

   if (!(pvalue->compositeSequence_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "CompositeSequences_assnreflist.compositeSequence_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->compositeSequence_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->compositeSequence_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CompositeSequence_ref (pctxt, ((CompositeSequence_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CompositeSequences_assnreflist (OSCTXT* pctxt, 
   CompositeSequences_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode compositeSequence_ref_list */

   if (!(pvalue->compositeSequence_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "CompositeSequences_assnreflist.compositeSequence_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->compositeSequence_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->compositeSequence_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CompositeSequence_ref (pctxt, 
         ((CompositeSequence_ref*)pnode->data)
         , OSUTF8("CompositeSequence_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CompositeGroup                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CompositeGroup (OSCTXT* pctxt,
   CompositeGroup *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode compositeSequences_assnreflist */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_CompositeSequences_assnreflist (pctxt, &pvalue->compositeSequences_assnreflist, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode designElementGroup_content */

   if (pvalue->m.designElementGroup_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_DesignElementGroup_content (pctxt, &pvalue->designElementGroup_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CompositeGroup (OSCTXT* pctxt, CompositeGroup* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode designElementGroup_content */

   if (pvalue->m.designElementGroup_contentPresent) {
      stat = XmlEnc_DesignElementGroup_content (pctxt, &pvalue->
         designElementGroup_content, 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode compositeSequences_assnreflist */

   stat = XmlEnc_CompositeSequences_assnreflist (pctxt, &pvalue->
      compositeSequences_assnreflist
      , OSUTF8("CompositeSequences_assnreflist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CompositeGroup_assnlist                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CompositeGroup_assnlist (OSCTXT* pctxt,
   CompositeGroup_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode compositeGroup_list */

   if (!(pvalue->compositeGroup_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "CompositeGroup_assnlist.compositeGroup_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->compositeGroup_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->compositeGroup_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CompositeGroup (pctxt, ((CompositeGroup*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CompositeGroup_assnlist (OSCTXT* pctxt, 
   CompositeGroup_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode compositeGroup_list */

   if (!(pvalue->compositeGroup_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "CompositeGroup_assnlist.compositeGroup_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->compositeGroup_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->compositeGroup_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CompositeGroup (pctxt, ((CompositeGroup*)pnode->data)
         , OSUTF8("CompositeGroup"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TechnologyType_assn                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TechnologyType_assn (OSCTXT* pctxt,
   TechnologyType_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode ontologyEntry */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_OntologyEntry (pctxt, &pvalue->ontologyEntry, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TechnologyType_assn (OSCTXT* pctxt, TechnologyType_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry */

   stat = XmlEnc_OntologyEntry (pctxt, &pvalue->ontologyEntry
      , OSUTF8("OntologyEntry"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeatureShape_assn                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FeatureShape_assn (OSCTXT* pctxt,
   FeatureShape_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode ontologyEntry */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_OntologyEntry (pctxt, &pvalue->ontologyEntry, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FeatureShape_assn (OSCTXT* pctxt, FeatureShape_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry */

   stat = XmlEnc_OntologyEntry (pctxt, &pvalue->ontologyEntry
      , OSUTF8("OntologyEntry"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ControlFeatures_assnreflist                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ControlFeatures_assnreflist (OSCTXT* pctxt,
   ControlFeatures_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode feature_ref_list */

   if (!(pvalue->feature_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ControlFeatures_assnreflist.feature_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->feature_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->feature_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Feature_ref (pctxt, ((Feature_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ControlFeatures_assnreflist (OSCTXT* pctxt, 
   ControlFeatures_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode feature_ref_list */

   if (!(pvalue->feature_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ControlFeatures_assnreflist.feature_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->feature_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->feature_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Feature_ref (pctxt, ((Feature_ref*)pnode->data)
         , OSUTF8("Feature_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ControlledFeatures_assnreflist                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ControlledFeatures_assnreflist (OSCTXT* pctxt,
   ControlledFeatures_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode feature_ref_list */

   if (!(pvalue->feature_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ControlledFeatures_assnreflist.feature_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->feature_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->feature_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Feature_ref (pctxt, ((Feature_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ControlledFeatures_assnreflist (OSCTXT* pctxt, 
   ControlledFeatures_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode feature_ref_list */

   if (!(pvalue->feature_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ControlledFeatures_assnreflist.feature_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->feature_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->feature_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Feature_ref (pctxt, ((Feature_ref*)pnode->data)
         , OSUTF8("Feature_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Feature                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Feature (OSCTXT* pctxt,
   Feature *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode featureLocation_assn */

   if (pvalue->m.featureLocation_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_FeatureLocation_assn (pctxt, &pvalue->featureLocation_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode zone_assnref */

   if (pvalue->m.zone_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_Zone_assnref (pctxt, &pvalue->zone_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode position_assn */

   if (pvalue->m.position_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_Position_assn (pctxt, &pvalue->position_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode controlledFeatures_assnreflist */

   if (pvalue->m.controlledFeatures_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_ControlledFeatures_assnreflist (pctxt, &pvalue->controlledFeatures_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode controlFeatures_assnreflist */

   if (pvalue->m.controlFeatures_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_ControlFeatures_assnreflist (pctxt, &pvalue->controlFeatures_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode designElement_content */

   if (pvalue->m.designElement_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_DesignElement_content (pctxt, &pvalue->designElement_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Feature (OSCTXT* pctxt, Feature* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode designElement_content */

   if (pvalue->m.designElement_contentPresent) {
      stat = XmlEnc_DesignElement_content (pctxt, &pvalue->
         designElement_content, 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode controlFeatures_assnreflist */

   if (pvalue->m.controlFeatures_assnreflistPresent) {
      stat = XmlEnc_ControlFeatures_assnreflist (pctxt, &pvalue->
         controlFeatures_assnreflist
         , OSUTF8("ControlFeatures_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode controlledFeatures_assnreflist */

   if (pvalue->m.controlledFeatures_assnreflistPresent) {
      stat = XmlEnc_ControlledFeatures_assnreflist (pctxt, &pvalue->
         controlledFeatures_assnreflist
         , OSUTF8("ControlledFeatures_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode position_assn */

   if (pvalue->m.position_assnPresent) {
      stat = XmlEnc_Position_assn (pctxt, &pvalue->position_assn
         , OSUTF8("Position_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode zone_assnref */

   if (pvalue->m.zone_assnrefPresent) {
      stat = XmlEnc_Zone_assnref (pctxt, &pvalue->zone_assnref
         , OSUTF8("Zone_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode featureLocation_assn */

   if (pvalue->m.featureLocation_assnPresent) {
      stat = XmlEnc_FeatureLocation_assn (pctxt, &pvalue->featureLocation_assn
         , OSUTF8("FeatureLocation_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Features_assnlist                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Features_assnlist (OSCTXT* pctxt,
   Features_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode feature_list */

   if (!(pvalue->feature_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Features_assnlist.feature_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->feature_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->feature_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Feature (pctxt, ((Feature*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Features_assnlist (OSCTXT* pctxt, Features_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode feature_list */

   if (!(pvalue->feature_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Features_assnlist.feature_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->feature_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->feature_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Feature (pctxt, ((Feature*)pnode->data)
         , OSUTF8("Feature"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeatureGroup                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FeatureGroup (OSCTXT* pctxt,
   FeatureGroup *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode features_assnlist */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9,
      asn1E_Features_assnlist (pctxt, &pvalue->features_assnlist, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode distanceUnit_assn */

   if (pvalue->m.distanceUnit_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_DistanceUnit_assn (pctxt, &pvalue->distanceUnit_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode featureShape_assn */

   if (pvalue->m.featureShape_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_FeatureShape_assn (pctxt, &pvalue->featureShape_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode technologyType_assn */

   if (pvalue->m.technologyType_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_TechnologyType_assn (pctxt, &pvalue->technologyType_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode designElementGroup_content */

   if (pvalue->m.designElementGroup_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_DesignElementGroup_content (pctxt, &pvalue->designElementGroup_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode featureWidth */

   if (pvalue->m.featureWidthPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->featureWidth, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode featureLength */

   if (pvalue->m.featureLengthPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->featureLength, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode featureHeight */

   if (pvalue->m.featureHeightPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->featureHeight, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FeatureGroup (OSCTXT* pctxt, FeatureGroup* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.featureHeightPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" featureHeight=\""), 16);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->featureHeight, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.featureLengthPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" featureLength=\""), 16);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->featureLength, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.featureWidthPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" featureWidth=\""), 15);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->featureWidth, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode designElementGroup_content */

   if (pvalue->m.designElementGroup_contentPresent) {
      stat = XmlEnc_DesignElementGroup_content (pctxt, &pvalue->
         designElementGroup_content, 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode technologyType_assn */

   if (pvalue->m.technologyType_assnPresent) {
      stat = XmlEnc_TechnologyType_assn (pctxt, &pvalue->technologyType_assn
         , OSUTF8("TechnologyType_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode featureShape_assn */

   if (pvalue->m.featureShape_assnPresent) {
      stat = XmlEnc_FeatureShape_assn (pctxt, &pvalue->featureShape_assn
         , OSUTF8("FeatureShape_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode distanceUnit_assn */

   if (pvalue->m.distanceUnit_assnPresent) {
      stat = XmlEnc_DistanceUnit_assn (pctxt, &pvalue->distanceUnit_assn
         , OSUTF8("DistanceUnit_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode features_assnlist */

   stat = XmlEnc_Features_assnlist (pctxt, &pvalue->features_assnlist
      , OSUTF8("Features_assnlist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeatureGroups_assnlist                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FeatureGroups_assnlist (OSCTXT* pctxt,
   FeatureGroups_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode featureGroup_list */

   if (!(pvalue->featureGroup_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FeatureGroups_assnlist.featureGroup_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->featureGroup_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->featureGroup_list.tail;
   while (0 != pnode2) {
      ll = asn1E_FeatureGroup (pctxt, ((FeatureGroup*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FeatureGroups_assnlist (OSCTXT* pctxt, 
   FeatureGroups_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode featureGroup_list */

   if (!(pvalue->featureGroup_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FeatureGroups_assnlist.featureGroup_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->featureGroup_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->featureGroup_list.head;
   while (0 != pnode) {
      stat = XmlEnc_FeatureGroup (pctxt, ((FeatureGroup*)pnode->data)
         , OSUTF8("FeatureGroup"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReporterGroup_ref                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ReporterGroup_ref (OSCTXT* pctxt,
   ReporterGroup_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ReporterGroup_ref (OSCTXT* pctxt, ReporterGroup_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReporterGroups_assnreflist                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ReporterGroups_assnreflist (OSCTXT* pctxt,
   ReporterGroups_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode reporterGroup_ref_list */

   if (!(pvalue->reporterGroup_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ReporterGroups_assnreflist.reporterGroup_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->reporterGroup_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->reporterGroup_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ReporterGroup_ref (pctxt, ((ReporterGroup_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ReporterGroups_assnreflist (OSCTXT* pctxt, 
   ReporterGroups_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode reporterGroup_ref_list */

   if (!(pvalue->reporterGroup_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ReporterGroups_assnreflist.reporterGroup_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->reporterGroup_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->reporterGroup_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ReporterGroup_ref (pctxt, ((ReporterGroup_ref*)pnode->data)
         , OSUTF8("ReporterGroup_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CompositeGroup_ref                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CompositeGroup_ref (OSCTXT* pctxt,
   CompositeGroup_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CompositeGroup_ref (OSCTXT* pctxt, CompositeGroup_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CompositeGroups_assnreflist                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CompositeGroups_assnreflist (OSCTXT* pctxt,
   CompositeGroups_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode compositeGroup_ref_list */

   if (!(pvalue->compositeGroup_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "CompositeGroups_assnreflist.compositeGroup_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->compositeGroup_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->compositeGroup_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CompositeGroup_ref (pctxt, ((CompositeGroup_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CompositeGroups_assnreflist (OSCTXT* pctxt, 
   CompositeGroups_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode compositeGroup_ref_list */

   if (!(pvalue->compositeGroup_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "CompositeGroups_assnreflist.compositeGroup_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->compositeGroup_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->compositeGroup_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CompositeGroup_ref (pctxt, 
         ((CompositeGroup_ref*)pnode->data)
         , OSUTF8("CompositeGroup_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignProviders_assnreflist                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignProviders_assnreflist (OSCTXT* pctxt,
   DesignProviders_assnreflist *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DesignProviders_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_Contact_ref_1 (pctxt, ((Contact_ref_1*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DesignProviders_assnreflist (OSCTXT* pctxt, 
   DesignProviders_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DesignProviders_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_Contact_ref_1 (pctxt, ((Contact_ref_1*)pnode->data)
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ArrayDesign                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ArrayDesign (OSCTXT* pctxt,
   ArrayDesign *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode designProviders_assnreflist */

   if (pvalue->m.designProviders_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9,
         asn1E_DesignProviders_assnreflist (pctxt, &pvalue->designProviders_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode compositeGroups_assnreflist */

   if (pvalue->m.compositeGroups_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_CompositeGroups_assnreflist (pctxt, &pvalue->compositeGroups_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode reporterGroups_assnreflist */

   if (pvalue->m.reporterGroups_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_ReporterGroups_assnreflist (pctxt, &pvalue->reporterGroups_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode featureGroups_assnlist */

   if (pvalue->m.featureGroups_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_FeatureGroups_assnlist (pctxt, &pvalue->featureGroups_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode protocolApplications_assnlist */

   if (pvalue->m.protocolApplications_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_ProtocolApplications_assnlist (pctxt, &pvalue->protocolApplications_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode version */

   if (pvalue->m.versionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_utf8str (pctxt, pvalue->version, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode numberOfFeatures */

   if (pvalue->m.numberOfFeaturesPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->numberOfFeatures, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ArrayDesign (OSCTXT* pctxt, ArrayDesign* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.numberOfFeaturesPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" numberOfFeatures=\""), 19);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->numberOfFeatures, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.versionPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->version, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode protocolApplications_assnlist */

   if (pvalue->m.protocolApplications_assnlistPresent) {
      stat = XmlEnc_ProtocolApplications_assnlist (pctxt, &pvalue->
         protocolApplications_assnlist
         , OSUTF8("ProtocolApplications_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode featureGroups_assnlist */

   if (pvalue->m.featureGroups_assnlistPresent) {
      stat = XmlEnc_FeatureGroups_assnlist (pctxt, &pvalue->
         featureGroups_assnlist, OSUTF8("FeatureGroups_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode reporterGroups_assnreflist */

   if (pvalue->m.reporterGroups_assnreflistPresent) {
      stat = XmlEnc_ReporterGroups_assnreflist (pctxt, &pvalue->
         reporterGroups_assnreflist
         , OSUTF8("ReporterGroups_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode compositeGroups_assnreflist */

   if (pvalue->m.compositeGroups_assnreflistPresent) {
      stat = XmlEnc_CompositeGroups_assnreflist (pctxt, &pvalue->
         compositeGroups_assnreflist
         , OSUTF8("CompositeGroups_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode designProviders_assnreflist */

   if (pvalue->m.designProviders_assnreflistPresent) {
      stat = XmlEnc_DesignProviders_assnreflist (pctxt, &pvalue->
         designProviders_assnreflist
         , OSUTF8("DesignProviders_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SurfaceType_assn                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SurfaceType_assn (OSCTXT* pctxt,
   SurfaceType_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode ontologyEntry */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_OntologyEntry (pctxt, &pvalue->ontologyEntry, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SurfaceType_assn (OSCTXT* pctxt, SurfaceType_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry */

   stat = XmlEnc_OntologyEntry (pctxt, &pvalue->ontologyEntry
      , OSUTF8("OntologyEntry"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Zone                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Zone (OSCTXT* pctxt,
   Zone *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode distanceUnit_assn */

   if (pvalue->m.distanceUnit_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9,
         asn1E_DistanceUnit_assn (pctxt, &pvalue->distanceUnit_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode upperLeftY */

   if (pvalue->m.upperLeftYPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
         xe_utf8str (pctxt, pvalue->upperLeftY, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode upperLeftX */

   if (pvalue->m.upperLeftXPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
         xe_utf8str (pctxt, pvalue->upperLeftX, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode row */

   if (pvalue->m.rowPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         xe_utf8str (pctxt, pvalue->row, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode lowerRightY */

   if (pvalue->m.lowerRightYPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_utf8str (pctxt, pvalue->lowerRightY, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode lowerRightX */

   if (pvalue->m.lowerRightXPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->lowerRightX, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode column */

   if (pvalue->m.columnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->column, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Zone (OSCTXT* pctxt, Zone* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.columnPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" column=\""), 9);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->column, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.lowerRightXPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" lowerRightX=\""), 14);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->lowerRightX, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.lowerRightYPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" lowerRightY=\""), 14);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->lowerRightY, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.rowPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" row=\""), 6);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->row, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.upperLeftXPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" upperLeftX=\""), 13);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->upperLeftX, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.upperLeftYPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" upperLeftY=\""), 13);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->upperLeftY, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode distanceUnit_assn */

   if (pvalue->m.distanceUnit_assnPresent) {
      stat = XmlEnc_DistanceUnit_assn (pctxt, &pvalue->distanceUnit_assn
         , OSUTF8("DistanceUnit_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ZoneLocations_assnlist                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ZoneLocations_assnlist (OSCTXT* pctxt,
   ZoneLocations_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode zone_list */

   if (!(pvalue->zone_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ZoneLocations_assnlist.zone_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->zone_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->zone_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Zone (pctxt, ((Zone*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ZoneLocations_assnlist (OSCTXT* pctxt, 
   ZoneLocations_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode zone_list */

   if (!(pvalue->zone_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ZoneLocations_assnlist.zone_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->zone_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->zone_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Zone (pctxt, ((Zone*)pnode->data)
         , OSUTF8("Zone"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ZoneGroup                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ZoneGroup (OSCTXT* pctxt,
   ZoneGroup *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode zoneLocations_assnlist */

   if (pvalue->m.zoneLocations_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_ZoneLocations_assnlist (pctxt, &pvalue->zoneLocations_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode zoneLayout_assn */

   if (pvalue->m.zoneLayout_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_ZoneLayout_assn (pctxt, &pvalue->zoneLayout_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode distanceUnit_assn */

   if (pvalue->m.distanceUnit_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_DistanceUnit_assn (pctxt, &pvalue->distanceUnit_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode zonesPerY */

   if (pvalue->m.zonesPerYPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_utf8str (pctxt, pvalue->zonesPerY, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode zonesPerX */

   if (pvalue->m.zonesPerXPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->zonesPerX, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode spacingsBetweenZonesY */

   if (pvalue->m.spacingsBetweenZonesYPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->spacingsBetweenZonesY, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode spacingsBetweenZonesX */

   if (pvalue->m.spacingsBetweenZonesXPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->spacingsBetweenZonesX, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ZoneGroup (OSCTXT* pctxt, ZoneGroup* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.spacingsBetweenZonesXPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" spacingsBetweenZonesX=\""), 24);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->spacingsBetweenZonesX, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.spacingsBetweenZonesYPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" spacingsBetweenZonesY=\""), 24);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->spacingsBetweenZonesY, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.zonesPerXPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" zonesPerX=\""), 12);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->zonesPerX, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.zonesPerYPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" zonesPerY=\""), 12);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->zonesPerY, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode distanceUnit_assn */

   if (pvalue->m.distanceUnit_assnPresent) {
      stat = XmlEnc_DistanceUnit_assn (pctxt, &pvalue->distanceUnit_assn
         , OSUTF8("DistanceUnit_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode zoneLayout_assn */

   if (pvalue->m.zoneLayout_assnPresent) {
      stat = XmlEnc_ZoneLayout_assn (pctxt, &pvalue->zoneLayout_assn
         , OSUTF8("ZoneLayout_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode zoneLocations_assnlist */

   if (pvalue->m.zoneLocations_assnlistPresent) {
      stat = XmlEnc_ZoneLocations_assnlist (pctxt, &pvalue->
         zoneLocations_assnlist, OSUTF8("ZoneLocations_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ZoneGroups_assnlist                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ZoneGroups_assnlist (OSCTXT* pctxt,
   ZoneGroups_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode zoneGroup_list */

   if (!(pvalue->zoneGroup_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ZoneGroups_assnlist.zoneGroup_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->zoneGroup_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->zoneGroup_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ZoneGroup (pctxt, ((ZoneGroup*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ZoneGroups_assnlist (OSCTXT* pctxt, ZoneGroups_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode zoneGroup_list */

   if (!(pvalue->zoneGroup_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ZoneGroups_assnlist.zoneGroup_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->zoneGroup_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->zoneGroup_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ZoneGroup (pctxt, ((ZoneGroup*)pnode->data)
         , OSUTF8("ZoneGroup"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PhysicalArrayDesign                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PhysicalArrayDesign (OSCTXT* pctxt,
   PhysicalArrayDesign *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode zoneGroups_assnlist */

   if (pvalue->m.zoneGroups_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|11,
         asn1E_ZoneGroups_assnlist (pctxt, &pvalue->zoneGroups_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode surfaceType_assn */

   if (pvalue->m.surfaceType_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10,
         asn1E_SurfaceType_assn (pctxt, &pvalue->surfaceType_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode designProviders_assnreflist */

   if (pvalue->m.designProviders_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9,
         asn1E_DesignProviders_assnreflist (pctxt, &pvalue->designProviders_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode compositeGroups_assnreflist */

   if (pvalue->m.compositeGroups_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_CompositeGroups_assnreflist (pctxt, &pvalue->compositeGroups_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode reporterGroups_assnreflist */

   if (pvalue->m.reporterGroups_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_ReporterGroups_assnreflist (pctxt, &pvalue->reporterGroups_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode featureGroups_assnlist */

   if (pvalue->m.featureGroups_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_FeatureGroups_assnlist (pctxt, &pvalue->featureGroups_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode protocolApplications_assnlist */

   if (pvalue->m.protocolApplications_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_ProtocolApplications_assnlist (pctxt, &pvalue->protocolApplications_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode version */

   if (pvalue->m.versionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_utf8str (pctxt, pvalue->version, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode numberOfFeatures */

   if (pvalue->m.numberOfFeaturesPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->numberOfFeatures, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PhysicalArrayDesign (OSCTXT* pctxt, PhysicalArrayDesign* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.numberOfFeaturesPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" numberOfFeatures=\""), 19);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->numberOfFeatures, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.versionPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->version, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode protocolApplications_assnlist */

   if (pvalue->m.protocolApplications_assnlistPresent) {
      stat = XmlEnc_ProtocolApplications_assnlist (pctxt, &pvalue->
         protocolApplications_assnlist
         , OSUTF8("ProtocolApplications_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode featureGroups_assnlist */

   if (pvalue->m.featureGroups_assnlistPresent) {
      stat = XmlEnc_FeatureGroups_assnlist (pctxt, &pvalue->
         featureGroups_assnlist, OSUTF8("FeatureGroups_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode reporterGroups_assnreflist */

   if (pvalue->m.reporterGroups_assnreflistPresent) {
      stat = XmlEnc_ReporterGroups_assnreflist (pctxt, &pvalue->
         reporterGroups_assnreflist
         , OSUTF8("ReporterGroups_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode compositeGroups_assnreflist */

   if (pvalue->m.compositeGroups_assnreflistPresent) {
      stat = XmlEnc_CompositeGroups_assnreflist (pctxt, &pvalue->
         compositeGroups_assnreflist
         , OSUTF8("CompositeGroups_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode designProviders_assnreflist */

   if (pvalue->m.designProviders_assnreflistPresent) {
      stat = XmlEnc_DesignProviders_assnreflist (pctxt, &pvalue->
         designProviders_assnreflist
         , OSUTF8("DesignProviders_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode surfaceType_assn */

   if (pvalue->m.surfaceType_assnPresent) {
      stat = XmlEnc_SurfaceType_assn (pctxt, &pvalue->surfaceType_assn
         , OSUTF8("SurfaceType_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode zoneGroups_assnlist */

   if (pvalue->m.zoneGroups_assnlistPresent) {
      stat = XmlEnc_ZoneGroups_assnlist (pctxt, &pvalue->zoneGroups_assnlist
         , OSUTF8("ZoneGroups_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ArrayDesign_classes_group                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ArrayDesign_classes_group (OSCTXT* pctxt,
   ArrayDesign_classes_group *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_ArrayDesign (pctxt, pvalue->u.arrayDesign, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_PhysicalArrayDesign (pctxt, pvalue->u.physicalArrayDesign, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_ArrayDesign_classes_group (OSCTXT* pctxt, 
   ArrayDesign_classes_group* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode arrayDesign */

         stat = XmlEnc_ArrayDesign (pctxt, pvalue->u.arrayDesign
            , OSUTF8("ArrayDesign"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode physicalArrayDesign */

         stat = XmlEnc_PhysicalArrayDesign (pctxt, pvalue->
            u.physicalArrayDesign, OSUTF8("PhysicalArrayDesign"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ArrayDesign_assnlist                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ArrayDesign_assnlist (OSCTXT* pctxt,
   ArrayDesign_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode arrayDesign_classes_list */

   if (!(pvalue->arrayDesign_classes_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ArrayDesign_assnlist.arrayDesign_classes_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->arrayDesign_classes_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->arrayDesign_classes_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ArrayDesign_classes_group (pctxt, ((ArrayDesign_classes_group*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ArrayDesign_assnlist (OSCTXT* pctxt, ArrayDesign_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode arrayDesign_classes_list */

   if (!(pvalue->arrayDesign_classes_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ArrayDesign_assnlist.arrayDesign_classes_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->arrayDesign_classes_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->arrayDesign_classes_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ArrayDesign_classes_group (pctxt, 
         ((ArrayDesign_classes_group*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ArrayDesign_package                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ArrayDesign_package (OSCTXT* pctxt,
   ArrayDesign_package *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode arrayDesign_assnlist */

   if (pvalue->m.arrayDesign_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_ArrayDesign_assnlist (pctxt, &pvalue->arrayDesign_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode compositeGroup_assnlist */

   if (pvalue->m.compositeGroup_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_CompositeGroup_assnlist (pctxt, &pvalue->compositeGroup_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode reporterGroup_assnlist */

   if (pvalue->m.reporterGroup_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ReporterGroup_assnlist (pctxt, &pvalue->reporterGroup_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ArrayDesign_package (OSCTXT* pctxt, ArrayDesign_package* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode reporterGroup_assnlist */

   if (pvalue->m.reporterGroup_assnlistPresent) {
      stat = XmlEnc_ReporterGroup_assnlist (pctxt, &pvalue->
         reporterGroup_assnlist, OSUTF8("ReporterGroup_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode compositeGroup_assnlist */

   if (pvalue->m.compositeGroup_assnlistPresent) {
      stat = XmlEnc_CompositeGroup_assnlist (pctxt, &pvalue->
         compositeGroup_assnlist
         , OSUTF8("CompositeGroup_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode arrayDesign_assnlist */

   if (pvalue->m.arrayDesign_assnlistPresent) {
      stat = XmlEnc_ArrayDesign_assnlist (pctxt, &pvalue->arrayDesign_assnlist
         , OSUTF8("ArrayDesign_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FiducialType_assn                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FiducialType_assn (OSCTXT* pctxt,
   FiducialType_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode ontologyEntry */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_OntologyEntry (pctxt, &pvalue->ontologyEntry, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FiducialType_assn (OSCTXT* pctxt, FiducialType_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry */

   stat = XmlEnc_OntologyEntry (pctxt, &pvalue->ontologyEntry
      , OSUTF8("OntologyEntry"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Fiducial                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Fiducial (OSCTXT* pctxt,
   Fiducial *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode position_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_Position_assn (pctxt, &pvalue->position_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode distanceUnit_assn */

   if (pvalue->m.distanceUnit_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_DistanceUnit_assn (pctxt, &pvalue->distanceUnit_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode fiducialType_assn */

   if (pvalue->m.fiducialType_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_FiducialType_assn (pctxt, &pvalue->fiducialType_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Describable_content (pctxt, &pvalue->describable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Fiducial (OSCTXT* pctxt, Fiducial* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      stat = XmlEnc_Describable_content (pctxt, &pvalue->describable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fiducialType_assn */

   if (pvalue->m.fiducialType_assnPresent) {
      stat = XmlEnc_FiducialType_assn (pctxt, &pvalue->fiducialType_assn
         , OSUTF8("FiducialType_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode distanceUnit_assn */

   if (pvalue->m.distanceUnit_assnPresent) {
      stat = XmlEnc_DistanceUnit_assn (pctxt, &pvalue->distanceUnit_assn
         , OSUTF8("DistanceUnit_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode position_assn */

   stat = XmlEnc_Position_assn (pctxt, &pvalue->position_assn
      , OSUTF8("Position_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Fiducials_assnlist                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Fiducials_assnlist (OSCTXT* pctxt,
   Fiducials_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode fiducial_list */

   if (!(pvalue->fiducial_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Fiducials_assnlist.fiducial_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->fiducial_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->fiducial_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Fiducial (pctxt, ((Fiducial*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Fiducials_assnlist (OSCTXT* pctxt, Fiducials_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode fiducial_list */

   if (!(pvalue->fiducial_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Fiducials_assnlist.fiducial_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->fiducial_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->fiducial_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Fiducial (pctxt, ((Fiducial*)pnode->data)
         , OSUTF8("Fiducial"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Array_ref                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Array_ref (OSCTXT* pctxt,
   Array_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Array_ref (OSCTXT* pctxt, Array_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Arrays_assnreflist                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Arrays_assnreflist (OSCTXT* pctxt,
   Arrays_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode array_ref_list */

   if (!(pvalue->array_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Arrays_assnreflist.array_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->array_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->array_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Array_ref (pctxt, ((Array_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Arrays_assnreflist (OSCTXT* pctxt, Arrays_assnreflist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode array_ref_list */

   if (!(pvalue->array_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Arrays_assnreflist.array_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->array_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->array_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Array_ref (pctxt, ((Array_ref*)pnode->data)
         , OSUTF8("Array_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SubstrateType_assn                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SubstrateType_assn (OSCTXT* pctxt,
   SubstrateType_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode ontologyEntry */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_OntologyEntry (pctxt, &pvalue->ontologyEntry, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SubstrateType_assn (OSCTXT* pctxt, SubstrateType_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry */

   stat = XmlEnc_OntologyEntry (pctxt, &pvalue->ontologyEntry
      , OSUTF8("OntologyEntry"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ArrayGroup                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ArrayGroup (OSCTXT* pctxt,
   ArrayGroup *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode distanceUnit_assn */

   if (pvalue->m.distanceUnit_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|14,
         asn1E_DistanceUnit_assn (pctxt, &pvalue->distanceUnit_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode substrateType_assn */

   if (pvalue->m.substrateType_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|13,
         asn1E_SubstrateType_assn (pctxt, &pvalue->substrateType_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode arrays_assnreflist */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|12,
      asn1E_Arrays_assnreflist (pctxt, &pvalue->arrays_assnreflist, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode fiducials_assnlist */

   if (pvalue->m.fiducials_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|11,
         asn1E_Fiducials_assnlist (pctxt, &pvalue->fiducials_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode width */

   if (pvalue->m.widthPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|9,
         xe_utf8str (pctxt, pvalue->width, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode orientationMarkPosition */

   if (pvalue->m.orientationMarkPositionPresent) {
      if(pvalue->orientationMarkPosition < 0 || pvalue->orientationMarkPosition > 3)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|8,
         asn1E_ArrayGroup_orientationMarkPosition (pctxt, &pvalue->orientationMarkPosition, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode orientationMark */

   if (pvalue->m.orientationMarkPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
         xe_utf8str (pctxt, pvalue->orientationMark, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode numArrays */

   if (pvalue->m.numArraysPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
         xe_utf8str (pctxt, pvalue->numArrays, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode length */

   if (pvalue->m.lengthPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_utf8str (pctxt, pvalue->length, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode barcode */

   if (pvalue->m.barcodePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->barcode, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode arraySpacingY */

   if (pvalue->m.arraySpacingYPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->arraySpacingY, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode arraySpacingX */

   if (pvalue->m.arraySpacingXPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->arraySpacingX, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ArrayGroup (OSCTXT* pctxt, ArrayGroup* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.arraySpacingXPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" arraySpacingX=\""), 16);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->arraySpacingX, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.arraySpacingYPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" arraySpacingY=\""), 16);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->arraySpacingY, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.barcodePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" barcode=\""), 10);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->barcode, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.lengthPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" length=\""), 9);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->length, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.numArraysPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" numArrays=\""), 12);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->numArrays, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.orientationMarkPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" orientationMark=\""), 18);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->orientationMark, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.orientationMarkPositionPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" orientationMarkPosition=\""), 26);

      if(pvalue->orientationMarkPosition < 0 || pvalue->orientationMarkPosition
          > 3)
         return LOG_RTERR (pctxt, RTERR_INVENUM);

      stat = XmlEnc_ArrayGroup_orientationMarkPosition (pctxt, pvalue->
         orientationMarkPosition, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');
   }

   if (pvalue->m.widthPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" width=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->width, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fiducials_assnlist */

   if (pvalue->m.fiducials_assnlistPresent) {
      stat = XmlEnc_Fiducials_assnlist (pctxt, &pvalue->fiducials_assnlist
         , OSUTF8("Fiducials_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode arrays_assnreflist */

   stat = XmlEnc_Arrays_assnreflist (pctxt, &pvalue->arrays_assnreflist
      , OSUTF8("Arrays_assnreflist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode substrateType_assn */

   if (pvalue->m.substrateType_assnPresent) {
      stat = XmlEnc_SubstrateType_assn (pctxt, &pvalue->substrateType_assn
         , OSUTF8("SubstrateType_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode distanceUnit_assn */

   if (pvalue->m.distanceUnit_assnPresent) {
      stat = XmlEnc_DistanceUnit_assn (pctxt, &pvalue->distanceUnit_assn
         , OSUTF8("DistanceUnit_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ArrayGroup_assnlist                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ArrayGroup_assnlist (OSCTXT* pctxt,
   ArrayGroup_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode arrayGroup_list */

   if (!(pvalue->arrayGroup_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ArrayGroup_assnlist.arrayGroup_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->arrayGroup_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->arrayGroup_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ArrayGroup (pctxt, ((ArrayGroup*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ArrayGroup_assnlist (OSCTXT* pctxt, ArrayGroup_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode arrayGroup_list */

   if (!(pvalue->arrayGroup_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ArrayGroup_assnlist.arrayGroup_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->arrayGroup_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->arrayGroup_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ArrayGroup (pctxt, ((ArrayGroup*)pnode->data)
         , OSUTF8("ArrayGroup"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DefectType_assn                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DefectType_assn (OSCTXT* pctxt,
   DefectType_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode ontologyEntry */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_OntologyEntry (pctxt, &pvalue->ontologyEntry, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DefectType_assn (OSCTXT* pctxt, DefectType_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry */

   stat = XmlEnc_OntologyEntry (pctxt, &pvalue->ontologyEntry
      , OSUTF8("OntologyEntry"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ZoneDefect                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ZoneDefect (OSCTXT* pctxt,
   ZoneDefect *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode zone_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_Zone_assnref (pctxt, &pvalue->zone_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode positionDelta_assn */

   if (pvalue->m.positionDelta_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_PositionDelta_assn (pctxt, &pvalue->positionDelta_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode defectType_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_DefectType_assn (pctxt, &pvalue->defectType_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ZoneDefect (OSCTXT* pctxt, ZoneDefect* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode defectType_assn */

   stat = XmlEnc_DefectType_assn (pctxt, &pvalue->defectType_assn
      , OSUTF8("DefectType_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode positionDelta_assn */

   if (pvalue->m.positionDelta_assnPresent) {
      stat = XmlEnc_PositionDelta_assn (pctxt, &pvalue->positionDelta_assn
         , OSUTF8("PositionDelta_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode zone_assnref */

   stat = XmlEnc_Zone_assnref (pctxt, &pvalue->zone_assnref
      , OSUTF8("Zone_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Adjustments_assnlist                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Adjustments_assnlist (OSCTXT* pctxt,
   Adjustments_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode zoneDefect_list */

   if (!(pvalue->zoneDefect_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Adjustments_assnlist.zoneDefect_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->zoneDefect_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->zoneDefect_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ZoneDefect (pctxt, ((ZoneDefect*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Adjustments_assnlist (OSCTXT* pctxt, Adjustments_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode zoneDefect_list */

   if (!(pvalue->zoneDefect_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Adjustments_assnlist.zoneDefect_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->zoneDefect_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->zoneDefect_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ZoneDefect (pctxt, ((ZoneDefect*)pnode->data)
         , OSUTF8("ZoneDefect"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeatureDefect                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FeatureDefect (OSCTXT* pctxt,
   FeatureDefect *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode feature_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_Feature_assnref (pctxt, &pvalue->feature_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode positionDelta_assn */

   if (pvalue->m.positionDelta_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_PositionDelta_assn (pctxt, &pvalue->positionDelta_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode defectType_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_DefectType_assn (pctxt, &pvalue->defectType_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FeatureDefect (OSCTXT* pctxt, FeatureDefect* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode defectType_assn */

   stat = XmlEnc_DefectType_assn (pctxt, &pvalue->defectType_assn
      , OSUTF8("DefectType_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode positionDelta_assn */

   if (pvalue->m.positionDelta_assnPresent) {
      stat = XmlEnc_PositionDelta_assn (pctxt, &pvalue->positionDelta_assn
         , OSUTF8("PositionDelta_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode feature_assnref */

   stat = XmlEnc_Feature_assnref (pctxt, &pvalue->feature_assnref
      , OSUTF8("Feature_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeatureDefects_assnlist                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FeatureDefects_assnlist (OSCTXT* pctxt,
   FeatureDefects_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode featureDefect_list */

   if (!(pvalue->featureDefect_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FeatureDefects_assnlist.featureDefect_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->featureDefect_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->featureDefect_list.tail;
   while (0 != pnode2) {
      ll = asn1E_FeatureDefect (pctxt, ((FeatureDefect*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FeatureDefects_assnlist (OSCTXT* pctxt, 
   FeatureDefects_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode featureDefect_list */

   if (!(pvalue->featureDefect_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FeatureDefects_assnlist.featureDefect_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->featureDefect_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->featureDefect_list.head;
   while (0 != pnode) {
      stat = XmlEnc_FeatureDefect (pctxt, ((FeatureDefect*)pnode->data)
         , OSUTF8("FeatureDefect"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ArrayManufactureDeviation                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ArrayManufactureDeviation (OSCTXT* pctxt,
   ArrayManufactureDeviation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode featureDefects_assnlist */

   if (pvalue->m.featureDefects_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_FeatureDefects_assnlist (pctxt, &pvalue->featureDefects_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode adjustments_assnlist */

   if (pvalue->m.adjustments_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Adjustments_assnlist (pctxt, &pvalue->adjustments_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ArrayManufactureDeviation (OSCTXT* pctxt, 
   ArrayManufactureDeviation* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode adjustments_assnlist */

   if (pvalue->m.adjustments_assnlistPresent) {
      stat = XmlEnc_Adjustments_assnlist (pctxt, &pvalue->adjustments_assnlist
         , OSUTF8("Adjustments_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode featureDefects_assnlist */

   if (pvalue->m.featureDefects_assnlistPresent) {
      stat = XmlEnc_FeatureDefects_assnlist (pctxt, &pvalue->
         featureDefects_assnlist
         , OSUTF8("FeatureDefects_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ArrayManufactureDeviations_assnlist                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ArrayManufactureDeviations_assnlist (OSCTXT* pctxt,
   ArrayManufactureDeviations_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode arrayManufactureDeviation_list */

   if (!(pvalue->arrayManufactureDeviation_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ArrayManufactureDeviations_assnlist.arrayManufactureDeviation_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->arrayManufactureDeviation_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->arrayManufactureDeviation_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ArrayManufactureDeviation (pctxt, ((ArrayManufactureDeviation*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ArrayManufactureDeviations_assnlist (OSCTXT* pctxt, 
   ArrayManufactureDeviations_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode arrayManufactureDeviation_list */

   if (!(pvalue->arrayManufactureDeviation_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ArrayManufactureDeviations_assnlist.arrayManufactureDeviation_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->arrayManufactureDeviation_list.
         count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->arrayManufactureDeviation_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ArrayManufactureDeviation (pctxt, 
         ((ArrayManufactureDeviation*)pnode->data)
         , OSUTF8("ArrayManufactureDeviation"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Array                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Array (OSCTXT* pctxt,
   Array *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode arrayManufactureDeviations_assnlist */

   if (pvalue->m.arrayManufactureDeviations_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10,
         asn1E_ArrayManufactureDeviations_assnlist (pctxt, &pvalue->arrayManufactureDeviations_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode arrayGroup_assnref */

   if (pvalue->m.arrayGroup_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9,
         asn1E_ArrayGroup_assnref (pctxt, &pvalue->arrayGroup_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode information_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
      asn1E_Information_assnref (pctxt, &pvalue->information_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode arrayDesign_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
      asn1E_ArrayDesign_assnref (pctxt, &pvalue->arrayDesign_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode originRelativeTo */

   if (pvalue->m.originRelativeToPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         xe_utf8str (pctxt, pvalue->originRelativeTo, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode arrayYOrigin */

   if (pvalue->m.arrayYOriginPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->arrayYOrigin, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode arrayXOrigin */

   if (pvalue->m.arrayXOriginPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->arrayXOrigin, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode arrayIdentifier */

   if (pvalue->m.arrayIdentifierPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->arrayIdentifier, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Array (OSCTXT* pctxt, Array* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.arrayIdentifierPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" arrayIdentifier=\""), 18);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->arrayIdentifier, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.arrayXOriginPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" arrayXOrigin=\""), 15);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->arrayXOrigin, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.arrayYOriginPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" arrayYOrigin=\""), 15);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->arrayYOrigin, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.originRelativeToPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" originRelativeTo=\""), 19);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->originRelativeTo, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode arrayDesign_assnref */

   stat = XmlEnc_ArrayDesign_assnref (pctxt, &pvalue->arrayDesign_assnref
      , OSUTF8("ArrayDesign_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode information_assnref */

   stat = XmlEnc_Information_assnref (pctxt, &pvalue->information_assnref
      , OSUTF8("Information_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode arrayGroup_assnref */

   if (pvalue->m.arrayGroup_assnrefPresent) {
      stat = XmlEnc_ArrayGroup_assnref (pctxt, &pvalue->arrayGroup_assnref
         , OSUTF8("ArrayGroup_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode arrayManufactureDeviations_assnlist */

   if (pvalue->m.arrayManufactureDeviations_assnlistPresent) {
      stat = XmlEnc_ArrayManufactureDeviations_assnlist (pctxt, &pvalue->
         arrayManufactureDeviations_assnlist
         , OSUTF8("ArrayManufactureDeviations_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Array_assnlist                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Array_assnlist (OSCTXT* pctxt,
   Array_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode array_list */

   if (!(pvalue->array_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Array_assnlist.array_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->array_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->array_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Array (pctxt, ((Array*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Array_assnlist (OSCTXT* pctxt, Array_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode array_list */

   if (!(pvalue->array_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Array_assnlist.array_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->array_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->array_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Array (pctxt, ((Array*)pnode->data)
         , OSUTF8("Array"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ArrayManufacturers_assnreflist                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ArrayManufacturers_assnreflist (OSCTXT* pctxt,
   ArrayManufacturers_assnreflist *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ArrayManufacturers_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_Contact_ref_1 (pctxt, ((Contact_ref_1*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ArrayManufacturers_assnreflist (OSCTXT* pctxt, 
   ArrayManufacturers_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ArrayManufacturers_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_Contact_ref_1 (pctxt, ((Contact_ref_1*)pnode->data)
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IdentifierLIMS_assn                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_IdentifierLIMS_assn (OSCTXT* pctxt,
   IdentifierLIMS_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode databaseEntry */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_DatabaseEntry (pctxt, &pvalue->databaseEntry, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_IdentifierLIMS_assn (OSCTXT* pctxt, IdentifierLIMS_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode databaseEntry */

   stat = XmlEnc_DatabaseEntry (pctxt, &pvalue->databaseEntry
      , OSUTF8("DatabaseEntry"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ManufactureLIMS                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ManufactureLIMS (OSCTXT* pctxt,
   ManufactureLIMS *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode identifierLIMS_assn */

   if (pvalue->m.identifierLIMS_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_IdentifierLIMS_assn (pctxt, &pvalue->identifierLIMS_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioMaterial_assnref */

   if (pvalue->m.bioMaterial_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_BioMaterial_assnref (pctxt, &pvalue->bioMaterial_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode feature_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_Feature_assnref (pctxt, &pvalue->feature_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Describable_content (pctxt, &pvalue->describable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode quality */

   if (pvalue->m.qualityPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->quality, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ManufactureLIMS (OSCTXT* pctxt, ManufactureLIMS* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.qualityPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" quality=\""), 10);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->quality, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      stat = XmlEnc_Describable_content (pctxt, &pvalue->describable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode feature_assnref */

   stat = XmlEnc_Feature_assnref (pctxt, &pvalue->feature_assnref
      , OSUTF8("Feature_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode bioMaterial_assnref */

   if (pvalue->m.bioMaterial_assnrefPresent) {
      stat = XmlEnc_BioMaterial_assnref (pctxt, &pvalue->bioMaterial_assnref
         , OSUTF8("BioMaterial_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode identifierLIMS_assn */

   if (pvalue->m.identifierLIMS_assnPresent) {
      stat = XmlEnc_IdentifierLIMS_assn (pctxt, &pvalue->identifierLIMS_assn
         , OSUTF8("IdentifierLIMS_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ManufactureLIMSBiomaterial                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ManufactureLIMSBiomaterial (OSCTXT* pctxt,
   ManufactureLIMSBiomaterial *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode identifierLIMS_assn */

   if (pvalue->m.identifierLIMS_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_IdentifierLIMS_assn (pctxt, &pvalue->identifierLIMS_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioMaterial_assnref */

   if (pvalue->m.bioMaterial_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_BioMaterial_assnref (pctxt, &pvalue->bioMaterial_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode feature_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_Feature_assnref (pctxt, &pvalue->feature_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Describable_content (pctxt, &pvalue->describable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode quality */

   if (pvalue->m.qualityPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_utf8str (pctxt, pvalue->quality, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioMaterialPlateRow */

   if (pvalue->m.bioMaterialPlateRowPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->bioMaterialPlateRow, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioMaterialPlateIdentifier */

   if (pvalue->m.bioMaterialPlateIdentifierPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->bioMaterialPlateIdentifier, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioMaterialPlateCol */

   if (pvalue->m.bioMaterialPlateColPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->bioMaterialPlateCol, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ManufactureLIMSBiomaterial (OSCTXT* pctxt, 
   ManufactureLIMSBiomaterial* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.bioMaterialPlateColPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" bioMaterialPlateCol=\""), 22);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->bioMaterialPlateCol, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.bioMaterialPlateIdentifierPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" bioMaterialPlateIdentifier=\""), 29);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->bioMaterialPlateIdentifier
         , 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.bioMaterialPlateRowPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" bioMaterialPlateRow=\""), 22);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->bioMaterialPlateRow, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.qualityPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" quality=\""), 10);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->quality, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      stat = XmlEnc_Describable_content (pctxt, &pvalue->describable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode feature_assnref */

   stat = XmlEnc_Feature_assnref (pctxt, &pvalue->feature_assnref
      , OSUTF8("Feature_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode bioMaterial_assnref */

   if (pvalue->m.bioMaterial_assnrefPresent) {
      stat = XmlEnc_BioMaterial_assnref (pctxt, &pvalue->bioMaterial_assnref
         , OSUTF8("BioMaterial_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode identifierLIMS_assn */

   if (pvalue->m.identifierLIMS_assnPresent) {
      stat = XmlEnc_IdentifierLIMS_assn (pctxt, &pvalue->identifierLIMS_assn
         , OSUTF8("IdentifierLIMS_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ManufactureLIMS_classes_group                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ManufactureLIMS_classes_group (OSCTXT* pctxt,
   ManufactureLIMS_classes_group *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_ManufactureLIMS (pctxt, pvalue->u.manufactureLIMS, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_ManufactureLIMSBiomaterial (pctxt, pvalue->u.manufactureLIMSBiomaterial, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_ManufactureLIMS_classes_group (OSCTXT* pctxt, 
   ManufactureLIMS_classes_group* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode manufactureLIMS */

         stat = XmlEnc_ManufactureLIMS (pctxt, pvalue->u.manufactureLIMS
            , OSUTF8("ManufactureLIMS"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode manufactureLIMSBiomaterial */

         stat = XmlEnc_ManufactureLIMSBiomaterial (pctxt, pvalue->
            u.manufactureLIMSBiomaterial
            , OSUTF8("ManufactureLIMSBiomaterial"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeatureLIMSs_assnlist                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FeatureLIMSs_assnlist (OSCTXT* pctxt,
   FeatureLIMSs_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode manufactureLIMS_classes_list */

   if (!(pvalue->manufactureLIMS_classes_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FeatureLIMSs_assnlist.manufactureLIMS_classes_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->manufactureLIMS_classes_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->manufactureLIMS_classes_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ManufactureLIMS_classes_group (pctxt, ((ManufactureLIMS_classes_group*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FeatureLIMSs_assnlist (OSCTXT* pctxt, 
   FeatureLIMSs_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode manufactureLIMS_classes_list */

   if (!(pvalue->manufactureLIMS_classes_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FeatureLIMSs_assnlist.manufactureLIMS_classes_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->manufactureLIMS_classes_list.count
         );
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->manufactureLIMS_classes_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ManufactureLIMS_classes_group (pctxt, 
         ((ManufactureLIMS_classes_group*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ArrayManufacture                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ArrayManufacture (OSCTXT* pctxt,
   ArrayManufacture *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode protocolApplications_assnlist */

   if (pvalue->m.protocolApplications_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9,
         asn1E_ProtocolApplications_assnlist (pctxt, &pvalue->protocolApplications_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode featureLIMSs_assnlist */

   if (pvalue->m.featureLIMSs_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_FeatureLIMSs_assnlist (pctxt, &pvalue->featureLIMSs_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode qualityControlStatistics_assnlist */

   if (pvalue->m.qualityControlStatistics_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_QualityControlStatistics_assnlist (pctxt, &pvalue->qualityControlStatistics_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode arrayManufacturers_assnreflist */

   if (pvalue->m.arrayManufacturers_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_ArrayManufacturers_assnreflist (pctxt, &pvalue->arrayManufacturers_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode arrays_assnreflist */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_Arrays_assnreflist (pctxt, &pvalue->arrays_assnreflist, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode tolerance */

   if (pvalue->m.tolerancePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_utf8str (pctxt, pvalue->tolerance, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode manufacturingDate */

   if (pvalue->m.manufacturingDatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->manufacturingDate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ArrayManufacture (OSCTXT* pctxt, ArrayManufacture* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.manufacturingDatePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" manufacturingDate=\""), 20);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->manufacturingDate, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.tolerancePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" tolerance=\""), 12);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->tolerance, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode arrays_assnreflist */

   stat = XmlEnc_Arrays_assnreflist (pctxt, &pvalue->arrays_assnreflist
      , OSUTF8("Arrays_assnreflist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode arrayManufacturers_assnreflist */

   if (pvalue->m.arrayManufacturers_assnreflistPresent) {
      stat = XmlEnc_ArrayManufacturers_assnreflist (pctxt, &pvalue->
         arrayManufacturers_assnreflist
         , OSUTF8("ArrayManufacturers_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode qualityControlStatistics_assnlist */

   if (pvalue->m.qualityControlStatistics_assnlistPresent) {
      stat = XmlEnc_QualityControlStatistics_assnlist (pctxt, &pvalue->
         qualityControlStatistics_assnlist
         , OSUTF8("QualityControlStatistics_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode featureLIMSs_assnlist */

   if (pvalue->m.featureLIMSs_assnlistPresent) {
      stat = XmlEnc_FeatureLIMSs_assnlist (pctxt, &pvalue->
         featureLIMSs_assnlist, OSUTF8("FeatureLIMSs_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode protocolApplications_assnlist */

   if (pvalue->m.protocolApplications_assnlistPresent) {
      stat = XmlEnc_ProtocolApplications_assnlist (pctxt, &pvalue->
         protocolApplications_assnlist
         , OSUTF8("ProtocolApplications_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ArrayManufacture_assnlist                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ArrayManufacture_assnlist (OSCTXT* pctxt,
   ArrayManufacture_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode arrayManufacture_list */

   if (!(pvalue->arrayManufacture_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ArrayManufacture_assnlist.arrayManufacture_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->arrayManufacture_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->arrayManufacture_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ArrayManufacture (pctxt, ((ArrayManufacture*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ArrayManufacture_assnlist (OSCTXT* pctxt, 
   ArrayManufacture_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode arrayManufacture_list */

   if (!(pvalue->arrayManufacture_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ArrayManufacture_assnlist.arrayManufacture_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->arrayManufacture_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->arrayManufacture_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ArrayManufacture (pctxt, ((ArrayManufacture*)pnode->data)
         , OSUTF8("ArrayManufacture"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Array_package                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Array_package (OSCTXT* pctxt,
   Array_package *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode arrayManufacture_assnlist */

   if (pvalue->m.arrayManufacture_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_ArrayManufacture_assnlist (pctxt, &pvalue->arrayManufacture_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode array_assnlist */

   if (pvalue->m.array_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Array_assnlist (pctxt, &pvalue->array_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode arrayGroup_assnlist */

   if (pvalue->m.arrayGroup_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ArrayGroup_assnlist (pctxt, &pvalue->arrayGroup_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Array_package (OSCTXT* pctxt, Array_package* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode arrayGroup_assnlist */

   if (pvalue->m.arrayGroup_assnlistPresent) {
      stat = XmlEnc_ArrayGroup_assnlist (pctxt, &pvalue->arrayGroup_assnlist
         , OSUTF8("ArrayGroup_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode array_assnlist */

   if (pvalue->m.array_assnlistPresent) {
      stat = XmlEnc_Array_assnlist (pctxt, &pvalue->array_assnlist
         , OSUTF8("Array_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode arrayManufacture_assnlist */

   if (pvalue->m.arrayManufacture_assnlistPresent) {
      stat = XmlEnc_ArrayManufacture_assnlist (pctxt, &pvalue->
         arrayManufacture_assnlist
         , OSUTF8("ArrayManufacture_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Channel                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Channel (OSCTXT* pctxt,
   Channel *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode labels_assnreflist */

   if (pvalue->m.labels_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Labels_assnreflist (pctxt, &pvalue->labels_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Channel (OSCTXT* pctxt, Channel* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode labels_assnreflist */

   if (pvalue->m.labels_assnreflistPresent) {
      stat = XmlEnc_Labels_assnreflist (pctxt, &pvalue->labels_assnreflist
         , OSUTF8("Labels_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Channel_assnlist                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Channel_assnlist (OSCTXT* pctxt,
   Channel_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode channel_list */

   if (!(pvalue->channel_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Channel_assnlist.channel_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->channel_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->channel_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Channel (pctxt, ((Channel*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Channel_assnlist (OSCTXT* pctxt, Channel_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode channel_list */

   if (!(pvalue->channel_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Channel_assnlist.channel_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->channel_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->channel_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Channel (pctxt, ((Channel*)pnode->data)
         , OSUTF8("Channel"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Channel_ref                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Channel_ref (OSCTXT* pctxt,
   Channel_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Channel_ref (OSCTXT* pctxt, Channel_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Channels_assnreflist                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Channels_assnreflist (OSCTXT* pctxt,
   Channels_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode channel_ref_list */

   if (!(pvalue->channel_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Channels_assnreflist.channel_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->channel_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->channel_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Channel_ref (pctxt, ((Channel_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Channels_assnreflist (OSCTXT* pctxt, Channels_assnreflist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode channel_ref_list */

   if (!(pvalue->channel_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Channels_assnreflist.channel_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->channel_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->channel_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Channel_ref (pctxt, ((Channel_ref*)pnode->data)
         , OSUTF8("Channel_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FactorValue_ref                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FactorValue_ref (OSCTXT* pctxt,
   FactorValue_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FactorValue_ref (OSCTXT* pctxt, FactorValue_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayFactorValues_assnreflist                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayFactorValues_assnreflist (OSCTXT* pctxt,
   BioAssayFactorValues_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode factorValue_ref_list */

   if (!(pvalue->factorValue_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioAssayFactorValues_assnreflist.factorValue_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->factorValue_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->factorValue_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_FactorValue_ref (pctxt, ((FactorValue_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayFactorValues_assnreflist (OSCTXT* pctxt, 
   BioAssayFactorValues_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode factorValue_ref_list */

   if (!(pvalue->factorValue_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioAssayFactorValues_assnreflist.factorValue_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->factorValue_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->factorValue_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_FactorValue_ref (pctxt, ((FactorValue_ref*)pnode->data)
         , OSUTF8("FactorValue_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssay_content                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssay_content (OSCTXT* pctxt,
   BioAssay_content *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode bioAssayFactorValues_assnreflist */

   if (pvalue->m.bioAssayFactorValues_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_BioAssayFactorValues_assnreflist (pctxt, &pvalue->bioAssayFactorValues_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode channels_assnreflist */

   if (pvalue->m.channels_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Channels_assnreflist (pctxt, &pvalue->channels_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssay_content (OSCTXT* pctxt, BioAssay_content* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode channels_assnreflist */

   if (pvalue->m.channels_assnreflistPresent) {
      stat = XmlEnc_Channels_assnreflist (pctxt, &pvalue->channels_assnreflist
         , OSUTF8("Channels_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioAssayFactorValues_assnreflist */

   if (pvalue->m.bioAssayFactorValues_assnreflistPresent) {
      stat = XmlEnc_BioAssayFactorValues_assnreflist (pctxt, &pvalue->
         bioAssayFactorValues_assnreflist
         , OSUTF8("BioAssayFactorValues_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DerivedBioAssayData_assnreflist                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DerivedBioAssayData_assnreflist (OSCTXT* pctxt,
   DerivedBioAssayData_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode derivedBioAssayData_ref_list */

   if (!(pvalue->derivedBioAssayData_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DerivedBioAssayData_assnreflist.derivedBioAssayData_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->derivedBioAssayData_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->derivedBioAssayData_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_DerivedBioAssayData_ref (pctxt, ((DerivedBioAssayData_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DerivedBioAssayData_assnreflist (OSCTXT* pctxt, 
   DerivedBioAssayData_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode derivedBioAssayData_ref_list */

   if (!(pvalue->derivedBioAssayData_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DerivedBioAssayData_assnreflist.derivedBioAssayData_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->derivedBioAssayData_ref_list.count
         );
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->derivedBioAssayData_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_DerivedBioAssayData_ref (pctxt, 
         ((DerivedBioAssayData_ref*)pnode->data)
         , OSUTF8("DerivedBioAssayData_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DerivedBioAssayMap_assnreflist                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DerivedBioAssayMap_assnreflist (OSCTXT* pctxt,
   DerivedBioAssayMap_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode bioAssayMap_ref_list */

   if (!(pvalue->bioAssayMap_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DerivedBioAssayMap_assnreflist.bioAssayMap_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioAssayMap_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->bioAssayMap_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_BioAssayMap_ref (pctxt, ((BioAssayMap_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DerivedBioAssayMap_assnreflist (OSCTXT* pctxt, 
   DerivedBioAssayMap_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bioAssayMap_ref_list */

   if (!(pvalue->bioAssayMap_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DerivedBioAssayMap_assnreflist.bioAssayMap_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioAssayMap_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->bioAssayMap_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_BioAssayMap_ref (pctxt, ((BioAssayMap_ref*)pnode->data)
         , OSUTF8("BioAssayMap_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DerivedBioAssay                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DerivedBioAssay (OSCTXT* pctxt,
   DerivedBioAssay *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode derivedBioAssayMap_assnreflist */

   if (pvalue->m.derivedBioAssayMap_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_DerivedBioAssayMap_assnreflist (pctxt, &pvalue->derivedBioAssayMap_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode derivedBioAssayData_assnreflist */

   if (pvalue->m.derivedBioAssayData_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_DerivedBioAssayData_assnreflist (pctxt, &pvalue->derivedBioAssayData_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode type_assn */

   if (pvalue->m.type_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Type_assn (pctxt, &pvalue->type_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioAssay_content */

   if (pvalue->m.bioAssay_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_BioAssay_content (pctxt, &pvalue->bioAssay_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DerivedBioAssay (OSCTXT* pctxt, DerivedBioAssay* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode bioAssay_content */

   if (pvalue->m.bioAssay_contentPresent) {
      stat = XmlEnc_BioAssay_content (pctxt, &pvalue->bioAssay_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode type_assn */

   if (pvalue->m.type_assnPresent) {
      stat = XmlEnc_Type_assn (pctxt, &pvalue->type_assn
         , OSUTF8("Type_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode derivedBioAssayData_assnreflist */

   if (pvalue->m.derivedBioAssayData_assnreflistPresent) {
      stat = XmlEnc_DerivedBioAssayData_assnreflist (pctxt, &pvalue->
         derivedBioAssayData_assnreflist
         , OSUTF8("DerivedBioAssayData_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode derivedBioAssayMap_assnreflist */

   if (pvalue->m.derivedBioAssayMap_assnreflistPresent) {
      stat = XmlEnc_DerivedBioAssayMap_assnreflist (pctxt, &pvalue->
         derivedBioAssayMap_assnreflist
         , OSUTF8("DerivedBioAssayMap_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasuredBioAssayData_assnreflist                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MeasuredBioAssayData_assnreflist (OSCTXT* pctxt,
   MeasuredBioAssayData_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode measuredBioAssayData_ref_list */

   if (!(pvalue->measuredBioAssayData_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "MeasuredBioAssayData_assnreflist.measuredBioAssayData_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->measuredBioAssayData_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->measuredBioAssayData_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_MeasuredBioAssayData_ref (pctxt, ((MeasuredBioAssayData_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MeasuredBioAssayData_assnreflist (OSCTXT* pctxt, 
   MeasuredBioAssayData_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode measuredBioAssayData_ref_list */

   if (!(pvalue->measuredBioAssayData_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "MeasuredBioAssayData_assnreflist.measuredBioAssayData_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->measuredBioAssayData_ref_list.count
         );
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->measuredBioAssayData_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_MeasuredBioAssayData_ref (pctxt, 
         ((MeasuredBioAssayData_ref*)pnode->data)
         , OSUTF8("MeasuredBioAssayData_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasuredBioAssay                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MeasuredBioAssay (OSCTXT* pctxt,
   MeasuredBioAssay *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode measuredBioAssayData_assnreflist */

   if (pvalue->m.measuredBioAssayData_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_MeasuredBioAssayData_assnreflist (pctxt, &pvalue->measuredBioAssayData_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode featureExtraction_assn */

   if (pvalue->m.featureExtraction_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_FeatureExtraction_assn (pctxt, &pvalue->featureExtraction_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioAssay_content */

   if (pvalue->m.bioAssay_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_BioAssay_content (pctxt, &pvalue->bioAssay_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MeasuredBioAssay (OSCTXT* pctxt, MeasuredBioAssay* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode bioAssay_content */

   if (pvalue->m.bioAssay_contentPresent) {
      stat = XmlEnc_BioAssay_content (pctxt, &pvalue->bioAssay_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode featureExtraction_assn */

   if (pvalue->m.featureExtraction_assnPresent) {
      stat = XmlEnc_FeatureExtraction_assn (pctxt, &pvalue->
         featureExtraction_assn, OSUTF8("FeatureExtraction_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode measuredBioAssayData_assnreflist */

   if (pvalue->m.measuredBioAssayData_assnreflistPresent) {
      stat = XmlEnc_MeasuredBioAssayData_assnreflist (pctxt, &pvalue->
         measuredBioAssayData_assnreflist
         , OSUTF8("MeasuredBioAssayData_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Format_assn                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Format_assn (OSCTXT* pctxt,
   Format_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode ontologyEntry */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_OntologyEntry (pctxt, &pvalue->ontologyEntry, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Format_assn (OSCTXT* pctxt, Format_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry */

   stat = XmlEnc_OntologyEntry (pctxt, &pvalue->ontologyEntry
      , OSUTF8("OntologyEntry"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Image                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Image (OSCTXT* pctxt,
   Image *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode format_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_Format_assn (pctxt, &pvalue->format_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode channels_assnreflist */

   if (pvalue->m.channels_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Channels_assnreflist (pctxt, &pvalue->channels_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode uRI */

   if (pvalue->m.uRIPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->uRI, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Image (OSCTXT* pctxt, Image* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.uRIPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" URI=\""), 6);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->uRI, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode channels_assnreflist */

   if (pvalue->m.channels_assnreflistPresent) {
      stat = XmlEnc_Channels_assnreflist (pctxt, &pvalue->channels_assnreflist
         , OSUTF8("Channels_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode format_assn */

   stat = XmlEnc_Format_assn (pctxt, &pvalue->format_assn
      , OSUTF8("Format_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PhysicalBioAssayData_assnlist                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PhysicalBioAssayData_assnlist (OSCTXT* pctxt,
   PhysicalBioAssayData_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode image_list */

   if (!(pvalue->image_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "PhysicalBioAssayData_assnlist.image_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->image_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->image_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Image (pctxt, ((Image*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PhysicalBioAssayData_assnlist (OSCTXT* pctxt, 
   PhysicalBioAssayData_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode image_list */

   if (!(pvalue->image_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "PhysicalBioAssayData_assnlist.image_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->image_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->image_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Image (pctxt, ((Image*)pnode->data)
         , OSUTF8("Image"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Target_assnref                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Target_assnref (OSCTXT* pctxt,
   Target_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode physicalBioAssay_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_PhysicalBioAssay_ref (pctxt, &pvalue->physicalBioAssay_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Target_assnref (OSCTXT* pctxt, Target_assnref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode physicalBioAssay_ref */

   stat = XmlEnc_PhysicalBioAssay_ref (pctxt, &pvalue->physicalBioAssay_ref
      , OSUTF8("PhysicalBioAssay_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayTreatment                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayTreatment (OSCTXT* pctxt,
   BioAssayTreatment *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode target_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_Target_assnref (pctxt, &pvalue->target_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode bioEvent_content */

   if (pvalue->m.bioEvent_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_BioEvent_content (pctxt, &pvalue->bioEvent_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayTreatment (OSCTXT* pctxt, BioAssayTreatment* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode bioEvent_content */

   if (pvalue->m.bioEvent_contentPresent) {
      stat = XmlEnc_BioEvent_content (pctxt, &pvalue->bioEvent_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode target_assnref */

   stat = XmlEnc_Target_assnref (pctxt, &pvalue->target_assnref
      , OSUTF8("Target_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Image_ref                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Image_ref (OSCTXT* pctxt,
   Image_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Image_ref (OSCTXT* pctxt, Image_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Images_assnreflist                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Images_assnreflist (OSCTXT* pctxt,
   Images_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode image_ref_list */

   if (!(pvalue->image_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Images_assnreflist.image_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->image_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->image_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Image_ref (pctxt, ((Image_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Images_assnreflist (OSCTXT* pctxt, Images_assnreflist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode image_ref_list */

   if (!(pvalue->image_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Images_assnreflist.image_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->image_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->image_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Image_ref (pctxt, ((Image_ref*)pnode->data)
         , OSUTF8("Image_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ImageAcquisition                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ImageAcquisition (OSCTXT* pctxt,
   ImageAcquisition *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode images_assnreflist */

   if (pvalue->m.images_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Images_assnreflist (pctxt, &pvalue->images_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode target_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_Target_assnref (pctxt, &pvalue->target_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode bioEvent_content */

   if (pvalue->m.bioEvent_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_BioEvent_content (pctxt, &pvalue->bioEvent_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ImageAcquisition (OSCTXT* pctxt, ImageAcquisition* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode bioEvent_content */

   if (pvalue->m.bioEvent_contentPresent) {
      stat = XmlEnc_BioEvent_content (pctxt, &pvalue->bioEvent_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode target_assnref */

   stat = XmlEnc_Target_assnref (pctxt, &pvalue->target_assnref
      , OSUTF8("Target_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode images_assnreflist */

   if (pvalue->m.images_assnreflistPresent) {
      stat = XmlEnc_Images_assnreflist (pctxt, &pvalue->images_assnreflist
         , OSUTF8("Images_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayTreatment_classes_group                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayTreatment_classes_group (OSCTXT* pctxt,
   BioAssayTreatment_classes_group *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_BioAssayTreatment (pctxt, pvalue->u.bioAssayTreatment, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_ImageAcquisition (pctxt, pvalue->u.imageAcquisition, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_BioAssayTreatment_classes_group (OSCTXT* pctxt, 
   BioAssayTreatment_classes_group* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode bioAssayTreatment */

         stat = XmlEnc_BioAssayTreatment (pctxt, pvalue->u.bioAssayTreatment
            , OSUTF8("BioAssayTreatment"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode imageAcquisition */

         stat = XmlEnc_ImageAcquisition (pctxt, pvalue->u.imageAcquisition
            , OSUTF8("ImageAcquisition"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayTreatments_assnlist                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayTreatments_assnlist (OSCTXT* pctxt,
   BioAssayTreatments_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode bioAssayTreatment_classes_list */

   if (!(pvalue->bioAssayTreatment_classes_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioAssayTreatments_assnlist.bioAssayTreatment_classes_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioAssayTreatment_classes_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->bioAssayTreatment_classes_list.tail;
   while (0 != pnode2) {
      ll = asn1E_BioAssayTreatment_classes_group (pctxt, ((BioAssayTreatment_classes_group*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayTreatments_assnlist (OSCTXT* pctxt, 
   BioAssayTreatments_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bioAssayTreatment_classes_list */

   if (!(pvalue->bioAssayTreatment_classes_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioAssayTreatments_assnlist.bioAssayTreatment_classes_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioAssayTreatment_classes_list.
         count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->bioAssayTreatment_classes_list.head;
   while (0 != pnode) {
      stat = XmlEnc_BioAssayTreatment_classes_group (pctxt, 
         ((BioAssayTreatment_classes_group*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PhysicalBioAssay                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PhysicalBioAssay (OSCTXT* pctxt,
   PhysicalBioAssay *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode bioAssayTreatments_assnlist */

   if (pvalue->m.bioAssayTreatments_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_BioAssayTreatments_assnlist (pctxt, &pvalue->bioAssayTreatments_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioAssayCreation_assn */

   if (pvalue->m.bioAssayCreation_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_BioAssayCreation_assn (pctxt, &pvalue->bioAssayCreation_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode physicalBioAssayData_assnlist */

   if (pvalue->m.physicalBioAssayData_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_PhysicalBioAssayData_assnlist (pctxt, &pvalue->physicalBioAssayData_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioAssay_content */

   if (pvalue->m.bioAssay_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_BioAssay_content (pctxt, &pvalue->bioAssay_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PhysicalBioAssay (OSCTXT* pctxt, PhysicalBioAssay* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode bioAssay_content */

   if (pvalue->m.bioAssay_contentPresent) {
      stat = XmlEnc_BioAssay_content (pctxt, &pvalue->bioAssay_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode physicalBioAssayData_assnlist */

   if (pvalue->m.physicalBioAssayData_assnlistPresent) {
      stat = XmlEnc_PhysicalBioAssayData_assnlist (pctxt, &pvalue->
         physicalBioAssayData_assnlist
         , OSUTF8("PhysicalBioAssayData_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioAssayCreation_assn */

   if (pvalue->m.bioAssayCreation_assnPresent) {
      stat = XmlEnc_BioAssayCreation_assn (pctxt, &pvalue->
         bioAssayCreation_assn, OSUTF8("BioAssayCreation_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioAssayTreatments_assnlist */

   if (pvalue->m.bioAssayTreatments_assnlistPresent) {
      stat = XmlEnc_BioAssayTreatments_assnlist (pctxt, &pvalue->
         bioAssayTreatments_assnlist
         , OSUTF8("BioAssayTreatments_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssay_classes_group                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssay_classes_group (OSCTXT* pctxt,
   BioAssay_classes_group *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_DerivedBioAssay (pctxt, pvalue->u.derivedBioAssay, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_MeasuredBioAssay (pctxt, pvalue->u.measuredBioAssay, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_PhysicalBioAssay (pctxt, pvalue->u.physicalBioAssay, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_BioAssay_classes_group (OSCTXT* pctxt, 
   BioAssay_classes_group* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode derivedBioAssay */

         stat = XmlEnc_DerivedBioAssay (pctxt, pvalue->u.derivedBioAssay
            , OSUTF8("DerivedBioAssay"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode measuredBioAssay */

         stat = XmlEnc_MeasuredBioAssay (pctxt, pvalue->u.measuredBioAssay
            , OSUTF8("MeasuredBioAssay"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode physicalBioAssay */

         stat = XmlEnc_PhysicalBioAssay (pctxt, pvalue->u.physicalBioAssay
            , OSUTF8("PhysicalBioAssay"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssay_assnlist                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssay_assnlist (OSCTXT* pctxt,
   BioAssay_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode bioAssay_classes_list */

   if (!(pvalue->bioAssay_classes_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioAssay_assnlist.bioAssay_classes_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioAssay_classes_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->bioAssay_classes_list.tail;
   while (0 != pnode2) {
      ll = asn1E_BioAssay_classes_group (pctxt, ((BioAssay_classes_group*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssay_assnlist (OSCTXT* pctxt, BioAssay_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bioAssay_classes_list */

   if (!(pvalue->bioAssay_classes_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioAssay_assnlist.bioAssay_classes_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioAssay_classes_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->bioAssay_classes_list.head;
   while (0 != pnode) {
      stat = XmlEnc_BioAssay_classes_group (pctxt, 
         ((BioAssay_classes_group*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssay_package                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssay_package (OSCTXT* pctxt,
   BioAssay_package *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode bioAssay_assnlist */

   if (pvalue->m.bioAssay_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_BioAssay_assnlist (pctxt, &pvalue->bioAssay_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode channel_assnlist */

   if (pvalue->m.channel_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Channel_assnlist (pctxt, &pvalue->channel_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssay_package (OSCTXT* pctxt, BioAssay_package* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode channel_assnlist */

   if (pvalue->m.channel_assnlistPresent) {
      stat = XmlEnc_Channel_assnlist (pctxt, &pvalue->channel_assnlist
         , OSUTF8("Channel_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioAssay_assnlist */

   if (pvalue->m.bioAssay_assnlistPresent) {
      stat = XmlEnc_BioAssay_assnlist (pctxt, &pvalue->bioAssay_assnlist
         , OSUTF8("BioAssay_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Channel_assnref                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Channel_assnref (OSCTXT* pctxt,
   Channel_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode channel_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Channel_ref (pctxt, &pvalue->channel_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Channel_assnref (OSCTXT* pctxt, Channel_assnref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode channel_ref */

   stat = XmlEnc_Channel_ref (pctxt, &pvalue->channel_ref
      , OSUTF8("Channel_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Scale_assn                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Scale_assn (OSCTXT* pctxt,
   Scale_assn *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode ontologyEntry */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_OntologyEntry (pctxt, &pvalue->ontologyEntry, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Scale_assn (OSCTXT* pctxt, Scale_assn* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode ontologyEntry */

   stat = XmlEnc_OntologyEntry (pctxt, &pvalue->ontologyEntry
      , OSUTF8("OntologyEntry"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConfidenceIndicator_ref_1                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ConfidenceIndicator_ref_1 (OSCTXT* pctxt,
   ConfidenceIndicator_ref_1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_Error_ref (pctxt, pvalue->u.error_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_PValue_ref (pctxt, pvalue->u.pValue_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_ExpectedValue_ref (pctxt, pvalue->u.expectedValue_ref, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_ConfidenceIndicator_ref_1 (OSCTXT* pctxt, 
   ConfidenceIndicator_ref_1* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode error_ref */

         stat = XmlEnc_Error_ref (pctxt, pvalue->u.error_ref
            , OSUTF8("Error_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode pValue_ref */

         stat = XmlEnc_PValue_ref (pctxt, pvalue->u.pValue_ref
            , OSUTF8("PValue_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode expectedValue_ref */

         stat = XmlEnc_ExpectedValue_ref (pctxt, pvalue->u.expectedValue_ref
            , OSUTF8("ExpectedValue_ref"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConfidenceIndicators_assnreflist                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ConfidenceIndicators_assnreflist (OSCTXT* pctxt,
   ConfidenceIndicators_assnreflist *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ConfidenceIndicators_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_ConfidenceIndicator_ref_1 (pctxt, ((ConfidenceIndicator_ref_1*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ConfidenceIndicators_assnreflist (OSCTXT* pctxt, 
   ConfidenceIndicators_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ConfidenceIndicators_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_ConfidenceIndicator_ref_1 (pctxt, 
         ((ConfidenceIndicator_ref_1*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SpecializedQuantitationType                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SpecializedQuantitationType (OSCTXT* pctxt,
   SpecializedQuantitationType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->quantitationTypeMaps_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_ConfidenceIndicators_assnreflist (pctxt, &pvalue->confidenceIndicators_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dataType_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_DataType_assn (pctxt, &pvalue->dataType_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode scale_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_Scale_assn (pctxt, &pvalue->scale_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Channel_assnref (pctxt, &pvalue->channel_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode isBackground */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->isBackground, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SpecializedQuantitationType (OSCTXT* pctxt, 
   SpecializedQuantitationType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" isBackground=\""), 15);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->isBackground, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      stat = XmlEnc_Channel_assnref (pctxt, &pvalue->channel_assnref
         , OSUTF8("Channel_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode scale_assn */

   stat = XmlEnc_Scale_assn (pctxt, &pvalue->scale_assn
      , OSUTF8("Scale_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dataType_assn */

   stat = XmlEnc_DataType_assn (pctxt, &pvalue->dataType_assn
      , OSUTF8("DataType_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      stat = XmlEnc_ConfidenceIndicators_assnreflist (pctxt, &pvalue->
         confidenceIndicators_assnreflist
         , OSUTF8("ConfidenceIndicators_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      stat = XmlEnc_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->
         quantitationTypeMaps_assnreflist
         , OSUTF8("QuantitationTypeMaps_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DerivedSignal                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DerivedSignal (OSCTXT* pctxt,
   DerivedSignal *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->quantitationTypeMaps_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_ConfidenceIndicators_assnreflist (pctxt, &pvalue->confidenceIndicators_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dataType_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_DataType_assn (pctxt, &pvalue->dataType_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode scale_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_Scale_assn (pctxt, &pvalue->scale_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Channel_assnref (pctxt, &pvalue->channel_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode isBackground */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->isBackground, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DerivedSignal (OSCTXT* pctxt, DerivedSignal* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" isBackground=\""), 15);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->isBackground, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      stat = XmlEnc_Channel_assnref (pctxt, &pvalue->channel_assnref
         , OSUTF8("Channel_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode scale_assn */

   stat = XmlEnc_Scale_assn (pctxt, &pvalue->scale_assn
      , OSUTF8("Scale_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dataType_assn */

   stat = XmlEnc_DataType_assn (pctxt, &pvalue->dataType_assn
      , OSUTF8("DataType_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      stat = XmlEnc_ConfidenceIndicators_assnreflist (pctxt, &pvalue->
         confidenceIndicators_assnreflist
         , OSUTF8("ConfidenceIndicators_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      stat = XmlEnc_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->
         quantitationTypeMaps_assnreflist
         , OSUTF8("QuantitationTypeMaps_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasuredSignal                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MeasuredSignal (OSCTXT* pctxt,
   MeasuredSignal *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->quantitationTypeMaps_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_ConfidenceIndicators_assnreflist (pctxt, &pvalue->confidenceIndicators_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dataType_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_DataType_assn (pctxt, &pvalue->dataType_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode scale_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_Scale_assn (pctxt, &pvalue->scale_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Channel_assnref (pctxt, &pvalue->channel_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode isBackground */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->isBackground, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MeasuredSignal (OSCTXT* pctxt, MeasuredSignal* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" isBackground=\""), 15);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->isBackground, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      stat = XmlEnc_Channel_assnref (pctxt, &pvalue->channel_assnref
         , OSUTF8("Channel_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode scale_assn */

   stat = XmlEnc_Scale_assn (pctxt, &pvalue->scale_assn
      , OSUTF8("Scale_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dataType_assn */

   stat = XmlEnc_DataType_assn (pctxt, &pvalue->dataType_assn
      , OSUTF8("DataType_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      stat = XmlEnc_ConfidenceIndicators_assnreflist (pctxt, &pvalue->
         confidenceIndicators_assnreflist
         , OSUTF8("ConfidenceIndicators_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      stat = XmlEnc_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->
         quantitationTypeMaps_assnreflist
         , OSUTF8("QuantitationTypeMaps_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Error                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Error (OSCTXT* pctxt,
   Error *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->quantitationTypeMaps_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_ConfidenceIndicators_assnreflist (pctxt, &pvalue->confidenceIndicators_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dataType_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_DataType_assn (pctxt, &pvalue->dataType_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode scale_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_Scale_assn (pctxt, &pvalue->scale_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Channel_assnref (pctxt, &pvalue->channel_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode isBackground */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->isBackground, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Error (OSCTXT* pctxt, Error* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" isBackground=\""), 15);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->isBackground, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      stat = XmlEnc_Channel_assnref (pctxt, &pvalue->channel_assnref
         , OSUTF8("Channel_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode scale_assn */

   stat = XmlEnc_Scale_assn (pctxt, &pvalue->scale_assn
      , OSUTF8("Scale_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dataType_assn */

   stat = XmlEnc_DataType_assn (pctxt, &pvalue->dataType_assn
      , OSUTF8("DataType_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      stat = XmlEnc_ConfidenceIndicators_assnreflist (pctxt, &pvalue->
         confidenceIndicators_assnreflist
         , OSUTF8("ConfidenceIndicators_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      stat = XmlEnc_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->
         quantitationTypeMaps_assnreflist
         , OSUTF8("QuantitationTypeMaps_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PValue                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PValue (OSCTXT* pctxt,
   PValue *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->quantitationTypeMaps_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_ConfidenceIndicators_assnreflist (pctxt, &pvalue->confidenceIndicators_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dataType_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_DataType_assn (pctxt, &pvalue->dataType_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode scale_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_Scale_assn (pctxt, &pvalue->scale_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Channel_assnref (pctxt, &pvalue->channel_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode isBackground */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->isBackground, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PValue (OSCTXT* pctxt, PValue* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" isBackground=\""), 15);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->isBackground, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      stat = XmlEnc_Channel_assnref (pctxt, &pvalue->channel_assnref
         , OSUTF8("Channel_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode scale_assn */

   stat = XmlEnc_Scale_assn (pctxt, &pvalue->scale_assn
      , OSUTF8("Scale_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dataType_assn */

   stat = XmlEnc_DataType_assn (pctxt, &pvalue->dataType_assn
      , OSUTF8("DataType_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      stat = XmlEnc_ConfidenceIndicators_assnreflist (pctxt, &pvalue->
         confidenceIndicators_assnreflist
         , OSUTF8("ConfidenceIndicators_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      stat = XmlEnc_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->
         quantitationTypeMaps_assnreflist
         , OSUTF8("QuantitationTypeMaps_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExpectedValue                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ExpectedValue (OSCTXT* pctxt,
   ExpectedValue *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->quantitationTypeMaps_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_ConfidenceIndicators_assnreflist (pctxt, &pvalue->confidenceIndicators_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dataType_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_DataType_assn (pctxt, &pvalue->dataType_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode scale_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_Scale_assn (pctxt, &pvalue->scale_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Channel_assnref (pctxt, &pvalue->channel_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode isBackground */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->isBackground, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ExpectedValue (OSCTXT* pctxt, ExpectedValue* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" isBackground=\""), 15);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->isBackground, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      stat = XmlEnc_Channel_assnref (pctxt, &pvalue->channel_assnref
         , OSUTF8("Channel_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode scale_assn */

   stat = XmlEnc_Scale_assn (pctxt, &pvalue->scale_assn
      , OSUTF8("Scale_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dataType_assn */

   stat = XmlEnc_DataType_assn (pctxt, &pvalue->dataType_assn
      , OSUTF8("DataType_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      stat = XmlEnc_ConfidenceIndicators_assnreflist (pctxt, &pvalue->
         confidenceIndicators_assnreflist
         , OSUTF8("ConfidenceIndicators_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      stat = XmlEnc_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->
         quantitationTypeMaps_assnreflist
         , OSUTF8("QuantitationTypeMaps_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ratio                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Ratio (OSCTXT* pctxt,
   Ratio *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->quantitationTypeMaps_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_ConfidenceIndicators_assnreflist (pctxt, &pvalue->confidenceIndicators_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dataType_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_DataType_assn (pctxt, &pvalue->dataType_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode scale_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_Scale_assn (pctxt, &pvalue->scale_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Channel_assnref (pctxt, &pvalue->channel_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode isBackground */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->isBackground, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Ratio (OSCTXT* pctxt, Ratio* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" isBackground=\""), 15);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->isBackground, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      stat = XmlEnc_Channel_assnref (pctxt, &pvalue->channel_assnref
         , OSUTF8("Channel_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode scale_assn */

   stat = XmlEnc_Scale_assn (pctxt, &pvalue->scale_assn
      , OSUTF8("Scale_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dataType_assn */

   stat = XmlEnc_DataType_assn (pctxt, &pvalue->dataType_assn
      , OSUTF8("DataType_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      stat = XmlEnc_ConfidenceIndicators_assnreflist (pctxt, &pvalue->
         confidenceIndicators_assnreflist
         , OSUTF8("ConfidenceIndicators_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      stat = XmlEnc_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->
         quantitationTypeMaps_assnreflist
         , OSUTF8("QuantitationTypeMaps_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PresentAbsent                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PresentAbsent (OSCTXT* pctxt,
   PresentAbsent *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->quantitationTypeMaps_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_ConfidenceIndicators_assnreflist (pctxt, &pvalue->confidenceIndicators_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dataType_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_DataType_assn (pctxt, &pvalue->dataType_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode scale_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_Scale_assn (pctxt, &pvalue->scale_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Channel_assnref (pctxt, &pvalue->channel_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode isBackground */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->isBackground, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PresentAbsent (OSCTXT* pctxt, PresentAbsent* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" isBackground=\""), 15);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->isBackground, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      stat = XmlEnc_Channel_assnref (pctxt, &pvalue->channel_assnref
         , OSUTF8("Channel_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode scale_assn */

   stat = XmlEnc_Scale_assn (pctxt, &pvalue->scale_assn
      , OSUTF8("Scale_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dataType_assn */

   stat = XmlEnc_DataType_assn (pctxt, &pvalue->dataType_assn
      , OSUTF8("DataType_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      stat = XmlEnc_ConfidenceIndicators_assnreflist (pctxt, &pvalue->
         confidenceIndicators_assnreflist
         , OSUTF8("ConfidenceIndicators_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      stat = XmlEnc_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->
         quantitationTypeMaps_assnreflist
         , OSUTF8("QuantitationTypeMaps_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Failed                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Failed (OSCTXT* pctxt,
   Failed *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->quantitationTypeMaps_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_ConfidenceIndicators_assnreflist (pctxt, &pvalue->confidenceIndicators_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dataType_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_DataType_assn (pctxt, &pvalue->dataType_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode scale_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_Scale_assn (pctxt, &pvalue->scale_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Channel_assnref (pctxt, &pvalue->channel_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode isBackground */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->isBackground, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Failed (OSCTXT* pctxt, Failed* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" isBackground=\""), 15);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->isBackground, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      stat = XmlEnc_Channel_assnref (pctxt, &pvalue->channel_assnref
         , OSUTF8("Channel_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode scale_assn */

   stat = XmlEnc_Scale_assn (pctxt, &pvalue->scale_assn
      , OSUTF8("Scale_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dataType_assn */

   stat = XmlEnc_DataType_assn (pctxt, &pvalue->dataType_assn
      , OSUTF8("DataType_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      stat = XmlEnc_ConfidenceIndicators_assnreflist (pctxt, &pvalue->
         confidenceIndicators_assnreflist
         , OSUTF8("ConfidenceIndicators_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      stat = XmlEnc_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->
         quantitationTypeMaps_assnreflist
         , OSUTF8("QuantitationTypeMaps_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantitationType_classes                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantitationType_classes (OSCTXT* pctxt,
   QuantitationType_classes *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_SpecializedQuantitationType (pctxt, pvalue->u.specializedQuantitationType, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_DerivedSignal (pctxt, pvalue->u.derivedSignal, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_MeasuredSignal (pctxt, pvalue->u.measuredSignal, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 4:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
            asn1E_Error (pctxt, pvalue->u.error, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 5:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
            asn1E_PValue (pctxt, pvalue->u.pValue, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 6:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
            asn1E_ExpectedValue (pctxt, pvalue->u.expectedValue, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 7:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
            asn1E_Ratio (pctxt, pvalue->u.ratio, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 8:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
            asn1E_PresentAbsent (pctxt, pvalue->u.presentAbsent, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 9:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
            asn1E_Failed (pctxt, pvalue->u.failed, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_QuantitationType_classes (OSCTXT* pctxt, 
   QuantitationType_classes* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode specializedQuantitationType */

         stat = XmlEnc_SpecializedQuantitationType (pctxt, pvalue->
            u.specializedQuantitationType
            , OSUTF8("SpecializedQuantitationType"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode derivedSignal */

         stat = XmlEnc_DerivedSignal (pctxt, pvalue->u.derivedSignal
            , OSUTF8("DerivedSignal"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode measuredSignal */

         stat = XmlEnc_MeasuredSignal (pctxt, pvalue->u.measuredSignal
            , OSUTF8("MeasuredSignal"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 4:
         /* encode error */

         stat = XmlEnc_Error (pctxt, pvalue->u.error
            , OSUTF8("Error"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 5:
         /* encode pValue */

         stat = XmlEnc_PValue (pctxt, pvalue->u.pValue
            , OSUTF8("PValue"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 6:
         /* encode expectedValue */

         stat = XmlEnc_ExpectedValue (pctxt, pvalue->u.expectedValue
            , OSUTF8("ExpectedValue"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 7:
         /* encode ratio */

         stat = XmlEnc_Ratio (pctxt, pvalue->u.ratio
            , OSUTF8("Ratio"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 8:
         /* encode presentAbsent */

         stat = XmlEnc_PresentAbsent (pctxt, pvalue->u.presentAbsent
            , OSUTF8("PresentAbsent"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 9:
         /* encode failed */

         stat = XmlEnc_Failed (pctxt, pvalue->u.failed
            , OSUTF8("Failed"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantitationType_assnlist                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantitationType_assnlist (OSCTXT* pctxt,
   QuantitationType_assnlist *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "QuantitationType_assnlist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_QuantitationType_classes (pctxt, ((QuantitationType_classes*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuantitationType_assnlist (OSCTXT* pctxt, 
   QuantitationType_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "QuantitationType_assnlist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_QuantitationType_classes (pctxt, 
         ((QuantitationType_classes*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantitationType_package                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantitationType_package (OSCTXT* pctxt,
   QuantitationType_package *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationType_assnlist */

   if (pvalue->m.quantitationType_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_QuantitationType_assnlist (pctxt, &pvalue->quantitationType_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuantitationType_package (OSCTXT* pctxt, 
   QuantitationType_package* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode quantitationType_assnlist */

   if (pvalue->m.quantitationType_assnlistPresent) {
      stat = XmlEnc_QuantitationType_assnlist (pctxt, &pvalue->
         quantitationType_assnlist
         , OSUTF8("QuantitationType_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssays_assnreflist                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssays_assnreflist (OSCTXT* pctxt,
   BioAssays_assnreflist *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioAssays_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_BioAssay_ref_1 (pctxt, ((BioAssay_ref_1*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssays_assnreflist (OSCTXT* pctxt, 
   BioAssays_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioAssays_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_BioAssay_ref_1 (pctxt, ((BioAssay_ref_1*)pnode->data)
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayDimension                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayDimension (OSCTXT* pctxt,
   BioAssayDimension *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode bioAssays_assnreflist */

   if (pvalue->m.bioAssays_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_BioAssays_assnreflist (pctxt, &pvalue->bioAssays_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayDimension (OSCTXT* pctxt, BioAssayDimension* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioAssays_assnreflist */

   if (pvalue->m.bioAssays_assnreflistPresent) {
      stat = XmlEnc_BioAssays_assnreflist (pctxt, &pvalue->
         bioAssays_assnreflist, OSUTF8("BioAssays_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayDimension_assnlist                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayDimension_assnlist (OSCTXT* pctxt,
   BioAssayDimension_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode bioAssayDimension_list */

   if (!(pvalue->bioAssayDimension_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioAssayDimension_assnlist.bioAssayDimension_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioAssayDimension_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->bioAssayDimension_list.tail;
   while (0 != pnode2) {
      ll = asn1E_BioAssayDimension (pctxt, ((BioAssayDimension*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayDimension_assnlist (OSCTXT* pctxt, 
   BioAssayDimension_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bioAssayDimension_list */

   if (!(pvalue->bioAssayDimension_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioAssayDimension_assnlist.bioAssayDimension_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioAssayDimension_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->bioAssayDimension_list.head;
   while (0 != pnode) {
      stat = XmlEnc_BioAssayDimension (pctxt, ((BioAssayDimension*)pnode->data)
         , OSUTF8("BioAssayDimension"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CompositeSequenceDimension                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CompositeSequenceDimension (OSCTXT* pctxt,
   CompositeSequenceDimension *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode compositeSequences_assnreflist */

   if (pvalue->m.compositeSequences_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_CompositeSequences_assnreflist (pctxt, &pvalue->compositeSequences_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode designElementDimension_content */

   if (pvalue->m.designElementDimension_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_DesignElementDimension_content (pctxt, &pvalue->designElementDimension_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CompositeSequenceDimension (OSCTXT* pctxt, 
   CompositeSequenceDimension* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode designElementDimension_content */

   if (pvalue->m.designElementDimension_contentPresent) {
      stat = XmlEnc_DesignElementDimension_content (pctxt, &pvalue->
         designElementDimension_content, 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode compositeSequences_assnreflist */

   if (pvalue->m.compositeSequences_assnreflistPresent) {
      stat = XmlEnc_CompositeSequences_assnreflist (pctxt, &pvalue->
         compositeSequences_assnreflist
         , OSUTF8("CompositeSequences_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ContainedFeatures_assnreflist                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ContainedFeatures_assnreflist (OSCTXT* pctxt,
   ContainedFeatures_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode feature_ref_list */

   if (!(pvalue->feature_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ContainedFeatures_assnreflist.feature_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->feature_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->feature_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Feature_ref (pctxt, ((Feature_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ContainedFeatures_assnreflist (OSCTXT* pctxt, 
   ContainedFeatures_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode feature_ref_list */

   if (!(pvalue->feature_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ContainedFeatures_assnreflist.feature_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->feature_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->feature_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Feature_ref (pctxt, ((Feature_ref*)pnode->data)
         , OSUTF8("Feature_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeatureDimension                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FeatureDimension (OSCTXT* pctxt,
   FeatureDimension *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode containedFeatures_assnreflist */

   if (pvalue->m.containedFeatures_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_ContainedFeatures_assnreflist (pctxt, &pvalue->containedFeatures_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode designElementDimension_content */

   if (pvalue->m.designElementDimension_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_DesignElementDimension_content (pctxt, &pvalue->designElementDimension_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FeatureDimension (OSCTXT* pctxt, FeatureDimension* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode designElementDimension_content */

   if (pvalue->m.designElementDimension_contentPresent) {
      stat = XmlEnc_DesignElementDimension_content (pctxt, &pvalue->
         designElementDimension_content, 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode containedFeatures_assnreflist */

   if (pvalue->m.containedFeatures_assnreflistPresent) {
      stat = XmlEnc_ContainedFeatures_assnreflist (pctxt, &pvalue->
         containedFeatures_assnreflist
         , OSUTF8("ContainedFeatures_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReporterDimension                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ReporterDimension (OSCTXT* pctxt,
   ReporterDimension *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode reporters_assnreflist */

   if (pvalue->m.reporters_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Reporters_assnreflist (pctxt, &pvalue->reporters_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode designElementDimension_content */

   if (pvalue->m.designElementDimension_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_DesignElementDimension_content (pctxt, &pvalue->designElementDimension_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ReporterDimension (OSCTXT* pctxt, ReporterDimension* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode designElementDimension_content */

   if (pvalue->m.designElementDimension_contentPresent) {
      stat = XmlEnc_DesignElementDimension_content (pctxt, &pvalue->
         designElementDimension_content, 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode reporters_assnreflist */

   if (pvalue->m.reporters_assnreflistPresent) {
      stat = XmlEnc_Reporters_assnreflist (pctxt, &pvalue->
         reporters_assnreflist, OSUTF8("Reporters_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElementDimension_classes_group                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElementDimension_classes_group (OSCTXT* pctxt,
   DesignElementDimension_classes_group *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_CompositeSequenceDimension (pctxt, pvalue->u.compositeSequenceDimension, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_FeatureDimension (pctxt, pvalue->u.featureDimension, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_ReporterDimension (pctxt, pvalue->u.reporterDimension, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_DesignElementDimension_classes_group (OSCTXT* pctxt, 
   DesignElementDimension_classes_group* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode compositeSequenceDimension */

         stat = XmlEnc_CompositeSequenceDimension (pctxt, pvalue->
            u.compositeSequenceDimension
            , OSUTF8("CompositeSequenceDimension"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode featureDimension */

         stat = XmlEnc_FeatureDimension (pctxt, pvalue->u.featureDimension
            , OSUTF8("FeatureDimension"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode reporterDimension */

         stat = XmlEnc_ReporterDimension (pctxt, pvalue->u.reporterDimension
            , OSUTF8("ReporterDimension"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElementDimension_assnlist                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElementDimension_assnlist (OSCTXT* pctxt,
   DesignElementDimension_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode designElementDimension_classes_list */

   if (!(pvalue->designElementDimension_classes_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DesignElementDimension_assnlist.designElementDimension_classes_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->designElementDimension_classes_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->designElementDimension_classes_list.tail;
   while (0 != pnode2) {
      ll = asn1E_DesignElementDimension_classes_group (pctxt, ((DesignElementDimension_classes_group*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DesignElementDimension_assnlist (OSCTXT* pctxt, 
   DesignElementDimension_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode designElementDimension_classes_list */

   if (!(pvalue->designElementDimension_classes_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DesignElementDimension_assnlist.designElementDimension_classes_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->designElementDimension_classes_list
         .count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->designElementDimension_classes_list.head;
   while (0 != pnode) {
      stat = XmlEnc_DesignElementDimension_classes_group (pctxt, 
         ((DesignElementDimension_classes_group*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantitationTypes_assnreflist                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantitationTypes_assnreflist (OSCTXT* pctxt,
   QuantitationTypes_assnreflist *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "QuantitationTypes_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_QuantitationType_ref_1 (pctxt, ((QuantitationType_ref_1*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuantitationTypes_assnreflist (OSCTXT* pctxt, 
   QuantitationTypes_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "QuantitationTypes_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_QuantitationType_ref_1 (pctxt, 
         ((QuantitationType_ref_1*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantitationTypeDimension                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantitationTypeDimension (OSCTXT* pctxt,
   QuantitationTypeDimension *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationTypes_assnreflist */

   if (pvalue->m.quantitationTypes_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_QuantitationTypes_assnreflist (pctxt, &pvalue->quantitationTypes_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuantitationTypeDimension (OSCTXT* pctxt, 
   QuantitationTypeDimension* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypes_assnreflist */

   if (pvalue->m.quantitationTypes_assnreflistPresent) {
      stat = XmlEnc_QuantitationTypes_assnreflist (pctxt, &pvalue->
         quantitationTypes_assnreflist
         , OSUTF8("QuantitationTypes_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantitationTypeDimension_assnlist                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantitationTypeDimension_assnlist (OSCTXT* pctxt,
   QuantitationTypeDimension_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode quantitationTypeDimension_list */

   if (!(pvalue->quantitationTypeDimension_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "QuantitationTypeDimension_assnlist.quantitationTypeDimension_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->quantitationTypeDimension_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->quantitationTypeDimension_list.tail;
   while (0 != pnode2) {
      ll = asn1E_QuantitationTypeDimension (pctxt, ((QuantitationTypeDimension*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuantitationTypeDimension_assnlist (OSCTXT* pctxt, 
   QuantitationTypeDimension_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode quantitationTypeDimension_list */

   if (!(pvalue->quantitationTypeDimension_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "QuantitationTypeDimension_assnlist.quantitationTypeDimension_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->quantitationTypeDimension_list.
         count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->quantitationTypeDimension_list.head;
   while (0 != pnode) {
      stat = XmlEnc_QuantitationTypeDimension (pctxt, 
         ((QuantitationTypeDimension*)pnode->data)
         , OSUTF8("QuantitationTypeDimension"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayMapTarget_assnref                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayMapTarget_assnref (OSCTXT* pctxt,
   BioAssayMapTarget_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode derivedBioAssay_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_DerivedBioAssay_ref (pctxt, &pvalue->derivedBioAssay_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayMapTarget_assnref (OSCTXT* pctxt, 
   BioAssayMapTarget_assnref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode derivedBioAssay_ref */

   stat = XmlEnc_DerivedBioAssay_ref (pctxt, &pvalue->derivedBioAssay_ref
      , OSUTF8("DerivedBioAssay_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourceBioAssays_assnreflist                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SourceBioAssays_assnreflist (OSCTXT* pctxt,
   SourceBioAssays_assnreflist *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SourceBioAssays_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_BioAssay_ref_1 (pctxt, ((BioAssay_ref_1*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SourceBioAssays_assnreflist (OSCTXT* pctxt, 
   SourceBioAssays_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SourceBioAssays_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_BioAssay_ref_1 (pctxt, ((BioAssay_ref_1*)pnode->data)
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayMap                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayMap (OSCTXT* pctxt,
   BioAssayMap *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode sourceBioAssays_assnreflist */

   if (pvalue->m.sourceBioAssays_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_SourceBioAssays_assnreflist (pctxt, &pvalue->sourceBioAssays_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioAssayMapTarget_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_BioAssayMapTarget_assnref (pctxt, &pvalue->bioAssayMapTarget_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode map_content */

   if (pvalue->m.map_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Map_content (pctxt, &pvalue->map_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayMap (OSCTXT* pctxt, BioAssayMap* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode map_content */

   if (pvalue->m.map_contentPresent) {
      stat = XmlEnc_Map_content (pctxt, &pvalue->map_content, 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioAssayMapTarget_assnref */

   stat = XmlEnc_BioAssayMapTarget_assnref (pctxt, &pvalue->
      bioAssayMapTarget_assnref
      , OSUTF8("BioAssayMapTarget_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode sourceBioAssays_assnreflist */

   if (pvalue->m.sourceBioAssays_assnreflistPresent) {
      stat = XmlEnc_SourceBioAssays_assnreflist (pctxt, &pvalue->
         sourceBioAssays_assnreflist
         , OSUTF8("SourceBioAssays_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayMap_assnlist                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayMap_assnlist (OSCTXT* pctxt,
   BioAssayMap_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode bioAssayMap_list */

   if (!(pvalue->bioAssayMap_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioAssayMap_assnlist.bioAssayMap_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioAssayMap_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->bioAssayMap_list.tail;
   while (0 != pnode2) {
      ll = asn1E_BioAssayMap (pctxt, ((BioAssayMap*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayMap_assnlist (OSCTXT* pctxt, BioAssayMap_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bioAssayMap_list */

   if (!(pvalue->bioAssayMap_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioAssayMap_assnlist.bioAssayMap_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioAssayMap_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->bioAssayMap_list.head;
   while (0 != pnode) {
      stat = XmlEnc_BioAssayMap (pctxt, ((BioAssayMap*)pnode->data)
         , OSUTF8("BioAssayMap"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SourcesQuantitationType_assnreflist                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SourcesQuantitationType_assnreflist (OSCTXT* pctxt,
   SourcesQuantitationType_assnreflist *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SourcesQuantitationType_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_QuantitationType_ref_1 (pctxt, ((QuantitationType_ref_1*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SourcesQuantitationType_assnreflist (OSCTXT* pctxt, 
   SourcesQuantitationType_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SourcesQuantitationType_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_QuantitationType_ref_1 (pctxt, 
         ((QuantitationType_ref_1*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantitationTypeMap                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantitationTypeMap (OSCTXT* pctxt,
   QuantitationTypeMap *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode sourcesQuantitationType_assnreflist */

   if (pvalue->m.sourcesQuantitationType_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_SourcesQuantitationType_assnreflist (pctxt, &pvalue->sourcesQuantitationType_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode targetQuantitationType_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_TargetQuantitationType_assnref (pctxt, &pvalue->targetQuantitationType_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode map_content */

   if (pvalue->m.map_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Map_content (pctxt, &pvalue->map_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuantitationTypeMap (OSCTXT* pctxt, QuantitationTypeMap* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode map_content */

   if (pvalue->m.map_contentPresent) {
      stat = XmlEnc_Map_content (pctxt, &pvalue->map_content, 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode targetQuantitationType_assnref */

   stat = XmlEnc_TargetQuantitationType_assnref (pctxt, &pvalue->
      targetQuantitationType_assnref
      , OSUTF8("TargetQuantitationType_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode sourcesQuantitationType_assnreflist */

   if (pvalue->m.sourcesQuantitationType_assnreflistPresent) {
      stat = XmlEnc_SourcesQuantitationType_assnreflist (pctxt, &pvalue->
         sourcesQuantitationType_assnreflist
         , OSUTF8("SourcesQuantitationType_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantitationTypeMap_assnlist                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantitationTypeMap_assnlist (OSCTXT* pctxt,
   QuantitationTypeMap_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode quantitationTypeMap_list */

   if (!(pvalue->quantitationTypeMap_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "QuantitationTypeMap_assnlist.quantitationTypeMap_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->quantitationTypeMap_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->quantitationTypeMap_list.tail;
   while (0 != pnode2) {
      ll = asn1E_QuantitationTypeMap (pctxt, ((QuantitationTypeMap*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuantitationTypeMap_assnlist (OSCTXT* pctxt, 
   QuantitationTypeMap_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode quantitationTypeMap_list */

   if (!(pvalue->quantitationTypeMap_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "QuantitationTypeMap_assnlist.quantitationTypeMap_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->quantitationTypeMap_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->quantitationTypeMap_list.head;
   while (0 != pnode) {
      stat = XmlEnc_QuantitationTypeMap (pctxt, 
         ((QuantitationTypeMap*)pnode->data)
         , OSUTF8("QuantitationTypeMap"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SummaryStatistics_assnlist                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SummaryStatistics_assnlist (OSCTXT* pctxt,
   SummaryStatistics_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode nameValueType_list */

   if (!(pvalue->nameValueType_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SummaryStatistics_assnlist.nameValueType_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->nameValueType_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->nameValueType_list.tail;
   while (0 != pnode2) {
      ll = asn1E_NameValueType (pctxt, ((NameValueType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SummaryStatistics_assnlist (OSCTXT* pctxt, 
   SummaryStatistics_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode nameValueType_list */

   if (!(pvalue->nameValueType_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SummaryStatistics_assnlist.nameValueType_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->nameValueType_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->nameValueType_list.head;
   while (0 != pnode) {
      stat = XmlEnc_NameValueType (pctxt, ((NameValueType*)pnode->data)
         , OSUTF8("NameValueType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DerivedBioAssayData                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DerivedBioAssayData (OSCTXT* pctxt,
   DerivedBioAssayData *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode producerTransformation_assn */

   if (pvalue->m.producerTransformation_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_ProducerTransformation_assn (pctxt, &pvalue->producerTransformation_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioDataValues_assn */

   if (pvalue->m.bioDataValues_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_BioDataValues_assn (pctxt, &pvalue->bioDataValues_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode quantitationTypeDimension_assnref */

   if (pvalue->m.quantitationTypeDimension_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_QuantitationTypeDimension_assnref (pctxt, &pvalue->quantitationTypeDimension_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode designElementDimension_assnref */

   if (pvalue->m.designElementDimension_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_DesignElementDimension_assnref (pctxt, &pvalue->designElementDimension_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioAssayDimension_assnref */

   if (pvalue->m.bioAssayDimension_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_BioAssayDimension_assnref (pctxt, &pvalue->bioAssayDimension_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode summaryStatistics_assnlist */

   if (pvalue->m.summaryStatistics_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_SummaryStatistics_assnlist (pctxt, &pvalue->summaryStatistics_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DerivedBioAssayData (OSCTXT* pctxt, DerivedBioAssayData* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode summaryStatistics_assnlist */

   if (pvalue->m.summaryStatistics_assnlistPresent) {
      stat = XmlEnc_SummaryStatistics_assnlist (pctxt, &pvalue->
         summaryStatistics_assnlist
         , OSUTF8("SummaryStatistics_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioAssayDimension_assnref */

   if (pvalue->m.bioAssayDimension_assnrefPresent) {
      stat = XmlEnc_BioAssayDimension_assnref (pctxt, &pvalue->
         bioAssayDimension_assnref
         , OSUTF8("BioAssayDimension_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode designElementDimension_assnref */

   if (pvalue->m.designElementDimension_assnrefPresent) {
      stat = XmlEnc_DesignElementDimension_assnref (pctxt, &pvalue->
         designElementDimension_assnref
         , OSUTF8("DesignElementDimension_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeDimension_assnref */

   if (pvalue->m.quantitationTypeDimension_assnrefPresent) {
      stat = XmlEnc_QuantitationTypeDimension_assnref (pctxt, &pvalue->
         quantitationTypeDimension_assnref
         , OSUTF8("QuantitationTypeDimension_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioDataValues_assn */

   if (pvalue->m.bioDataValues_assnPresent) {
      stat = XmlEnc_BioDataValues_assn (pctxt, &pvalue->bioDataValues_assn
         , OSUTF8("BioDataValues_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode producerTransformation_assn */

   if (pvalue->m.producerTransformation_assnPresent) {
      stat = XmlEnc_ProducerTransformation_assn (pctxt, &pvalue->
         producerTransformation_assn
         , OSUTF8("ProducerTransformation_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasuredBioAssayData                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MeasuredBioAssayData (OSCTXT* pctxt,
   MeasuredBioAssayData *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode bioDataValues_assn */

   if (pvalue->m.bioDataValues_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_BioDataValues_assn (pctxt, &pvalue->bioDataValues_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode quantitationTypeDimension_assnref */

   if (pvalue->m.quantitationTypeDimension_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_QuantitationTypeDimension_assnref (pctxt, &pvalue->quantitationTypeDimension_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode designElementDimension_assnref */

   if (pvalue->m.designElementDimension_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_DesignElementDimension_assnref (pctxt, &pvalue->designElementDimension_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioAssayDimension_assnref */

   if (pvalue->m.bioAssayDimension_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_BioAssayDimension_assnref (pctxt, &pvalue->bioAssayDimension_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode summaryStatistics_assnlist */

   if (pvalue->m.summaryStatistics_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_SummaryStatistics_assnlist (pctxt, &pvalue->summaryStatistics_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MeasuredBioAssayData (OSCTXT* pctxt, MeasuredBioAssayData* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode summaryStatistics_assnlist */

   if (pvalue->m.summaryStatistics_assnlistPresent) {
      stat = XmlEnc_SummaryStatistics_assnlist (pctxt, &pvalue->
         summaryStatistics_assnlist
         , OSUTF8("SummaryStatistics_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioAssayDimension_assnref */

   if (pvalue->m.bioAssayDimension_assnrefPresent) {
      stat = XmlEnc_BioAssayDimension_assnref (pctxt, &pvalue->
         bioAssayDimension_assnref
         , OSUTF8("BioAssayDimension_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode designElementDimension_assnref */

   if (pvalue->m.designElementDimension_assnrefPresent) {
      stat = XmlEnc_DesignElementDimension_assnref (pctxt, &pvalue->
         designElementDimension_assnref
         , OSUTF8("DesignElementDimension_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeDimension_assnref */

   if (pvalue->m.quantitationTypeDimension_assnrefPresent) {
      stat = XmlEnc_QuantitationTypeDimension_assnref (pctxt, &pvalue->
         quantitationTypeDimension_assnref
         , OSUTF8("QuantitationTypeDimension_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioDataValues_assn */

   if (pvalue->m.bioDataValues_assnPresent) {
      stat = XmlEnc_BioDataValues_assn (pctxt, &pvalue->bioDataValues_assn
         , OSUTF8("BioDataValues_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayData_classes_group                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayData_classes_group (OSCTXT* pctxt,
   BioAssayData_classes_group *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_DerivedBioAssayData (pctxt, pvalue->u.derivedBioAssayData, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_MeasuredBioAssayData (pctxt, pvalue->u.measuredBioAssayData, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_BioAssayData_classes_group (OSCTXT* pctxt, 
   BioAssayData_classes_group* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode derivedBioAssayData */

         stat = XmlEnc_DerivedBioAssayData (pctxt, pvalue->
            u.derivedBioAssayData, OSUTF8("DerivedBioAssayData"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode measuredBioAssayData */

         stat = XmlEnc_MeasuredBioAssayData (pctxt, pvalue->
            u.measuredBioAssayData, OSUTF8("MeasuredBioAssayData"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayData_assnlist                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayData_assnlist (OSCTXT* pctxt,
   BioAssayData_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode bioAssayData_classes_list */

   if (!(pvalue->bioAssayData_classes_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioAssayData_assnlist.bioAssayData_classes_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioAssayData_classes_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->bioAssayData_classes_list.tail;
   while (0 != pnode2) {
      ll = asn1E_BioAssayData_classes_group (pctxt, ((BioAssayData_classes_group*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayData_assnlist (OSCTXT* pctxt, 
   BioAssayData_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bioAssayData_classes_list */

   if (!(pvalue->bioAssayData_classes_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioAssayData_assnlist.bioAssayData_classes_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioAssayData_classes_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->bioAssayData_classes_list.head;
   while (0 != pnode) {
      stat = XmlEnc_BioAssayData_classes_group (pctxt, 
         ((BioAssayData_classes_group*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayData_package                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayData_package (OSCTXT* pctxt,
   BioAssayData_package *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode bioAssayData_assnlist */

   if (pvalue->m.bioAssayData_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_BioAssayData_assnlist (pctxt, &pvalue->bioAssayData_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode quantitationTypeMap_assnlist */

   if (pvalue->m.quantitationTypeMap_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_QuantitationTypeMap_assnlist (pctxt, &pvalue->quantitationTypeMap_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioAssayMap_assnlist */

   if (pvalue->m.bioAssayMap_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_BioAssayMap_assnlist (pctxt, &pvalue->bioAssayMap_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode quantitationTypeDimension_assnlist */

   if (pvalue->m.quantitationTypeDimension_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_QuantitationTypeDimension_assnlist (pctxt, &pvalue->quantitationTypeDimension_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode designElementDimension_assnlist */

   if (pvalue->m.designElementDimension_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_DesignElementDimension_assnlist (pctxt, &pvalue->designElementDimension_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioAssayDimension_assnlist */

   if (pvalue->m.bioAssayDimension_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_BioAssayDimension_assnlist (pctxt, &pvalue->bioAssayDimension_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayData_package (OSCTXT* pctxt, BioAssayData_package* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bioAssayDimension_assnlist */

   if (pvalue->m.bioAssayDimension_assnlistPresent) {
      stat = XmlEnc_BioAssayDimension_assnlist (pctxt, &pvalue->
         bioAssayDimension_assnlist
         , OSUTF8("BioAssayDimension_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode designElementDimension_assnlist */

   if (pvalue->m.designElementDimension_assnlistPresent) {
      stat = XmlEnc_DesignElementDimension_assnlist (pctxt, &pvalue->
         designElementDimension_assnlist
         , OSUTF8("DesignElementDimension_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeDimension_assnlist */

   if (pvalue->m.quantitationTypeDimension_assnlistPresent) {
      stat = XmlEnc_QuantitationTypeDimension_assnlist (pctxt, &pvalue->
         quantitationTypeDimension_assnlist
         , OSUTF8("QuantitationTypeDimension_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioAssayMap_assnlist */

   if (pvalue->m.bioAssayMap_assnlistPresent) {
      stat = XmlEnc_BioAssayMap_assnlist (pctxt, &pvalue->bioAssayMap_assnlist
         , OSUTF8("BioAssayMap_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeMap_assnlist */

   if (pvalue->m.quantitationTypeMap_assnlistPresent) {
      stat = XmlEnc_QuantitationTypeMap_assnlist (pctxt, &pvalue->
         quantitationTypeMap_assnlist
         , OSUTF8("QuantitationTypeMap_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioAssayData_assnlist */

   if (pvalue->m.bioAssayData_assnlistPresent) {
      stat = XmlEnc_BioAssayData_assnlist (pctxt, &pvalue->
         bioAssayData_assnlist, OSUTF8("BioAssayData_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Providers_assnreflist                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Providers_assnreflist (OSCTXT* pctxt,
   Providers_assnreflist *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Providers_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_Contact_ref_1 (pctxt, ((Contact_ref_1*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Providers_assnreflist (OSCTXT* pctxt, 
   Providers_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Providers_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_Contact_ref_1 (pctxt, ((Contact_ref_1*)pnode->data)
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayDataCluster_ref                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayDataCluster_ref (OSCTXT* pctxt,
   BioAssayDataCluster_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayDataCluster_ref (OSCTXT* pctxt, 
   BioAssayDataCluster_ref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AnalysisResults_assnreflist                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AnalysisResults_assnreflist (OSCTXT* pctxt,
   AnalysisResults_assnreflist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode bioAssayDataCluster_ref_list */

   if (!(pvalue->bioAssayDataCluster_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "AnalysisResults_assnreflist.bioAssayDataCluster_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioAssayDataCluster_ref_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->bioAssayDataCluster_ref_list.tail;
   while (0 != pnode2) {
      ll = asn1E_BioAssayDataCluster_ref (pctxt, ((BioAssayDataCluster_ref*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_AnalysisResults_assnreflist (OSCTXT* pctxt, 
   AnalysisResults_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bioAssayDataCluster_ref_list */

   if (!(pvalue->bioAssayDataCluster_ref_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "AnalysisResults_assnreflist.bioAssayDataCluster_ref_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioAssayDataCluster_ref_list.count
         );
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->bioAssayDataCluster_ref_list.head;
   while (0 != pnode) {
      stat = XmlEnc_BioAssayDataCluster_ref (pctxt, 
         ((BioAssayDataCluster_ref*)pnode->data)
         , OSUTF8("BioAssayDataCluster_ref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayData_assnreflist                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayData_assnreflist (OSCTXT* pctxt,
   BioAssayData_assnreflist *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioAssayData_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_BioAssayData_ref_1 (pctxt, ((BioAssayData_ref_1*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayData_assnreflist (OSCTXT* pctxt, 
   BioAssayData_assnreflist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioAssayData_assnreflist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_BioAssayData_ref_1 (pctxt, 
         ((BioAssayData_ref_1*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Experiment                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MAGE_Experiment (OSCTXT* pctxt,
   MAGE_Experiment *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode experimentDesign_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
      asn1E_ExperimentDesign_assn (pctxt, &pvalue->experimentDesign_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode bioAssays_assnreflist */

   if (pvalue->m.bioAssays_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_BioAssays_assnreflist (pctxt, &pvalue->bioAssays_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioAssayData_assnreflist */

   if (pvalue->m.bioAssayData_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_BioAssayData_assnreflist (pctxt, &pvalue->bioAssayData_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode analysisResults_assnreflist */

   if (pvalue->m.analysisResults_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_AnalysisResults_assnreflist (pctxt, &pvalue->analysisResults_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode providers_assnreflist */

   if (pvalue->m.providers_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Providers_assnreflist (pctxt, &pvalue->providers_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MAGE_Experiment (OSCTXT* pctxt, MAGE_Experiment* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode providers_assnreflist */

   if (pvalue->m.providers_assnreflistPresent) {
      stat = XmlEnc_Providers_assnreflist (pctxt, &pvalue->
         providers_assnreflist, OSUTF8("Providers_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode analysisResults_assnreflist */

   if (pvalue->m.analysisResults_assnreflistPresent) {
      stat = XmlEnc_AnalysisResults_assnreflist (pctxt, &pvalue->
         analysisResults_assnreflist
         , OSUTF8("AnalysisResults_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioAssayData_assnreflist */

   if (pvalue->m.bioAssayData_assnreflistPresent) {
      stat = XmlEnc_BioAssayData_assnreflist (pctxt, &pvalue->
         bioAssayData_assnreflist
         , OSUTF8("BioAssayData_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioAssays_assnreflist */

   if (pvalue->m.bioAssays_assnreflistPresent) {
      stat = XmlEnc_BioAssays_assnreflist (pctxt, &pvalue->
         bioAssays_assnreflist, OSUTF8("BioAssays_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode experimentDesign_assn */

   stat = XmlEnc_ExperimentDesign_assn (pctxt, &pvalue->experimentDesign_assn
      , OSUTF8("ExperimentDesign_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Experiment_assnlist                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Experiment_assnlist (OSCTXT* pctxt,
   Experiment_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode experiment_list */

   if (!(pvalue->experiment_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Experiment_assnlist.experiment_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->experiment_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->experiment_list.tail;
   while (0 != pnode2) {
      ll = asn1E_MAGE_Experiment (pctxt, ((MAGE_Experiment*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Experiment_assnlist (OSCTXT* pctxt, Experiment_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode experiment_list */

   if (!(pvalue->experiment_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Experiment_assnlist.experiment_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->experiment_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->experiment_list.head;
   while (0 != pnode) {
      stat = XmlEnc_MAGE_Experiment (pctxt, ((MAGE_Experiment*)pnode->data)
         , OSUTF8("Experiment"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Experiment_package                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Experiment_package (OSCTXT* pctxt,
   Experiment_package *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode experiment_assnlist */

   if (pvalue->m.experiment_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Experiment_assnlist (pctxt, &pvalue->experiment_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Experiment_package (OSCTXT* pctxt, Experiment_package* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode experiment_assnlist */

   if (pvalue->m.experiment_assnlistPresent) {
      stat = XmlEnc_Experiment_assnlist (pctxt, &pvalue->experiment_assnlist
         , OSUTF8("Experiment_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NodeContents                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_NodeContents (OSCTXT* pctxt,
   NodeContents *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationDimension_assnref */

   if (pvalue->m.quantitationDimension_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_QuantitationDimension_assnref (pctxt, &pvalue->quantitationDimension_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode designElementDimension_assnref */

   if (pvalue->m.designElementDimension_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_DesignElementDimension_assnref (pctxt, &pvalue->designElementDimension_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioAssayDimension_assnref */

   if (pvalue->m.bioAssayDimension_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_BioAssayDimension_assnref (pctxt, &pvalue->bioAssayDimension_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Describable_content (pctxt, &pvalue->describable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_NodeContents (OSCTXT* pctxt, NodeContents* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      stat = XmlEnc_Describable_content (pctxt, &pvalue->describable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioAssayDimension_assnref */

   if (pvalue->m.bioAssayDimension_assnrefPresent) {
      stat = XmlEnc_BioAssayDimension_assnref (pctxt, &pvalue->
         bioAssayDimension_assnref
         , OSUTF8("BioAssayDimension_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode designElementDimension_assnref */

   if (pvalue->m.designElementDimension_assnrefPresent) {
      stat = XmlEnc_DesignElementDimension_assnref (pctxt, &pvalue->
         designElementDimension_assnref
         , OSUTF8("DesignElementDimension_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationDimension_assnref */

   if (pvalue->m.quantitationDimension_assnrefPresent) {
      stat = XmlEnc_QuantitationDimension_assnref (pctxt, &pvalue->
         quantitationDimension_assnref
         , OSUTF8("QuantitationDimension_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NodeContents_assnlist                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_NodeContents_assnlist (OSCTXT* pctxt,
   NodeContents_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode nodeContents_list */

   if (!(pvalue->nodeContents_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "NodeContents_assnlist.nodeContents_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->nodeContents_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->nodeContents_list.tail;
   while (0 != pnode2) {
      ll = asn1E_NodeContents (pctxt, ((NodeContents*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_NodeContents_assnlist (OSCTXT* pctxt, 
   NodeContents_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode nodeContents_list */

   if (!(pvalue->nodeContents_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "NodeContents_assnlist.nodeContents_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->nodeContents_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->nodeContents_list.head;
   while (0 != pnode) {
      stat = XmlEnc_NodeContents (pctxt, ((NodeContents*)pnode->data)
         , OSUTF8("NodeContents"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NodeValue                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_NodeValue (OSCTXT* pctxt,
   NodeValue *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode dataType_assn */

   if (pvalue->m.dataType_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_DataType_assn (pctxt, &pvalue->dataType_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode scale_assn */

   if (pvalue->m.scale_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Scale_assn (pctxt, &pvalue->scale_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode type_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_Type_assn (pctxt, &pvalue->type_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode value */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->value, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_NodeValue (OSCTXT* pctxt, NodeValue* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" value=\""), 8);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->value, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode type_assn */

   stat = XmlEnc_Type_assn (pctxt, &pvalue->type_assn
      , OSUTF8("Type_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode scale_assn */

   if (pvalue->m.scale_assnPresent) {
      stat = XmlEnc_Scale_assn (pctxt, &pvalue->scale_assn
         , OSUTF8("Scale_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode dataType_assn */

   if (pvalue->m.dataType_assnPresent) {
      stat = XmlEnc_DataType_assn (pctxt, &pvalue->dataType_assn
         , OSUTF8("DataType_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NodeValue_assnlist                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_NodeValue_assnlist (OSCTXT* pctxt,
   NodeValue_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode nodeValue_list */

   if (!(pvalue->nodeValue_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "NodeValue_assnlist.nodeValue_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->nodeValue_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->nodeValue_list.tail;
   while (0 != pnode2) {
      ll = asn1E_NodeValue (pctxt, ((NodeValue*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_NodeValue_assnlist (OSCTXT* pctxt, NodeValue_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode nodeValue_list */

   if (!(pvalue->nodeValue_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "NodeValue_assnlist.nodeValue_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->nodeValue_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->nodeValue_list.head;
   while (0 != pnode) {
      stat = XmlEnc_NodeValue (pctxt, ((NodeValue*)pnode->data)
         , OSUTF8("NodeValue"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Node                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Node (OSCTXT* pctxt,
   Node *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode nodeValue_assnlist */

   if (pvalue->m.nodeValue_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_NodeValue_assnlist (pctxt, &pvalue->nodeValue_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode nodeContents_assnlist */

   if (pvalue->m.nodeContents_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_NodeContents_assnlist (pctxt, &pvalue->nodeContents_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode nodes_assnlist */

   if (pvalue->m.nodes_assnlistPresent) {
      if (pvalue->nodes_assnlist == NULL) {
         rtxErrAddStrParm (pctxt, "pvalue->nodes_assnlist");
         return LOG_RTERR (pctxt, RTERR_NULLPTR);
      }
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Nodes_assnlist (pctxt, (Nodes_assnlist*)pvalue->nodes_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Describable_content (pctxt, &pvalue->describable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Node (OSCTXT* pctxt, Node* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      stat = XmlEnc_Describable_content (pctxt, &pvalue->describable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode nodes_assnlist */

   if (pvalue->m.nodes_assnlistPresent) {
      stat = XmlEnc_Nodes_assnlist (pctxt, pvalue->nodes_assnlist
         , OSUTF8("Nodes_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode nodeContents_assnlist */

   if (pvalue->m.nodeContents_assnlistPresent) {
      stat = XmlEnc_NodeContents_assnlist (pctxt, &pvalue->
         nodeContents_assnlist, OSUTF8("NodeContents_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode nodeValue_assnlist */

   if (pvalue->m.nodeValue_assnlistPresent) {
      stat = XmlEnc_NodeValue_assnlist (pctxt, &pvalue->nodeValue_assnlist
         , OSUTF8("NodeValue_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Nodes_assnlist                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Nodes_assnlist (OSCTXT* pctxt,
   Nodes_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode node_list */

   if (!(pvalue->node_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Nodes_assnlist.node_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->node_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->node_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Node (pctxt, ((Node*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Nodes_assnlist (OSCTXT* pctxt, Nodes_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode node_list */

   if (!(pvalue->node_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Nodes_assnlist.node_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->node_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->node_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Node (pctxt, ((Node*)pnode->data)
         , OSUTF8("Node"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayDataCluster                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayDataCluster (OSCTXT* pctxt,
   BioAssayDataCluster *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode nodes_assnlist */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_Nodes_assnlist (pctxt, &pvalue->nodes_assnlist, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode clusterBioAssayData_assnref */

   if (pvalue->m.clusterBioAssayData_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_ClusterBioAssayData_assnref (pctxt, &pvalue->clusterBioAssayData_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayDataCluster (OSCTXT* pctxt, BioAssayDataCluster* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode clusterBioAssayData_assnref */

   if (pvalue->m.clusterBioAssayData_assnrefPresent) {
      stat = XmlEnc_ClusterBioAssayData_assnref (pctxt, &pvalue->
         clusterBioAssayData_assnref
         , OSUTF8("ClusterBioAssayData_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode nodes_assnlist */

   stat = XmlEnc_Nodes_assnlist (pctxt, &pvalue->nodes_assnlist
      , OSUTF8("Nodes_assnlist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayDataCluster_assnlist                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayDataCluster_assnlist (OSCTXT* pctxt,
   BioAssayDataCluster_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode bioAssayDataCluster_list */

   if (!(pvalue->bioAssayDataCluster_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioAssayDataCluster_assnlist.bioAssayDataCluster_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioAssayDataCluster_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->bioAssayDataCluster_list.tail;
   while (0 != pnode2) {
      ll = asn1E_BioAssayDataCluster (pctxt, ((BioAssayDataCluster*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayDataCluster_assnlist (OSCTXT* pctxt, 
   BioAssayDataCluster_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bioAssayDataCluster_list */

   if (!(pvalue->bioAssayDataCluster_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "BioAssayDataCluster_assnlist.bioAssayDataCluster_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->bioAssayDataCluster_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->bioAssayDataCluster_list.head;
   while (0 != pnode) {
      stat = XmlEnc_BioAssayDataCluster (pctxt, 
         ((BioAssayDataCluster*)pnode->data)
         , OSUTF8("BioAssayDataCluster"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HigherLevelAnalysis_package                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_HigherLevelAnalysis_package (OSCTXT* pctxt,
   HigherLevelAnalysis_package *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode bioAssayDataCluster_assnlist */

   if (pvalue->m.bioAssayDataCluster_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_BioAssayDataCluster_assnlist (pctxt, &pvalue->bioAssayDataCluster_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_HigherLevelAnalysis_package (OSCTXT* pctxt, 
   HigherLevelAnalysis_package* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bioAssayDataCluster_assnlist */

   if (pvalue->m.bioAssayDataCluster_assnlistPresent) {
      stat = XmlEnc_BioAssayDataCluster_assnlist (pctxt, &pvalue->
         bioAssayDataCluster_assnlist
         , OSUTF8("BioAssayDataCluster_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MAGE_ML                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MAGE_ML (OSCTXT* pctxt,
   MAGE_ML *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode higherLevelAnalysis_package */

   if (pvalue->m.higherLevelAnalysis_packagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|18,
         asn1E_HigherLevelAnalysis_package (pctxt, &pvalue->higherLevelAnalysis_package, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode experiment_package */

   if (pvalue->m.experiment_packagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|17,
         asn1E_Experiment_package (pctxt, &pvalue->experiment_package, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioAssayData_package */

   if (pvalue->m.bioAssayData_packagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|16,
         asn1E_BioAssayData_package (pctxt, &pvalue->bioAssayData_package, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode quantitationType_package */

   if (pvalue->m.quantitationType_packagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|15,
         asn1E_QuantitationType_package (pctxt, &pvalue->quantitationType_package, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioAssay_package */

   if (pvalue->m.bioAssay_packagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|14,
         asn1E_BioAssay_package (pctxt, &pvalue->bioAssay_package, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode array_package */

   if (pvalue->m.array_packagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|13,
         asn1E_Array_package (pctxt, &pvalue->array_package, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode arrayDesign_package */

   if (pvalue->m.arrayDesign_packagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|12,
         asn1E_ArrayDesign_package (pctxt, &pvalue->arrayDesign_package, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode designElement_package */

   if (pvalue->m.designElement_packagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|11,
         asn1E_DesignElement_package (pctxt, &pvalue->designElement_package, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioSequence_package */

   if (pvalue->m.bioSequence_packagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10,
         asn1E_BioSequence_package (pctxt, &pvalue->bioSequence_package, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioMaterial_package */

   if (pvalue->m.bioMaterial_packagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9,
         asn1E_BioMaterial_package (pctxt, &pvalue->bioMaterial_package, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode protocol_package */

   if (pvalue->m.protocol_packagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_Protocol_package (pctxt, &pvalue->protocol_package, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioEvent_package */

   if (pvalue->m.bioEvent_packagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_BioEvent_package (pctxt, &pvalue->bioEvent_package, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bQS_package */

   if (pvalue->m.bQS_packagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_BQS_package (pctxt, &pvalue->bQS_package, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode measurement_package */

   if (pvalue->m.measurement_packagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_Measurement_package (pctxt, &pvalue->measurement_package, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode description_package */

   if (pvalue->m.description_packagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Description_package (pctxt, &pvalue->description_package, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode auditAndSecurity_package */

   if (pvalue->m.auditAndSecurity_packagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_AuditAndSecurity_package (pctxt, &pvalue->auditAndSecurity_package, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MAGE_ML (OSCTXT* pctxt, MAGE_ML* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode auditAndSecurity_package */

   if (pvalue->m.auditAndSecurity_packagePresent) {
      stat = XmlEnc_AuditAndSecurity_package (pctxt, &pvalue->
         auditAndSecurity_package
         , OSUTF8("AuditAndSecurity_package"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode description_package */

   if (pvalue->m.description_packagePresent) {
      stat = XmlEnc_Description_package (pctxt, &pvalue->description_package
         , OSUTF8("Description_package"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode measurement_package */

   if (pvalue->m.measurement_packagePresent) {
      stat = XmlEnc_Measurement_package (pctxt, &pvalue->measurement_package
         , OSUTF8("Measurement_package"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bQS_package */

   if (pvalue->m.bQS_packagePresent) {
      stat = XmlEnc_BQS_package (pctxt, &pvalue->bQS_package
         , OSUTF8("BQS_package"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioEvent_package */

   if (pvalue->m.bioEvent_packagePresent) {
      stat = XmlEnc_BioEvent_package (pctxt, &pvalue->bioEvent_package
         , OSUTF8("BioEvent_package"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode protocol_package */

   if (pvalue->m.protocol_packagePresent) {
      stat = XmlEnc_Protocol_package (pctxt, &pvalue->protocol_package
         , OSUTF8("Protocol_package"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioMaterial_package */

   if (pvalue->m.bioMaterial_packagePresent) {
      stat = XmlEnc_BioMaterial_package (pctxt, &pvalue->bioMaterial_package
         , OSUTF8("BioMaterial_package"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioSequence_package */

   if (pvalue->m.bioSequence_packagePresent) {
      stat = XmlEnc_BioSequence_package (pctxt, &pvalue->bioSequence_package
         , OSUTF8("BioSequence_package"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode designElement_package */

   if (pvalue->m.designElement_packagePresent) {
      stat = XmlEnc_DesignElement_package (pctxt, &pvalue->
         designElement_package, OSUTF8("DesignElement_package"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode arrayDesign_package */

   if (pvalue->m.arrayDesign_packagePresent) {
      stat = XmlEnc_ArrayDesign_package (pctxt, &pvalue->arrayDesign_package
         , OSUTF8("ArrayDesign_package"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode array_package */

   if (pvalue->m.array_packagePresent) {
      stat = XmlEnc_Array_package (pctxt, &pvalue->array_package
         , OSUTF8("Array_package"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioAssay_package */

   if (pvalue->m.bioAssay_packagePresent) {
      stat = XmlEnc_BioAssay_package (pctxt, &pvalue->bioAssay_package
         , OSUTF8("BioAssay_package"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationType_package */

   if (pvalue->m.quantitationType_packagePresent) {
      stat = XmlEnc_QuantitationType_package (pctxt, &pvalue->
         quantitationType_package
         , OSUTF8("QuantitationType_package"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioAssayData_package */

   if (pvalue->m.bioAssayData_packagePresent) {
      stat = XmlEnc_BioAssayData_package (pctxt, &pvalue->bioAssayData_package
         , OSUTF8("BioAssayData_package"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode experiment_package */

   if (pvalue->m.experiment_packagePresent) {
      stat = XmlEnc_Experiment_package (pctxt, &pvalue->experiment_package
         , OSUTF8("Experiment_package"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode higherLevelAnalysis_package */

   if (pvalue->m.higherLevelAnalysis_packagePresent) {
      stat = XmlEnc_HigherLevelAnalysis_package (pctxt, &pvalue->
         higherLevelAnalysis_package
         , OSUTF8("HigherLevelAnalysis_package"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantitationType_ref                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantitationType_ref (OSCTXT* pctxt,
   QuantitationType_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuantitationType_ref (OSCTXT* pctxt, QuantitationType_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  StandardQuantitationType_ref                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_StandardQuantitationType_ref (OSCTXT* pctxt,
   StandardQuantitationType_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_StandardQuantitationType_ref (OSCTXT* pctxt, 
   StandardQuantitationType_ref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConfidenceIndicator_classes                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ConfidenceIndicator_classes (OSCTXT* pctxt,
   ConfidenceIndicator_classes *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_Error (pctxt, pvalue->u.error, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_PValue (pctxt, pvalue->u.pValue, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_ExpectedValue (pctxt, pvalue->u.expectedValue, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_ConfidenceIndicator_classes (OSCTXT* pctxt, 
   ConfidenceIndicator_classes* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode error */

         stat = XmlEnc_Error (pctxt, pvalue->u.error
            , OSUTF8("Error"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode pValue */

         stat = XmlEnc_PValue (pctxt, pvalue->u.pValue
            , OSUTF8("PValue"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode expectedValue */

         stat = XmlEnc_ExpectedValue (pctxt, pvalue->u.expectedValue
            , OSUTF8("ExpectedValue"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConfidenceIndicator_assnlist                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ConfidenceIndicator_assnlist (OSCTXT* pctxt,
   ConfidenceIndicator_assnlist *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ConfidenceIndicator_assnlist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_ConfidenceIndicator_classes (pctxt, ((ConfidenceIndicator_classes*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ConfidenceIndicator_assnlist (OSCTXT* pctxt, 
   ConfidenceIndicator_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ConfidenceIndicator_assnlist.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_ConfidenceIndicator_classes (pctxt, 
         ((ConfidenceIndicator_classes*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConfidenceIndicator_ref                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ConfidenceIndicator_ref (OSCTXT* pctxt,
   ConfidenceIndicator_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ConfidenceIndicator_ref (OSCTXT* pctxt, 
   ConfidenceIndicator_ref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Contact_ref                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Contact_ref (OSCTXT* pctxt,
   Contact_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Contact_ref (OSCTXT* pctxt, Contact_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Organization_assnlist                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Organization_assnlist (OSCTXT* pctxt,
   Organization_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode organization_list */

   if (!(pvalue->organization_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Organization_assnlist.organization_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->organization_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->organization_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Organization (pctxt, ((Organization*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Organization_assnlist (OSCTXT* pctxt, 
   Organization_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode organization_list */

   if (!(pvalue->organization_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Organization_assnlist.organization_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->organization_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->organization_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Organization (pctxt, ((Organization*)pnode->data)
         , OSUTF8("Organization"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Person_assnlist                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Person_assnlist (OSCTXT* pctxt,
   Person_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode person_list */

   if (!(pvalue->person_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Person_assnlist.person_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->person_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->person_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Person (pctxt, ((Person*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Person_assnlist (OSCTXT* pctxt, Person_assnlist* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode person_list */

   if (!(pvalue->person_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "Person_assnlist.person_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->person_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->person_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Person (pctxt, ((Person*)pnode->data)
         , OSUTF8("Person"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Array_assnref                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Array_assnref (OSCTXT* pctxt,
   Array_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode array_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_Array_ref (pctxt, &pvalue->array_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Array_assnref (OSCTXT* pctxt, Array_assnref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode array_ref */

   stat = XmlEnc_Array_ref (pctxt, &pvalue->array_ref
      , OSUTF8("Array_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioMaterial_ref                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioMaterial_ref (OSCTXT* pctxt,
   BioMaterial_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioMaterial_ref (OSCTXT* pctxt, BioMaterial_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssay_ref                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssay_ref (OSCTXT* pctxt,
   BioAssay_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssay_ref (OSCTXT* pctxt, BioAssay_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DerivedBioAssay_assnlist                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DerivedBioAssay_assnlist (OSCTXT* pctxt,
   DerivedBioAssay_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode derivedBioAssay_list */

   if (!(pvalue->derivedBioAssay_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DerivedBioAssay_assnlist.derivedBioAssay_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->derivedBioAssay_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->derivedBioAssay_list.tail;
   while (0 != pnode2) {
      ll = asn1E_DerivedBioAssay (pctxt, ((DerivedBioAssay*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DerivedBioAssay_assnlist (OSCTXT* pctxt, 
   DerivedBioAssay_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode derivedBioAssay_list */

   if (!(pvalue->derivedBioAssay_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DerivedBioAssay_assnlist.derivedBioAssay_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->derivedBioAssay_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->derivedBioAssay_list.head;
   while (0 != pnode) {
      stat = XmlEnc_DerivedBioAssay (pctxt, ((DerivedBioAssay*)pnode->data)
         , OSUTF8("DerivedBioAssay"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasuredBioAssay_assnlist                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MeasuredBioAssay_assnlist (OSCTXT* pctxt,
   MeasuredBioAssay_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode measuredBioAssay_list */

   if (!(pvalue->measuredBioAssay_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "MeasuredBioAssay_assnlist.measuredBioAssay_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->measuredBioAssay_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->measuredBioAssay_list.tail;
   while (0 != pnode2) {
      ll = asn1E_MeasuredBioAssay (pctxt, ((MeasuredBioAssay*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MeasuredBioAssay_assnlist (OSCTXT* pctxt, 
   MeasuredBioAssay_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode measuredBioAssay_list */

   if (!(pvalue->measuredBioAssay_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "MeasuredBioAssay_assnlist.measuredBioAssay_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->measuredBioAssay_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->measuredBioAssay_list.head;
   while (0 != pnode) {
      stat = XmlEnc_MeasuredBioAssay (pctxt, ((MeasuredBioAssay*)pnode->data)
         , OSUTF8("MeasuredBioAssay"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasuredBioAssayTarget_assnref                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MeasuredBioAssayTarget_assnref (OSCTXT* pctxt,
   MeasuredBioAssayTarget_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode measuredBioAssay_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_MeasuredBioAssay_ref (pctxt, &pvalue->measuredBioAssay_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MeasuredBioAssayTarget_assnref (OSCTXT* pctxt, 
   MeasuredBioAssayTarget_assnref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode measuredBioAssay_ref */

   stat = XmlEnc_MeasuredBioAssay_ref (pctxt, &pvalue->measuredBioAssay_ref
      , OSUTF8("MeasuredBioAssay_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PhysicalBioAssay_assnlist                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PhysicalBioAssay_assnlist (OSCTXT* pctxt,
   PhysicalBioAssay_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode physicalBioAssay_list */

   if (!(pvalue->physicalBioAssay_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "PhysicalBioAssay_assnlist.physicalBioAssay_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->physicalBioAssay_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->physicalBioAssay_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PhysicalBioAssay (pctxt, ((PhysicalBioAssay*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PhysicalBioAssay_assnlist (OSCTXT* pctxt, 
   PhysicalBioAssay_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode physicalBioAssay_list */

   if (!(pvalue->physicalBioAssay_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "PhysicalBioAssay_assnlist.physicalBioAssay_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->physicalBioAssay_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->physicalBioAssay_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PhysicalBioAssay (pctxt, ((PhysicalBioAssay*)pnode->data)
         , OSUTF8("PhysicalBioAssay"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PhysicalBioAssay_assnref                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PhysicalBioAssay_assnref (OSCTXT* pctxt,
   PhysicalBioAssay_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode physicalBioAssay_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_PhysicalBioAssay_ref (pctxt, &pvalue->physicalBioAssay_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PhysicalBioAssay_assnref (OSCTXT* pctxt, 
   PhysicalBioAssay_assnref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode physicalBioAssay_ref */

   stat = XmlEnc_PhysicalBioAssay_ref (pctxt, &pvalue->physicalBioAssay_ref
      , OSUTF8("PhysicalBioAssay_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PhysicalBioAssayTarget_assnref                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PhysicalBioAssayTarget_assnref (OSCTXT* pctxt,
   PhysicalBioAssayTarget_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode physicalBioAssay_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_PhysicalBioAssay_ref (pctxt, &pvalue->physicalBioAssay_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PhysicalBioAssayTarget_assnref (OSCTXT* pctxt, 
   PhysicalBioAssayTarget_assnref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode physicalBioAssay_ref */

   stat = XmlEnc_PhysicalBioAssay_ref (pctxt, &pvalue->physicalBioAssay_ref
      , OSUTF8("PhysicalBioAssay_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayData_ref                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayData_ref (OSCTXT* pctxt,
   BioAssayData_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayData_ref (OSCTXT* pctxt, BioAssayData_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DerivedBioAssayData_assnlist                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DerivedBioAssayData_assnlist (OSCTXT* pctxt,
   DerivedBioAssayData_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode derivedBioAssayData_list */

   if (!(pvalue->derivedBioAssayData_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DerivedBioAssayData_assnlist.derivedBioAssayData_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->derivedBioAssayData_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->derivedBioAssayData_list.tail;
   while (0 != pnode2) {
      ll = asn1E_DerivedBioAssayData (pctxt, ((DerivedBioAssayData*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DerivedBioAssayData_assnlist (OSCTXT* pctxt, 
   DerivedBioAssayData_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode derivedBioAssayData_list */

   if (!(pvalue->derivedBioAssayData_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DerivedBioAssayData_assnlist.derivedBioAssayData_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->derivedBioAssayData_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->derivedBioAssayData_list.head;
   while (0 != pnode) {
      stat = XmlEnc_DerivedBioAssayData (pctxt, 
         ((DerivedBioAssayData*)pnode->data)
         , OSUTF8("DerivedBioAssayData"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DerivedBioAssayDataTarget_assnref                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DerivedBioAssayDataTarget_assnref (OSCTXT* pctxt,
   DerivedBioAssayDataTarget_assnref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode derivedBioAssayData_ref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_DerivedBioAssayData_ref (pctxt, &pvalue->derivedBioAssayData_ref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DerivedBioAssayDataTarget_assnref (OSCTXT* pctxt, 
   DerivedBioAssayDataTarget_assnref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode derivedBioAssayData_ref */

   stat = XmlEnc_DerivedBioAssayData_ref (pctxt, &pvalue->
      derivedBioAssayData_ref, OSUTF8("DerivedBioAssayData_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElementDimension_ref                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElementDimension_ref (OSCTXT* pctxt,
   DesignElementDimension_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DesignElementDimension_ref (OSCTXT* pctxt, 
   DesignElementDimension_ref* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElementMap_classes_group                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElementMap_classes_group (OSCTXT* pctxt,
   DesignElementMap_classes_group *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_CompositeCompositeMap (pctxt, pvalue->u.compositeCompositeMap, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_FeatureReporterMap (pctxt, pvalue->u.featureReporterMap, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_ReporterCompositeMap (pctxt, pvalue->u.reporterCompositeMap, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_DesignElementMap_classes_group (OSCTXT* pctxt, 
   DesignElementMap_classes_group* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode compositeCompositeMap */

         stat = XmlEnc_CompositeCompositeMap (pctxt, pvalue->
            u.compositeCompositeMap
            , OSUTF8("CompositeCompositeMap"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode featureReporterMap */

         stat = XmlEnc_FeatureReporterMap (pctxt, pvalue->u.featureReporterMap
            , OSUTF8("FeatureReporterMap"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode reporterCompositeMap */

         stat = XmlEnc_ReporterCompositeMap (pctxt, pvalue->
            u.reporterCompositeMap, OSUTF8("ReporterCompositeMap"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElementMap_assnlist                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElementMap_assnlist (OSCTXT* pctxt,
   DesignElementMap_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode designElementMap_classes_list */

   if (!(pvalue->designElementMap_classes_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DesignElementMap_assnlist.designElementMap_classes_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->designElementMap_classes_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->designElementMap_classes_list.tail;
   while (0 != pnode2) {
      ll = asn1E_DesignElementMap_classes_group (pctxt, ((DesignElementMap_classes_group*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DesignElementMap_assnlist (OSCTXT* pctxt, 
   DesignElementMap_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode designElementMap_classes_list */

   if (!(pvalue->designElementMap_classes_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DesignElementMap_assnlist.designElementMap_classes_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->designElementMap_classes_list.count
         );
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->designElementMap_classes_list.head;
   while (0 != pnode) {
      stat = XmlEnc_DesignElementMap_classes_group (pctxt, 
         ((DesignElementMap_classes_group*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElementMap_ref                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElementMap_ref (OSCTXT* pctxt,
   DesignElementMap_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DesignElementMap_ref (OSCTXT* pctxt, DesignElementMap_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasuredBioAssayData_assnlist                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MeasuredBioAssayData_assnlist (OSCTXT* pctxt,
   MeasuredBioAssayData_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode measuredBioAssayData_list */

   if (!(pvalue->measuredBioAssayData_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "MeasuredBioAssayData_assnlist.measuredBioAssayData_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->measuredBioAssayData_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->measuredBioAssayData_list.tail;
   while (0 != pnode2) {
      ll = asn1E_MeasuredBioAssayData (pctxt, ((MeasuredBioAssayData*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_MeasuredBioAssayData_assnlist (OSCTXT* pctxt, 
   MeasuredBioAssayData_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode measuredBioAssayData_list */

   if (!(pvalue->measuredBioAssayData_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "MeasuredBioAssayData_assnlist.measuredBioAssayData_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->measuredBioAssayData_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->measuredBioAssayData_list.head;
   while (0 != pnode) {
      stat = XmlEnc_MeasuredBioAssayData (pctxt, 
         ((MeasuredBioAssayData*)pnode->data)
         , OSUTF8("MeasuredBioAssayData"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElement_classes_group                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElement_classes_group (OSCTXT* pctxt,
   DesignElement_classes_group *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_CompositeSequence (pctxt, pvalue->u.compositeSequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_Feature (pctxt, pvalue->u.feature, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_Reporter (pctxt, pvalue->u.reporter, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_DesignElement_classes_group (OSCTXT* pctxt, 
   DesignElement_classes_group* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   switch (pvalue->t)
   {
      case 1:
         /* encode compositeSequence */

         stat = XmlEnc_CompositeSequence (pctxt, pvalue->u.compositeSequence
            , OSUTF8("CompositeSequence"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode feature */

         stat = XmlEnc_Feature (pctxt, pvalue->u.feature
            , OSUTF8("Feature"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode reporter */

         stat = XmlEnc_Reporter (pctxt, pvalue->u.reporter
            , OSUTF8("Reporter"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElement_assnlist                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElement_assnlist (OSCTXT* pctxt,
   DesignElement_assnlist *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode designElement_classes_list */

   if (!(pvalue->designElement_classes_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DesignElement_assnlist.designElement_classes_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->designElement_classes_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->designElement_classes_list.tail;
   while (0 != pnode2) {
      ll = asn1E_DesignElement_classes_group (pctxt, ((DesignElement_classes_group*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DesignElement_assnlist (OSCTXT* pctxt, 
   DesignElement_assnlist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode designElement_classes_list */

   if (!(pvalue->designElement_classes_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DesignElement_assnlist.designElement_classes_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->designElement_classes_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { OSRTDListNode* pnode = pvalue->designElement_classes_list.head;
   while (0 != pnode) {
      stat = XmlEnc_DesignElement_classes_group (pctxt, 
         ((DesignElement_classes_group*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DesignElement_ref                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DesignElement_ref (OSCTXT* pctxt,
   DesignElement_ref *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DesignElement_ref (OSCTXT* pctxt, DesignElement_ref* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayCreation_classes                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayCreation_classes (OSCTXT* pctxt,
   BioAssayCreation_classes *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode array_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_Array_assnref (pctxt, &pvalue->array_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode sourceBioMaterialMeasurements_assnlist */

   if (pvalue->m.sourceBioMaterialMeasurements_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_SourceBioMaterialMeasurements_assnlist (pctxt, &pvalue->sourceBioMaterialMeasurements_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioEvent_content */

   if (pvalue->m.bioEvent_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_BioEvent_content (pctxt, &pvalue->bioEvent_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayCreation_classes (OSCTXT* pctxt, 
   BioAssayCreation_classes* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode bioEvent_content */

   if (pvalue->m.bioEvent_contentPresent) {
      stat = XmlEnc_BioEvent_content (pctxt, &pvalue->bioEvent_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode sourceBioMaterialMeasurements_assnlist */

   if (pvalue->m.sourceBioMaterialMeasurements_assnlistPresent) {
      stat = XmlEnc_SourceBioMaterialMeasurements_assnlist (pctxt, &pvalue->
         sourceBioMaterialMeasurements_assnlist
         , OSUTF8("SourceBioMaterialMeasurements_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode array_assnref */

   stat = XmlEnc_Array_assnref (pctxt, &pvalue->array_assnref
      , OSUTF8("Array_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantitationType_content                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantitationType_content (OSCTXT* pctxt,
   QuantitationType_content *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->quantitationTypeMaps_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_ConfidenceIndicators_assnreflist (pctxt, &pvalue->confidenceIndicators_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dataType_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_DataType_assn (pctxt, &pvalue->dataType_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode scale_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_Scale_assn (pctxt, &pvalue->scale_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Channel_assnref (pctxt, &pvalue->channel_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuantitationType_content (OSCTXT* pctxt, 
   QuantitationType_content* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      stat = XmlEnc_Channel_assnref (pctxt, &pvalue->channel_assnref
         , OSUTF8("Channel_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode scale_assn */

   stat = XmlEnc_Scale_assn (pctxt, &pvalue->scale_assn
      , OSUTF8("Scale_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dataType_assn */

   stat = XmlEnc_DataType_assn (pctxt, &pvalue->dataType_assn
      , OSUTF8("DataType_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      stat = XmlEnc_ConfidenceIndicators_assnreflist (pctxt, &pvalue->
         confidenceIndicators_assnreflist
         , OSUTF8("ConfidenceIndicators_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      stat = XmlEnc_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->
         quantitationTypeMaps_assnreflist
         , OSUTF8("QuantitationTypeMaps_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  StandardQuantitationType_content                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_StandardQuantitationType_content (OSCTXT* pctxt,
   StandardQuantitationType_content *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->quantitationTypeMaps_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_ConfidenceIndicators_assnreflist (pctxt, &pvalue->confidenceIndicators_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dataType_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_DataType_assn (pctxt, &pvalue->dataType_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode scale_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_Scale_assn (pctxt, &pvalue->scale_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Channel_assnref (pctxt, &pvalue->channel_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_StandardQuantitationType_content (OSCTXT* pctxt, 
   StandardQuantitationType_content* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      stat = XmlEnc_Channel_assnref (pctxt, &pvalue->channel_assnref
         , OSUTF8("Channel_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode scale_assn */

   stat = XmlEnc_Scale_assn (pctxt, &pvalue->scale_assn
      , OSUTF8("Scale_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dataType_assn */

   stat = XmlEnc_DataType_assn (pctxt, &pvalue->dataType_assn
      , OSUTF8("DataType_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      stat = XmlEnc_ConfidenceIndicators_assnreflist (pctxt, &pvalue->
         confidenceIndicators_assnreflist
         , OSUTF8("ConfidenceIndicators_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      stat = XmlEnc_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->
         quantitationTypeMaps_assnreflist
         , OSUTF8("QuantitationTypeMaps_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConfidenceIndicator_content                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ConfidenceIndicator_content (OSCTXT* pctxt,
   ConfidenceIndicator_content *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode targetQuantitationType_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_TargetQuantitationType_assnref (pctxt, &pvalue->targetQuantitationType_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->quantitationTypeMaps_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_ConfidenceIndicators_assnreflist (pctxt, &pvalue->confidenceIndicators_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dataType_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_DataType_assn (pctxt, &pvalue->dataType_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode scale_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_Scale_assn (pctxt, &pvalue->scale_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Channel_assnref (pctxt, &pvalue->channel_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ConfidenceIndicator_content (OSCTXT* pctxt, 
   ConfidenceIndicator_content* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      stat = XmlEnc_Channel_assnref (pctxt, &pvalue->channel_assnref
         , OSUTF8("Channel_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode scale_assn */

   stat = XmlEnc_Scale_assn (pctxt, &pvalue->scale_assn
      , OSUTF8("Scale_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dataType_assn */

   stat = XmlEnc_DataType_assn (pctxt, &pvalue->dataType_assn
      , OSUTF8("DataType_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      stat = XmlEnc_ConfidenceIndicators_assnreflist (pctxt, &pvalue->
         confidenceIndicators_assnreflist
         , OSUTF8("ConfidenceIndicators_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      stat = XmlEnc_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->
         quantitationTypeMaps_assnreflist
         , OSUTF8("QuantitationTypeMaps_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode targetQuantitationType_assnref */

   stat = XmlEnc_TargetQuantitationType_assnref (pctxt, &pvalue->
      targetQuantitationType_assnref
      , OSUTF8("TargetQuantitationType_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ArrayDesign_content                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ArrayDesign_content (OSCTXT* pctxt,
   ArrayDesign_content *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode designProviders_assnreflist */

   if (pvalue->m.designProviders_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_DesignProviders_assnreflist (pctxt, &pvalue->designProviders_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode compositeGroups_assnreflist */

   if (pvalue->m.compositeGroups_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_CompositeGroups_assnreflist (pctxt, &pvalue->compositeGroups_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode reporterGroups_assnreflist */

   if (pvalue->m.reporterGroups_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_ReporterGroups_assnreflist (pctxt, &pvalue->reporterGroups_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode featureGroups_assnlist */

   if (pvalue->m.featureGroups_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_FeatureGroups_assnlist (pctxt, &pvalue->featureGroups_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode protocolApplications_assnlist */

   if (pvalue->m.protocolApplications_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ProtocolApplications_assnlist (pctxt, &pvalue->protocolApplications_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ArrayDesign_content (OSCTXT* pctxt, ArrayDesign_content* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode protocolApplications_assnlist */

   if (pvalue->m.protocolApplications_assnlistPresent) {
      stat = XmlEnc_ProtocolApplications_assnlist (pctxt, &pvalue->
         protocolApplications_assnlist
         , OSUTF8("ProtocolApplications_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode featureGroups_assnlist */

   if (pvalue->m.featureGroups_assnlistPresent) {
      stat = XmlEnc_FeatureGroups_assnlist (pctxt, &pvalue->
         featureGroups_assnlist, OSUTF8("FeatureGroups_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode reporterGroups_assnreflist */

   if (pvalue->m.reporterGroups_assnreflistPresent) {
      stat = XmlEnc_ReporterGroups_assnreflist (pctxt, &pvalue->
         reporterGroups_assnreflist
         , OSUTF8("ReporterGroups_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode compositeGroups_assnreflist */

   if (pvalue->m.compositeGroups_assnreflistPresent) {
      stat = XmlEnc_CompositeGroups_assnreflist (pctxt, &pvalue->
         compositeGroups_assnreflist
         , OSUTF8("CompositeGroups_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode designProviders_assnreflist */

   if (pvalue->m.designProviders_assnreflistPresent) {
      stat = XmlEnc_DesignProviders_assnreflist (pctxt, &pvalue->
         designProviders_assnreflist
         , OSUTF8("DesignProviders_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ManufactureLIMS_content                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ManufactureLIMS_content (OSCTXT* pctxt,
   ManufactureLIMS_content *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode identifierLIMS_assn */

   if (pvalue->m.identifierLIMS_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_IdentifierLIMS_assn (pctxt, &pvalue->identifierLIMS_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioMaterial_assnref */

   if (pvalue->m.bioMaterial_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_BioMaterial_assnref (pctxt, &pvalue->bioMaterial_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode feature_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Feature_assnref (pctxt, &pvalue->feature_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Describable_content (pctxt, &pvalue->describable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ManufactureLIMS_content (OSCTXT* pctxt, 
   ManufactureLIMS_content* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      stat = XmlEnc_Describable_content (pctxt, &pvalue->describable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode feature_assnref */

   stat = XmlEnc_Feature_assnref (pctxt, &pvalue->feature_assnref
      , OSUTF8("Feature_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode bioMaterial_assnref */

   if (pvalue->m.bioMaterial_assnrefPresent) {
      stat = XmlEnc_BioMaterial_assnref (pctxt, &pvalue->bioMaterial_assnref
         , OSUTF8("BioMaterial_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode identifierLIMS_assn */

   if (pvalue->m.identifierLIMS_assnPresent) {
      stat = XmlEnc_IdentifierLIMS_assn (pctxt, &pvalue->identifierLIMS_assn
         , OSUTF8("IdentifierLIMS_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayCreation_content                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayCreation_content (OSCTXT* pctxt,
   BioAssayCreation_content *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode array_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_Array_assnref (pctxt, &pvalue->array_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode sourceBioMaterialMeasurements_assnlist */

   if (pvalue->m.sourceBioMaterialMeasurements_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_SourceBioMaterialMeasurements_assnlist (pctxt, &pvalue->sourceBioMaterialMeasurements_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioEvent_content */

   if (pvalue->m.bioEvent_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_BioEvent_content (pctxt, &pvalue->bioEvent_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayCreation_content (OSCTXT* pctxt, 
   BioAssayCreation_content* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bioEvent_content */

   if (pvalue->m.bioEvent_contentPresent) {
      stat = XmlEnc_BioEvent_content (pctxt, &pvalue->bioEvent_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode sourceBioMaterialMeasurements_assnlist */

   if (pvalue->m.sourceBioMaterialMeasurements_assnlistPresent) {
      stat = XmlEnc_SourceBioMaterialMeasurements_assnlist (pctxt, &pvalue->
         sourceBioMaterialMeasurements_assnlist
         , OSUTF8("SourceBioMaterialMeasurements_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode array_assnref */

   stat = XmlEnc_Array_assnref (pctxt, &pvalue->array_assnref
      , OSUTF8("Array_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayTreatment_content                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayTreatment_content (OSCTXT* pctxt,
   BioAssayTreatment_content *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode target_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_Target_assnref (pctxt, &pvalue->target_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode bioEvent_content */

   if (pvalue->m.bioEvent_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_BioEvent_content (pctxt, &pvalue->bioEvent_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayTreatment_content (OSCTXT* pctxt, 
   BioAssayTreatment_content* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode bioEvent_content */

   if (pvalue->m.bioEvent_contentPresent) {
      stat = XmlEnc_BioEvent_content (pctxt, &pvalue->bioEvent_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode target_assnref */

   stat = XmlEnc_Target_assnref (pctxt, &pvalue->target_assnref
      , OSUTF8("Target_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayData_content                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayData_content (OSCTXT* pctxt,
   BioAssayData_content *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode bioDataValues_assn */

   if (pvalue->m.bioDataValues_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_BioDataValues_assn (pctxt, &pvalue->bioDataValues_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode quantitationTypeDimension_assnref */

   if (pvalue->m.quantitationTypeDimension_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_QuantitationTypeDimension_assnref (pctxt, &pvalue->quantitationTypeDimension_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode designElementDimension_assnref */

   if (pvalue->m.designElementDimension_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_DesignElementDimension_assnref (pctxt, &pvalue->designElementDimension_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioAssayDimension_assnref */

   if (pvalue->m.bioAssayDimension_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_BioAssayDimension_assnref (pctxt, &pvalue->bioAssayDimension_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode summaryStatistics_assnlist */

   if (pvalue->m.summaryStatistics_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_SummaryStatistics_assnlist (pctxt, &pvalue->summaryStatistics_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayData_content (OSCTXT* pctxt, BioAssayData_content* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode summaryStatistics_assnlist */

   if (pvalue->m.summaryStatistics_assnlistPresent) {
      stat = XmlEnc_SummaryStatistics_assnlist (pctxt, &pvalue->
         summaryStatistics_assnlist
         , OSUTF8("SummaryStatistics_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioAssayDimension_assnref */

   if (pvalue->m.bioAssayDimension_assnrefPresent) {
      stat = XmlEnc_BioAssayDimension_assnref (pctxt, &pvalue->
         bioAssayDimension_assnref
         , OSUTF8("BioAssayDimension_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode designElementDimension_assnref */

   if (pvalue->m.designElementDimension_assnrefPresent) {
      stat = XmlEnc_DesignElementDimension_assnref (pctxt, &pvalue->
         designElementDimension_assnref
         , OSUTF8("DesignElementDimension_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeDimension_assnref */

   if (pvalue->m.quantitationTypeDimension_assnrefPresent) {
      stat = XmlEnc_QuantitationTypeDimension_assnref (pctxt, &pvalue->
         quantitationTypeDimension_assnref
         , OSUTF8("QuantitationTypeDimension_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioDataValues_assn */

   if (pvalue->m.bioDataValues_assnPresent) {
      stat = XmlEnc_BioDataValues_assn (pctxt, &pvalue->bioDataValues_assn
         , OSUTF8("BioDataValues_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantitationType_content_derivations_specializedQuantita  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantitationType_content_derivations_specializedQuantitationType (OSCTXT* pctxt,
   QuantitationType_content_derivations_specializedQuantitationType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->quantitationTypeMaps_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_ConfidenceIndicators_assnreflist (pctxt, &pvalue->confidenceIndicators_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dataType_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_DataType_assn (pctxt, &pvalue->dataType_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode scale_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_Scale_assn (pctxt, &pvalue->scale_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Channel_assnref (pctxt, &pvalue->channel_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode isBackground */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->isBackground, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_QuantitationType_content_derivations_specializedQuantitationType 
   (OSCTXT* pctxt, 
   QuantitationType_content_derivations_specializedQuantitationType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" isBackground=\""), 15);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->isBackground, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      stat = XmlEnc_Channel_assnref (pctxt, &pvalue->channel_assnref
         , OSUTF8("Channel_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode scale_assn */

   stat = XmlEnc_Scale_assn (pctxt, &pvalue->scale_assn
      , OSUTF8("Scale_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dataType_assn */

   stat = XmlEnc_DataType_assn (pctxt, &pvalue->dataType_assn
      , OSUTF8("DataType_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      stat = XmlEnc_ConfidenceIndicators_assnreflist (pctxt, &pvalue->
         confidenceIndicators_assnreflist
         , OSUTF8("ConfidenceIndicators_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      stat = XmlEnc_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->
         quantitationTypeMaps_assnreflist
         , OSUTF8("QuantitationTypeMaps_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  StandardQuantitationType_content_derivations_derivedSign  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_StandardQuantitationType_content_derivations_derivedSignal (OSCTXT* pctxt,
   StandardQuantitationType_content_derivations_derivedSignal *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->quantitationTypeMaps_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_ConfidenceIndicators_assnreflist (pctxt, &pvalue->confidenceIndicators_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dataType_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_DataType_assn (pctxt, &pvalue->dataType_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode scale_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_Scale_assn (pctxt, &pvalue->scale_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Channel_assnref (pctxt, &pvalue->channel_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode isBackground */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->isBackground, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_StandardQuantitationType_content_derivations_derivedSignal 
   (OSCTXT* pctxt, 
   StandardQuantitationType_content_derivations_derivedSignal* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" isBackground=\""), 15);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->isBackground, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      stat = XmlEnc_Channel_assnref (pctxt, &pvalue->channel_assnref
         , OSUTF8("Channel_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode scale_assn */

   stat = XmlEnc_Scale_assn (pctxt, &pvalue->scale_assn
      , OSUTF8("Scale_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dataType_assn */

   stat = XmlEnc_DataType_assn (pctxt, &pvalue->dataType_assn
      , OSUTF8("DataType_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      stat = XmlEnc_ConfidenceIndicators_assnreflist (pctxt, &pvalue->
         confidenceIndicators_assnreflist
         , OSUTF8("ConfidenceIndicators_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      stat = XmlEnc_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->
         quantitationTypeMaps_assnreflist
         , OSUTF8("QuantitationTypeMaps_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  StandardQuantitationType_content_derivations_measuredSig  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_StandardQuantitationType_content_derivations_measuredSignal (OSCTXT* pctxt,
   StandardQuantitationType_content_derivations_measuredSignal *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->quantitationTypeMaps_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_ConfidenceIndicators_assnreflist (pctxt, &pvalue->confidenceIndicators_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dataType_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_DataType_assn (pctxt, &pvalue->dataType_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode scale_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_Scale_assn (pctxt, &pvalue->scale_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Channel_assnref (pctxt, &pvalue->channel_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode isBackground */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->isBackground, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_StandardQuantitationType_content_derivations_measuredSignal 
   (OSCTXT* pctxt, 
   StandardQuantitationType_content_derivations_measuredSignal* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" isBackground=\""), 15);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->isBackground, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      stat = XmlEnc_Channel_assnref (pctxt, &pvalue->channel_assnref
         , OSUTF8("Channel_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode scale_assn */

   stat = XmlEnc_Scale_assn (pctxt, &pvalue->scale_assn
      , OSUTF8("Scale_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dataType_assn */

   stat = XmlEnc_DataType_assn (pctxt, &pvalue->dataType_assn
      , OSUTF8("DataType_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      stat = XmlEnc_ConfidenceIndicators_assnreflist (pctxt, &pvalue->
         confidenceIndicators_assnreflist
         , OSUTF8("ConfidenceIndicators_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      stat = XmlEnc_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->
         quantitationTypeMaps_assnreflist
         , OSUTF8("QuantitationTypeMaps_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConfidenceIndicator_content_derivations_error             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ConfidenceIndicator_content_derivations_error (OSCTXT* pctxt,
   ConfidenceIndicator_content_derivations_error *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->quantitationTypeMaps_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_ConfidenceIndicators_assnreflist (pctxt, &pvalue->confidenceIndicators_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dataType_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_DataType_assn (pctxt, &pvalue->dataType_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode scale_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_Scale_assn (pctxt, &pvalue->scale_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Channel_assnref (pctxt, &pvalue->channel_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode isBackground */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->isBackground, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ConfidenceIndicator_content_derivations_error (OSCTXT* pctxt, 
   ConfidenceIndicator_content_derivations_error* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" isBackground=\""), 15);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->isBackground, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      stat = XmlEnc_Channel_assnref (pctxt, &pvalue->channel_assnref
         , OSUTF8("Channel_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode scale_assn */

   stat = XmlEnc_Scale_assn (pctxt, &pvalue->scale_assn
      , OSUTF8("Scale_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dataType_assn */

   stat = XmlEnc_DataType_assn (pctxt, &pvalue->dataType_assn
      , OSUTF8("DataType_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      stat = XmlEnc_ConfidenceIndicators_assnreflist (pctxt, &pvalue->
         confidenceIndicators_assnreflist
         , OSUTF8("ConfidenceIndicators_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      stat = XmlEnc_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->
         quantitationTypeMaps_assnreflist
         , OSUTF8("QuantitationTypeMaps_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConfidenceIndicator_content_derivations_pValue            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ConfidenceIndicator_content_derivations_pValue (OSCTXT* pctxt,
   ConfidenceIndicator_content_derivations_pValue *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->quantitationTypeMaps_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_ConfidenceIndicators_assnreflist (pctxt, &pvalue->confidenceIndicators_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dataType_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_DataType_assn (pctxt, &pvalue->dataType_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode scale_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_Scale_assn (pctxt, &pvalue->scale_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Channel_assnref (pctxt, &pvalue->channel_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode isBackground */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->isBackground, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ConfidenceIndicator_content_derivations_pValue (OSCTXT* pctxt, 
   ConfidenceIndicator_content_derivations_pValue* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" isBackground=\""), 15);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->isBackground, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      stat = XmlEnc_Channel_assnref (pctxt, &pvalue->channel_assnref
         , OSUTF8("Channel_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode scale_assn */

   stat = XmlEnc_Scale_assn (pctxt, &pvalue->scale_assn
      , OSUTF8("Scale_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dataType_assn */

   stat = XmlEnc_DataType_assn (pctxt, &pvalue->dataType_assn
      , OSUTF8("DataType_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      stat = XmlEnc_ConfidenceIndicators_assnreflist (pctxt, &pvalue->
         confidenceIndicators_assnreflist
         , OSUTF8("ConfidenceIndicators_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      stat = XmlEnc_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->
         quantitationTypeMaps_assnreflist
         , OSUTF8("QuantitationTypeMaps_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConfidenceIndicator_content_derivations_expectedValue     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ConfidenceIndicator_content_derivations_expectedValue (OSCTXT* pctxt,
   ConfidenceIndicator_content_derivations_expectedValue *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->quantitationTypeMaps_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_ConfidenceIndicators_assnreflist (pctxt, &pvalue->confidenceIndicators_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dataType_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_DataType_assn (pctxt, &pvalue->dataType_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode scale_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_Scale_assn (pctxt, &pvalue->scale_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Channel_assnref (pctxt, &pvalue->channel_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode isBackground */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->isBackground, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ConfidenceIndicator_content_derivations_expectedValue 
   (OSCTXT* pctxt, 
   ConfidenceIndicator_content_derivations_expectedValue* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" isBackground=\""), 15);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->isBackground, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      stat = XmlEnc_Channel_assnref (pctxt, &pvalue->channel_assnref
         , OSUTF8("Channel_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode scale_assn */

   stat = XmlEnc_Scale_assn (pctxt, &pvalue->scale_assn
      , OSUTF8("Scale_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dataType_assn */

   stat = XmlEnc_DataType_assn (pctxt, &pvalue->dataType_assn
      , OSUTF8("DataType_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      stat = XmlEnc_ConfidenceIndicators_assnreflist (pctxt, &pvalue->
         confidenceIndicators_assnreflist
         , OSUTF8("ConfidenceIndicators_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      stat = XmlEnc_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->
         quantitationTypeMaps_assnreflist
         , OSUTF8("QuantitationTypeMaps_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConfidenceIndicator_content_derivations                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ConfidenceIndicator_content_derivations (OSCTXT* pctxt,
   ConfidenceIndicator_content_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_ConfidenceIndicator_content (pctxt, pvalue->u.confidenceIndicator_content, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_ConfidenceIndicator_content_derivations_error (pctxt, pvalue->u.error, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_ConfidenceIndicator_content_derivations_pValue (pctxt, pvalue->u.pValue, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 4:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
            asn1E_ConfidenceIndicator_content_derivations_expectedValue (pctxt, pvalue->u.expectedValue, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_ConfidenceIndicator_content_derivations (OSCTXT* pctxt, 
   ConfidenceIndicator_content_derivations* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   switch (pvalue->t)
   {
      case 1:
         /* encode confidenceIndicator_content */

         stat = XmlEnc_ConfidenceIndicator_content (pctxt, pvalue->
            u.confidenceIndicator_content, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode error */

         stat = XmlEnc_ConfidenceIndicator_content_derivations_error (pctxt, 
            pvalue->u.error, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode pValue */

         stat = XmlEnc_ConfidenceIndicator_content_derivations_pValue (pctxt, 
            pvalue->u.pValue, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 4:
         /* encode expectedValue */

         stat = XmlEnc_ConfidenceIndicator_content_derivations_expectedValue (pctxt
            , pvalue->u.expectedValue, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  StandardQuantitationType_content_derivations_ratio        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_StandardQuantitationType_content_derivations_ratio (OSCTXT* pctxt,
   StandardQuantitationType_content_derivations_ratio *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->quantitationTypeMaps_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_ConfidenceIndicators_assnreflist (pctxt, &pvalue->confidenceIndicators_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dataType_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_DataType_assn (pctxt, &pvalue->dataType_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode scale_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_Scale_assn (pctxt, &pvalue->scale_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Channel_assnref (pctxt, &pvalue->channel_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode isBackground */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->isBackground, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_StandardQuantitationType_content_derivations_ratio (OSCTXT* pctxt, 
   StandardQuantitationType_content_derivations_ratio* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" isBackground=\""), 15);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->isBackground, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      stat = XmlEnc_Channel_assnref (pctxt, &pvalue->channel_assnref
         , OSUTF8("Channel_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode scale_assn */

   stat = XmlEnc_Scale_assn (pctxt, &pvalue->scale_assn
      , OSUTF8("Scale_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dataType_assn */

   stat = XmlEnc_DataType_assn (pctxt, &pvalue->dataType_assn
      , OSUTF8("DataType_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      stat = XmlEnc_ConfidenceIndicators_assnreflist (pctxt, &pvalue->
         confidenceIndicators_assnreflist
         , OSUTF8("ConfidenceIndicators_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      stat = XmlEnc_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->
         quantitationTypeMaps_assnreflist
         , OSUTF8("QuantitationTypeMaps_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  StandardQuantitationType_content_derivations_presentAbse  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_StandardQuantitationType_content_derivations_presentAbsent (OSCTXT* pctxt,
   StandardQuantitationType_content_derivations_presentAbsent *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->quantitationTypeMaps_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_ConfidenceIndicators_assnreflist (pctxt, &pvalue->confidenceIndicators_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dataType_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_DataType_assn (pctxt, &pvalue->dataType_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode scale_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_Scale_assn (pctxt, &pvalue->scale_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Channel_assnref (pctxt, &pvalue->channel_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode isBackground */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->isBackground, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_StandardQuantitationType_content_derivations_presentAbsent 
   (OSCTXT* pctxt, 
   StandardQuantitationType_content_derivations_presentAbsent* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" isBackground=\""), 15);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->isBackground, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      stat = XmlEnc_Channel_assnref (pctxt, &pvalue->channel_assnref
         , OSUTF8("Channel_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode scale_assn */

   stat = XmlEnc_Scale_assn (pctxt, &pvalue->scale_assn
      , OSUTF8("Scale_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dataType_assn */

   stat = XmlEnc_DataType_assn (pctxt, &pvalue->dataType_assn
      , OSUTF8("DataType_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      stat = XmlEnc_ConfidenceIndicators_assnreflist (pctxt, &pvalue->
         confidenceIndicators_assnreflist
         , OSUTF8("ConfidenceIndicators_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      stat = XmlEnc_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->
         quantitationTypeMaps_assnreflist
         , OSUTF8("QuantitationTypeMaps_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  StandardQuantitationType_content_derivations_failed       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_StandardQuantitationType_content_derivations_failed (OSCTXT* pctxt,
   StandardQuantitationType_content_derivations_failed *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->quantitationTypeMaps_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_ConfidenceIndicators_assnreflist (pctxt, &pvalue->confidenceIndicators_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dataType_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_DataType_assn (pctxt, &pvalue->dataType_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode scale_assn */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_Scale_assn (pctxt, &pvalue->scale_assn, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Channel_assnref (pctxt, &pvalue->channel_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode isBackground */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->isBackground, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_StandardQuantitationType_content_derivations_failed (OSCTXT* pctxt, 
   StandardQuantitationType_content_derivations_failed* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" isBackground=\""), 15);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->isBackground, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode channel_assnref */

   if (pvalue->m.channel_assnrefPresent) {
      stat = XmlEnc_Channel_assnref (pctxt, &pvalue->channel_assnref
         , OSUTF8("Channel_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode scale_assn */

   stat = XmlEnc_Scale_assn (pctxt, &pvalue->scale_assn
      , OSUTF8("Scale_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dataType_assn */

   stat = XmlEnc_DataType_assn (pctxt, &pvalue->dataType_assn
      , OSUTF8("DataType_assn"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode confidenceIndicators_assnreflist */

   if (pvalue->m.confidenceIndicators_assnreflistPresent) {
      stat = XmlEnc_ConfidenceIndicators_assnreflist (pctxt, &pvalue->
         confidenceIndicators_assnreflist
         , OSUTF8("ConfidenceIndicators_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeMaps_assnreflist */

   if (pvalue->m.quantitationTypeMaps_assnreflistPresent) {
      stat = XmlEnc_QuantitationTypeMaps_assnreflist (pctxt, &pvalue->
         quantitationTypeMaps_assnreflist
         , OSUTF8("QuantitationTypeMaps_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  StandardQuantitationType_content_derivations              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_StandardQuantitationType_content_derivations (OSCTXT* pctxt,
   StandardQuantitationType_content_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_StandardQuantitationType_content (pctxt, pvalue->u.standardQuantitationType_content, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_StandardQuantitationType_content_derivations_derivedSignal (pctxt, pvalue->u.derivedSignal, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_StandardQuantitationType_content_derivations_measuredSignal (pctxt, pvalue->u.measuredSignal, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 4:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
            asn1E_ConfidenceIndicator_content_derivations (pctxt, pvalue->u.confidenceIndicator_content, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 5:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
            asn1E_StandardQuantitationType_content_derivations_ratio (pctxt, pvalue->u.ratio, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 6:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
            asn1E_StandardQuantitationType_content_derivations_presentAbsent (pctxt, pvalue->u.presentAbsent, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 7:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
            asn1E_StandardQuantitationType_content_derivations_failed (pctxt, pvalue->u.failed, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_StandardQuantitationType_content_derivations (OSCTXT* pctxt, 
   StandardQuantitationType_content_derivations* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   switch (pvalue->t)
   {
      case 1:
         /* encode standardQuantitationType_content */

         stat = XmlEnc_StandardQuantitationType_content (pctxt, pvalue->
            u.standardQuantitationType_content, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode derivedSignal */

         stat = XmlEnc_StandardQuantitationType_content_derivations_derivedSignal (pctxt
            , pvalue->u.derivedSignal, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode measuredSignal */

         stat = XmlEnc_StandardQuantitationType_content_derivations_measuredSignal (pctxt
            , pvalue->u.measuredSignal, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 4:
         /* encode confidenceIndicator_content */

         stat = XmlEnc_ConfidenceIndicator_content_derivations (pctxt, pvalue->
            u.confidenceIndicator_content, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 5:
         /* encode ratio */

         stat = XmlEnc_StandardQuantitationType_content_derivations_ratio (pctxt
            , pvalue->u.ratio, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 6:
         /* encode presentAbsent */

         stat = XmlEnc_StandardQuantitationType_content_derivations_presentAbsent (pctxt
            , pvalue->u.presentAbsent, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 7:
         /* encode failed */

         stat = XmlEnc_StandardQuantitationType_content_derivations_failed (pctxt
            , pvalue->u.failed, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantitationType_content_derivations                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_QuantitationType_content_derivations (OSCTXT* pctxt,
   QuantitationType_content_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_QuantitationType_content (pctxt, pvalue->u.quantitationType_content, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_QuantitationType_content_derivations_specializedQuantitationType (pctxt, pvalue->u.specializedQuantitationType, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_StandardQuantitationType_content_derivations (pctxt, pvalue->u.standardQuantitationType_content, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_QuantitationType_content_derivations (OSCTXT* pctxt, 
   QuantitationType_content_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   switch (pvalue->t)
   {
      case 1:
         /* encode quantitationType_content */

         stat = XmlEnc_QuantitationType_content (pctxt, pvalue->
            u.quantitationType_content, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode specializedQuantitationType */

         stat = XmlEnc_QuantitationType_content_derivations_specializedQuantitationType (pctxt
            , pvalue->u.specializedQuantitationType, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode standardQuantitationType_content */

         stat = XmlEnc_StandardQuantitationType_content_derivations (pctxt, 
            pvalue->u.standardQuantitationType_content, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unit_content_derivations_distanceUnit                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Unit_content_derivations_distanceUnit (OSCTXT* pctxt,
   Unit_content_derivations_distanceUnit *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode unitNameCV */

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 7)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_Unit_content_derivations_distanceUnit_unitNameCV (pctxt, &pvalue->unitNameCV, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode unitName */

   if (pvalue->m.unitNamePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->unitName, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Unit_content_derivations_distanceUnit (OSCTXT* pctxt, 
   Unit_content_derivations_distanceUnit* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.unitNamePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitName=\""), 11);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->unitName, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitNameCV=\""), 13);

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 7)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_Unit_content_derivations_distanceUnit_unitNameCV (pctxt, 
      pvalue->unitNameCV, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unit_content_derivations_concentrationUnit                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Unit_content_derivations_concentrationUnit (OSCTXT* pctxt,
   Unit_content_derivations_concentrationUnit *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode unitNameCV */

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 12)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_Unit_content_derivations_concentrationUnit_unitNameCV (pctxt, &pvalue->unitNameCV, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode unitName */

   if (pvalue->m.unitNamePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->unitName, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Unit_content_derivations_concentrationUnit (OSCTXT* pctxt, 
   Unit_content_derivations_concentrationUnit* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.unitNamePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitName=\""), 11);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->unitName, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitNameCV=\""), 13);

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 12)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_Unit_content_derivations_concentrationUnit_unitNameCV (pctxt, 
      pvalue->unitNameCV, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unit_content_derivations_massUnit                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Unit_content_derivations_massUnit (OSCTXT* pctxt,
   Unit_content_derivations_massUnit *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode unitNameCV */

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 7)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_Unit_content_derivations_massUnit_unitNameCV (pctxt, &pvalue->unitNameCV, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode unitName */

   if (pvalue->m.unitNamePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->unitName, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Unit_content_derivations_massUnit (OSCTXT* pctxt, 
   Unit_content_derivations_massUnit* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.unitNamePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitName=\""), 11);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->unitName, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitNameCV=\""), 13);

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 7)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_Unit_content_derivations_massUnit_unitNameCV (pctxt, pvalue->
      unitNameCV, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unit_content_derivations_quantityUnit                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Unit_content_derivations_quantityUnit (OSCTXT* pctxt,
   Unit_content_derivations_quantityUnit *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode unitNameCV */

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 8)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_Unit_content_derivations_quantityUnit_unitNameCV (pctxt, &pvalue->unitNameCV, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode unitName */

   if (pvalue->m.unitNamePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->unitName, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Unit_content_derivations_quantityUnit (OSCTXT* pctxt, 
   Unit_content_derivations_quantityUnit* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.unitNamePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitName=\""), 11);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->unitName, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitNameCV=\""), 13);

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 8)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_Unit_content_derivations_quantityUnit_unitNameCV (pctxt, 
      pvalue->unitNameCV, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unit_content_derivations_temperatureUnit                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Unit_content_derivations_temperatureUnit (OSCTXT* pctxt,
   Unit_content_derivations_temperatureUnit *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode unitNameCV */

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_Unit_content_derivations_temperatureUnit_unitNameCV (pctxt, &pvalue->unitNameCV, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode unitName */

   if (pvalue->m.unitNamePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->unitName, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Unit_content_derivations_temperatureUnit (OSCTXT* pctxt, 
   Unit_content_derivations_temperatureUnit* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.unitNamePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitName=\""), 11);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->unitName, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitNameCV=\""), 13);

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_Unit_content_derivations_temperatureUnit_unitNameCV (pctxt, 
      pvalue->unitNameCV, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unit_content_derivations_timeUnit                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Unit_content_derivations_timeUnit (OSCTXT* pctxt,
   Unit_content_derivations_timeUnit *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode unitNameCV */

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 8)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_Unit_content_derivations_timeUnit_unitNameCV (pctxt, &pvalue->unitNameCV, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode unitName */

   if (pvalue->m.unitNamePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->unitName, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Unit_content_derivations_timeUnit (OSCTXT* pctxt, 
   Unit_content_derivations_timeUnit* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.unitNamePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitName=\""), 11);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->unitName, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitNameCV=\""), 13);

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 8)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_Unit_content_derivations_timeUnit_unitNameCV (pctxt, pvalue->
      unitNameCV, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unit_content_derivations_volumeUnit                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Unit_content_derivations_volumeUnit (OSCTXT* pctxt,
   Unit_content_derivations_volumeUnit *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode unitNameCV */

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 8)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_Unit_content_derivations_volumeUnit_unitNameCV (pctxt, &pvalue->unitNameCV, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode unitName */

   if (pvalue->m.unitNamePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->unitName, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Unit_content_derivations_volumeUnit (OSCTXT* pctxt, 
   Unit_content_derivations_volumeUnit* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.unitNamePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitName=\""), 11);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->unitName, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" unitNameCV=\""), 13);

   if(pvalue->unitNameCV < 0 || pvalue->unitNameCV > 8)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   stat = XmlEnc_Unit_content_derivations_volumeUnit_unitNameCV (pctxt, pvalue
      ->unitNameCV, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Unit_content_derivations                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Unit_content_derivations (OSCTXT* pctxt,
   Unit_content_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_Unit_content (pctxt, pvalue->u.unit_content, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_Unit_content_derivations_distanceUnit (pctxt, pvalue->u.distanceUnit, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_Unit_content_derivations_concentrationUnit (pctxt, pvalue->u.concentrationUnit, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 4:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
            asn1E_Unit_content_derivations_massUnit (pctxt, pvalue->u.massUnit, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 5:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
            asn1E_Unit_content_derivations_quantityUnit (pctxt, pvalue->u.quantityUnit, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 6:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
            asn1E_Unit_content_derivations_temperatureUnit (pctxt, pvalue->u.temperatureUnit, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 7:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
            asn1E_Unit_content_derivations_timeUnit (pctxt, pvalue->u.timeUnit, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 8:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
            asn1E_Unit_content_derivations_volumeUnit (pctxt, pvalue->u.volumeUnit, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_Unit_content_derivations (OSCTXT* pctxt, 
   Unit_content_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   switch (pvalue->t)
   {
      case 1:
         /* encode unit_content */

         stat = XmlEnc_Unit_content (pctxt, pvalue->u.unit_content
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode distanceUnit */

         stat = XmlEnc_Unit_content_derivations_distanceUnit (pctxt, pvalue->
            u.distanceUnit, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode concentrationUnit */

         stat = XmlEnc_Unit_content_derivations_concentrationUnit (pctxt, 
            pvalue->u.concentrationUnit, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 4:
         /* encode massUnit */

         stat = XmlEnc_Unit_content_derivations_massUnit (pctxt, pvalue->
            u.massUnit, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 5:
         /* encode quantityUnit */

         stat = XmlEnc_Unit_content_derivations_quantityUnit (pctxt, pvalue->
            u.quantityUnit, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 6:
         /* encode temperatureUnit */

         stat = XmlEnc_Unit_content_derivations_temperatureUnit (pctxt, pvalue
            ->u.temperatureUnit, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 7:
         /* encode timeUnit */

         stat = XmlEnc_Unit_content_derivations_timeUnit (pctxt, pvalue->
            u.timeUnit, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 8:
         /* encode volumeUnit */

         stat = XmlEnc_Unit_content_derivations_volumeUnit (pctxt, pvalue->
            u.volumeUnit, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SequencePosition_content_derivations_sequencePosition     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SequencePosition_content_derivations_sequencePosition (OSCTXT* pctxt,
   SequencePosition_content_derivations_sequencePosition *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode start */

   if (pvalue->m.startPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->start, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode end */

   if (pvalue->m.endPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->end, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SequencePosition_content_derivations_sequencePosition 
   (OSCTXT* pctxt, 
   SequencePosition_content_derivations_sequencePosition* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.endPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" end=\""), 6);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->end, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.startPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" start=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->start, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SequencePosition_content_derivations_compositePosition    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SequencePosition_content_derivations_compositePosition (OSCTXT* pctxt,
   SequencePosition_content_derivations_compositePosition *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode mismatchInformation_assnlist */

   if (pvalue->m.mismatchInformation_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_MismatchInformation_assnlist (pctxt, &pvalue->mismatchInformation_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode composite_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_Composite_assnref (pctxt, &pvalue->composite_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode start */

   if (pvalue->m.startPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->start, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode end */

   if (pvalue->m.endPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->end, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SequencePosition_content_derivations_compositePosition 
   (OSCTXT* pctxt, 
   SequencePosition_content_derivations_compositePosition* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.endPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" end=\""), 6);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->end, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.startPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" start=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->start, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode composite_assnref */

   stat = XmlEnc_Composite_assnref (pctxt, &pvalue->composite_assnref
      , OSUTF8("Composite_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode mismatchInformation_assnlist */

   if (pvalue->m.mismatchInformation_assnlistPresent) {
      stat = XmlEnc_MismatchInformation_assnlist (pctxt, &pvalue->
         mismatchInformation_assnlist
         , OSUTF8("MismatchInformation_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SequencePosition_content_derivations_reporterPosition     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SequencePosition_content_derivations_reporterPosition (OSCTXT* pctxt,
   SequencePosition_content_derivations_reporterPosition *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode mismatchInformation_assnlist */

   if (pvalue->m.mismatchInformation_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_MismatchInformation_assnlist (pctxt, &pvalue->mismatchInformation_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode reporter_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_Reporter_assnref (pctxt, &pvalue->reporter_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Extendable_content (pctxt, &pvalue->extendable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode start */

   if (pvalue->m.startPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->start, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode end */

   if (pvalue->m.endPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->end, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SequencePosition_content_derivations_reporterPosition 
   (OSCTXT* pctxt, 
   SequencePosition_content_derivations_reporterPosition* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.endPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" end=\""), 6);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->end, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.startPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" start=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->start, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode extendable_content */

   if (pvalue->m.extendable_contentPresent) {
      stat = XmlEnc_Extendable_content (pctxt, &pvalue->extendable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode reporter_assnref */

   stat = XmlEnc_Reporter_assnref (pctxt, &pvalue->reporter_assnref
      , OSUTF8("Reporter_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode mismatchInformation_assnlist */

   if (pvalue->m.mismatchInformation_assnlistPresent) {
      stat = XmlEnc_MismatchInformation_assnlist (pctxt, &pvalue->
         mismatchInformation_assnlist
         , OSUTF8("MismatchInformation_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SequencePosition_content_derivations                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SequencePosition_content_derivations (OSCTXT* pctxt,
   SequencePosition_content_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_SequencePosition_content (pctxt, pvalue->u.sequencePosition_content, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_SequencePosition_content_derivations_sequencePosition (pctxt, pvalue->u.sequencePosition, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_SequencePosition_content_derivations_compositePosition (pctxt, pvalue->u.compositePosition, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 4:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
            asn1E_SequencePosition_content_derivations_reporterPosition (pctxt, pvalue->u.reporterPosition, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_SequencePosition_content_derivations (OSCTXT* pctxt, 
   SequencePosition_content_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   switch (pvalue->t)
   {
      case 1:
         /* encode sequencePosition_content */

         stat = XmlEnc_SequencePosition_content (pctxt, pvalue->
            u.sequencePosition_content, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode sequencePosition */

         stat = XmlEnc_SequencePosition_content_derivations_sequencePosition (pctxt
            , pvalue->u.sequencePosition, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode compositePosition */

         stat = XmlEnc_SequencePosition_content_derivations_compositePosition (pctxt
            , pvalue->u.compositePosition, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 4:
         /* encode reporterPosition */

         stat = XmlEnc_SequencePosition_content_derivations_reporterPosition (pctxt
            , pvalue->u.reporterPosition, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayCreation_content_derivations_bioAssayCreation_cl  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayCreation_content_derivations_bioAssayCreation_classes (OSCTXT* pctxt,
   BioAssayCreation_content_derivations_bioAssayCreation_classes *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode array_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_Array_assnref (pctxt, &pvalue->array_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode sourceBioMaterialMeasurements_assnlist */

   if (pvalue->m.sourceBioMaterialMeasurements_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_SourceBioMaterialMeasurements_assnlist (pctxt, &pvalue->sourceBioMaterialMeasurements_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioEvent_content */

   if (pvalue->m.bioEvent_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_BioEvent_content (pctxt, &pvalue->bioEvent_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayCreation_content_derivations_bioAssayCreation_classes 
   (OSCTXT* pctxt, 
   BioAssayCreation_content_derivations_bioAssayCreation_classes* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode bioEvent_content */

   if (pvalue->m.bioEvent_contentPresent) {
      stat = XmlEnc_BioEvent_content (pctxt, &pvalue->bioEvent_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode sourceBioMaterialMeasurements_assnlist */

   if (pvalue->m.sourceBioMaterialMeasurements_assnlistPresent) {
      stat = XmlEnc_SourceBioMaterialMeasurements_assnlist (pctxt, &pvalue->
         sourceBioMaterialMeasurements_assnlist
         , OSUTF8("SourceBioMaterialMeasurements_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode array_assnref */

   stat = XmlEnc_Array_assnref (pctxt, &pvalue->array_assnref
      , OSUTF8("Array_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayCreation_content_derivations                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayCreation_content_derivations (OSCTXT* pctxt,
   BioAssayCreation_content_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_BioAssayCreation_content (pctxt, pvalue->u.bioAssayCreation_content, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_BioAssayCreation_content_derivations_bioAssayCreation_classes (pctxt, pvalue->u.bioAssayCreation_classes, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_BioAssayCreation_content_derivations (OSCTXT* pctxt, 
   BioAssayCreation_content_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   switch (pvalue->t)
   {
      case 1:
         /* encode bioAssayCreation_content */

         stat = XmlEnc_BioAssayCreation_content (pctxt, pvalue->
            u.bioAssayCreation_content, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode bioAssayCreation_classes */

         stat = XmlEnc_BioAssayCreation_content_derivations_bioAssayCreation_classes (pctxt
            , pvalue->u.bioAssayCreation_classes, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ArrayDesign_content_derivations_arrayDesign               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ArrayDesign_content_derivations_arrayDesign (OSCTXT* pctxt,
   ArrayDesign_content_derivations_arrayDesign *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode designProviders_assnreflist */

   if (pvalue->m.designProviders_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9,
         asn1E_DesignProviders_assnreflist (pctxt, &pvalue->designProviders_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode compositeGroups_assnreflist */

   if (pvalue->m.compositeGroups_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_CompositeGroups_assnreflist (pctxt, &pvalue->compositeGroups_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode reporterGroups_assnreflist */

   if (pvalue->m.reporterGroups_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_ReporterGroups_assnreflist (pctxt, &pvalue->reporterGroups_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode featureGroups_assnlist */

   if (pvalue->m.featureGroups_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_FeatureGroups_assnlist (pctxt, &pvalue->featureGroups_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode protocolApplications_assnlist */

   if (pvalue->m.protocolApplications_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_ProtocolApplications_assnlist (pctxt, &pvalue->protocolApplications_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode version */

   if (pvalue->m.versionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_utf8str (pctxt, pvalue->version, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode numberOfFeatures */

   if (pvalue->m.numberOfFeaturesPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->numberOfFeatures, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ArrayDesign_content_derivations_arrayDesign (OSCTXT* pctxt, 
   ArrayDesign_content_derivations_arrayDesign* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.numberOfFeaturesPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" numberOfFeatures=\""), 19);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->numberOfFeatures, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.versionPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->version, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode protocolApplications_assnlist */

   if (pvalue->m.protocolApplications_assnlistPresent) {
      stat = XmlEnc_ProtocolApplications_assnlist (pctxt, &pvalue->
         protocolApplications_assnlist
         , OSUTF8("ProtocolApplications_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode featureGroups_assnlist */

   if (pvalue->m.featureGroups_assnlistPresent) {
      stat = XmlEnc_FeatureGroups_assnlist (pctxt, &pvalue->
         featureGroups_assnlist, OSUTF8("FeatureGroups_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode reporterGroups_assnreflist */

   if (pvalue->m.reporterGroups_assnreflistPresent) {
      stat = XmlEnc_ReporterGroups_assnreflist (pctxt, &pvalue->
         reporterGroups_assnreflist
         , OSUTF8("ReporterGroups_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode compositeGroups_assnreflist */

   if (pvalue->m.compositeGroups_assnreflistPresent) {
      stat = XmlEnc_CompositeGroups_assnreflist (pctxt, &pvalue->
         compositeGroups_assnreflist
         , OSUTF8("CompositeGroups_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode designProviders_assnreflist */

   if (pvalue->m.designProviders_assnreflistPresent) {
      stat = XmlEnc_DesignProviders_assnreflist (pctxt, &pvalue->
         designProviders_assnreflist
         , OSUTF8("DesignProviders_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ArrayDesign_content_derivations_physicalArrayDesign       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ArrayDesign_content_derivations_physicalArrayDesign (OSCTXT* pctxt,
   ArrayDesign_content_derivations_physicalArrayDesign *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode zoneGroups_assnlist */

   if (pvalue->m.zoneGroups_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|11,
         asn1E_ZoneGroups_assnlist (pctxt, &pvalue->zoneGroups_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode surfaceType_assn */

   if (pvalue->m.surfaceType_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10,
         asn1E_SurfaceType_assn (pctxt, &pvalue->surfaceType_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode designProviders_assnreflist */

   if (pvalue->m.designProviders_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9,
         asn1E_DesignProviders_assnreflist (pctxt, &pvalue->designProviders_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode compositeGroups_assnreflist */

   if (pvalue->m.compositeGroups_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_CompositeGroups_assnreflist (pctxt, &pvalue->compositeGroups_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode reporterGroups_assnreflist */

   if (pvalue->m.reporterGroups_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_ReporterGroups_assnreflist (pctxt, &pvalue->reporterGroups_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode featureGroups_assnlist */

   if (pvalue->m.featureGroups_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_FeatureGroups_assnlist (pctxt, &pvalue->featureGroups_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode protocolApplications_assnlist */

   if (pvalue->m.protocolApplications_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_ProtocolApplications_assnlist (pctxt, &pvalue->protocolApplications_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode version */

   if (pvalue->m.versionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_utf8str (pctxt, pvalue->version, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode numberOfFeatures */

   if (pvalue->m.numberOfFeaturesPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->numberOfFeatures, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ArrayDesign_content_derivations_physicalArrayDesign (OSCTXT* pctxt, 
   ArrayDesign_content_derivations_physicalArrayDesign* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.numberOfFeaturesPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" numberOfFeatures=\""), 19);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->numberOfFeatures, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.versionPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" version=\""), 10);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->version, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode protocolApplications_assnlist */

   if (pvalue->m.protocolApplications_assnlistPresent) {
      stat = XmlEnc_ProtocolApplications_assnlist (pctxt, &pvalue->
         protocolApplications_assnlist
         , OSUTF8("ProtocolApplications_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode featureGroups_assnlist */

   if (pvalue->m.featureGroups_assnlistPresent) {
      stat = XmlEnc_FeatureGroups_assnlist (pctxt, &pvalue->
         featureGroups_assnlist, OSUTF8("FeatureGroups_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode reporterGroups_assnreflist */

   if (pvalue->m.reporterGroups_assnreflistPresent) {
      stat = XmlEnc_ReporterGroups_assnreflist (pctxt, &pvalue->
         reporterGroups_assnreflist
         , OSUTF8("ReporterGroups_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode compositeGroups_assnreflist */

   if (pvalue->m.compositeGroups_assnreflistPresent) {
      stat = XmlEnc_CompositeGroups_assnreflist (pctxt, &pvalue->
         compositeGroups_assnreflist
         , OSUTF8("CompositeGroups_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode designProviders_assnreflist */

   if (pvalue->m.designProviders_assnreflistPresent) {
      stat = XmlEnc_DesignProviders_assnreflist (pctxt, &pvalue->
         designProviders_assnreflist
         , OSUTF8("DesignProviders_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode surfaceType_assn */

   if (pvalue->m.surfaceType_assnPresent) {
      stat = XmlEnc_SurfaceType_assn (pctxt, &pvalue->surfaceType_assn
         , OSUTF8("SurfaceType_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode zoneGroups_assnlist */

   if (pvalue->m.zoneGroups_assnlistPresent) {
      stat = XmlEnc_ZoneGroups_assnlist (pctxt, &pvalue->zoneGroups_assnlist
         , OSUTF8("ZoneGroups_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ArrayDesign_content_derivations                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ArrayDesign_content_derivations (OSCTXT* pctxt,
   ArrayDesign_content_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_ArrayDesign_content (pctxt, pvalue->u.arrayDesign_content, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_ArrayDesign_content_derivations_arrayDesign (pctxt, pvalue->u.arrayDesign, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_ArrayDesign_content_derivations_physicalArrayDesign (pctxt, pvalue->u.physicalArrayDesign, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_ArrayDesign_content_derivations (OSCTXT* pctxt, 
   ArrayDesign_content_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   switch (pvalue->t)
   {
      case 1:
         /* encode arrayDesign_content */

         stat = XmlEnc_ArrayDesign_content (pctxt, pvalue->
            u.arrayDesign_content, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode arrayDesign */

         stat = XmlEnc_ArrayDesign_content_derivations_arrayDesign (pctxt, 
            pvalue->u.arrayDesign, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode physicalArrayDesign */

         stat = XmlEnc_ArrayDesign_content_derivations_physicalArrayDesign (pctxt
            , pvalue->u.physicalArrayDesign, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ManufactureLIMS_content_derivations_manufactureLIMS       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ManufactureLIMS_content_derivations_manufactureLIMS (OSCTXT* pctxt,
   ManufactureLIMS_content_derivations_manufactureLIMS *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode identifierLIMS_assn */

   if (pvalue->m.identifierLIMS_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_IdentifierLIMS_assn (pctxt, &pvalue->identifierLIMS_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioMaterial_assnref */

   if (pvalue->m.bioMaterial_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_BioMaterial_assnref (pctxt, &pvalue->bioMaterial_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode feature_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_Feature_assnref (pctxt, &pvalue->feature_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_Describable_content (pctxt, &pvalue->describable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode quality */

   if (pvalue->m.qualityPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->quality, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ManufactureLIMS_content_derivations_manufactureLIMS (OSCTXT* pctxt, 
   ManufactureLIMS_content_derivations_manufactureLIMS* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.qualityPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" quality=\""), 10);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->quality, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      stat = XmlEnc_Describable_content (pctxt, &pvalue->describable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode feature_assnref */

   stat = XmlEnc_Feature_assnref (pctxt, &pvalue->feature_assnref
      , OSUTF8("Feature_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode bioMaterial_assnref */

   if (pvalue->m.bioMaterial_assnrefPresent) {
      stat = XmlEnc_BioMaterial_assnref (pctxt, &pvalue->bioMaterial_assnref
         , OSUTF8("BioMaterial_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode identifierLIMS_assn */

   if (pvalue->m.identifierLIMS_assnPresent) {
      stat = XmlEnc_IdentifierLIMS_assn (pctxt, &pvalue->identifierLIMS_assn
         , OSUTF8("IdentifierLIMS_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ManufactureLIMS_content_derivations_manufactureLIMSBioma  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ManufactureLIMS_content_derivations_manufactureLIMSBiomaterial (OSCTXT* pctxt,
   ManufactureLIMS_content_derivations_manufactureLIMSBiomaterial *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode identifierLIMS_assn */

   if (pvalue->m.identifierLIMS_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_IdentifierLIMS_assn (pctxt, &pvalue->identifierLIMS_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioMaterial_assnref */

   if (pvalue->m.bioMaterial_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_BioMaterial_assnref (pctxt, &pvalue->bioMaterial_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode feature_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
      asn1E_Feature_assnref (pctxt, &pvalue->feature_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Describable_content (pctxt, &pvalue->describable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode quality */

   if (pvalue->m.qualityPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_utf8str (pctxt, pvalue->quality, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioMaterialPlateRow */

   if (pvalue->m.bioMaterialPlateRowPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->bioMaterialPlateRow, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioMaterialPlateIdentifier */

   if (pvalue->m.bioMaterialPlateIdentifierPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->bioMaterialPlateIdentifier, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioMaterialPlateCol */

   if (pvalue->m.bioMaterialPlateColPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->bioMaterialPlateCol, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ManufactureLIMS_content_derivations_manufactureLIMSBiomaterial 
   (OSCTXT* pctxt, 
   ManufactureLIMS_content_derivations_manufactureLIMSBiomaterial* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.bioMaterialPlateColPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" bioMaterialPlateCol=\""), 22);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->bioMaterialPlateCol, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.bioMaterialPlateIdentifierPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" bioMaterialPlateIdentifier=\""), 29);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->bioMaterialPlateIdentifier
         , 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.bioMaterialPlateRowPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" bioMaterialPlateRow=\""), 22);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->bioMaterialPlateRow, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.qualityPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" quality=\""), 10);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->quality, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode describable_content */

   if (pvalue->m.describable_contentPresent) {
      stat = XmlEnc_Describable_content (pctxt, &pvalue->describable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode feature_assnref */

   stat = XmlEnc_Feature_assnref (pctxt, &pvalue->feature_assnref
      , OSUTF8("Feature_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode bioMaterial_assnref */

   if (pvalue->m.bioMaterial_assnrefPresent) {
      stat = XmlEnc_BioMaterial_assnref (pctxt, &pvalue->bioMaterial_assnref
         , OSUTF8("BioMaterial_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode identifierLIMS_assn */

   if (pvalue->m.identifierLIMS_assnPresent) {
      stat = XmlEnc_IdentifierLIMS_assn (pctxt, &pvalue->identifierLIMS_assn
         , OSUTF8("IdentifierLIMS_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ManufactureLIMS_content_derivations                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ManufactureLIMS_content_derivations (OSCTXT* pctxt,
   ManufactureLIMS_content_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_ManufactureLIMS_content (pctxt, pvalue->u.manufactureLIMS_content, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_ManufactureLIMS_content_derivations_manufactureLIMS (pctxt, pvalue->u.manufactureLIMS, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_ManufactureLIMS_content_derivations_manufactureLIMSBiomaterial (pctxt, pvalue->u.manufactureLIMSBiomaterial, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_ManufactureLIMS_content_derivations (OSCTXT* pctxt, 
   ManufactureLIMS_content_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   switch (pvalue->t)
   {
      case 1:
         /* encode manufactureLIMS_content */

         stat = XmlEnc_ManufactureLIMS_content (pctxt, pvalue->
            u.manufactureLIMS_content, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode manufactureLIMS */

         stat = XmlEnc_ManufactureLIMS_content_derivations_manufactureLIMS (pctxt
            , pvalue->u.manufactureLIMS, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode manufactureLIMSBiomaterial */

         stat = XmlEnc_ManufactureLIMS_content_derivations_manufactureLIMSBiomaterial (pctxt
            , pvalue->u.manufactureLIMSBiomaterial, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayTreatment_content_derivations_bioAssayTreatment   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayTreatment_content_derivations_bioAssayTreatment (OSCTXT* pctxt,
   BioAssayTreatment_content_derivations_bioAssayTreatment *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode target_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_Target_assnref (pctxt, &pvalue->target_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode bioEvent_content */

   if (pvalue->m.bioEvent_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_BioEvent_content (pctxt, &pvalue->bioEvent_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayTreatment_content_derivations_bioAssayTreatment 
   (OSCTXT* pctxt, 
   BioAssayTreatment_content_derivations_bioAssayTreatment* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode bioEvent_content */

   if (pvalue->m.bioEvent_contentPresent) {
      stat = XmlEnc_BioEvent_content (pctxt, &pvalue->bioEvent_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode target_assnref */

   stat = XmlEnc_Target_assnref (pctxt, &pvalue->target_assnref
      , OSUTF8("Target_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayTreatment_content_derivations_imageAcquisition    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayTreatment_content_derivations_imageAcquisition (OSCTXT* pctxt,
   BioAssayTreatment_content_derivations_imageAcquisition *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode images_assnreflist */

   if (pvalue->m.images_assnreflistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Images_assnreflist (pctxt, &pvalue->images_assnreflist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode target_assnref */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_Target_assnref (pctxt, &pvalue->target_assnref, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode bioEvent_content */

   if (pvalue->m.bioEvent_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_BioEvent_content (pctxt, &pvalue->bioEvent_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayTreatment_content_derivations_imageAcquisition 
   (OSCTXT* pctxt, 
   BioAssayTreatment_content_derivations_imageAcquisition* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode bioEvent_content */

   if (pvalue->m.bioEvent_contentPresent) {
      stat = XmlEnc_BioEvent_content (pctxt, &pvalue->bioEvent_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode target_assnref */

   stat = XmlEnc_Target_assnref (pctxt, &pvalue->target_assnref
      , OSUTF8("Target_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode images_assnreflist */

   if (pvalue->m.images_assnreflistPresent) {
      stat = XmlEnc_Images_assnreflist (pctxt, &pvalue->images_assnreflist
         , OSUTF8("Images_assnreflist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayTreatment_content_derivations                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayTreatment_content_derivations (OSCTXT* pctxt,
   BioAssayTreatment_content_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_BioAssayTreatment_content (pctxt, pvalue->u.bioAssayTreatment_content, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_BioAssayTreatment_content_derivations_bioAssayTreatment (pctxt, pvalue->u.bioAssayTreatment, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_BioAssayTreatment_content_derivations_imageAcquisition (pctxt, pvalue->u.imageAcquisition, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_BioAssayTreatment_content_derivations (OSCTXT* pctxt, 
   BioAssayTreatment_content_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   switch (pvalue->t)
   {
      case 1:
         /* encode bioAssayTreatment_content */

         stat = XmlEnc_BioAssayTreatment_content (pctxt, pvalue->
            u.bioAssayTreatment_content, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode bioAssayTreatment */

         stat = XmlEnc_BioAssayTreatment_content_derivations_bioAssayTreatment (pctxt
            , pvalue->u.bioAssayTreatment, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode imageAcquisition */

         stat = XmlEnc_BioAssayTreatment_content_derivations_imageAcquisition (pctxt
            , pvalue->u.imageAcquisition, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayData_content_derivations_derivedBioAssayData      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayData_content_derivations_derivedBioAssayData (OSCTXT* pctxt,
   BioAssayData_content_derivations_derivedBioAssayData *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode producerTransformation_assn */

   if (pvalue->m.producerTransformation_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8,
         asn1E_ProducerTransformation_assn (pctxt, &pvalue->producerTransformation_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioDataValues_assn */

   if (pvalue->m.bioDataValues_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_BioDataValues_assn (pctxt, &pvalue->bioDataValues_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode quantitationTypeDimension_assnref */

   if (pvalue->m.quantitationTypeDimension_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_QuantitationTypeDimension_assnref (pctxt, &pvalue->quantitationTypeDimension_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode designElementDimension_assnref */

   if (pvalue->m.designElementDimension_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_DesignElementDimension_assnref (pctxt, &pvalue->designElementDimension_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioAssayDimension_assnref */

   if (pvalue->m.bioAssayDimension_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_BioAssayDimension_assnref (pctxt, &pvalue->bioAssayDimension_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode summaryStatistics_assnlist */

   if (pvalue->m.summaryStatistics_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_SummaryStatistics_assnlist (pctxt, &pvalue->summaryStatistics_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayData_content_derivations_derivedBioAssayData 
   (OSCTXT* pctxt, 
   BioAssayData_content_derivations_derivedBioAssayData* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode summaryStatistics_assnlist */

   if (pvalue->m.summaryStatistics_assnlistPresent) {
      stat = XmlEnc_SummaryStatistics_assnlist (pctxt, &pvalue->
         summaryStatistics_assnlist
         , OSUTF8("SummaryStatistics_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioAssayDimension_assnref */

   if (pvalue->m.bioAssayDimension_assnrefPresent) {
      stat = XmlEnc_BioAssayDimension_assnref (pctxt, &pvalue->
         bioAssayDimension_assnref
         , OSUTF8("BioAssayDimension_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode designElementDimension_assnref */

   if (pvalue->m.designElementDimension_assnrefPresent) {
      stat = XmlEnc_DesignElementDimension_assnref (pctxt, &pvalue->
         designElementDimension_assnref
         , OSUTF8("DesignElementDimension_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeDimension_assnref */

   if (pvalue->m.quantitationTypeDimension_assnrefPresent) {
      stat = XmlEnc_QuantitationTypeDimension_assnref (pctxt, &pvalue->
         quantitationTypeDimension_assnref
         , OSUTF8("QuantitationTypeDimension_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioDataValues_assn */

   if (pvalue->m.bioDataValues_assnPresent) {
      stat = XmlEnc_BioDataValues_assn (pctxt, &pvalue->bioDataValues_assn
         , OSUTF8("BioDataValues_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode producerTransformation_assn */

   if (pvalue->m.producerTransformation_assnPresent) {
      stat = XmlEnc_ProducerTransformation_assn (pctxt, &pvalue->
         producerTransformation_assn
         , OSUTF8("ProducerTransformation_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayData_content_derivations_measuredBioAssayData     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayData_content_derivations_measuredBioAssayData (OSCTXT* pctxt,
   BioAssayData_content_derivations_measuredBioAssayData *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode bioDataValues_assn */

   if (pvalue->m.bioDataValues_assnPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_BioDataValues_assn (pctxt, &pvalue->bioDataValues_assn, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode quantitationTypeDimension_assnref */

   if (pvalue->m.quantitationTypeDimension_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_QuantitationTypeDimension_assnref (pctxt, &pvalue->quantitationTypeDimension_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode designElementDimension_assnref */

   if (pvalue->m.designElementDimension_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_DesignElementDimension_assnref (pctxt, &pvalue->designElementDimension_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bioAssayDimension_assnref */

   if (pvalue->m.bioAssayDimension_assnrefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_BioAssayDimension_assnref (pctxt, &pvalue->bioAssayDimension_assnref, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode summaryStatistics_assnlist */

   if (pvalue->m.summaryStatistics_assnlistPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_SummaryStatistics_assnlist (pctxt, &pvalue->summaryStatistics_assnlist, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Identifiable_content (pctxt, &pvalue->identifiable_content, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name */

   if (pvalue->m.namePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->name, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode identifier */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->identifier, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_BioAssayData_content_derivations_measuredBioAssayData 
   (OSCTXT* pctxt, 
   BioAssayData_content_derivations_measuredBioAssayData* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" identifier=\""), 13);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->identifier, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   if (pvalue->m.namePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" name=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->name, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   /* encode identifiable_content */

   if (pvalue->m.identifiable_contentPresent) {
      stat = XmlEnc_Identifiable_content (pctxt, &pvalue->identifiable_content
         , 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode summaryStatistics_assnlist */

   if (pvalue->m.summaryStatistics_assnlistPresent) {
      stat = XmlEnc_SummaryStatistics_assnlist (pctxt, &pvalue->
         summaryStatistics_assnlist
         , OSUTF8("SummaryStatistics_assnlist"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioAssayDimension_assnref */

   if (pvalue->m.bioAssayDimension_assnrefPresent) {
      stat = XmlEnc_BioAssayDimension_assnref (pctxt, &pvalue->
         bioAssayDimension_assnref
         , OSUTF8("BioAssayDimension_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode designElementDimension_assnref */

   if (pvalue->m.designElementDimension_assnrefPresent) {
      stat = XmlEnc_DesignElementDimension_assnref (pctxt, &pvalue->
         designElementDimension_assnref
         , OSUTF8("DesignElementDimension_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantitationTypeDimension_assnref */

   if (pvalue->m.quantitationTypeDimension_assnrefPresent) {
      stat = XmlEnc_QuantitationTypeDimension_assnref (pctxt, &pvalue->
         quantitationTypeDimension_assnref
         , OSUTF8("QuantitationTypeDimension_assnref"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bioDataValues_assn */

   if (pvalue->m.bioDataValues_assnPresent) {
      stat = XmlEnc_BioDataValues_assn (pctxt, &pvalue->bioDataValues_assn
         , OSUTF8("BioDataValues_assn"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BioAssayData_content_derivations                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_BioAssayData_content_derivations (OSCTXT* pctxt,
   BioAssayData_content_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_BioAssayData_content (pctxt, pvalue->u.bioAssayData_content, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_BioAssayData_content_derivations_derivedBioAssayData (pctxt, pvalue->u.derivedBioAssayData, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_BioAssayData_content_derivations_measuredBioAssayData (pctxt, pvalue->u.measuredBioAssayData, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_BioAssayData_content_derivations (OSCTXT* pctxt, 
   BioAssayData_content_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   switch (pvalue->t)
   {
      case 1:
         /* encode bioAssayData_content */

         stat = XmlEnc_BioAssayData_content (pctxt, pvalue->
            u.bioAssayData_content, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode derivedBioAssayData */

         stat = XmlEnc_BioAssayData_content_derivations_derivedBioAssayData (pctxt
            , pvalue->u.derivedBioAssayData, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode measuredBioAssayData */

         stat = XmlEnc_BioAssayData_content_derivations_measuredBioAssayData (pctxt
            , pvalue->u.measuredBioAssayData, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }

   return (stat);
}

int XmlEnc_FeatureGroup_assnref_PDU (OSCTXT* pctxt, FeatureGroup_assnref* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("FeatureGroup_assnref"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_FeatureGroup_assnref (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("FeatureGroup_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_ExperimentalFactor_assnref_PDU (OSCTXT* pctxt, ExperimentalFactor_assnref* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("ExperimentalFactor_assnref"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_ExperimentalFactor_assnref (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("ExperimentalFactor_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_ArrayDesign_classes_PDU (OSCTXT* pctxt, ArrayDesign_classes value)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("arrayDesign-classes"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_ArrayDesign_classes (pctxt, value, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("arrayDesign-classes"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_Contact_classes_PDU (OSCTXT* pctxt, Contact_classes value)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("contact-classes"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_Contact_classes (pctxt, value, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("contact-classes"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_Unit_classes_PDU (OSCTXT* pctxt, Unit_classes value)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("unit-classes"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_Unit_classes (pctxt, value, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("unit-classes"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_ManufactureLIMS_classes_PDU (OSCTXT* pctxt, ManufactureLIMS_classes value)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("manufactureLIMS-classes"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_ManufactureLIMS_classes (pctxt, value, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("manufactureLIMS-classes"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_SequencePosition_classes_PDU (OSCTXT* pctxt, SequencePosition_classes value)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("sequencePosition-classes"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_SequencePosition_classes (pctxt, value, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("sequencePosition-classes"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_BioMaterial_classes_PDU (OSCTXT* pctxt, BioMaterial_classes value)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("bioMaterial-classes"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_BioMaterial_classes (pctxt, value, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("bioMaterial-classes"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_BioAssayTreatment_classes_PDU (OSCTXT* pctxt, BioAssayTreatment_classes value)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("bioAssayTreatment-classes"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_BioAssayTreatment_classes (pctxt, value, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("bioAssayTreatment-classes"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_BioAssay_classes_PDU (OSCTXT* pctxt, BioAssay_classes value)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("bioAssay-classes"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_BioAssay_classes (pctxt, value, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("bioAssay-classes"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_BioDataValues_classes_PDU (OSCTXT* pctxt, BioDataValues_classes value)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("bioDataValues-classes"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_BioDataValues_classes (pctxt, value, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("bioDataValues-classes"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_BioAssayData_classes_PDU (OSCTXT* pctxt, BioAssayData_classes value)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("bioAssayData-classes"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_BioAssayData_classes (pctxt, value, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("bioAssayData-classes"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_DesignElementDimension_classes_PDU (OSCTXT* pctxt, DesignElementDimension_classes value)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("designElementDimension-classes"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_DesignElementDimension_classes (pctxt, value, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("designElementDimension-classes"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_DesignElementMap_classes_PDU (OSCTXT* pctxt, DesignElementMap_classes value)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("designElementMap-classes"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_DesignElementMap_classes (pctxt, value, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("designElementMap-classes"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_DesignElement_classes_PDU (OSCTXT* pctxt, DesignElement_classes value)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("designElement-classes"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_DesignElement_classes (pctxt, value, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("designElement-classes"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_MAGE_ML_PDU (OSCTXT* pctxt, MAGE_ML* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("MAGE-ML"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_MAGE_ML (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("MAGE-ML"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_QuantitationType_ref_PDU (OSCTXT* pctxt, QuantitationType_ref* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("QuantitationType_ref"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_QuantitationType_ref (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("QuantitationType_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_StandardQuantitationType_ref_PDU (OSCTXT* pctxt, StandardQuantitationType_ref* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("StandardQuantitationType_ref"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_StandardQuantitationType_ref (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("StandardQuantitationType_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_ConfidenceIndicator_assnlist_PDU (OSCTXT* pctxt, ConfidenceIndicator_assnlist* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("ConfidenceIndicator_assnlist"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_ConfidenceIndicator_assnlist (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("ConfidenceIndicator_assnlist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_ConfidenceIndicator_ref_PDU (OSCTXT* pctxt, ConfidenceIndicator_ref* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("ConfidenceIndicator_ref"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_ConfidenceIndicator_ref (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("ConfidenceIndicator_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_Contact_ref_PDU (OSCTXT* pctxt, Contact_ref* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("Contact_ref"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_Contact_ref (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("Contact_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_Organization_assnlist_PDU (OSCTXT* pctxt, Organization_assnlist* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("Organization_assnlist"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_Organization_assnlist (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("Organization_assnlist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_Person_assnlist_PDU (OSCTXT* pctxt, Person_assnlist* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("Person_assnlist"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_Person_assnlist (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("Person_assnlist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_BioMaterial_ref_PDU (OSCTXT* pctxt, BioMaterial_ref* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("BioMaterial_ref"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_BioMaterial_ref (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("BioMaterial_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_BioAssay_ref_PDU (OSCTXT* pctxt, BioAssay_ref* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("BioAssay_ref"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_BioAssay_ref (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("BioAssay_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_DerivedBioAssay_assnlist_PDU (OSCTXT* pctxt, DerivedBioAssay_assnlist* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("DerivedBioAssay_assnlist"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_DerivedBioAssay_assnlist (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("DerivedBioAssay_assnlist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_MeasuredBioAssay_assnlist_PDU (OSCTXT* pctxt, MeasuredBioAssay_assnlist* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("MeasuredBioAssay_assnlist"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_MeasuredBioAssay_assnlist (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("MeasuredBioAssay_assnlist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_MeasuredBioAssayTarget_assnref_PDU (OSCTXT* pctxt, MeasuredBioAssayTarget_assnref* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("MeasuredBioAssayTarget_assnref"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_MeasuredBioAssayTarget_assnref (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("MeasuredBioAssayTarget_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_PhysicalBioAssay_assnlist_PDU (OSCTXT* pctxt, PhysicalBioAssay_assnlist* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("PhysicalBioAssay_assnlist"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_PhysicalBioAssay_assnlist (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("PhysicalBioAssay_assnlist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_PhysicalBioAssay_assnref_PDU (OSCTXT* pctxt, PhysicalBioAssay_assnref* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("PhysicalBioAssay_assnref"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_PhysicalBioAssay_assnref (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("PhysicalBioAssay_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_PhysicalBioAssayTarget_assnref_PDU (OSCTXT* pctxt, PhysicalBioAssayTarget_assnref* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("PhysicalBioAssayTarget_assnref"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_PhysicalBioAssayTarget_assnref (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("PhysicalBioAssayTarget_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_BioAssayData_ref_PDU (OSCTXT* pctxt, BioAssayData_ref* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("BioAssayData_ref"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_BioAssayData_ref (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("BioAssayData_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_DerivedBioAssayData_assnlist_PDU (OSCTXT* pctxt, DerivedBioAssayData_assnlist* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("DerivedBioAssayData_assnlist"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_DerivedBioAssayData_assnlist (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("DerivedBioAssayData_assnlist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_DerivedBioAssayDataTarget_assnref_PDU (OSCTXT* pctxt, DerivedBioAssayDataTarget_assnref* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("DerivedBioAssayDataTarget_assnref"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_DerivedBioAssayDataTarget_assnref (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("DerivedBioAssayDataTarget_assnref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_DesignElementDimension_ref_PDU (OSCTXT* pctxt, DesignElementDimension_ref* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("DesignElementDimension_ref"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_DesignElementDimension_ref (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("DesignElementDimension_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_DesignElementMap_assnlist_PDU (OSCTXT* pctxt, DesignElementMap_assnlist* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("DesignElementMap_assnlist"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_DesignElementMap_assnlist (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("DesignElementMap_assnlist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_DesignElementMap_ref_PDU (OSCTXT* pctxt, DesignElementMap_ref* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("DesignElementMap_ref"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_DesignElementMap_ref (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("DesignElementMap_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_MeasuredBioAssayData_assnlist_PDU (OSCTXT* pctxt, MeasuredBioAssayData_assnlist* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("MeasuredBioAssayData_assnlist"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_MeasuredBioAssayData_assnlist (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("MeasuredBioAssayData_assnlist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_DesignElement_assnlist_PDU (OSCTXT* pctxt, DesignElement_assnlist* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("DesignElement_assnlist"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_DesignElement_assnlist (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("DesignElement_assnlist"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_DesignElement_ref_PDU (OSCTXT* pctxt, DesignElement_ref* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("DesignElement_ref"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_DesignElement_ref (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("DesignElement_ref"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_BioAssayCreation_classes_PDU (OSCTXT* pctxt, BioAssayCreation_classes* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("bioAssayCreation-classes"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_BioAssayCreation_classes (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("bioAssayCreation-classes"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
