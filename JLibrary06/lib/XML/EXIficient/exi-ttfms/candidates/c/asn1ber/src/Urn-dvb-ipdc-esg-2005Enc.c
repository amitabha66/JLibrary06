/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "Urn-dvb-ipdc-esg-2005.h"
#include "rtxsrc/rtxCommon.h"

/**************************************************************/
/*                                                            */
/*  ESGIDRefType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_ESGIDRefType (OSCTXT* pctxt,
   CBMS_ESGIDRefType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode iDRef */

   if (pvalue->m.iDRefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->iDRef, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_ESGIDRefType (OSCTXT* pctxt, CBMS_ESGIDRefType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.iDRefPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" IDRef=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->iDRef, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AcquisitionRefType                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_AcquisitionRefType (OSCTXT* pctxt,
   CBMS_AcquisitionRefType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode label_list */

   pnode2 = pvalue->label_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TextualType (pctxt, ((TextualType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode iDRef */

   if (pvalue->m.iDRefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->iDRef, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_AcquisitionRefType (OSCTXT* pctxt, 
   CBMS_AcquisitionRefType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.iDRefPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" IDRef=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->iDRef, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode label_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->label_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TextualType (pctxt, ((TextualType*)pnode->data)
         , OSUTF8("Label"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ServiceRefType                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_ServiceRefType (OSCTXT* pctxt,
   CBMS_ServiceRefType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode serviceNumber */

   if (pvalue->m.serviceNumberPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_uint16 (pctxt, &pvalue->serviceNumber, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode iDRef */

   if (pvalue->m.iDRefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->iDRef, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_ServiceRefType (OSCTXT* pctxt, CBMS_ServiceRefType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.iDRefPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" IDRef=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->iDRef, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.serviceNumberPresent) {
      stat = rtXmlEncUIntAttr
         (pctxt, pvalue->serviceNumber, OSUTF8("serviceNumber"), 13);
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ESGIDRefType_derivations                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_ESGIDRefType_derivations (OSCTXT* pctxt,
   CBMS_ESGIDRefType_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_CBMS_ESGIDRefType (pctxt, pvalue->u.eSGIDRefType, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_CBMS_AcquisitionRefType (pctxt, pvalue->u.acquisitionRefType, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_CBMS_ServiceRefType (pctxt, pvalue->u.serviceRefType, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_CBMS_ESGIDRefType_derivations (OSCTXT* pctxt, 
   CBMS_ESGIDRefType_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   switch (pvalue->t)
   {
      case 1:
         /* encode eSGIDRefType */

         stat = XmlEnc_CBMS_ESGIDRefType (pctxt, pvalue->u.eSGIDRefType
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode acquisitionRefType */

         stat = XmlEnc_CBMS_AcquisitionRefType (pctxt, pvalue->
            u.acquisitionRefType, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode serviceRefType */

         stat = XmlEnc_CBMS_ServiceRefType (pctxt, pvalue->u.serviceRefType
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelatedMaterialType                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_RelatedMaterialType (OSCTXT* pctxt,
   CBMS_RelatedMaterialType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode promotionalMedia_list */

   pnode2 = pvalue->promotionalMedia_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TitleMediaType (pctxt, ((TitleMediaType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode promotionalText_list */

   pnode2 = pvalue->promotionalText_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TextualType (pctxt, ((TextualType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode mediaLocator */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_MediaLocatorType_derivations (pctxt, &pvalue->mediaLocator, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode howRelated */

   if (pvalue->m.howRelatedPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ControlledTermType_derivations (pctxt, &pvalue->howRelated, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_RelatedMaterialType (OSCTXT* pctxt, 
   CBMS_RelatedMaterialType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode howRelated */

   if (pvalue->m.howRelatedPresent) {
      stat = XmlEnc_ControlledTermType_derivations (pctxt, &pvalue->howRelated
         , OSUTF8("HowRelated"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode mediaLocator */

   stat = XmlEnc_MediaLocatorType_derivations (pctxt, &pvalue->mediaLocator
      , OSUTF8("MediaLocator"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode promotionalText_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->promotionalText_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TextualType (pctxt, ((TextualType*)pnode->data)
         , OSUTF8("PromotionalText"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode promotionalMedia_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->promotionalMedia_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TitleMediaType (pctxt, ((TitleMediaType*)pnode->data)
         , OSUTF8("PromotionalMedia"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrivateDataType                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_PrivateDataType (OSCTXT* pctxt,
   CBMS_PrivateDataType *pvalue, ASN1TagType tagging)
{
   int ll0 = 0;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_PrivateDataType (OSCTXT* pctxt, CBMS_PrivateDataType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ContentType                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_ContentType (OSCTXT* pctxt,
   CBMS_ContentType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode privateData_list */

   pnode2 = pvalue->privateData_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CBMS_PrivateDataType (pctxt, ((CBMS_PrivateDataType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|15, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode duration */

   if (pvalue->m.durationPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|14,
         xe_utf8str (pctxt, pvalue->duration, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode relatedMaterial_list */

   pnode2 = pvalue->relatedMaterial_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CBMS_RelatedMaterialType (pctxt, ((CBMS_RelatedMaterialType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|13, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode creditsList */

   if (pvalue->m.creditsListPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|12,
         asn1E_CreditsListType (pctxt, &pvalue->creditsList, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode signLanguage_list */

   pnode2 = pvalue->signLanguage_list.tail;
   while (0 != pnode2) {
      ll = asn1E_SignLanguageType (pctxt, ((SignLanguageType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|11, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode captionLanguage_list */

   pnode2 = pvalue->captionLanguage_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CaptionLanguageType (pctxt, ((CaptionLanguageType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode language_list */

   pnode2 = pvalue->language_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ExtendedLanguageType (pctxt, ((ExtendedLanguageType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode parentalGuidance_list */

   pnode2 = pvalue->parentalGuidance_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ParentalGuidanceType (pctxt, ((ParentalGuidanceType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode contentType_list */

   pnode2 = pvalue->contentType_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ControlledTermType_derivations (pctxt, ((ControlledTermType_derivations*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode genre_list */

   pnode2 = pvalue->genre_list.tail;
   while (0 != pnode2) {
      ll = asn1E_GenreType (pctxt, ((GenreType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode keyword_list */

   pnode2 = pvalue->keyword_list.tail;
   while (0 != pnode2) {
      ll = asn1E_KeywordType (pctxt, ((KeywordType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode synopsis_list */

   pnode2 = pvalue->synopsis_list.tail;
   while (0 != pnode2) {
      ll = asn1E_SynopsisType (pctxt, ((SynopsisType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode serviceRef_list */

   pnode2 = pvalue->serviceRef_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CBMS_ESGIDRefType_derivations (pctxt, ((CBMS_ESGIDRefType_derivations*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode mediaTitle_list */

   pnode2 = pvalue->mediaTitle_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TitleMediaType (pctxt, ((TitleMediaType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode title_list */

   pnode2 = pvalue->title_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TitleType (pctxt, ((TitleType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode contentID */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->contentID, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_ContentType (OSCTXT* pctxt, CBMS_ContentType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" contentID=\""), 12);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->contentID, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode title_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->title_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TitleType (pctxt, ((TitleType*)pnode->data)
         , OSUTF8("Title"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode mediaTitle_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->mediaTitle_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TitleMediaType (pctxt, ((TitleMediaType*)pnode->data)
         , OSUTF8("MediaTitle"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode serviceRef_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->serviceRef_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CBMS_ESGIDRefType_derivations (pctxt, 
         ((CBMS_ESGIDRefType_derivations*)pnode->data)
         , OSUTF8("ServiceRef"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode synopsis_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->synopsis_list.head;
   while (0 != pnode) {
      stat = XmlEnc_SynopsisType (pctxt, ((SynopsisType*)pnode->data)
         , OSUTF8("Synopsis"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode keyword_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->keyword_list.head;
   while (0 != pnode) {
      stat = XmlEnc_KeywordType (pctxt, ((KeywordType*)pnode->data)
         , OSUTF8("Keyword"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode genre_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->genre_list.head;
   while (0 != pnode) {
      stat = XmlEnc_GenreType (pctxt, ((GenreType*)pnode->data)
         , OSUTF8("Genre"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode contentType_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->contentType_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ControlledTermType_derivations (pctxt, 
         ((ControlledTermType_derivations*)pnode->data)
         , OSUTF8("ContentType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode parentalGuidance_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->parentalGuidance_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ParentalGuidanceType (pctxt, 
         ((ParentalGuidanceType*)pnode->data)
         , OSUTF8("ParentalGuidance"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode language_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->language_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ExtendedLanguageType (pctxt, 
         ((ExtendedLanguageType*)pnode->data), OSUTF8("Language"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode captionLanguage_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->captionLanguage_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CaptionLanguageType (pctxt, 
         ((CaptionLanguageType*)pnode->data)
         , OSUTF8("CaptionLanguage"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode signLanguage_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->signLanguage_list.head;
   while (0 != pnode) {
      stat = XmlEnc_SignLanguageType (pctxt, ((SignLanguageType*)pnode->data)
         , OSUTF8("SignLanguage"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode creditsList */

   if (pvalue->m.creditsListPresent) {
      stat = XmlEnc_CreditsListType (pctxt, &pvalue->creditsList
         , OSUTF8("CreditsList"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode relatedMaterial_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->relatedMaterial_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CBMS_RelatedMaterialType (pctxt, 
         ((CBMS_RelatedMaterialType*)pnode->data)
         , OSUTF8("RelatedMaterial"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode duration */

   if (pvalue->m.durationPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->duration
         , OSUTF8("Duration"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode privateData_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->privateData_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CBMS_PrivateDataType (pctxt, 
         ((CBMS_PrivateDataType*)pnode->data)
         , OSUTF8("PrivateData"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ContentTableType                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_ContentTableType (OSCTXT* pctxt,
   CBMS_ContentTableType *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_CBMS_ContentType (pctxt, ((CBMS_ContentType*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_ContentTableType (OSCTXT* pctxt, 
   CBMS_ContentTableType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_CBMS_ContentType (pctxt, ((CBMS_ContentType*)pnode->data)
         , OSUTF8("Content"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ScheduleEventType_element_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_ScheduleEventType_element_element (OSCTXT* pctxt,
   CBMS_ScheduleEventType_element_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode contentLocation */

   if (pvalue->m.contentLocationPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->contentLocation, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode acquisitionRef */

   if (pvalue->m.acquisitionRefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_CBMS_AcquisitionRefType (pctxt, &pvalue->acquisitionRef, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_ScheduleEventType_element_element (OSCTXT* pctxt, 
   CBMS_ScheduleEventType_element_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode acquisitionRef */

   if (pvalue->m.acquisitionRefPresent) {
      stat = XmlEnc_CBMS_AcquisitionRefType (pctxt, &pvalue->acquisitionRef
         , OSUTF8("AcquisitionRef"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode contentLocation */

   if (pvalue->m.contentLocationPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->contentLocation
         , OSUTF8("ContentLocation"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ScheduleEventType_element                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_ScheduleEventType_element (OSCTXT* pctxt,
   CBMS_ScheduleEventType_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode sequence_list */

   if (pvalue->m.sequence_listPresent) {
      pnode2 = pvalue->sequence_list.tail;
      while (0 != pnode2) {
         ll = asn1E_CBMS_ScheduleEventType_element_element (pctxt, ((CBMS_ScheduleEventType_element_element*)pnode2->data), ASN1EXPL);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll2 += ll;

         pnode2 = pnode2->prev;
      }
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      else { ll1 += ll; ll2 = 0; }
   }
   /* encode contentFragmentRef */

   if (pvalue->m.contentFragmentRefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_CBMS_ESGIDRefType_derivations (pctxt, &pvalue->contentFragmentRef, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_ScheduleEventType_element (OSCTXT* pctxt, 
   CBMS_ScheduleEventType_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode contentFragmentRef */

   if (pvalue->m.contentFragmentRefPresent) {
      stat = XmlEnc_CBMS_ESGIDRefType_derivations (pctxt, &pvalue->
         contentFragmentRef, OSUTF8("ContentFragmentRef"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode sequence_list */

   if (pvalue->m.sequence_listPresent) {
      { const OSUTF8CHAR* savedPrefix = nsPrefix;
      nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

      { OSRTDListNode* pnode = pvalue->sequence_list.head;
      while (0 != pnode) {
         stat = XmlEnc_CBMS_ScheduleEventType_element_element (pctxt, 
            ((CBMS_ScheduleEventType_element_element*)pnode->data)
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         pnode = pnode->next;
      }}
      nsPrefix = savedPrefix;
      }

   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ScheduleEventType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_ScheduleEventType (OSCTXT* pctxt,
   CBMS_ScheduleEventType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode sequence_list */

   if (pvalue->m.sequence_listPresent) {
      pnode2 = pvalue->sequence_list.tail;
      while (0 != pnode2) {
         ll = asn1E_CBMS_ScheduleEventType_element (pctxt, ((CBMS_ScheduleEventType_element*)pnode2->data), ASN1EXPL);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll2 += ll;

         pnode2 = pnode2->prev;
      }
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8, ll2);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      else { ll1 += ll; ll2 = 0; }
   }
   /* encode serviceRef */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
      asn1E_CBMS_ESGIDRefType_derivations (pctxt, &pvalue->serviceRef, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode publishedEndTime */

   if (pvalue->m.publishedEndTimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
         xe_charstr (pctxt, pvalue->publishedEndTime, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode publishedStartTime */

   if (pvalue->m.publishedStartTimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         xe_charstr (pctxt, pvalue->publishedStartTime, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode scheduleId */

   if (pvalue->m.scheduleIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_utf8str (pctxt, pvalue->scheduleId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode repeat */

   if (pvalue->m.repeatPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_boolean (pctxt, &pvalue->repeat, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode live */

   if (pvalue->m.livePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_boolean (pctxt, &pvalue->live, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode freeToAir */

   if (pvalue->m.freeToAirPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_boolean (pctxt, &pvalue->freeToAir, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode clearToAir */

   if (pvalue->m.clearToAirPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_boolean (pctxt, &pvalue->clearToAir, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_ScheduleEventType (OSCTXT* pctxt, 
   CBMS_ScheduleEventType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.clearToAirPresent) {
      stat = rtXmlEncBoolAttr (pctxt, pvalue->clearToAir
         , OSUTF8("clearToAir"), 10);
   }

   if (pvalue->m.freeToAirPresent) {
      stat = rtXmlEncBoolAttr (pctxt, pvalue->freeToAir
         , OSUTF8("freeToAir"), 9);
   }

   if (pvalue->m.livePresent) {
      stat = rtXmlEncBoolAttr (pctxt, pvalue->live, OSUTF8("live"), 4);
   }

   if (pvalue->m.repeatPresent) {
      stat = rtXmlEncBoolAttr (pctxt, pvalue->repeat, OSUTF8("repeat"), 6);
   }

   if (pvalue->m.scheduleIdPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" scheduleId=\""), 13);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->scheduleId, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode publishedStartTime */

   if (pvalue->m.publishedStartTimePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         publishedStartTime, OSUTF8("PublishedStartTime"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode publishedEndTime */

   if (pvalue->m.publishedEndTimePresent) {
      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->
         publishedEndTime, OSUTF8("PublishedEndTime"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode serviceRef */

   stat = XmlEnc_CBMS_ESGIDRefType_derivations (pctxt, &pvalue->serviceRef
      , OSUTF8("ServiceRef"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode sequence_list */

   if (pvalue->m.sequence_listPresent) {
      { const OSUTF8CHAR* savedPrefix = nsPrefix;
      nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

      { OSRTDListNode* pnode = pvalue->sequence_list.head;
      while (0 != pnode) {
         stat = XmlEnc_CBMS_ScheduleEventType_element (pctxt, 
            ((CBMS_ScheduleEventType_element*)pnode->data), 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         pnode = pnode->next;
      }}
      nsPrefix = savedPrefix;
      }

   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ScheduleEventTableType                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_ScheduleEventTableType (OSCTXT* pctxt,
   CBMS_ScheduleEventTableType *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_CBMS_ScheduleEventType (pctxt, ((CBMS_ScheduleEventType*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_ScheduleEventTableType (OSCTXT* pctxt, 
   CBMS_ScheduleEventTableType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_CBMS_ScheduleEventType (pctxt, 
         ((CBMS_ScheduleEventType*)pnode->data)
         , OSUTF8("ScheduleEvent"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ProviderType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_ProviderType (OSCTXT* pctxt,
   CBMS_ProviderType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode providerInformationURL */

   if (pvalue->m.providerInformationURLPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_utf8str (pctxt, pvalue->providerInformationURL, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode providerLogo */

   if (pvalue->m.providerLogoPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_TitleMediaType (pctxt, &pvalue->providerLogo, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode providerName_list */

   if (!(pvalue->providerName_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ProviderType.providerName_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->providerName_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->providerName_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TextualType (pctxt, ((TextualType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode providerURI */

   if (pvalue->m.providerURIPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->providerURI, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_ProviderType (OSCTXT* pctxt, CBMS_ProviderType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode providerURI */

   if (pvalue->m.providerURIPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->providerURI
         , OSUTF8("ProviderURI"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode providerName_list */

   if (!(pvalue->providerName_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ProviderType.providerName_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->providerName_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->providerName_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TextualType (pctxt, ((TextualType*)pnode->data)
         , OSUTF8("ProviderName"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode providerLogo */

   if (pvalue->m.providerLogoPresent) {
      stat = XmlEnc_TitleMediaType (pctxt, &pvalue->providerLogo
         , OSUTF8("ProviderLogo"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode providerInformationURL */

   if (pvalue->m.providerInformationURLPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->providerInformationURL
         , OSUTF8("ProviderInformationURL"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ServiceType                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_ServiceType (OSCTXT* pctxt,
   CBMS_ServiceType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode privateData_list */

   pnode2 = pvalue->privateData_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CBMS_PrivateDataType (pctxt, ((CBMS_PrivateDataType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|14, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode relatedMaterial_list */

   pnode2 = pvalue->relatedMaterial_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CBMS_RelatedMaterialType (pctxt, ((CBMS_RelatedMaterialType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|13, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode acquisitionRef_list */

   pnode2 = pvalue->acquisitionRef_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CBMS_AcquisitionRefType (pctxt, ((CBMS_AcquisitionRefType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|12, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode serviceProvider */

   if (pvalue->m.serviceProviderPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|11,
         asn1E_CBMS_ProviderType (pctxt, &pvalue->serviceProvider, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode serviceLanguage */

   if (pvalue->m.serviceLanguagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|10,
         xe_utf8str (pctxt, pvalue->serviceLanguage, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode parentalGuidance_list */

   pnode2 = pvalue->parentalGuidance_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ParentalGuidanceType (pctxt, ((ParentalGuidanceType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode serviceType_list */

   pnode2 = pvalue->serviceType_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ControlledTermType_derivations (pctxt, ((ControlledTermType_derivations*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode serviceGenre_list */

   pnode2 = pvalue->serviceGenre_list.tail;
   while (0 != pnode2) {
      ll = asn1E_GenreType (pctxt, ((GenreType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode serviceDescription_list */

   pnode2 = pvalue->serviceDescription_list.tail;
   while (0 != pnode2) {
      ll = asn1E_SynopsisType (pctxt, ((SynopsisType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode serviceLogo_list */

   pnode2 = pvalue->serviceLogo_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TitleMediaType (pctxt, ((TitleMediaType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode serviceNumber */

   if (pvalue->m.serviceNumberPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_uint16 (pctxt, &pvalue->serviceNumber, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode serviceName_list */

   if (!(pvalue->serviceName_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ServiceType.serviceName_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->serviceName_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->serviceName_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ServiceInformationNameType (pctxt, ((ServiceInformationNameType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode serviceID */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_utf8str (pctxt, pvalue->serviceID, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode freeToAir */

   if (pvalue->m.freeToAirPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_boolean (pctxt, &pvalue->freeToAir, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode clearToAir */

   if (pvalue->m.clearToAirPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_boolean (pctxt, &pvalue->clearToAir, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_ServiceType (OSCTXT* pctxt, CBMS_ServiceType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.clearToAirPresent) {
      stat = rtXmlEncBoolAttr (pctxt, pvalue->clearToAir
         , OSUTF8("clearToAir"), 10);
   }

   if (pvalue->m.freeToAirPresent) {
      stat = rtXmlEncBoolAttr (pctxt, pvalue->freeToAir
         , OSUTF8("freeToAir"), 9);
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" serviceID=\""), 12);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->serviceID, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode serviceName_list */

   if (!(pvalue->serviceName_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ServiceType.serviceName_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->serviceName_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->serviceName_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ServiceInformationNameType (pctxt, 
         ((ServiceInformationNameType*)pnode->data)
         , OSUTF8("ServiceName"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode serviceNumber */

   if (pvalue->m.serviceNumberPresent) {
      stat = rtXmlEncUInt (pctxt, pvalue->serviceNumber
         , OSUTF8("ServiceNumber"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode serviceLogo_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->serviceLogo_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TitleMediaType (pctxt, ((TitleMediaType*)pnode->data)
         , OSUTF8("ServiceLogo"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode serviceDescription_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->serviceDescription_list.head;
   while (0 != pnode) {
      stat = XmlEnc_SynopsisType (pctxt, ((SynopsisType*)pnode->data)
         , OSUTF8("ServiceDescription"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode serviceGenre_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->serviceGenre_list.head;
   while (0 != pnode) {
      stat = XmlEnc_GenreType (pctxt, ((GenreType*)pnode->data)
         , OSUTF8("ServiceGenre"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode serviceType_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->serviceType_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ControlledTermType_derivations (pctxt, 
         ((ControlledTermType_derivations*)pnode->data)
         , OSUTF8("ServiceType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode parentalGuidance_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->parentalGuidance_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ParentalGuidanceType (pctxt, 
         ((ParentalGuidanceType*)pnode->data)
         , OSUTF8("ParentalGuidance"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode serviceLanguage */

   if (pvalue->m.serviceLanguagePresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->serviceLanguage
         , OSUTF8("ServiceLanguage"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode serviceProvider */

   if (pvalue->m.serviceProviderPresent) {
      stat = XmlEnc_CBMS_ProviderType (pctxt, &pvalue->serviceProvider
         , OSUTF8("ServiceProvider"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode acquisitionRef_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->acquisitionRef_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CBMS_AcquisitionRefType (pctxt, 
         ((CBMS_AcquisitionRefType*)pnode->data)
         , OSUTF8("AcquisitionRef"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode relatedMaterial_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->relatedMaterial_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CBMS_RelatedMaterialType (pctxt, 
         ((CBMS_RelatedMaterialType*)pnode->data)
         , OSUTF8("RelatedMaterial"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode privateData_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->privateData_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CBMS_PrivateDataType (pctxt, 
         ((CBMS_PrivateDataType*)pnode->data)
         , OSUTF8("PrivateData"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ServiceTableType                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_ServiceTableType (OSCTXT* pctxt,
   CBMS_ServiceTableType *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_CBMS_ServiceType (pctxt, ((CBMS_ServiceType*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_ServiceTableType (OSCTXT* pctxt, 
   CBMS_ServiceTableType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_CBMS_ServiceType (pctxt, ((CBMS_ServiceType*)pnode->data)
         , OSUTF8("Service"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ServiceBundleType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_ServiceBundleType (OSCTXT* pctxt,
   CBMS_ServiceBundleType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode relatedMaterial_list */

   pnode2 = pvalue->relatedMaterial_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CBMS_RelatedMaterialType (pctxt, ((CBMS_RelatedMaterialType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode parentalGuidance_list */

   pnode2 = pvalue->parentalGuidance_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ParentalGuidanceType (pctxt, ((ParentalGuidanceType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode serviceRef_list */

   pnode2 = pvalue->serviceRef_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CBMS_ServiceRefType (pctxt, ((CBMS_ServiceRefType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode serviceBundleGenre_list */

   pnode2 = pvalue->serviceBundleGenre_list.tail;
   while (0 != pnode2) {
      ll = asn1E_GenreType (pctxt, ((GenreType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode serviceBundleDescription_list */

   pnode2 = pvalue->serviceBundleDescription_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TextualType (pctxt, ((TextualType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode serviceBundleMediaTitle */

   if (pvalue->m.serviceBundleMediaTitlePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_TitleMediaType (pctxt, &pvalue->serviceBundleMediaTitle, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode serviceBundleProvider */

   if (pvalue->m.serviceBundleProviderPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_CBMS_ProviderType (pctxt, &pvalue->serviceBundleProvider, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode serviceBundleName_list */

   if (!(pvalue->serviceBundleName_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ServiceBundleType.serviceBundleName_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->serviceBundleName_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->serviceBundleName_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TextualType (pctxt, ((TextualType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode serviceBundleID */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->serviceBundleID, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_ServiceBundleType (OSCTXT* pctxt, 
   CBMS_ServiceBundleType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" serviceBundleID=\""), 18);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->serviceBundleID, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode serviceBundleName_list */

   if (!(pvalue->serviceBundleName_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ServiceBundleType.serviceBundleName_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->serviceBundleName_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->serviceBundleName_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TextualType (pctxt, ((TextualType*)pnode->data)
         , OSUTF8("ServiceBundleName"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode serviceBundleProvider */

   if (pvalue->m.serviceBundleProviderPresent) {
      stat = XmlEnc_CBMS_ProviderType (pctxt, &pvalue->serviceBundleProvider
         , OSUTF8("ServiceBundleProvider"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode serviceBundleMediaTitle */

   if (pvalue->m.serviceBundleMediaTitlePresent) {
      stat = XmlEnc_TitleMediaType (pctxt, &pvalue->serviceBundleMediaTitle
         , OSUTF8("ServiceBundleMediaTitle"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode serviceBundleDescription_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->serviceBundleDescription_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TextualType (pctxt, ((TextualType*)pnode->data)
         , OSUTF8("ServiceBundleDescription"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode serviceBundleGenre_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->serviceBundleGenre_list.head;
   while (0 != pnode) {
      stat = XmlEnc_GenreType (pctxt, ((GenreType*)pnode->data)
         , OSUTF8("ServiceBundleGenre"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode serviceRef_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->serviceRef_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CBMS_ServiceRefType (pctxt, 
         ((CBMS_ServiceRefType*)pnode->data), OSUTF8("ServiceRef"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode parentalGuidance_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->parentalGuidance_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ParentalGuidanceType (pctxt, 
         ((ParentalGuidanceType*)pnode->data)
         , OSUTF8("ParentalGuidance"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode relatedMaterial_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->relatedMaterial_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CBMS_RelatedMaterialType (pctxt, 
         ((CBMS_RelatedMaterialType*)pnode->data)
         , OSUTF8("RelatedMaterial"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ServiceBundleTableType                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_ServiceBundleTableType (OSCTXT* pctxt,
   CBMS_ServiceBundleTableType *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_CBMS_ServiceBundleType (pctxt, ((CBMS_ServiceBundleType*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_ServiceBundleTableType (OSCTXT* pctxt, 
   CBMS_ServiceBundleTableType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_CBMS_ServiceBundleType (pctxt, 
         ((CBMS_ServiceBundleType*)pnode->data)
         , OSUTF8("ServiceBundle"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CurrencyCodeType                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_CurrencyCodeType (OSCTXT* pctxt,
   CBMS_CurrencyCodeType pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_utf8str (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_CBMS_CurrencyCodeType (OSCTXT* pctxt, CBMS_CurrencyCodeType value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!rtxMatchPattern (pctxt, value, OSUTF8("[a-zA-Z]{3}"))) {
      return LOG_RTERRNEW2 (pctxt, RTERR_PATMATCH,
         rtxErrAddStrParm (pctxt, "CurrencyCodeType"),
         rtxErrAddStrParm (pctxt, (const char*)value));
   }

   stat = rtXmlEncUTF8Str (pctxt, value, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseType_price                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_PurchaseType_price (OSCTXT* pctxt,
   CBMS_PurchaseType_price *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_real (pctxt, &pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode currency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_CBMS_CurrencyCodeType (pctxt, pvalue->currency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_PurchaseType_price (OSCTXT* pctxt, 
   CBMS_PurchaseType_price* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (!rtxMatchPattern (pctxt, pvalue->currency, OSUTF8("[a-zA-Z]{3}"))) {
      return LOG_RTERRNEW2 (pctxt, RTERR_PATMATCH,
         rtxErrAddStrParm (pctxt, "PurchaseType_price.currency"),
         rtxErrAddStrParm (pctxt, (const char*)pvalue->currency));
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" currency=\""), 11);

   stat = XmlEnc_CBMS_CurrencyCodeType (pctxt, pvalue->currency, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode base */

   stat = rtXmlEncDouble (pctxt, pvalue->base, 0, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UsageConstraintsType_quantityRange                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_UsageConstraintsType_quantityRange (OSCTXT* pctxt,
   CBMS_UsageConstraintsType_quantityRange *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode min */

   if (pvalue->m.minPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_unsigned (pctxt, &pvalue->min, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode max */

   if (pvalue->m.maxPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_unsigned (pctxt, &pvalue->max, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_UsageConstraintsType_quantityRange (OSCTXT* pctxt, 
   CBMS_UsageConstraintsType_quantityRange* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.maxPresent) {
      stat = rtXmlEncUIntAttr
         (pctxt, pvalue->max, OSUTF8("max"), 3);
   }

   if (pvalue->m.minPresent) {
      stat = rtXmlEncUIntAttr
         (pctxt, pvalue->min, OSUTF8("min"), 3);
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UsageConstraintsType                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_UsageConstraintsType (OSCTXT* pctxt,
   CBMS_UsageConstraintsType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode quantityRange */

   if (pvalue->m.quantityRangePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_CBMS_UsageConstraintsType_quantityRange (pctxt, &pvalue->quantityRange, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode quantityUnit */

   if (pvalue->m.quantityUnitPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ControlledTermType_derivations (pctxt, &pvalue->quantityUnit, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode purchaseType */

   if (pvalue->m.purchaseTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ControlledTermType_derivations (pctxt, &pvalue->purchaseType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_UsageConstraintsType (OSCTXT* pctxt, 
   CBMS_UsageConstraintsType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode purchaseType */

   if (pvalue->m.purchaseTypePresent) {
      stat = XmlEnc_ControlledTermType_derivations (pctxt, &pvalue->
         purchaseType, OSUTF8("PurchaseType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantityUnit */

   if (pvalue->m.quantityUnitPresent) {
      stat = XmlEnc_ControlledTermType_derivations (pctxt, &pvalue->
         quantityUnit, OSUTF8("QuantityUnit"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode quantityRange */

   if (pvalue->m.quantityRangePresent) {
      stat = XmlEnc_CBMS_UsageConstraintsType_quantityRange (pctxt, &pvalue->
         quantityRange, OSUTF8("QuantityRange"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseDataType                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_PurchaseDataType (OSCTXT* pctxt,
   CBMS_PurchaseDataType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode data */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->data, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_PurchaseDataType (OSCTXT* pctxt, 
   CBMS_PurchaseDataType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode data */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->data, OSUTF8("Data"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseDataBaseType_derivations                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_PurchaseDataBaseType_derivations (OSCTXT* pctxt,
   CBMS_PurchaseDataBaseType_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_CBMS_PurchaseDataType (pctxt, pvalue->u.purchaseDataType, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_CBMS_PurchaseDataBaseType_derivations (OSCTXT* pctxt, 
   CBMS_PurchaseDataBaseType_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   switch (pvalue->t)
   {
      case 1:
         /* encode purchaseDataType */

         stat = XmlEnc_CBMS_PurchaseDataType (pctxt, pvalue->u.purchaseDataType
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseRequestType                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_PurchaseRequestType (OSCTXT* pctxt,
   CBMS_PurchaseRequestType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode purchaseChannelIDRef */

   if (pvalue->m.purchaseChannelIDRefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_CBMS_ESGIDRefType_derivations (pctxt, &pvalue->purchaseChannelIDRef, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode purchaseData */

   if (pvalue->m.purchaseDataPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_CBMS_PurchaseDataBaseType_derivations (pctxt, &pvalue->purchaseData, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dRMSystem */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->dRMSystem, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_PurchaseRequestType (OSCTXT* pctxt, 
   CBMS_PurchaseRequestType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode dRMSystem */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->dRMSystem
      , OSUTF8("DRMSystem"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode purchaseData */

   if (pvalue->m.purchaseDataPresent) {
      stat = XmlEnc_CBMS_PurchaseDataBaseType_derivations (pctxt, &pvalue->
         purchaseData, OSUTF8("PurchaseData"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode purchaseChannelIDRef */

   if (pvalue->m.purchaseChannelIDRefPresent) {
      stat = XmlEnc_CBMS_ESGIDRefType_derivations (pctxt, &pvalue->
         purchaseChannelIDRef, OSUTF8("PurchaseChannelIDRef"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_PurchaseType (OSCTXT* pctxt,
   CBMS_PurchaseType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode mediaTitle_list */

   pnode2 = pvalue->mediaTitle_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TitleMediaType (pctxt, ((TitleMediaType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode purchaseRequest_list */

   pnode2 = pvalue->purchaseRequest_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CBMS_PurchaseRequestType (pctxt, ((CBMS_PurchaseRequestType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode description_list */

   pnode2 = pvalue->description_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TextualType (pctxt, ((TextualType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode usageConstraints_list */

   pnode2 = pvalue->usageConstraints_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CBMS_UsageConstraintsType (pctxt, ((CBMS_UsageConstraintsType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode price_list */

   if (!(pvalue->price_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "PurchaseType.price_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->price_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->price_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CBMS_PurchaseType_price (pctxt, ((CBMS_PurchaseType_price*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode serviceBundleRef */

   if (pvalue->m.serviceBundleRefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_CBMS_ESGIDRefType_derivations (pctxt, &pvalue->serviceBundleRef, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode start */

   if (pvalue->m.startPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_charstr (pctxt, pvalue->start, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode purchaseId */

   if (pvalue->m.purchaseIdPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->purchaseId, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode end */

   if (pvalue->m.endPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_charstr (pctxt, pvalue->end, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_PurchaseType (OSCTXT* pctxt, CBMS_PurchaseType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.endPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" end=\""), 6);

      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->end, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.purchaseIdPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" purchaseId=\""), 13);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->purchaseId, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.startPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" start=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->start, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode serviceBundleRef */

   if (pvalue->m.serviceBundleRefPresent) {
      stat = XmlEnc_CBMS_ESGIDRefType_derivations (pctxt, &pvalue->
         serviceBundleRef, OSUTF8("ServiceBundleRef"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode price_list */

   if (!(pvalue->price_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "PurchaseType.price_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->price_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->price_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CBMS_PurchaseType_price (pctxt, 
         ((CBMS_PurchaseType_price*)pnode->data), OSUTF8("Price"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode usageConstraints_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->usageConstraints_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CBMS_UsageConstraintsType (pctxt, 
         ((CBMS_UsageConstraintsType*)pnode->data)
         , OSUTF8("UsageConstraints"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode description_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->description_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TextualType (pctxt, ((TextualType*)pnode->data)
         , OSUTF8("Description"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode purchaseRequest_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->purchaseRequest_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CBMS_PurchaseRequestType (pctxt, 
         ((CBMS_PurchaseRequestType*)pnode->data)
         , OSUTF8("PurchaseRequest"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode mediaTitle_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->mediaTitle_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TitleMediaType (pctxt, ((TitleMediaType*)pnode->data)
         , OSUTF8("MediaTitle"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseTableType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_PurchaseTableType (OSCTXT* pctxt,
   CBMS_PurchaseTableType *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_CBMS_PurchaseType (pctxt, ((CBMS_PurchaseType*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_PurchaseTableType (OSCTXT* pctxt, 
   CBMS_PurchaseTableType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_CBMS_PurchaseType (pctxt, ((CBMS_PurchaseType*)pnode->data)
         , OSUTF8("Purchase"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseChannelType                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_PurchaseChannelType (OSCTXT* pctxt,
   CBMS_PurchaseChannelType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode privateData_list */

   pnode2 = pvalue->privateData_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CBMS_PrivateDataType (pctxt, ((CBMS_PrivateDataType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode mediaTitle_list */

   pnode2 = pvalue->mediaTitle_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TitleMediaType (pctxt, ((TitleMediaType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode contactInfo_list */

   pnode2 = pvalue->contactInfo_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode portalURL */

   if (pvalue->m.portalURLPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_utf8str (pctxt, pvalue->portalURL, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode description_list */

   pnode2 = pvalue->description_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TextualType (pctxt, ((TextualType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode name_list */

   if (!(pvalue->name_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "PurchaseChannelType.name_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->name_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->name_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TextualType (pctxt, ((TextualType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode purchaseChannelID */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->purchaseChannelID, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_PurchaseChannelType (OSCTXT* pctxt, 
   CBMS_PurchaseChannelType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" purchaseChannelID=\""), 20);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->purchaseChannelID, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode name_list */

   if (!(pvalue->name_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "PurchaseChannelType.name_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->name_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->name_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TextualType (pctxt, ((TextualType*)pnode->data)
         , OSUTF8("Name"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode description_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->description_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TextualType (pctxt, ((TextualType*)pnode->data)
         , OSUTF8("Description"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode portalURL */

   if (pvalue->m.portalURLPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->portalURL
         , OSUTF8("PortalURL"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode contactInfo_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->contactInfo_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("ContactInfo"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode mediaTitle_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->mediaTitle_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TitleMediaType (pctxt, ((TitleMediaType*)pnode->data)
         , OSUTF8("MediaTitle"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode privateData_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->privateData_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CBMS_PrivateDataType (pctxt, 
         ((CBMS_PrivateDataType*)pnode->data)
         , OSUTF8("PrivateData"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseChannelTableType                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_PurchaseChannelTableType (OSCTXT* pctxt,
   CBMS_PurchaseChannelTableType *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_CBMS_PurchaseChannelType (pctxt, ((CBMS_PurchaseChannelType*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_PurchaseChannelTableType (OSCTXT* pctxt, 
   CBMS_PurchaseChannelTableType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_CBMS_PurchaseChannelType (pctxt, 
         ((CBMS_PurchaseChannelType*)pnode->data)
         , OSUTF8("PurchaseChannel"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VideoCodecCharacteristicType                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_VideoCodecCharacteristicType (OSCTXT* pctxt,
   CBMS_VideoCodecCharacteristicType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode profileLevelIndication */

   if (pvalue->m.profileLevelIndicationPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ControlledTermType_derivations (pctxt, &pvalue->profileLevelIndication, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode codec */

   if (pvalue->m.codecPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ControlledTermType_derivations (pctxt, &pvalue->codec, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_VideoCodecCharacteristicType (OSCTXT* pctxt, 
   CBMS_VideoCodecCharacteristicType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode codec */

   if (pvalue->m.codecPresent) {
      stat = XmlEnc_ControlledTermType_derivations (pctxt, &pvalue->codec
         , OSUTF8("Codec"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode profileLevelIndication */

   if (pvalue->m.profileLevelIndicationPresent) {
      stat = XmlEnc_ControlledTermType_derivations (pctxt, &pvalue->
         profileLevelIndication, OSUTF8("ProfileLevelIndication"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VideoComponentType                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_VideoComponentType (OSCTXT* pctxt,
   CBMS_VideoComponentType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode signLanguage */

   if (pvalue->m.signLanguagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_SignLanguageType (pctxt, &pvalue->signLanguage, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode openCaptionLanguage */

   if (pvalue->m.openCaptionLanguagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_utf8str (pctxt, pvalue->openCaptionLanguage, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode frameRate */

   if (pvalue->m.frameRatePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         asn1E_FrameRateType (pctxt, pvalue->frameRate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode codecCharacteristic */

   if (pvalue->m.codecCharacteristicPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_CBMS_VideoCodecCharacteristicType (pctxt, &pvalue->codecCharacteristic, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bandwidth */

   if (pvalue->m.bandwidthPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_BitRateType (pctxt, &pvalue->bandwidth, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode purpose */

   if (pvalue->m.purposePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->purpose, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_VideoComponentType (OSCTXT* pctxt, 
   CBMS_VideoComponentType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.purposePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" purpose=\""), 10);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->purpose, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode bandwidth */

   if (pvalue->m.bandwidthPresent) {
      stat = XmlEnc_BitRateType (pctxt, &pvalue->bandwidth
         , OSUTF8("Bandwidth"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode codecCharacteristic */

   if (pvalue->m.codecCharacteristicPresent) {
      stat = XmlEnc_CBMS_VideoCodecCharacteristicType (pctxt, &pvalue->
         codecCharacteristic, OSUTF8("CodecCharacteristic"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode frameRate */

   if (pvalue->m.frameRatePresent) {
      stat = XmlEnc_FrameRateType (pctxt, pvalue->frameRate
         , OSUTF8("FrameRate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode openCaptionLanguage */

   if (pvalue->m.openCaptionLanguagePresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->openCaptionLanguage
         , OSUTF8("OpenCaptionLanguage"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode signLanguage */

   if (pvalue->m.signLanguagePresent) {
      stat = XmlEnc_SignLanguageType (pctxt, &pvalue->signLanguage
         , OSUTF8("SignLanguage"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AudioComponentType                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_AudioComponentType (OSCTXT* pctxt,
   CBMS_AudioComponentType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode language_list */

   pnode2 = pvalue->language_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ExtendedLanguageType (pctxt, ((ExtendedLanguageType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode mode */

   if (pvalue->m.modePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_ControlledTermType_derivations (pctxt, &pvalue->mode, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode codec */

   if (pvalue->m.codecPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_ControlledTermType_derivations (pctxt, &pvalue->codec, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bandwidth */

   if (pvalue->m.bandwidthPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_BitRateType (pctxt, &pvalue->bandwidth, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode purpose */

   if (pvalue->m.purposePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->purpose, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_AudioComponentType (OSCTXT* pctxt, 
   CBMS_AudioComponentType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.purposePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" purpose=\""), 10);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->purpose, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode bandwidth */

   if (pvalue->m.bandwidthPresent) {
      stat = XmlEnc_BitRateType (pctxt, &pvalue->bandwidth
         , OSUTF8("Bandwidth"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode codec */

   if (pvalue->m.codecPresent) {
      stat = XmlEnc_ControlledTermType_derivations (pctxt, &pvalue->codec
         , OSUTF8("Codec"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode mode */

   if (pvalue->m.modePresent) {
      stat = XmlEnc_ControlledTermType_derivations (pctxt, &pvalue->mode
         , OSUTF8("Mode"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode language_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->language_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ExtendedLanguageType (pctxt, 
         ((ExtendedLanguageType*)pnode->data), OSUTF8("Language"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FileDownloadComponentType                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_FileDownloadComponentType (OSCTXT* pctxt,
   CBMS_FileDownloadComponentType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode storage */

   if (pvalue->m.storagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_unsigned (pctxt, &pvalue->storage, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode fileFormat_list */

   pnode2 = pvalue->fileFormat_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode bandwidth */

   if (pvalue->m.bandwidthPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_BitRateType (pctxt, &pvalue->bandwidth, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode purpose */

   if (pvalue->m.purposePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->purpose, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_FileDownloadComponentType (OSCTXT* pctxt, 
   CBMS_FileDownloadComponentType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.purposePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" purpose=\""), 10);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->purpose, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode bandwidth */

   if (pvalue->m.bandwidthPresent) {
      stat = XmlEnc_BitRateType (pctxt, &pvalue->bandwidth
         , OSUTF8("Bandwidth"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fileFormat_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->fileFormat_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("FileFormat"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode storage */

   if (pvalue->m.storagePresent) {
      stat = rtXmlEncUInt (pctxt, pvalue->storage, OSUTF8("Storage"), nsPrefix
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ComponentCharacteristicType_derivations                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_ComponentCharacteristicType_derivations (OSCTXT* pctxt,
   CBMS_ComponentCharacteristicType_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_CBMS_VideoComponentType (pctxt, pvalue->u.videoComponentType, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_CBMS_AudioComponentType (pctxt, pvalue->u.audioComponentType, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_CBMS_FileDownloadComponentType (pctxt, pvalue->u.fileDownloadComponentType, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_CBMS_ComponentCharacteristicType_derivations (OSCTXT* pctxt, 
   CBMS_ComponentCharacteristicType_derivations* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   switch (pvalue->t)
   {
      case 1:
         /* encode videoComponentType */

         stat = XmlEnc_CBMS_VideoComponentType (pctxt, pvalue->
            u.videoComponentType, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode audioComponentType */

         stat = XmlEnc_CBMS_AudioComponentType (pctxt, pvalue->
            u.audioComponentType, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode fileDownloadComponentType */

         stat = XmlEnc_CBMS_FileDownloadComponentType (pctxt, pvalue->
            u.fileDownloadComponentType, 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDPType                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_SDPType (OSCTXT* pctxt,
   CBMS_SDPType pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_utf8str (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_CBMS_SDPType (OSCTXT* pctxt, CBMS_SDPType value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt, value, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InlinedSDPType                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_InlinedSDPType (OSCTXT* pctxt,
   CBMS_InlinedSDPType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode associatedDeliveryProcedure */

   if (pvalue->m.associatedDeliveryProcedurePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->associatedDeliveryProcedure, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode sDP */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_CBMS_SDPType (pctxt, pvalue->sDP, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_InlinedSDPType (OSCTXT* pctxt, CBMS_InlinedSDPType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode sDP */

   stat = XmlEnc_CBMS_SDPType (pctxt, pvalue->sDP, OSUTF8("SDP"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode associatedDeliveryProcedure */

   if (pvalue->m.associatedDeliveryProcedurePresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->associatedDeliveryProcedure
         , OSUTF8("AssociatedDeliveryProcedure"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SDPRefType                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_SDPRefType (OSCTXT* pctxt,
   CBMS_SDPRefType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode associatedDeliveryProcedure */

   if (pvalue->m.associatedDeliveryProcedurePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->associatedDeliveryProcedure, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode sDPURI */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->sDPURI, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode sDPStream */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_CBMS_SDPType (pctxt, pvalue->sDPStream, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_SDPRefType (OSCTXT* pctxt, CBMS_SDPRefType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode sDPStream */

   stat = XmlEnc_CBMS_SDPType (pctxt, pvalue->sDPStream
      , OSUTF8("SDPStream"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode sDPURI */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->sDPURI, OSUTF8("SDPURI"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode associatedDeliveryProcedure */

   if (pvalue->m.associatedDeliveryProcedurePresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->associatedDeliveryProcedure
         , OSUTF8("AssociatedDeliveryProcedure"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SessionDescriptionBaseType_derivations                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_SessionDescriptionBaseType_derivations (OSCTXT* pctxt,
   CBMS_SessionDescriptionBaseType_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_CBMS_InlinedSDPType (pctxt, pvalue->u.inlinedSDPType, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_CBMS_SDPRefType (pctxt, pvalue->u.sDPRefType, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         rtxErrAddIntParm (pctxt, pvalue->t);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_CBMS_SessionDescriptionBaseType_derivations (OSCTXT* pctxt, 
   CBMS_SessionDescriptionBaseType_derivations* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   switch (pvalue->t)
   {
      case 1:
         /* encode inlinedSDPType */

         stat = XmlEnc_CBMS_InlinedSDPType (pctxt, pvalue->u.inlinedSDPType
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode sDPRefType */

         stat = XmlEnc_CBMS_SDPRefType (pctxt, pvalue->u.sDPRefType
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ComponentDescriptionType                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_ComponentDescriptionType (OSCTXT* pctxt,
   CBMS_ComponentDescriptionType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode sessionDescription */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_CBMS_SessionDescriptionBaseType_derivations (pctxt, &pvalue->sessionDescription, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode componentCharacteristic_list */

   pnode2 = pvalue->componentCharacteristic_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CBMS_ComponentCharacteristicType_derivations (pctxt, ((CBMS_ComponentCharacteristicType_derivations*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_ComponentDescriptionType (OSCTXT* pctxt, 
   CBMS_ComponentDescriptionType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode componentCharacteristic_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->componentCharacteristic_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CBMS_ComponentCharacteristicType_derivations (pctxt, 
         ((CBMS_ComponentCharacteristicType_derivations*)pnode->data)
         , OSUTF8("ComponentCharacteristic"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode sessionDescription */

   stat = XmlEnc_CBMS_SessionDescriptionBaseType_derivations (pctxt, &pvalue->
      sessionDescription, OSUTF8("SessionDescription"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ZappingSupportType_element_choice                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_ZappingSupportType_element_choice (OSCTXT* pctxt,
   CBMS_ZappingSupportType_element_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_MediaLocatorType_derivations (pctxt, pvalue->u.mediaLocator, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         if (!((pvalue->u.zappingSDP_list->count >= 0 && pvalue->u.zappingSDP_list->
            count <= 1))) {
            rtxErrAddStrParm (pctxt, "ZappingSupportType_element_choice.u.zappingSDP_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.zappingSDP_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         pnode2 = pvalue->u.zappingSDP_list->tail;
         while (0 != pnode2) {
            ll = asn1E_CBMS_SessionDescriptionBaseType_derivations (pctxt, ((CBMS_SessionDescriptionBaseType_derivations*)pnode2->data), ASN1EXPL);
            if (ll < 0) return LOG_RTERR (pctxt, ll);
            ll2 += ll;

            pnode2 = pnode2->prev;
         }
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else { ll1 += ll; ll2 = 0; }
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_CBMS_ZappingSupportType_element_choice (OSCTXT* pctxt, 
   CBMS_ZappingSupportType_element_choice* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   switch (pvalue->t)
   {
      case 1:
         /* encode mediaLocator */

         stat = XmlEnc_MediaLocatorType_derivations (pctxt, pvalue->
            u.mediaLocator, OSUTF8("MediaLocator"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode zappingSDP_list */

         if (!((pvalue->u.zappingSDP_list->count >= 0 && pvalue->
            u.zappingSDP_list->count <= 1))) {
            rtxErrAddStrParm (pctxt, "ZappingSupportType_element_choice.u.zappingSDP_list.count");
            rtxErrAddIntParm (pctxt, (int)pvalue->u.zappingSDP_list->count);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         { const OSUTF8CHAR* savedPrefix = nsPrefix;
         nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

         { OSRTDListNode* pnode = pvalue->u.zappingSDP_list->head;
         while (0 != pnode) {
            stat = XmlEnc_CBMS_SessionDescriptionBaseType_derivations (pctxt, 
               ((CBMS_SessionDescriptionBaseType_derivations*)pnode->data)
               , OSUTF8("ZappingSDP"), nsPrefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            pnode = pnode->next;
         }}
         nsPrefix = savedPrefix;
         }

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ZappingSupportType_element                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_ZappingSupportType_element (OSCTXT* pctxt,
   CBMS_ZappingSupportType_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode choice */

   if (pvalue->m.choicePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_CBMS_ZappingSupportType_element_choice (pctxt, &pvalue->choice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode type_list */

   pnode2 = pvalue->type_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ControlledTermType_derivations (pctxt, ((ControlledTermType_derivations*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_ZappingSupportType_element (OSCTXT* pctxt, 
   CBMS_ZappingSupportType_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode type_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->type_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ControlledTermType_derivations (pctxt, 
         ((ControlledTermType_derivations*)pnode->data)
         , OSUTF8("Type"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode choice */

   if (pvalue->m.choicePresent) {
      stat = XmlEnc_CBMS_ZappingSupportType_element_choice (pctxt, &pvalue->
         choice, OSUTF8(""), 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ZappingSupportType                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_ZappingSupportType (OSCTXT* pctxt,
   CBMS_ZappingSupportType *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_CBMS_ZappingSupportType_element (pctxt, ((CBMS_ZappingSupportType_element*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_ZappingSupportType (OSCTXT* pctxt, 
   CBMS_ZappingSupportType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_CBMS_ZappingSupportType_element (pctxt, 
         ((CBMS_ZappingSupportType_element*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  KeyStreamType                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_KeyStreamType (OSCTXT* pctxt,
   CBMS_KeyStreamType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode iPDCOperatorID */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->iPDCOperatorID, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode cBMSKMSId */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_uint16 (pctxt, &pvalue->cBMSKMSId, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_KeyStreamType (OSCTXT* pctxt, CBMS_KeyStreamType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   stat = rtXmlEncUIntAttr
      (pctxt, pvalue->cBMSKMSId, OSUTF8("CBMSKMSId"), 9);

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" IPDCOperatorID=\""), 17);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->iPDCOperatorID, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  KeyStreamBaseType_derivations                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_KeyStreamBaseType_derivations (OSCTXT* pctxt,
   CBMS_KeyStreamBaseType_derivations *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_CBMS_KeyStreamType (pctxt, pvalue->u.keyStreamType, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_CBMS_KeyStreamBaseType_derivations (OSCTXT* pctxt, 
   CBMS_KeyStreamBaseType_derivations* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   switch (pvalue->t)
   {
      case 1:
         /* encode keyStreamType */

         stat = XmlEnc_CBMS_KeyStreamType (pctxt, pvalue->u.keyStreamType
            , 0, nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AcquisitionType                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_AcquisitionType (OSCTXT* pctxt,
   CBMS_AcquisitionType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode keyStream_list */

   pnode2 = pvalue->keyStream_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CBMS_KeyStreamBaseType_derivations (pctxt, ((CBMS_KeyStreamBaseType_derivations*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode zappingSupport */

   if (pvalue->m.zappingSupportPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_CBMS_ZappingSupportType (pctxt, &pvalue->zappingSupport, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode componentDescription_list */

   if (!(pvalue->componentDescription_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "AcquisitionType.componentDescription_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->componentDescription_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->componentDescription_list.tail;
   while (0 != pnode2) {
      ll = asn1E_CBMS_ComponentDescriptionType (pctxt, ((CBMS_ComponentDescriptionType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode contentMimeType */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_MimeType (pctxt, pvalue->contentMimeType, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode acquisitionID */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->acquisitionID, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_AcquisitionType (OSCTXT* pctxt, CBMS_AcquisitionType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" acquisitionID=\""), 16);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->acquisitionID, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" contentMimeType=\""), 18);

   stat = XmlEnc_MimeType (pctxt, pvalue->contentMimeType, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode componentDescription_list */

   if (!(pvalue->componentDescription_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "AcquisitionType.componentDescription_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->componentDescription_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->componentDescription_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CBMS_ComponentDescriptionType (pctxt, 
         ((CBMS_ComponentDescriptionType*)pnode->data)
         , OSUTF8("ComponentDescription"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode zappingSupport */

   if (pvalue->m.zappingSupportPresent) {
      stat = XmlEnc_CBMS_ZappingSupportType (pctxt, &pvalue->zappingSupport
         , OSUTF8("ZappingSupport"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode keyStream_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->keyStream_list.head;
   while (0 != pnode) {
      stat = XmlEnc_CBMS_KeyStreamBaseType_derivations (pctxt, 
         ((CBMS_KeyStreamBaseType_derivations*)pnode->data)
         , OSUTF8("KeyStream"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AcquisitionTableType                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_AcquisitionTableType (OSCTXT* pctxt,
   CBMS_AcquisitionTableType *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_CBMS_AcquisitionType (pctxt, ((CBMS_AcquisitionType*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_AcquisitionTableType (OSCTXT* pctxt, 
   CBMS_AcquisitionTableType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_CBMS_AcquisitionType (pctxt, 
         ((CBMS_AcquisitionType*)pnode->data)
         , OSUTF8("Acquisition"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ESGType                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_ESGType (OSCTXT* pctxt,
   CBMS_ESGType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode acquisitionTable */

   if (pvalue->m.acquisitionTablePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_CBMS_AcquisitionTableType (pctxt, &pvalue->acquisitionTable, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode purchaseChannelTable */

   if (pvalue->m.purchaseChannelTablePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_CBMS_PurchaseChannelTableType (pctxt, &pvalue->purchaseChannelTable, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode purchaseTable */

   if (pvalue->m.purchaseTablePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_CBMS_PurchaseTableType (pctxt, &pvalue->purchaseTable, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode serviceBundleTable */

   if (pvalue->m.serviceBundleTablePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_CBMS_ServiceBundleTableType (pctxt, &pvalue->serviceBundleTable, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode serviceTable */

   if (pvalue->m.serviceTablePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_CBMS_ServiceTableType (pctxt, &pvalue->serviceTable, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode scheduleEventTable */

   if (pvalue->m.scheduleEventTablePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_CBMS_ScheduleEventTableType (pctxt, &pvalue->scheduleEventTable, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode contentTable */

   if (pvalue->m.contentTablePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_CBMS_ContentTableType (pctxt, &pvalue->contentTable, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_ESGType (OSCTXT* pctxt, CBMS_ESGType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode contentTable */

   if (pvalue->m.contentTablePresent) {
      stat = XmlEnc_CBMS_ContentTableType (pctxt, &pvalue->contentTable
         , OSUTF8("ContentTable"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode scheduleEventTable */

   if (pvalue->m.scheduleEventTablePresent) {
      stat = XmlEnc_CBMS_ScheduleEventTableType (pctxt, &pvalue->
         scheduleEventTable, OSUTF8("ScheduleEventTable"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode serviceTable */

   if (pvalue->m.serviceTablePresent) {
      stat = XmlEnc_CBMS_ServiceTableType (pctxt, &pvalue->serviceTable
         , OSUTF8("ServiceTable"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode serviceBundleTable */

   if (pvalue->m.serviceBundleTablePresent) {
      stat = XmlEnc_CBMS_ServiceBundleTableType (pctxt, &pvalue->
         serviceBundleTable, OSUTF8("ServiceBundleTable"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode purchaseTable */

   if (pvalue->m.purchaseTablePresent) {
      stat = XmlEnc_CBMS_PurchaseTableType (pctxt, &pvalue->purchaseTable
         , OSUTF8("PurchaseTable"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode purchaseChannelTable */

   if (pvalue->m.purchaseChannelTablePresent) {
      stat = XmlEnc_CBMS_PurchaseChannelTableType (pctxt, &pvalue->
         purchaseChannelTable, OSUTF8("PurchaseChannelTable"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode acquisitionTable */

   if (pvalue->m.acquisitionTablePresent) {
      stat = XmlEnc_CBMS_AcquisitionTableType (pctxt, &pvalue->acquisitionTable
         , OSUTF8("AcquisitionTable"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ESGMainType                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_ESGMainType (OSCTXT* pctxt,
   CBMS_ESGMainType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode eSG */

   if (pvalue->m.eSGPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_CBMS_ESGType (pctxt, &pvalue->eSG, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode classificationSchemeTable */

   if (pvalue->m.classificationSchemeTablePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_ClassificationSchemeTableType (pctxt, &pvalue->classificationSchemeTable, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode copyrightNotice */

   if (pvalue->m.copyrightNoticePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_utf8str (pctxt, pvalue->copyrightNotice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode lang */

   if (pvalue->m.langPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_utf8str (pctxt, pvalue->lang, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode rightsOwner */

   if (pvalue->m.rightsOwnerPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->rightsOwner, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode publisher */

   if (pvalue->m.publisherPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->publisher, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode publicationTime */

   if (pvalue->m.publicationTimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_charstr (pctxt, pvalue->publicationTime, ASN1IMPL, TM_UNIV|TM_PRIM|26));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_ESGMainType (OSCTXT* pctxt, CBMS_ESGMainType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.publicationTimePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" publicationTime=\""), 18);

      stat = rtXmlEncUTF8Str (pctxt, (const OSUTF8CHAR*)pvalue->publicationTime
         , 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.publisherPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" publisher=\""), 12);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->publisher, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.rightsOwnerPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" rightsOwner=\""), 14);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->rightsOwner, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.langPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" xml:lang=\""), 11);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->lang, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode copyrightNotice */

   if (pvalue->m.copyrightNoticePresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->copyrightNotice
         , OSUTF8("CopyrightNotice"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode classificationSchemeTable */

   if (pvalue->m.classificationSchemeTablePresent) {
      stat = XmlEnc_ClassificationSchemeTableType (pctxt, &pvalue->
         classificationSchemeTable
         , OSUTF8("ClassificationSchemeTable"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode eSG */

   if (pvalue->m.eSGPresent) {
      stat = XmlEnc_CBMS_ESGType (pctxt, &pvalue->eSG
         , OSUTF8("ESG"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ESGMain                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_ESGMain (OSCTXT* pctxt,
   CBMS_ESGMain *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_CBMS_ESGMainType (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_CBMS_ESGMain (OSCTXT* pctxt, CBMS_ESGMain* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_CBMS_ESGMainType (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseDataBaseType                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_PurchaseDataBaseType (OSCTXT* pctxt,
   CBMS_PurchaseDataBaseType *pvalue, ASN1TagType tagging)
{
   int ll0 = 0;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_PurchaseDataBaseType (OSCTXT* pctxt, 
   CBMS_PurchaseDataBaseType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ComponentCharacteristicType                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_ComponentCharacteristicType (OSCTXT* pctxt,
   CBMS_ComponentCharacteristicType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode bandwidth */

   if (pvalue->m.bandwidthPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_BitRateType (pctxt, &pvalue->bandwidth, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode purpose */

   if (pvalue->m.purposePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->purpose, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_ComponentCharacteristicType (OSCTXT* pctxt, 
   CBMS_ComponentCharacteristicType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.purposePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" purpose=\""), 10);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->purpose, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   /* encode bandwidth */

   if (pvalue->m.bandwidthPresent) {
      stat = XmlEnc_BitRateType (pctxt, &pvalue->bandwidth
         , OSUTF8("Bandwidth"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SessionDescriptionBaseType                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_SessionDescriptionBaseType (OSCTXT* pctxt,
   CBMS_SessionDescriptionBaseType *pvalue, ASN1TagType tagging)
{
   int ll0 = 0;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_SessionDescriptionBaseType (OSCTXT* pctxt, 
   CBMS_SessionDescriptionBaseType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  KeyStreamBaseType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CBMS_KeyStreamBaseType (OSCTXT* pctxt,
   CBMS_KeyStreamBaseType *pvalue, ASN1TagType tagging)
{
   int ll0 = 0;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CBMS_KeyStreamBaseType (OSCTXT* pctxt, 
   CBMS_KeyStreamBaseType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlEnc_CBMS_ESGMain_PDU (OSCTXT* pctxt, CBMS_ESGMain* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   rtXmlNSSetNamespace (pctxt, OSUTF8("esg"), OSUTF8("urn:dvb:ipdc:esg:2005"), 
      FALSE);

   rtXmlNSSetNamespace (pctxt, OSUTF8("tva"), OSUTF8("urn:tva:metadata:2005"), 
      FALSE);

   rtXmlNSSetNamespace (pctxt, OSUTF8("mpeg7"), 
      OSUTF8("urn:mpeg:mpeg7:schema:2001"), FALSE);

   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("ESGMain"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_CBMS_ESGMain (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("ESGMain"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_CBMS_PurchaseDataBaseType_PDU (OSCTXT* pctxt, CBMS_PurchaseDataBaseType* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   rtXmlNSSetNamespace (pctxt, OSUTF8("esg"), OSUTF8("urn:dvb:ipdc:esg:2005"), 
      FALSE);

   rtXmlNSSetNamespace (pctxt, OSUTF8("tva"), OSUTF8("urn:tva:metadata:2005"), 
      FALSE);

   rtXmlNSSetNamespace (pctxt, OSUTF8("mpeg7"), 
      OSUTF8("urn:mpeg:mpeg7:schema:2001"), FALSE);

   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("purchaseDataBaseType"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_CBMS_PurchaseDataBaseType (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("purchaseDataBaseType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_CBMS_ComponentCharacteristicType_PDU (OSCTXT* pctxt, CBMS_ComponentCharacteristicType* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   rtXmlNSSetNamespace (pctxt, OSUTF8("esg"), OSUTF8("urn:dvb:ipdc:esg:2005"), 
      FALSE);

   rtXmlNSSetNamespace (pctxt, OSUTF8("tva"), OSUTF8("urn:tva:metadata:2005"), 
      FALSE);

   rtXmlNSSetNamespace (pctxt, OSUTF8("mpeg7"), 
      OSUTF8("urn:mpeg:mpeg7:schema:2001"), FALSE);

   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("componentCharacteristicType"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_CBMS_ComponentCharacteristicType (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("componentCharacteristicType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_CBMS_SessionDescriptionBaseType_PDU (OSCTXT* pctxt, CBMS_SessionDescriptionBaseType* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   rtXmlNSSetNamespace (pctxt, OSUTF8("esg"), OSUTF8("urn:dvb:ipdc:esg:2005"), 
      FALSE);

   rtXmlNSSetNamespace (pctxt, OSUTF8("tva"), OSUTF8("urn:tva:metadata:2005"), 
      FALSE);

   rtXmlNSSetNamespace (pctxt, OSUTF8("mpeg7"), 
      OSUTF8("urn:mpeg:mpeg7:schema:2001"), FALSE);

   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("sessionDescriptionBaseType"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_CBMS_SessionDescriptionBaseType (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("sessionDescriptionBaseType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_CBMS_KeyStreamBaseType_PDU (OSCTXT* pctxt, CBMS_KeyStreamBaseType* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   rtXmlNSSetNamespace (pctxt, OSUTF8("esg"), OSUTF8("urn:dvb:ipdc:esg:2005"), 
      FALSE);

   rtXmlNSSetNamespace (pctxt, OSUTF8("tva"), OSUTF8("urn:tva:metadata:2005"), 
      FALSE);

   rtXmlNSSetNamespace (pctxt, OSUTF8("mpeg7"), 
      OSUTF8("urn:mpeg:mpeg7:schema:2001"), FALSE);

   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:dvb:ipdc:esg:2005"));

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("keyStreamBaseType"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_CBMS_KeyStreamBaseType (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("keyStreamBaseType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
