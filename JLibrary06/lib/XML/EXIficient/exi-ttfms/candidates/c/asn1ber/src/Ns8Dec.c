/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "Ns8.h"
#include "Odf.h"
#include "Ns12.h"
#include "Ns10.h"
#include "Ns15.h"
#include "Ns3.h"
#include "Ns7.h"
#include "Ns13.h"
#include "rtxsrc/rtxCommon.h"

/**************************************************************/
/*                                                            */
/*  Name                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Name (OSCTXT* pctxt, Ns8_Name *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Name (OSCTXT* pctxt, Ns8_Name* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Num_format_alt_1                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Num_format_alt_1 (OSCTXT* pctxt, 
   Ns8_Num_format_alt_1 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Num_format_alt_1 (OSCTXT* pctxt, Ns8_Num_format_alt_1* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns8_Num_format_alt_1_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Num_format_alt_2                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Num_format_alt_2 (OSCTXT* pctxt, 
   Ns8_Num_format_alt_2 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Num_format_alt_2 (OSCTXT* pctxt, Ns8_Num_format_alt_2* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns8_Num_format_alt_2_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Num_format_alt_3                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Num_format_alt_3 (OSCTXT* pctxt, 
   Ns8_Num_format_alt_3 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Num_format_alt_3 (OSCTXT* pctxt, Ns8_Num_format_alt_3* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns8_Num_format_alt_3_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Num_format_alt_5                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Num_format_alt_5 (OSCTXT* pctxt, 
   Ns8_Num_format_alt_5 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Num_format_alt_5 (OSCTXT* pctxt, Ns8_Num_format_alt_5* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns8_Num_format_alt_5_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Num_format                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Num_format (OSCTXT* pctxt, Ns8_Num_format *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
         stat = asn1D_Ns8_Num_format_alt_1 (pctxt, 
            &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_PRIM|2):
         stat = asn1D_Ns8_Num_format_alt_2 (pctxt, 
            &pvalue->u.alt_2, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_PRIM|3):
         stat = asn1D_Ns8_Num_format_alt_3 (pctxt, 
            &pvalue->u.alt_3, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_PRIM|4):
      case (TM_CTXT|TM_CONS|4):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_4, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|5):
         stat = asn1D_Ns8_Num_format_alt_5 (pctxt, 
            &pvalue->u.alt_5, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns8_Num_format (OSCTXT* pctxt, Ns8_Num_format* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      stat = Ns8_Num_format_alt_1_ToEnum (pctxt, pdata1, &pvalue->u.alt_1);
      if (stat == 0) pvalue->t = 2;
   }
   if (pvalue->t == 0) {
      stat = Ns8_Num_format_alt_2_ToEnum (pctxt, pdata1, &pvalue->u.alt_2);
      if (stat == 0) pvalue->t = 3;
   }
   if (pvalue->t == 0) {
      stat = Ns8_Num_format_alt_3_ToEnum (pctxt, pdata1, &pvalue->u.alt_3);
      if (stat == 0) pvalue->t = 4;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_4 = pdata1;
      pvalue->t = 5;
   }
   if (pvalue->t == 0) {
      stat = Ns8_Num_format_alt_5_ToEnum (pctxt, pdata1, &pvalue->u.alt_5);
      if (stat == 0) pvalue->t = 6;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Num_letter_sync                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Num_letter_sync (OSCTXT* pctxt, 
   Ns8_Num_letter_sync *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Num_letter_sync (OSCTXT* pctxt, Ns8_Num_letter_sync* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns8_Num_letter_sync_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Num_prefix                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Num_prefix (OSCTXT* pctxt, Ns8_Num_prefix *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Num_prefix (OSCTXT* pctxt, Ns8_Num_prefix* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Num_suffix                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Num_suffix (OSCTXT* pctxt, Ns8_Num_suffix *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Num_suffix (OSCTXT* pctxt, Ns8_Num_suffix* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  List_level_properties                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_List_level_properties (OSCTXT* pctxt, 
   Ns8_List_level_properties *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode attr */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->attr);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->attr, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode element14_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Element14* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->element14_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Element14, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = asn1D_Odf_Element14 (pctxt, 
                     (Odf_Element14*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->element14_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_List_level_properties (OSCTXT* pctxt, 
   Ns8_List_level_properties* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      size_t i, nAttrs = 0;
      const OSUTF8CHAR* attrStr;

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         stat = rtXmlpDecAnyAttrStr (pctxt, &attrStr, i);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, &pvalue->attr, (void*)attrStr);
      }
   }

   { OSXSDAny* pdata1;
   OSXMLElemDescr elemDescr;
   const OSUTF8CHAR* pxmlstr;
   for (;;) {
      stat = rtXmlpGetNextElem (pctxt, &elemDescr, -1);
      if (0 != stat) break;

      stat = rtXmlpDecAnyElem (pctxt, &pxmlstr);
      if (0 != stat) break;

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      pdata1 = rtxMemAllocType (pctxt, OSXSDAny);
      if (0 == pdata1) return LOG_RTERR (pctxt, RTERR_NOMEM);

      pdata1->t = OSXSDAny_xmlText;
      pdata1->u.xmlText = pxmlstr;

      if (0 == rtxDListAppend (pctxt, &pvalue->element14_list, pdata1))
         return LOG_RTERR (pctxt, RTERR_NOMEM);
   }
   if (stat == XML_OK_EOB) stat = 0;
   else return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Text_properties                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Text_properties (OSCTXT* pctxt, 
   Ns8_Text_properties *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode attr */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->attr);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->attr, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode element14_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Element14* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->element14_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Element14, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = asn1D_Odf_Element14 (pctxt, 
                     (Odf_Element14*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->element14_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Text_properties (OSCTXT* pctxt, Ns8_Text_properties* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      size_t i, nAttrs = 0;
      const OSUTF8CHAR* attrStr;

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         stat = rtXmlpDecAnyAttrStr (pctxt, &attrStr, i);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, &pvalue->attr, (void*)attrStr);
      }
   }

   { OSXSDAny* pdata1;
   OSXMLElemDescr elemDescr;
   const OSUTF8CHAR* pxmlstr;
   for (;;) {
      stat = rtXmlpGetNextElem (pctxt, &elemDescr, -1);
      if (0 != stat) break;

      stat = rtXmlpDecAnyElem (pctxt, &pxmlstr);
      if (0 != stat) break;

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      pdata1 = rtxMemAllocType (pctxt, OSXSDAny);
      if (0 == pdata1) return LOG_RTERR (pctxt, RTERR_NOMEM);

      pdata1->t = OSXSDAny_xmlText;
      pdata1->u.xmlText = pxmlstr;

      if (0 == rtxDListAppend (pctxt, &pvalue->element14_list, pdata1))
         return LOG_RTERR (pctxt, RTERR_NOMEM);
   }
   if (stat == XML_OK_EOB) stat = 0;
   else return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Rel_height_alt_1                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Rel_height_alt_1 (OSCTXT* pctxt, 
   Ns8_Rel_height_alt_1 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Rel_height_alt_1 (OSCTXT* pctxt, Ns8_Rel_height_alt_1* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns8_Rel_height_alt_1_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Rel_height_alt_2                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Rel_height_alt_2 (OSCTXT* pctxt, 
   Ns8_Rel_height_alt_2 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Rel_height_alt_2 (OSCTXT* pctxt, Ns8_Rel_height_alt_2* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns8_Rel_height_alt_2_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Rel_height                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Rel_height (OSCTXT* pctxt, Ns8_Rel_height *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
         stat = asn1D_Ns8_Rel_height_alt_1 (pctxt, 
            &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_PRIM|2):
         stat = asn1D_Ns8_Rel_height_alt_2 (pctxt, 
            &pvalue->u.alt_2, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns8_Rel_height (OSCTXT* pctxt, Ns8_Rel_height* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      stat = Ns8_Rel_height_alt_1_ToEnum (pctxt, pdata1, &pvalue->u.alt_1);
      if (stat == 0) pvalue->t = 2;
   }
   if (pvalue->t == 0) {
      stat = Ns8_Rel_height_alt_2_ToEnum (pctxt, pdata1, &pvalue->u.alt_2);
      if (stat == 0) pvalue->t = 3;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Rel_width_alt_1                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Rel_width_alt_1 (OSCTXT* pctxt, 
   Ns8_Rel_width_alt_1 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Rel_width_alt_1 (OSCTXT* pctxt, Ns8_Rel_width_alt_1* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns8_Rel_width_alt_1_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Rel_width_alt_2                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Rel_width_alt_2 (OSCTXT* pctxt, 
   Ns8_Rel_width_alt_2 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Rel_width_alt_2 (OSCTXT* pctxt, Ns8_Rel_width_alt_2* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns8_Rel_width_alt_2_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Rel_width                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Rel_width (OSCTXT* pctxt, Ns8_Rel_width *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
         stat = asn1D_Ns8_Rel_width_alt_1 (pctxt, 
            &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_PRIM|2):
         stat = asn1D_Ns8_Rel_width_alt_2 (pctxt, 
            &pvalue->u.alt_2, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns8_Rel_width (OSCTXT* pctxt, Ns8_Rel_width* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      stat = Ns8_Rel_width_alt_1_ToEnum (pctxt, pdata1, &pvalue->u.alt_1);
      if (stat == 0) pvalue->t = 2;
   }
   if (pvalue->t == 0) {
      stat = Ns8_Rel_width_alt_2_ToEnum (pctxt, pdata1, &pvalue->u.alt_2);
      if (stat == 0) pvalue->t = 3;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Leader_char                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Leader_char (OSCTXT* pctxt, Ns8_Leader_char *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Leader_char (OSCTXT* pctxt, Ns8_Leader_char* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Position                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Position (OSCTXT* pctxt, Ns8_Position *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Position (OSCTXT* pctxt, Ns8_Position* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Type                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Type (OSCTXT* pctxt, Ns8_Type *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Type (OSCTXT* pctxt, Ns8_Type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns8_Type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Font_face_font_family_generic                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Font_face_font_family_generic (OSCTXT* pctxt, 
   Ns8_Font_face_font_family_generic *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Font_face_font_family_generic (OSCTXT* pctxt, 
   Ns8_Font_face_font_family_generic* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns8_Font_face_font_family_generic_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Font_face_font_pitch                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Font_face_font_pitch (OSCTXT* pctxt, 
   Ns8_Font_face_font_pitch *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Font_face_font_pitch (OSCTXT* pctxt, 
   Ns8_Font_face_font_pitch* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns8_Font_face_font_pitch_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Font_face                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Font_face (OSCTXT* pctxt, Ns8_Font_face *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode font_adornments */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->font_adornments, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.font_adornmentsPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode font_charset */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->font_charset, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.font_charsetPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode font_family_generic */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Font_face_font_family_generic (pctxt, 
               &pvalue->font_family_generic, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.font_family_genericPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode font_pitch */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Font_face_font_pitch (pctxt, 
               &pvalue->font_pitch, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.font_pitchPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode accent_height */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Accent_height (pctxt, 
               (Accent_height*)&pvalue->accent_height, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.accent_heightPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode alphabetic */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Alphabetic (pctxt, 
               (Alphabetic*)&pvalue->alphabetic, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.alphabeticPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode ascent */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ascent (pctxt, 
               (Ascent*)&pvalue->ascent, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.ascentPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode bbox */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Bbox (pctxt, 
               (Bbox*)&pvalue->bbox, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bboxPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode cap_height */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Cap_height (pctxt, 
               (Cap_height*)&pvalue->cap_height, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.cap_heightPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode descent */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Descent (pctxt, 
               (Descent*)&pvalue->descent, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descentPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode font_family */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Font_family (pctxt, 
               (Font_family*)&pvalue->font_family, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.font_familyPresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode font_size */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Font_size (pctxt, 
               (Font_size*)&pvalue->font_size, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.font_sizePresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode font_stretch */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Font_stretch (pctxt, 
               (Font_stretch*)&pvalue->font_stretch, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.font_stretchPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode font_style */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Font_style (pctxt, 
               (Font_style*)&pvalue->font_style, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.font_stylePresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode font_variant */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Font_variant (pctxt, 
               (Font_variant*)&pvalue->font_variant, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.font_variantPresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode font_weight */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Font_weight (pctxt, 
               (Font_weight*)&pvalue->font_weight, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.font_weightPresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode hanging */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Hanging (pctxt, 
               (Hanging*)&pvalue->hanging, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.hangingPresent = TRUE;
            }
         }
         break;

      case 18:
         /* decode ideographic */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ideographic (pctxt, 
               (Ideographic*)&pvalue->ideographic, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.ideographicPresent = TRUE;
            }
         }
         break;

      case 19:
         /* decode mathematical */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Mathematical (pctxt, 
               (Mathematical*)&pvalue->mathematical, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mathematicalPresent = TRUE;
            }
         }
         break;

      case 20:
         /* decode overline_position */
         if (XD_PEEKTAG (pctxt, 0x94)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Overline_position (pctxt, 
               (Overline_position*)&pvalue->overline_position, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.overline_positionPresent = TRUE;
            }
         }
         break;

      case 21:
         /* decode overline_thickness */
         if (XD_PEEKTAG (pctxt, 0x95)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Overline_thickness (pctxt, 
               (Overline_thickness*)&pvalue->overline_thickness, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.overline_thicknessPresent = TRUE;
            }
         }
         break;

      case 22:
         /* decode panose_1 */
         if (XD_PEEKTAG (pctxt, 0x96)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Panose_1 (pctxt, 
               (Panose_1*)&pvalue->panose_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.panose_1Present = TRUE;
            }
         }
         break;

      case 23:
         /* decode slope */
         if (XD_PEEKTAG (pctxt, 0x97)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Slope (pctxt, 
               (Slope*)&pvalue->slope, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.slopePresent = TRUE;
            }
         }
         break;

      case 24:
         /* decode stemh */
         if (XD_PEEKTAG (pctxt, 0x98)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Stemh (pctxt, 
               (Stemh*)&pvalue->stemh, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.stemhPresent = TRUE;
            }
         }
         break;

      case 25:
         /* decode stemv */
         if (XD_PEEKTAG (pctxt, 0x99)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Stemv (pctxt, 
               (Stemv*)&pvalue->stemv, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.stemvPresent = TRUE;
            }
         }
         break;

      case 26:
         /* decode strikethrough_position */
         if (XD_PEEKTAG (pctxt, 0x9a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Strikethrough_position (pctxt, 
               (Strikethrough_position*)&pvalue->strikethrough_position, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.strikethrough_positionPresent = TRUE;
            }
         }
         break;

      case 27:
         /* decode strikethrough_thickness */
         if (XD_PEEKTAG (pctxt, 0x9b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Strikethrough_thickness (pctxt, 
               (Strikethrough_thickness*)&pvalue->strikethrough_thickness, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.strikethrough_thicknessPresent = TRUE;
            }
         }
         break;

      case 28:
         /* decode underline_position */
         if (XD_PEEKTAG (pctxt, 0x9c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Underline_position (pctxt, 
               (Underline_position*)&pvalue->underline_position, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.underline_positionPresent = TRUE;
            }
         }
         break;

      case 29:
         /* decode underline_thickness */
         if (XD_PEEKTAG (pctxt, 0x9d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Underline_thickness (pctxt, 
               (Underline_thickness*)&pvalue->underline_thickness, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.underline_thicknessPresent = TRUE;
            }
         }
         break;

      case 30:
         /* decode unicode_range */
         if (XD_PEEKTAG (pctxt, 0x9e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Unicode_range (pctxt, 
               (Unicode_range*)&pvalue->unicode_range, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.unicode_rangePresent = TRUE;
            }
         }
         break;

      case 31:
         /* decode units_per_em */
         if ((stat = xd_match (pctxt, TM_CTXT|TM_PRIM|31, &length, XM_ADVANCE)) == 0) {
            stat = asn1D_Units_per_em (pctxt, 
               (Units_per_em*)&pvalue->units_per_em, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.units_per_emPresent = TRUE;
            }
         }
         else if (stat == RTERR_IDNOTFOU) {
            stat = rtxErrReset (pctxt);
         }
         break;

      case 32:
         /* decode v_alphabetic */
         if ((stat = xd_match (pctxt, TM_CTXT|TM_PRIM|32, &length, XM_ADVANCE)) == 0) {
            stat = asn1D_V_alphabetic (pctxt, 
               (V_alphabetic*)&pvalue->v_alphabetic, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.v_alphabeticPresent = TRUE;
            }
         }
         else if (stat == RTERR_IDNOTFOU) {
            stat = rtxErrReset (pctxt);
         }
         break;

      case 33:
         /* decode v_hanging */
         if ((stat = xd_match (pctxt, TM_CTXT|TM_PRIM|33, &length, XM_ADVANCE)) == 0) {
            stat = asn1D_V_hanging (pctxt, 
               (V_hanging*)&pvalue->v_hanging, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.v_hangingPresent = TRUE;
            }
         }
         else if (stat == RTERR_IDNOTFOU) {
            stat = rtxErrReset (pctxt);
         }
         break;

      case 34:
         /* decode v_ideographic */
         if ((stat = xd_match (pctxt, TM_CTXT|TM_PRIM|34, &length, XM_ADVANCE)) == 0) {
            stat = asn1D_V_ideographic (pctxt, 
               (V_ideographic*)&pvalue->v_ideographic, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.v_ideographicPresent = TRUE;
            }
         }
         else if (stat == RTERR_IDNOTFOU) {
            stat = rtxErrReset (pctxt);
         }
         break;

      case 35:
         /* decode v_mathematical */
         if ((stat = xd_match (pctxt, TM_CTXT|TM_PRIM|35, &length, XM_ADVANCE)) == 0) {
            stat = asn1D_V_mathematical (pctxt, 
               (V_mathematical*)&pvalue->v_mathematical, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.v_mathematicalPresent = TRUE;
            }
         }
         else if (stat == RTERR_IDNOTFOU) {
            stat = rtxErrReset (pctxt);
         }
         break;

      case 36:
         /* decode widths */
         if ((stat = xd_match (pctxt, TM_CTXT|TM_PRIM|36, &length, XM_ADVANCE)) == 0) {
            stat = asn1D_Widths (pctxt, 
               (Widths*)&pvalue->widths, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.widthsPresent = TRUE;
            }
         }
         else if (stat == RTERR_IDNOTFOU) {
            stat = rtxErrReset (pctxt);
         }
         break;

      case 37:
         /* decode x_height */
         if ((stat = xd_match (pctxt, TM_CTXT|TM_PRIM|37, &length, XM_ADVANCE)) == 0) {
            stat = asn1D_X_height (pctxt, 
               (X_height*)&pvalue->x_height, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.x_heightPresent = TRUE;
            }
         }
         else if (stat == RTERR_IDNOTFOU) {
            stat = rtxErrReset (pctxt);
         }
         break;

      case 38:
         /* decode font_face_src */
         if ((stat = xd_match (pctxt, TM_CTXT|TM_CONS|38, &length, XM_ADVANCE)) == 0) {
            stat = asn1D_Font_face_src (pctxt, 
               (Font_face_src*)&pvalue->font_face_src, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.font_face_srcPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         else if (stat == RTERR_IDNOTFOU) {
            stat = rtxErrReset (pctxt);
         }
         break;

      case 39:
         /* decode definition_src */
         if ((stat = xd_match (pctxt, TM_CTXT|TM_CONS|39, &length, XM_ADVANCE)) == 0) {
            pvalue->definition_src = rtxMemAllocType (pctxt, Definition_src);

            if (pvalue->definition_src == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Definition_src ((Definition_src*)pvalue->definition_src);
            asn1Init_Definition_src ((Definition_src*)pvalue->definition_src);

            stat = asn1D_Definition_src (pctxt, 
               (Definition_src*)pvalue->definition_src, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.definition_srcPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         else if (stat == RTERR_IDNOTFOU) {
            stat = rtxErrReset (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_PRIM|17):
         case (TM_CTXT|TM_PRIM|18):
         case (TM_CTXT|TM_PRIM|19):
         case (TM_CTXT|TM_PRIM|20):
         case (TM_CTXT|TM_PRIM|21):
         case (TM_CTXT|TM_PRIM|22):
         case (TM_CTXT|TM_CONS|22):
         case (TM_CTXT|TM_PRIM|23):
         case (TM_CTXT|TM_PRIM|24):
         case (TM_CTXT|TM_PRIM|25):
         case (TM_CTXT|TM_PRIM|26):
         case (TM_CTXT|TM_PRIM|27):
         case (TM_CTXT|TM_PRIM|28):
         case (TM_CTXT|TM_PRIM|29):
         case (TM_CTXT|TM_PRIM|30):
         case (TM_CTXT|TM_CONS|30):
         case (TM_CTXT|TM_PRIM|31):
         case (TM_CTXT|TM_PRIM|32):
         case (TM_CTXT|TM_PRIM|33):
         case (TM_CTXT|TM_PRIM|34):
         case (TM_CTXT|TM_PRIM|35):
         case (TM_CTXT|TM_PRIM|36):
         case (TM_CTXT|TM_CONS|36):
         case (TM_CTXT|TM_PRIM|37):
         case (TM_CTXT|TM_CONS|38):
         case (TM_CTXT|TM_CONS|39):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Font_face (OSCTXT* pctxt, Ns8_Font_face* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("font-adornments"), 15}, 0 },
         { {OSUTF8("font-charset"), 12}, 0 },
         { {OSUTF8("font-family-generic"), 19}, 0 },
         { {OSUTF8("font-pitch"), 10}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("accent-height"), 13}, 0 },
         { {OSUTF8("alphabetic"), 10}, 0 },
         { {OSUTF8("ascent"), 6}, 0 },
         { {OSUTF8("bbox"), 4}, 0 },
         { {OSUTF8("cap-height"), 10}, 0 },
         { {OSUTF8("descent"), 7}, 0 },
         { {OSUTF8("font-family"), 11}, 0 },
         { {OSUTF8("font-size"), 9}, 0 },
         { {OSUTF8("font-stretch"), 12}, 0 },
         { {OSUTF8("font-style"), 10}, 0 },
         { {OSUTF8("font-variant"), 12}, 0 },
         { {OSUTF8("font-weight"), 11}, 0 },
         { {OSUTF8("hanging"), 7}, 0 },
         { {OSUTF8("ideographic"), 11}, 0 },
         { {OSUTF8("mathematical"), 12}, 0 },
         { {OSUTF8("overline-position"), 17}, 0 },
         { {OSUTF8("overline-thickness"), 18}, 0 },
         { {OSUTF8("panose-1"), 8}, 0 },
         { {OSUTF8("slope"), 5}, 0 },
         { {OSUTF8("stemh"), 5}, 0 },
         { {OSUTF8("stemv"), 5}, 0 },
         { {OSUTF8("strikethrough-position"), 22}, 0 },
         { {OSUTF8("strikethrough-thickness"), 23}, 0 },
         { {OSUTF8("underline-position"), 18}, 0 },
         { {OSUTF8("underline-thickness"), 19}, 0 },
         { {OSUTF8("unicode-range"), 13}, 0 },
         { {OSUTF8("units-per-em"), 12}, 0 },
         { {OSUTF8("v-alphabetic"), 12}, 0 },
         { {OSUTF8("v-hanging"), 9}, 0 },
         { {OSUTF8("v-ideographic"), 13}, 0 },
         { {OSUTF8("v-mathematical"), 14}, 0 },
         { {OSUTF8("widths"), 6}, 0 },
         { {OSUTF8("x-height"), 8}, 0 }
      } ;
      OSUINT32 attrPresent[2];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 38, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* font-adornments */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->font_adornments);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.font_adornmentsPresent = TRUE;
            break;

         case 1: /* font-charset */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->font_charset);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.font_charsetPresent = TRUE;
            break;

         case 2: /* font-family-generic */
            stat = XmlDec_Ns8_Font_face_font_family_generic (pctxt, &pvalue->
               font_family_generic);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.font_family_genericPresent = TRUE;
            break;

         case 3: /* font-pitch */
            stat = XmlDec_Ns8_Font_face_font_pitch (pctxt, &pvalue->font_pitch
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.font_pitchPresent = TRUE;
            break;

         case 4: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* accent-height */
            stat = XmlDec_Accent_height (pctxt, &pvalue->accent_height);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.accent_heightPresent = TRUE;
            break;

         case 6: /* alphabetic */
            stat = XmlDec_Alphabetic (pctxt, &pvalue->alphabetic);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.alphabeticPresent = TRUE;
            break;

         case 7: /* ascent */
            stat = XmlDec_Ascent (pctxt, &pvalue->ascent);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.ascentPresent = TRUE;
            break;

         case 8: /* bbox */
            stat = XmlDec_Bbox (pctxt, &pvalue->bbox);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bboxPresent = TRUE;
            break;

         case 9: /* cap-height */
            stat = XmlDec_Cap_height (pctxt, &pvalue->cap_height);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.cap_heightPresent = TRUE;
            break;

         case 10: /* descent */
            stat = XmlDec_Descent (pctxt, &pvalue->descent);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descentPresent = TRUE;
            break;

         case 11: /* font-family */
            stat = XmlDec_Font_family (pctxt, &pvalue->font_family);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.font_familyPresent = TRUE;
            break;

         case 12: /* font-size */
            stat = XmlDec_Font_size (pctxt, &pvalue->font_size);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.font_sizePresent = TRUE;
            break;

         case 13: /* font-stretch */
            stat = XmlDec_Font_stretch (pctxt, &pvalue->font_stretch);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.font_stretchPresent = TRUE;
            break;

         case 14: /* font-style */
            stat = XmlDec_Font_style (pctxt, &pvalue->font_style);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.font_stylePresent = TRUE;
            break;

         case 15: /* font-variant */
            stat = XmlDec_Font_variant (pctxt, &pvalue->font_variant);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.font_variantPresent = TRUE;
            break;

         case 16: /* font-weight */
            stat = XmlDec_Font_weight (pctxt, &pvalue->font_weight);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.font_weightPresent = TRUE;
            break;

         case 17: /* hanging */
            stat = XmlDec_Hanging (pctxt, &pvalue->hanging);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.hangingPresent = TRUE;
            break;

         case 18: /* ideographic */
            stat = XmlDec_Ideographic (pctxt, &pvalue->ideographic);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.ideographicPresent = TRUE;
            break;

         case 19: /* mathematical */
            stat = XmlDec_Mathematical (pctxt, &pvalue->mathematical);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mathematicalPresent = TRUE;
            break;

         case 20: /* overline-position */
            stat = XmlDec_Overline_position (pctxt, &pvalue->overline_position
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.overline_positionPresent = TRUE;
            break;

         case 21: /* overline-thickness */
            stat = XmlDec_Overline_thickness (pctxt, &pvalue->
               overline_thickness);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.overline_thicknessPresent = TRUE;
            break;

         case 22: /* panose-1 */
            stat = XmlDec_Panose_1 (pctxt, &pvalue->panose_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.panose_1Present = TRUE;
            break;

         case 23: /* slope */
            stat = XmlDec_Slope (pctxt, &pvalue->slope);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.slopePresent = TRUE;
            break;

         case 24: /* stemh */
            stat = XmlDec_Stemh (pctxt, &pvalue->stemh);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.stemhPresent = TRUE;
            break;

         case 25: /* stemv */
            stat = XmlDec_Stemv (pctxt, &pvalue->stemv);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.stemvPresent = TRUE;
            break;

         case 26: /* strikethrough-position */
            stat = XmlDec_Strikethrough_position (pctxt, &pvalue->
               strikethrough_position);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.strikethrough_positionPresent = TRUE;
            break;

         case 27: /* strikethrough-thickness */
            stat = XmlDec_Strikethrough_thickness (pctxt, &pvalue->
               strikethrough_thickness);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.strikethrough_thicknessPresent = TRUE;
            break;

         case 28: /* underline-position */
            stat = XmlDec_Underline_position (pctxt, &pvalue->
               underline_position);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.underline_positionPresent = TRUE;
            break;

         case 29: /* underline-thickness */
            stat = XmlDec_Underline_thickness (pctxt, &pvalue->
               underline_thickness);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.underline_thicknessPresent = TRUE;
            break;

         case 30: /* unicode-range */
            stat = XmlDec_Unicode_range (pctxt, &pvalue->unicode_range);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.unicode_rangePresent = TRUE;
            break;

         case 31: /* units-per-em */
            stat = XmlDec_Units_per_em (pctxt, &pvalue->units_per_em);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.units_per_emPresent = TRUE;
            break;

         case 32: /* v-alphabetic */
            stat = XmlDec_V_alphabetic (pctxt, &pvalue->v_alphabetic);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.v_alphabeticPresent = TRUE;
            break;

         case 33: /* v-hanging */
            stat = XmlDec_V_hanging (pctxt, &pvalue->v_hanging);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.v_hangingPresent = TRUE;
            break;

         case 34: /* v-ideographic */
            stat = XmlDec_V_ideographic (pctxt, &pvalue->v_ideographic);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.v_ideographicPresent = TRUE;
            break;

         case 35: /* v-mathematical */
            stat = XmlDec_V_mathematical (pctxt, &pvalue->v_mathematical);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.v_mathematicalPresent = TRUE;
            break;

         case 36: /* widths */
            stat = XmlDec_Widths (pctxt, &pvalue->widths);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.widthsPresent = TRUE;
            break;

         case 37: /* x-height */
            stat = XmlDec_X_height (pctxt, &pvalue->x_height);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.x_heightPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns8_Font_face");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns8_Font_face");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("font-face-src"), 13}, 0}, 0 },
      {{{OSUTF8("definition-src"), 14}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* font-face-src */
         stat = XmlDec_Font_face_src (pctxt, &pvalue->font_face_src);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.font_face_srcPresent = TRUE;
         break;
      }
      case 1: { /* definition-src */
         pvalue->definition_src = rtxMemAllocType (pctxt, Definition_src);

         if (pvalue->definition_src == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Definition_src ((Definition_src*)pvalue->definition_src);

         stat = XmlDec_Definition_src (pctxt, pvalue->definition_src);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.definition_srcPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Style_auto_update                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Style_auto_update (OSCTXT* pctxt, 
   Ns8_Style_auto_update *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Style_auto_update (OSCTXT* pctxt, Ns8_Style_auto_update* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns8_Style_auto_update_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Data_style_name                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Data_style_name (OSCTXT* pctxt, 
   Ns8_Data_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns8_Data_style_name (OSCTXT* pctxt, Ns8_Data_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Display_name                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Display_name (OSCTXT* pctxt, Ns8_Display_name *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Display_name (OSCTXT* pctxt, Ns8_Display_name* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Style_family                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Style_family (OSCTXT* pctxt, Ns8_Style_family *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Style_family (OSCTXT* pctxt, Ns8_Style_family* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns8_Style_family_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Style_list_style_name                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Style_list_style_name (OSCTXT* pctxt, 
   Ns8_Style_list_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns8_Style_list_style_name (OSCTXT* pctxt, 
   Ns8_Style_list_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Style_master_page_name                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Style_master_page_name (OSCTXT* pctxt, 
   Ns8_Style_master_page_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns8_Style_master_page_name (OSCTXT* pctxt, 
   Ns8_Style_master_page_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Style_next_style_name                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Style_next_style_name (OSCTXT* pctxt, 
   Ns8_Style_next_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns8_Style_next_style_name (OSCTXT* pctxt, 
   Ns8_Style_next_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Style_parent_style_name                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Style_parent_style_name (OSCTXT* pctxt, 
   Ns8_Style_parent_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns8_Style_parent_style_name (OSCTXT* pctxt, 
   Ns8_Style_parent_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Section_properties                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Section_properties (OSCTXT* pctxt, 
   Ns8_Section_properties *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode attr */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->attr);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->attr, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode element14_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Element14* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->element14_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Element14, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = asn1D_Odf_Element14 (pctxt, 
                     (Odf_Element14*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->element14_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Section_properties (OSCTXT* pctxt, 
   Ns8_Section_properties* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      size_t i, nAttrs = 0;
      const OSUTF8CHAR* attrStr;

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         stat = rtXmlpDecAnyAttrStr (pctxt, &attrStr, i);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, &pvalue->attr, (void*)attrStr);
      }
   }

   { OSXSDAny* pdata1;
   OSXMLElemDescr elemDescr;
   const OSUTF8CHAR* pxmlstr;
   for (;;) {
      stat = rtXmlpGetNextElem (pctxt, &elemDescr, -1);
      if (0 != stat) break;

      stat = rtXmlpDecAnyElem (pctxt, &pxmlstr);
      if (0 != stat) break;

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      pdata1 = rtxMemAllocType (pctxt, OSXSDAny);
      if (0 == pdata1) return LOG_RTERR (pctxt, RTERR_NOMEM);

      pdata1->t = OSXSDAny_xmlText;
      pdata1->u.xmlText = pxmlstr;

      if (0 == rtxDListAppend (pctxt, &pvalue->element14_list, pdata1))
         return LOG_RTERR (pctxt, RTERR_NOMEM);
   }
   if (stat == XML_OK_EOB) stat = 0;
   else return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_properties                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Table_properties (OSCTXT* pctxt, 
   Ns8_Table_properties *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode attr */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->attr);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->attr, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode element14_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Element14* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->element14_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Element14, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = asn1D_Odf_Element14 (pctxt, 
                     (Odf_Element14*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->element14_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Table_properties (OSCTXT* pctxt, Ns8_Table_properties* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      size_t i, nAttrs = 0;
      const OSUTF8CHAR* attrStr;

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         stat = rtXmlpDecAnyAttrStr (pctxt, &attrStr, i);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, &pvalue->attr, (void*)attrStr);
      }
   }

   { OSXSDAny* pdata1;
   OSXMLElemDescr elemDescr;
   const OSUTF8CHAR* pxmlstr;
   for (;;) {
      stat = rtXmlpGetNextElem (pctxt, &elemDescr, -1);
      if (0 != stat) break;

      stat = rtXmlpDecAnyElem (pctxt, &pxmlstr);
      if (0 != stat) break;

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      pdata1 = rtxMemAllocType (pctxt, OSXSDAny);
      if (0 == pdata1) return LOG_RTERR (pctxt, RTERR_NOMEM);

      pdata1->t = OSXSDAny_xmlText;
      pdata1->u.xmlText = pxmlstr;

      if (0 == rtxDListAppend (pctxt, &pvalue->element14_list, pdata1))
         return LOG_RTERR (pctxt, RTERR_NOMEM);
   }
   if (stat == XML_OK_EOB) stat = 0;
   else return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_column_properties                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Table_column_properties (OSCTXT* pctxt, 
   Ns8_Table_column_properties *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode attr */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->attr);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->attr, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode element14_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Element14* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->element14_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Element14, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = asn1D_Odf_Element14 (pctxt, 
                     (Odf_Element14*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->element14_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Table_column_properties (OSCTXT* pctxt, 
   Ns8_Table_column_properties* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      size_t i, nAttrs = 0;
      const OSUTF8CHAR* attrStr;

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         stat = rtXmlpDecAnyAttrStr (pctxt, &attrStr, i);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, &pvalue->attr, (void*)attrStr);
      }
   }

   { OSXSDAny* pdata1;
   OSXMLElemDescr elemDescr;
   const OSUTF8CHAR* pxmlstr;
   for (;;) {
      stat = rtXmlpGetNextElem (pctxt, &elemDescr, -1);
      if (0 != stat) break;

      stat = rtXmlpDecAnyElem (pctxt, &pxmlstr);
      if (0 != stat) break;

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      pdata1 = rtxMemAllocType (pctxt, OSXSDAny);
      if (0 == pdata1) return LOG_RTERR (pctxt, RTERR_NOMEM);

      pdata1->t = OSXSDAny_xmlText;
      pdata1->u.xmlText = pxmlstr;

      if (0 == rtxDListAppend (pctxt, &pvalue->element14_list, pdata1))
         return LOG_RTERR (pctxt, RTERR_NOMEM);
   }
   if (stat == XML_OK_EOB) stat = 0;
   else return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_row_properties                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Table_row_properties (OSCTXT* pctxt, 
   Ns8_Table_row_properties *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode attr */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->attr);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->attr, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode element14_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Element14* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->element14_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Element14, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = asn1D_Odf_Element14 (pctxt, 
                     (Odf_Element14*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->element14_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Table_row_properties (OSCTXT* pctxt, 
   Ns8_Table_row_properties* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      size_t i, nAttrs = 0;
      const OSUTF8CHAR* attrStr;

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         stat = rtXmlpDecAnyAttrStr (pctxt, &attrStr, i);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, &pvalue->attr, (void*)attrStr);
      }
   }

   { OSXSDAny* pdata1;
   OSXMLElemDescr elemDescr;
   const OSUTF8CHAR* pxmlstr;
   for (;;) {
      stat = rtXmlpGetNextElem (pctxt, &elemDescr, -1);
      if (0 != stat) break;

      stat = rtXmlpDecAnyElem (pctxt, &pxmlstr);
      if (0 != stat) break;

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      pdata1 = rtxMemAllocType (pctxt, OSXSDAny);
      if (0 == pdata1) return LOG_RTERR (pctxt, RTERR_NOMEM);

      pdata1->t = OSXSDAny_xmlText;
      pdata1->u.xmlText = pxmlstr;

      if (0 == rtxDListAppend (pctxt, &pvalue->element14_list, pdata1))
         return LOG_RTERR (pctxt, RTERR_NOMEM);
   }
   if (stat == XML_OK_EOB) stat = 0;
   else return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ruby_properties                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Ruby_properties (OSCTXT* pctxt, 
   Ns8_Ruby_properties *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode attr */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->attr);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->attr, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode element14_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Element14* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->element14_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Element14, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = asn1D_Odf_Element14 (pctxt, 
                     (Odf_Element14*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->element14_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Ruby_properties (OSCTXT* pctxt, Ns8_Ruby_properties* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      size_t i, nAttrs = 0;
      const OSUTF8CHAR* attrStr;

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         stat = rtXmlpDecAnyAttrStr (pctxt, &attrStr, i);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, &pvalue->attr, (void*)attrStr);
      }
   }

   { OSXSDAny* pdata1;
   OSXMLElemDescr elemDescr;
   const OSUTF8CHAR* pxmlstr;
   for (;;) {
      stat = rtXmlpGetNextElem (pctxt, &elemDescr, -1);
      if (0 != stat) break;

      stat = rtXmlpDecAnyElem (pctxt, &pxmlstr);
      if (0 != stat) break;

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      pdata1 = rtxMemAllocType (pctxt, OSXSDAny);
      if (0 == pdata1) return LOG_RTERR (pctxt, RTERR_NOMEM);

      pdata1->t = OSXSDAny_xmlText;
      pdata1->u.xmlText = pxmlstr;

      if (0 == rtxDListAppend (pctxt, &pvalue->element14_list, pdata1))
         return LOG_RTERR (pctxt, RTERR_NOMEM);
   }
   if (stat == XML_OK_EOB) stat = 0;
   else return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Drawing_page_properties                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Drawing_page_properties (OSCTXT* pctxt, 
   Ns8_Drawing_page_properties *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode attr */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->attr);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->attr, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode element14_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Element14* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->element14_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Element14, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = asn1D_Odf_Element14 (pctxt, 
                     (Odf_Element14*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->element14_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Drawing_page_properties (OSCTXT* pctxt, 
   Ns8_Drawing_page_properties* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      size_t i, nAttrs = 0;
      const OSUTF8CHAR* attrStr;

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         stat = rtXmlpDecAnyAttrStr (pctxt, &attrStr, i);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, &pvalue->attr, (void*)attrStr);
      }
   }

   { OSXSDAny* pdata1;
   OSXMLElemDescr elemDescr;
   const OSUTF8CHAR* pxmlstr;
   for (;;) {
      stat = rtXmlpGetNextElem (pctxt, &elemDescr, -1);
      if (0 != stat) break;

      stat = rtXmlpDecAnyElem (pctxt, &pxmlstr);
      if (0 != stat) break;

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      pdata1 = rtxMemAllocType (pctxt, OSXSDAny);
      if (0 == pdata1) return LOG_RTERR (pctxt, RTERR_NOMEM);

      pdata1->t = OSXSDAny_xmlText;
      pdata1->u.xmlText = pxmlstr;

      if (0 == rtxDListAppend (pctxt, &pvalue->element14_list, pdata1))
         return LOG_RTERR (pctxt, RTERR_NOMEM);
   }
   if (stat == XML_OK_EOB) stat = 0;
   else return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Chart_properties                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Chart_properties (OSCTXT* pctxt, 
   Ns8_Chart_properties *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode attr */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->attr);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->attr, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode element14_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Element14* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->element14_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Element14, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = asn1D_Odf_Element14 (pctxt, 
                     (Odf_Element14*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->element14_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Chart_properties (OSCTXT* pctxt, Ns8_Chart_properties* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      size_t i, nAttrs = 0;
      const OSUTF8CHAR* attrStr;

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         stat = rtXmlpDecAnyAttrStr (pctxt, &attrStr, i);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, &pvalue->attr, (void*)attrStr);
      }
   }

   { OSXSDAny* pdata1;
   OSXMLElemDescr elemDescr;
   const OSUTF8CHAR* pxmlstr;
   for (;;) {
      stat = rtXmlpGetNextElem (pctxt, &elemDescr, -1);
      if (0 != stat) break;

      stat = rtXmlpDecAnyElem (pctxt, &pxmlstr);
      if (0 != stat) break;

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      pdata1 = rtxMemAllocType (pctxt, OSXSDAny);
      if (0 == pdata1) return LOG_RTERR (pctxt, RTERR_NOMEM);

      pdata1->t = OSXSDAny_xmlText;
      pdata1->u.xmlText = pxmlstr;

      if (0 == rtxDListAppend (pctxt, &pvalue->element14_list, pdata1))
         return LOG_RTERR (pctxt, RTERR_NOMEM);
   }
   if (stat == XML_OK_EOB) stat = 0;
   else return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Graphic_properties                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Graphic_properties (OSCTXT* pctxt, 
   Ns8_Graphic_properties *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode attr */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->attr);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->attr, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode element14_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Element14* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->element14_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Element14, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = asn1D_Odf_Element14 (pctxt, 
                     (Odf_Element14*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->element14_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Graphic_properties (OSCTXT* pctxt, 
   Ns8_Graphic_properties* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      size_t i, nAttrs = 0;
      const OSUTF8CHAR* attrStr;

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         stat = rtXmlpDecAnyAttrStr (pctxt, &attrStr, i);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, &pvalue->attr, (void*)attrStr);
      }
   }

   { OSXSDAny* pdata1;
   OSXMLElemDescr elemDescr;
   const OSUTF8CHAR* pxmlstr;
   for (;;) {
      stat = rtXmlpGetNextElem (pctxt, &elemDescr, -1);
      if (0 != stat) break;

      stat = rtXmlpDecAnyElem (pctxt, &pxmlstr);
      if (0 != stat) break;

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      pdata1 = rtxMemAllocType (pctxt, OSXSDAny);
      if (0 == pdata1) return LOG_RTERR (pctxt, RTERR_NOMEM);

      pdata1->t = OSXSDAny_xmlText;
      pdata1->u.xmlText = pxmlstr;

      if (0 == rtxDListAppend (pctxt, &pvalue->element14_list, pdata1))
         return LOG_RTERR (pctxt, RTERR_NOMEM);
   }
   if (stat == XML_OK_EOB) stat = 0;
   else return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Table_cell_properties                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Table_cell_properties (OSCTXT* pctxt, 
   Ns8_Table_cell_properties *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode attr */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->attr);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->attr, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode element14_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Element14* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->element14_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Element14, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = asn1D_Odf_Element14 (pctxt, 
                     (Odf_Element14*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->element14_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Table_cell_properties (OSCTXT* pctxt, 
   Ns8_Table_cell_properties* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      size_t i, nAttrs = 0;
      const OSUTF8CHAR* attrStr;

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         stat = rtXmlpDecAnyAttrStr (pctxt, &attrStr, i);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, &pvalue->attr, (void*)attrStr);
      }
   }

   { OSXSDAny* pdata1;
   OSXMLElemDescr elemDescr;
   const OSUTF8CHAR* pxmlstr;
   for (;;) {
      stat = rtXmlpGetNextElem (pctxt, &elemDescr, -1);
      if (0 != stat) break;

      stat = rtXmlpDecAnyElem (pctxt, &pxmlstr);
      if (0 != stat) break;

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      pdata1 = rtxMemAllocType (pctxt, OSXSDAny);
      if (0 == pdata1) return LOG_RTERR (pctxt, RTERR_NOMEM);

      pdata1->t = OSXSDAny_xmlText;
      pdata1->u.xmlText = pxmlstr;

      if (0 == rtxDListAppend (pctxt, &pvalue->element14_list, pdata1))
         return LOG_RTERR (pctxt, RTERR_NOMEM);
   }
   if (stat == XML_OK_EOB) stat = 0;
   else return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Paragraph_properties                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Paragraph_properties (OSCTXT* pctxt, 
   Ns8_Paragraph_properties *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode attr */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->attr);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->attr, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode element14_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Element14* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->element14_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Element14, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = asn1D_Odf_Element14 (pctxt, 
                     (Odf_Element14*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->element14_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Paragraph_properties (OSCTXT* pctxt, 
   Ns8_Paragraph_properties* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      size_t i, nAttrs = 0;
      const OSUTF8CHAR* attrStr;

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         stat = rtXmlpDecAnyAttrStr (pctxt, &attrStr, i);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, &pvalue->attr, (void*)attrStr);
      }
   }

   { OSXSDAny* pdata1;
   OSXMLElemDescr elemDescr;
   const OSUTF8CHAR* pxmlstr;
   for (;;) {
      stat = rtXmlpGetNextElem (pctxt, &elemDescr, -1);
      if (0 != stat) break;

      stat = rtXmlpDecAnyElem (pctxt, &pxmlstr);
      if (0 != stat) break;

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      pdata1 = rtxMemAllocType (pctxt, OSXSDAny);
      if (0 == pdata1) return LOG_RTERR (pctxt, RTERR_NOMEM);

      pdata1->t = OSXSDAny_xmlText;
      pdata1->u.xmlText = pxmlstr;

      if (0 == rtxDListAppend (pctxt, &pvalue->element14_list, pdata1))
         return LOG_RTERR (pctxt, RTERR_NOMEM);
   }
   if (stat == XML_OK_EOB) stat = 0;
   else return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Map_apply_style_name                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Map_apply_style_name (OSCTXT* pctxt, 
   Ns8_Map_apply_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns8_Map_apply_style_name (OSCTXT* pctxt, 
   Ns8_Map_apply_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Map                                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Map (OSCTXT* pctxt, Ns8_Map *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode apply_style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Map_apply_style_name (pctxt, 
               &pvalue->apply_style_name, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode base_cell_address */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->base_cell_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.base_cell_addressPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode condition */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->condition, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Map (OSCTXT* pctxt, Ns8_Map* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("apply-style-name"), 16}, 0 },
         { {OSUTF8("base-cell-address"), 17}, 0 },
         { {OSUTF8("condition"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* apply-style-name */
            stat = XmlDec_Ns8_Map_apply_style_name (pctxt, &pvalue->
               apply_style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* base-cell-address */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->base_cell_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.base_cell_addressPresent = TRUE;
            break;

         case 2: /* condition */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->condition);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns8_Map");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns8_Map");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Style                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Style (OSCTXT* pctxt, Ns8_Style *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode auto_update */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Style_auto_update (pctxt, 
               &pvalue->auto_update, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.auto_updatePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode class_ */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->class_, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_Present = TRUE;
            }
         }
         break;

      case 2:
         /* decode data_style_name */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Data_style_name (pctxt, 
               &pvalue->data_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode default_outline_level */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->default_outline_level, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.default_outline_levelPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode display_name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Display_name (pctxt, 
               &pvalue->display_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.display_namePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode family */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Style_family (pctxt, 
               &pvalue->family, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode list_style_name */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Style_list_style_name (pctxt, 
               &pvalue->list_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.list_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode master_page_name */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Style_master_page_name (pctxt, 
               &pvalue->master_page_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.master_page_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Name (pctxt, 
               &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 9:
         /* decode next_style_name */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Style_next_style_name (pctxt, 
               &pvalue->next_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.next_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 10:
         /* decode parent_style_name */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Style_parent_style_name (pctxt, 
               &pvalue->parent_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.parent_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 11:
         /* decode section_properties */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Section_properties (pctxt, 
               &pvalue->section_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.section_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 12:
         /* decode table_properties */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Table_properties (pctxt, 
               &pvalue->table_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 13:
         /* decode table_column_properties */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Table_column_properties (pctxt, 
               &pvalue->table_column_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_column_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 14:
         /* decode table_row_properties */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Table_row_properties (pctxt, 
               &pvalue->table_row_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_row_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 15:
         /* decode ruby_properties */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Ruby_properties (pctxt, 
               &pvalue->ruby_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.ruby_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 16:
         /* decode drawing_page_properties */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Drawing_page_properties (pctxt, 
               &pvalue->drawing_page_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.drawing_page_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 17:
         /* decode chart_properties */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Chart_properties (pctxt, 
               &pvalue->chart_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.chart_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 18:
         /* decode graphic_properties */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Graphic_properties (pctxt, 
               &pvalue->graphic_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.graphic_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 19:
         /* decode table_cell_properties */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Table_cell_properties (pctxt, 
               &pvalue->table_cell_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_cell_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 20:
         /* decode paragraph_properties */
         if (XD_PEEKTAG (pctxt, 0x94)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Paragraph_properties (pctxt, 
               &pvalue->paragraph_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.paragraph_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 21:
         /* decode text_properties */
         if (XD_PEEKTAG (pctxt, 0x95)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Text_properties (pctxt, 
               &pvalue->text_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 22:
         /* decode map_list */
         if (XD_PEEKTAG (pctxt, 0x96)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns8_Map* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->map_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns8_Map, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns8_Map (pdata2);

                  stat = asn1D_Ns8_Map (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->map_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_CONS|18):
         case (TM_CTXT|TM_CONS|19):
         case (TM_CTXT|TM_CONS|20):
         case (TM_CTXT|TM_CONS|21):
         case (TM_CTXT|TM_CONS|22):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Style (OSCTXT* pctxt, Ns8_Style* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("auto-update"), 11}, 0 },
         { {OSUTF8("class"), 5}, 0 },
         { {OSUTF8("data-style-name"), 15}, 0 },
         { {OSUTF8("default-outline-level"), 21}, 0 },
         { {OSUTF8("display-name"), 12}, 0 },
         { {OSUTF8("family"), 6}, 0 },
         { {OSUTF8("list-style-name"), 15}, 0 },
         { {OSUTF8("master-page-name"), 16}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("next-style-name"), 15}, 0 },
         { {OSUTF8("parent-style-name"), 17}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 11, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* auto-update */
            stat = XmlDec_Ns8_Style_auto_update (pctxt, &pvalue->auto_update);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.auto_updatePresent = TRUE;
            break;

         case 1: /* class */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->class_);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_Present = TRUE;
            break;

         case 2: /* data-style-name */
            stat = XmlDec_Ns8_Data_style_name (pctxt, &pvalue->data_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_style_namePresent = TRUE;
            break;

         case 3: /* default-outline-level */
            stat = rtXmlpDecUInt (pctxt, &pvalue->default_outline_level);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.default_outline_levelPresent = TRUE;
            break;

         case 4: /* display-name */
            stat = XmlDec_Ns8_Display_name (pctxt, &pvalue->display_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.display_namePresent = TRUE;
            break;

         case 5: /* family */
            stat = XmlDec_Ns8_Style_family (pctxt, &pvalue->family);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 6: /* list-style-name */
            stat = XmlDec_Ns8_Style_list_style_name (pctxt, &pvalue->
               list_style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.list_style_namePresent = TRUE;
            break;

         case 7: /* master-page-name */
            stat = XmlDec_Ns8_Style_master_page_name (pctxt, &pvalue->
               master_page_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.master_page_namePresent = TRUE;
            break;

         case 8: /* name */
            stat = XmlDec_Ns8_Name (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 9: /* next-style-name */
            stat = XmlDec_Ns8_Style_next_style_name (pctxt, &pvalue->
               next_style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.next_style_namePresent = TRUE;
            break;

         case 10: /* parent-style-name */
            stat = XmlDec_Ns8_Style_parent_style_name (pctxt, &pvalue->
               parent_style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.parent_style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns8_Style");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns8_Style");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("section-properties"), 18}, 0}, 0 },
      {{{OSUTF8("table-properties"), 16}, 0}, 1 },
      {{{OSUTF8("table-column-properties"), 23}, 0}, 2 },
      {{{OSUTF8("table-row-properties"), 20}, 0}, 3 },
      {{{OSUTF8("ruby-properties"), 15}, 0}, 4 },
      {{{OSUTF8("drawing-page-properties"), 23}, 0}, 5 },
      {{{OSUTF8("chart-properties"), 16}, 0}, 6 },
      {{{OSUTF8("graphic-properties"), 18}, 0}, 7 },
      {{{OSUTF8("table-cell-properties"), 21}, 0}, 8 },
      {{{OSUTF8("paragraph-properties"), 20}, 0}, 9 },
      {{{OSUTF8("text-properties"), 15}, 0}, 10 },
      {{{OSUTF8("map"), 3}, 0}, 11 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 12, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 12; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* section-properties */
         stat = XmlDec_Ns8_Section_properties (pctxt, &pvalue->
            section_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.section_propertiesPresent = TRUE;
         break;
      }
      case 1: { /* table-properties */
         stat = XmlDec_Ns8_Table_properties (pctxt, &pvalue->table_properties
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.table_propertiesPresent = TRUE;
         break;
      }
      case 2: { /* table-column-properties */
         stat = XmlDec_Ns8_Table_column_properties (pctxt, &pvalue->
            table_column_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.table_column_propertiesPresent = TRUE;
         break;
      }
      case 3: { /* table-row-properties */
         stat = XmlDec_Ns8_Table_row_properties (pctxt, &pvalue->
            table_row_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.table_row_propertiesPresent = TRUE;
         break;
      }
      case 4: { /* ruby-properties */
         stat = XmlDec_Ns8_Ruby_properties (pctxt, &pvalue->ruby_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.ruby_propertiesPresent = TRUE;
         break;
      }
      case 5: { /* drawing-page-properties */
         stat = XmlDec_Ns8_Drawing_page_properties (pctxt, &pvalue->
            drawing_page_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.drawing_page_propertiesPresent = TRUE;
         break;
      }
      case 6: { /* chart-properties */
         stat = XmlDec_Ns8_Chart_properties (pctxt, &pvalue->chart_properties
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.chart_propertiesPresent = TRUE;
         break;
      }
      case 7: { /* graphic-properties */
         stat = XmlDec_Ns8_Graphic_properties (pctxt, &pvalue->
            graphic_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.graphic_propertiesPresent = TRUE;
         break;
      }
      case 8: { /* table-cell-properties */
         stat = XmlDec_Ns8_Table_cell_properties (pctxt, &pvalue->
            table_cell_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.table_cell_propertiesPresent = TRUE;
         break;
      }
      case 9: { /* paragraph-properties */
         stat = XmlDec_Ns8_Paragraph_properties (pctxt, &pvalue->
            paragraph_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.paragraph_propertiesPresent = TRUE;
         break;
      }
      case 10: { /* text-properties */
         stat = XmlDec_Ns8_Text_properties (pctxt, &pvalue->text_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.text_propertiesPresent = TRUE;
         break;
      }
      case 11: {
         Ns8_Map* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns8_Map);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Map (pdata1);

            stat = XmlDec_Ns8_Map (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->map_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 11, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 11);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Volatile                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Volatile (OSCTXT* pctxt, Ns8_Volatile *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Volatile (OSCTXT* pctxt, Ns8_Volatile* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns8_Volatile_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Default_style_family                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Default_style_family (OSCTXT* pctxt, 
   Ns8_Default_style_family *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Default_style_family (OSCTXT* pctxt, 
   Ns8_Default_style_family* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns8_Default_style_family_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Default_style                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Default_style (OSCTXT* pctxt, Ns8_Default_style *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode family */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Default_style_family (pctxt, 
               &pvalue->family, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode section_properties */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Section_properties (pctxt, 
               &pvalue->section_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.section_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode table_properties */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Table_properties (pctxt, 
               &pvalue->table_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode table_column_properties */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Table_column_properties (pctxt, 
               &pvalue->table_column_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_column_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode table_row_properties */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Table_row_properties (pctxt, 
               &pvalue->table_row_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_row_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode ruby_properties */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Ruby_properties (pctxt, 
               &pvalue->ruby_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.ruby_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode drawing_page_properties */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Drawing_page_properties (pctxt, 
               &pvalue->drawing_page_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.drawing_page_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode chart_properties */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Chart_properties (pctxt, 
               &pvalue->chart_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.chart_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode graphic_properties */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Graphic_properties (pctxt, 
               &pvalue->graphic_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.graphic_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode table_cell_properties */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Table_cell_properties (pctxt, 
               &pvalue->table_cell_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_cell_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 10:
         /* decode paragraph_properties */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Paragraph_properties (pctxt, 
               &pvalue->paragraph_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.paragraph_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 11:
         /* decode text_properties */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Text_properties (pctxt, 
               &pvalue->text_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_CONS|11):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Default_style (OSCTXT* pctxt, Ns8_Default_style* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("family"), 6}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* family */
            stat = XmlDec_Ns8_Default_style_family (pctxt, &pvalue->family);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns8_Default_style");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns8_Default_style");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("section-properties"), 18}, 0}, 0 },
      {{{OSUTF8("table-properties"), 16}, 0}, 1 },
      {{{OSUTF8("table-column-properties"), 23}, 0}, 2 },
      {{{OSUTF8("table-row-properties"), 20}, 0}, 3 },
      {{{OSUTF8("ruby-properties"), 15}, 0}, 4 },
      {{{OSUTF8("drawing-page-properties"), 23}, 0}, 5 },
      {{{OSUTF8("chart-properties"), 16}, 0}, 6 },
      {{{OSUTF8("graphic-properties"), 18}, 0}, 7 },
      {{{OSUTF8("table-cell-properties"), 21}, 0}, 8 },
      {{{OSUTF8("paragraph-properties"), 20}, 0}, 9 },
      {{{OSUTF8("text-properties"), 15}, 0}, 10 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 11, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 11; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* section-properties */
         stat = XmlDec_Ns8_Section_properties (pctxt, &pvalue->
            section_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.section_propertiesPresent = TRUE;
         break;
      }
      case 1: { /* table-properties */
         stat = XmlDec_Ns8_Table_properties (pctxt, &pvalue->table_properties
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.table_propertiesPresent = TRUE;
         break;
      }
      case 2: { /* table-column-properties */
         stat = XmlDec_Ns8_Table_column_properties (pctxt, &pvalue->
            table_column_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.table_column_propertiesPresent = TRUE;
         break;
      }
      case 3: { /* table-row-properties */
         stat = XmlDec_Ns8_Table_row_properties (pctxt, &pvalue->
            table_row_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.table_row_propertiesPresent = TRUE;
         break;
      }
      case 4: { /* ruby-properties */
         stat = XmlDec_Ns8_Ruby_properties (pctxt, &pvalue->ruby_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.ruby_propertiesPresent = TRUE;
         break;
      }
      case 5: { /* drawing-page-properties */
         stat = XmlDec_Ns8_Drawing_page_properties (pctxt, &pvalue->
            drawing_page_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.drawing_page_propertiesPresent = TRUE;
         break;
      }
      case 6: { /* chart-properties */
         stat = XmlDec_Ns8_Chart_properties (pctxt, &pvalue->chart_properties
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.chart_propertiesPresent = TRUE;
         break;
      }
      case 7: { /* graphic-properties */
         stat = XmlDec_Ns8_Graphic_properties (pctxt, &pvalue->
            graphic_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.graphic_propertiesPresent = TRUE;
         break;
      }
      case 8: { /* table-cell-properties */
         stat = XmlDec_Ns8_Table_cell_properties (pctxt, &pvalue->
            table_cell_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.table_cell_propertiesPresent = TRUE;
         break;
      }
      case 9: { /* paragraph-properties */
         stat = XmlDec_Ns8_Paragraph_properties (pctxt, &pvalue->
            paragraph_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.paragraph_propertiesPresent = TRUE;
         break;
      }
      case 10: { /* text-properties */
         stat = XmlDec_Ns8_Text_properties (pctxt, &pvalue->text_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.text_propertiesPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Presentation_page_layout                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Presentation_page_layout (OSCTXT* pctxt, 
   Ns8_Presentation_page_layout *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode display_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Display_name (pctxt, 
               &pvalue->display_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.display_namePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Name (pctxt, 
               &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode placeholder_list */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns10_Placeholder* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->placeholder_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns10_Placeholder, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns10_Placeholder ((Ns10_Placeholder*)pdata2);

                  stat = asn1D_Ns10_Placeholder (pctxt, 
                     (Ns10_Placeholder*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->placeholder_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Presentation_page_layout (OSCTXT* pctxt, 
   Ns8_Presentation_page_layout* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("display-name"), 12}, 0 },
         { {OSUTF8("name"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* display-name */
            stat = XmlDec_Ns8_Display_name (pctxt, &pvalue->display_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.display_namePresent = TRUE;
            break;

         case 1: /* name */
            stat = XmlDec_Ns8_Name (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns8_Presentation_page_layout");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns8_Presentation_page_layout");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("placeholder"), 11}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Ns10_Placeholder* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns10_Placeholder);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns10_Placeholder ((Ns10_Placeholder*)pdata1);

            stat = XmlDec_Ns10_Placeholder (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->placeholder_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Page_layout_page_usage                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Page_layout_page_usage (OSCTXT* pctxt, 
   Ns8_Page_layout_page_usage *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Page_layout_page_usage (OSCTXT* pctxt, 
   Ns8_Page_layout_page_usage* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns8_Page_layout_page_usage_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Page_layout_properties                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Page_layout_properties (OSCTXT* pctxt, 
   Ns8_Page_layout_properties *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode attr */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->attr);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->attr, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode element14_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Element14* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->element14_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Element14, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = asn1D_Odf_Element14 (pctxt, 
                     (Odf_Element14*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->element14_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Page_layout_properties (OSCTXT* pctxt, 
   Ns8_Page_layout_properties* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      size_t i, nAttrs = 0;
      const OSUTF8CHAR* attrStr;

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         stat = rtXmlpDecAnyAttrStr (pctxt, &attrStr, i);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, &pvalue->attr, (void*)attrStr);
      }
   }

   { OSXSDAny* pdata1;
   OSXMLElemDescr elemDescr;
   const OSUTF8CHAR* pxmlstr;
   for (;;) {
      stat = rtXmlpGetNextElem (pctxt, &elemDescr, -1);
      if (0 != stat) break;

      stat = rtXmlpDecAnyElem (pctxt, &pxmlstr);
      if (0 != stat) break;

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      pdata1 = rtxMemAllocType (pctxt, OSXSDAny);
      if (0 == pdata1) return LOG_RTERR (pctxt, RTERR_NOMEM);

      pdata1->t = OSXSDAny_xmlText;
      pdata1->u.xmlText = pxmlstr;

      if (0 == rtxDListAppend (pctxt, &pvalue->element14_list, pdata1))
         return LOG_RTERR (pctxt, RTERR_NOMEM);
   }
   if (stat == XML_OK_EOB) stat = 0;
   else return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Header_footer_properties                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Header_footer_properties (OSCTXT* pctxt, 
   Ns8_Header_footer_properties *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode attr */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->attr);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->attr, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode element14_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_Element14* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->element14_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_Element14, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = asn1D_Odf_Element14 (pctxt, 
                     (Odf_Element14*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->element14_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Header_footer_properties (OSCTXT* pctxt, 
   Ns8_Header_footer_properties* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      size_t i, nAttrs = 0;
      const OSUTF8CHAR* attrStr;

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         stat = rtXmlpDecAnyAttrStr (pctxt, &attrStr, i);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, &pvalue->attr, (void*)attrStr);
      }
   }

   { OSXSDAny* pdata1;
   OSXMLElemDescr elemDescr;
   const OSUTF8CHAR* pxmlstr;
   for (;;) {
      stat = rtXmlpGetNextElem (pctxt, &elemDescr, -1);
      if (0 != stat) break;

      stat = rtXmlpDecAnyElem (pctxt, &pxmlstr);
      if (0 != stat) break;

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      pdata1 = rtxMemAllocType (pctxt, OSXSDAny);
      if (0 == pdata1) return LOG_RTERR (pctxt, RTERR_NOMEM);

      pdata1->t = OSXSDAny_xmlText;
      pdata1->u.xmlText = pxmlstr;

      if (0 == rtxDListAppend (pctxt, &pvalue->element14_list, pdata1))
         return LOG_RTERR (pctxt, RTERR_NOMEM);
   }
   if (stat == XML_OK_EOB) stat = 0;
   else return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Header_style                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Header_style (OSCTXT* pctxt, Ns8_Header_style *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode header_footer_properties */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Header_footer_properties (pctxt, 
               &pvalue->header_footer_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.header_footer_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Header_style (OSCTXT* pctxt, Ns8_Header_style* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("header-footer-properties"), 24}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* header-footer-properties */
         stat = XmlDec_Ns8_Header_footer_properties (pctxt, &pvalue->
            header_footer_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.header_footer_propertiesPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Footer_style                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Footer_style (OSCTXT* pctxt, Ns8_Footer_style *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode header_footer_properties */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Header_footer_properties (pctxt, 
               &pvalue->header_footer_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.header_footer_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Footer_style (OSCTXT* pctxt, Ns8_Footer_style* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("header-footer-properties"), 24}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* header-footer-properties */
         stat = XmlDec_Ns8_Header_footer_properties (pctxt, &pvalue->
            header_footer_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.header_footer_propertiesPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Page_layout                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Page_layout (OSCTXT* pctxt, Ns8_Page_layout *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Name (pctxt, 
               &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode page_usage */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Page_layout_page_usage (pctxt, 
               &pvalue->page_usage, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.page_usagePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode page_layout_properties */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Page_layout_properties (pctxt, 
               &pvalue->page_layout_properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.page_layout_propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode header_style */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Header_style (pctxt, 
               &pvalue->header_style, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.header_stylePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode footer_style */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Footer_style (pctxt, 
               &pvalue->footer_style, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.footer_stylePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Page_layout (OSCTXT* pctxt, Ns8_Page_layout* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("page-usage"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* name */
            stat = XmlDec_Ns8_Name (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* page-usage */
            stat = XmlDec_Ns8_Page_layout_page_usage (pctxt, &pvalue->
               page_usage);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.page_usagePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns8_Page_layout");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns8_Page_layout");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("page-layout-properties"), 22}, 0}, 0 },
      {{{OSUTF8("header-style"), 12}, 0}, 1 },
      {{{OSUTF8("footer-style"), 12}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* page-layout-properties */
         stat = XmlDec_Ns8_Page_layout_properties (pctxt, &pvalue->
            page_layout_properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.page_layout_propertiesPresent = TRUE;
         break;
      }
      case 1: { /* header-style */
         stat = XmlDec_Ns8_Header_style (pctxt, &pvalue->header_style);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.header_stylePresent = TRUE;
         break;
      }
      case 2: { /* footer-style */
         stat = XmlDec_Ns8_Footer_style (pctxt, &pvalue->footer_style);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.footer_stylePresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Master_page_next_style_name                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Master_page_next_style_name (OSCTXT* pctxt, 
   Ns8_Master_page_next_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns8_Master_page_next_style_name (OSCTXT* pctxt, 
   Ns8_Master_page_next_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Page_layout_name                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Page_layout_name (OSCTXT* pctxt, 
   Ns8_Page_layout_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns8_Page_layout_name (OSCTXT* pctxt, Ns8_Page_layout_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Header_display                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Header_display (OSCTXT* pctxt, 
   Ns8_Header_display *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Header_display (OSCTXT* pctxt, Ns8_Header_display* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns8_Header_display_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Header_sequence_element                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Header_sequence_element (OSCTXT* pctxt, 
   Ns8_Header_sequence_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

         if (pvalue->u.h == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_H ((Odf_H*)pvalue->u.h);
         stat = asn1D_Odf_H (pctxt, 
            (Odf_H*)pvalue->u.h, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P ((Odf_P*)pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            (Odf_P*)pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List ((Odf_List*)pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            (Odf_List*)pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.table = rtxMemAllocType (pctxt, Table);

         if (pvalue->u.table == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table ((Table*)pvalue->u.table);
         stat = asn1D_Table (pctxt, 
            (Table*)pvalue->u.table, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.section = rtxMemAllocType (pctxt, Odf_Section);

         if (pvalue->u.section == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Section ((Odf_Section*)pvalue->u.section);
         stat = asn1D_Odf_Section (pctxt, 
            (Odf_Section*)pvalue->u.section, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.table_of_content
             = rtxMemAllocType (pctxt, Odf_Table_of_content);

         if (pvalue->u.table_of_content == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_of_content ((Odf_Table_of_content*)pvalue->u.table_of_content);
         stat = asn1D_Odf_Table_of_content (pctxt, 
            (Odf_Table_of_content*)pvalue->u.table_of_content, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.illustration_index
             = rtxMemAllocType (pctxt, Odf_Illustration_index);

         if (pvalue->u.illustration_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Illustration_index ((Odf_Illustration_index*)pvalue->u.illustration_index);
         stat = asn1D_Odf_Illustration_index (pctxt, 
            (Odf_Illustration_index*)pvalue->u.illustration_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.table_index = rtxMemAllocType (pctxt, Odf_Table_index);

         if (pvalue->u.table_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_index ((Odf_Table_index*)pvalue->u.table_index);
         stat = asn1D_Odf_Table_index (pctxt, 
            (Odf_Table_index*)pvalue->u.table_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.object_index = rtxMemAllocType (pctxt, Odf_Object_index);

         if (pvalue->u.object_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Object_index ((Odf_Object_index*)pvalue->u.object_index);
         stat = asn1D_Odf_Object_index (pctxt, 
            (Odf_Object_index*)pvalue->u.object_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.user_index = rtxMemAllocType (pctxt, Odf_User_index);

         if (pvalue->u.user_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index ((Odf_User_index*)pvalue->u.user_index);
         stat = asn1D_Odf_User_index (pctxt, 
            (Odf_User_index*)pvalue->u.user_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.alphabetical_index
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index);

         if (pvalue->u.alphabetical_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index ((Odf_Alphabetical_index*)pvalue->u.alphabetical_index);
         stat = asn1D_Odf_Alphabetical_index (pctxt, 
            (Odf_Alphabetical_index*)pvalue->u.alphabetical_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.bibliography = rtxMemAllocType (pctxt, Odf_Bibliography);

         if (pvalue->u.bibliography == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bibliography ((Odf_Bibliography*)pvalue->u.bibliography);
         stat = asn1D_Odf_Bibliography (pctxt, 
            (Odf_Bibliography*)pvalue->u.bibliography, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.index_title = rtxMemAllocType (pctxt, Odf_Index_title);

         if (pvalue->u.index_title == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_title ((Odf_Index_title*)pvalue->u.index_title);
         stat = asn1D_Odf_Index_title (pctxt, 
            (Odf_Index_title*)pvalue->u.index_title, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

         if (pvalue->u.change == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change ((Odf_Change*)pvalue->u.change);
         stat = asn1D_Odf_Change (pctxt, 
            (Odf_Change*)pvalue->u.change, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

         if (pvalue->u.change_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_start ((Odf_Change_start*)pvalue->u.change_start);
         stat = asn1D_Odf_Change_start (pctxt, 
            (Odf_Change_start*)pvalue->u.change_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

         if (pvalue->u.change_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_end ((Odf_Change_end*)pvalue->u.change_end);
         stat = asn1D_Odf_Change_end (pctxt, 
            (Odf_Change_end*)pvalue->u.change_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns8_Header_sequence_element (OSCTXT* pctxt, 
   Ns8_Header_sequence_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("h"), 1}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 1 },
      {{{OSUTF8("list"), 4}, 0}, 2 },
      {{{OSUTF8("table"), 5}, 0}, 3 },
      {{{OSUTF8("section"), 7}, 0}, 4 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 5 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 6 },
      {{{OSUTF8("table-index"), 11}, 0}, 7 },
      {{{OSUTF8("object-index"), 12}, 0}, 8 },
      {{{OSUTF8("user-index"), 10}, 0}, 9 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 10 },
      {{{OSUTF8("bibliography"), 12}, 0}, 11 },
      {{{OSUTF8("index-title"), 11}, 0}, 12 },
      {{{OSUTF8("change"), 6}, 0}, 13 },
      {{{OSUTF8("change-start"), 12}, 0}, 14 },
      {{{OSUTF8("change-end"), 10}, 0}, 15 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 16, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* h */
      pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

      if (pvalue->u.h == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_H ((Odf_H*)pvalue->u.h);

      stat = XmlDec_Odf_H (pctxt, pvalue->u.h);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P ((Odf_P*)pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List ((Odf_List*)pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* table */
      pvalue->u.table = rtxMemAllocType (pctxt, Table);

      if (pvalue->u.table == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table ((Table*)pvalue->u.table);

      stat = XmlDec_Table (pctxt, pvalue->u.table);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* section */
      pvalue->u.section = rtxMemAllocType (pctxt, Odf_Section);

      if (pvalue->u.section == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Section ((Odf_Section*)pvalue->u.section);

      stat = XmlDec_Odf_Section (pctxt, pvalue->u.section);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* table-of-content */
      pvalue->u.table_of_content
          = rtxMemAllocType (pctxt, Odf_Table_of_content);

      if (pvalue->u.table_of_content == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_of_content ((Odf_Table_of_content*)pvalue->
         u.table_of_content);

      stat = XmlDec_Odf_Table_of_content (pctxt, pvalue->u.table_of_content);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* illustration-index */
      pvalue->u.illustration_index
          = rtxMemAllocType (pctxt, Odf_Illustration_index);

      if (pvalue->u.illustration_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Illustration_index ((Odf_Illustration_index*)pvalue->
         u.illustration_index);

      stat = XmlDec_Odf_Illustration_index (pctxt, pvalue->u.illustration_index
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* table-index */
      pvalue->u.table_index = rtxMemAllocType (pctxt, Odf_Table_index);

      if (pvalue->u.table_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_index ((Odf_Table_index*)pvalue->u.table_index);

      stat = XmlDec_Odf_Table_index (pctxt, pvalue->u.table_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* object-index */
      pvalue->u.object_index = rtxMemAllocType (pctxt, Odf_Object_index);

      if (pvalue->u.object_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Object_index ((Odf_Object_index*)pvalue->u.object_index);

      stat = XmlDec_Odf_Object_index (pctxt, pvalue->u.object_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* user-index */
      pvalue->u.user_index = rtxMemAllocType (pctxt, Odf_User_index);

      if (pvalue->u.user_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index ((Odf_User_index*)pvalue->u.user_index);

      stat = XmlDec_Odf_User_index (pctxt, pvalue->u.user_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* alphabetical-index */
      pvalue->u.alphabetical_index
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index);

      if (pvalue->u.alphabetical_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index ((Odf_Alphabetical_index*)pvalue->
         u.alphabetical_index);

      stat = XmlDec_Odf_Alphabetical_index (pctxt, pvalue->u.alphabetical_index
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* bibliography */
      pvalue->u.bibliography = rtxMemAllocType (pctxt, Odf_Bibliography);

      if (pvalue->u.bibliography == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bibliography ((Odf_Bibliography*)pvalue->u.bibliography);

      stat = XmlDec_Odf_Bibliography (pctxt, pvalue->u.bibliography);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* index-title */
      pvalue->u.index_title = rtxMemAllocType (pctxt, Odf_Index_title);

      if (pvalue->u.index_title == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_title ((Odf_Index_title*)pvalue->u.index_title);

      stat = XmlDec_Odf_Index_title (pctxt, pvalue->u.index_title);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* change */
      pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

      if (pvalue->u.change == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change ((Odf_Change*)pvalue->u.change);

      stat = XmlDec_Odf_Change (pctxt, pvalue->u.change);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* change-start */
      pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

      if (pvalue->u.change_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_start ((Odf_Change_start*)pvalue->u.change_start);

      stat = XmlDec_Odf_Change_start (pctxt, pvalue->u.change_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* change-end */
      pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

      if (pvalue->u.change_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_end ((Odf_Change_end*)pvalue->u.change_end);

      stat = XmlDec_Odf_Change_end (pctxt, pvalue->u.change_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Header_sequence                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Header_sequence (OSCTXT* pctxt, 
   Ns8_Header_sequence *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode variable_decls */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->variable_decls
                = rtxMemAllocType (pctxt, Odf_Variable_decls);

            if (pvalue->variable_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->variable_decls);
            asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->variable_decls);

            stat = asn1D_Odf_Variable_decls (pctxt, 
               (Odf_Variable_decls*)pvalue->variable_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.variable_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode sequence_decls */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->sequence_decls
                = rtxMemAllocType (pctxt, Odf_Sequence_decls);

            if (pvalue->sequence_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->sequence_decls);
            asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->sequence_decls);

            stat = asn1D_Odf_Sequence_decls (pctxt, 
               (Odf_Sequence_decls*)pvalue->sequence_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sequence_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode user_field_decls */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->user_field_decls
                = rtxMemAllocType (pctxt, Odf_User_field_decls);

            if (pvalue->user_field_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->user_field_decls);
            asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->user_field_decls);

            stat = asn1D_Odf_User_field_decls (pctxt, 
               (Odf_User_field_decls*)pvalue->user_field_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.user_field_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode dde_connection_decls */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->dde_connection_decls
                = rtxMemAllocType (pctxt, Odf_Dde_connection_decls);

            if (pvalue->dde_connection_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->dde_connection_decls);
            asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->dde_connection_decls);

            stat = asn1D_Odf_Dde_connection_decls (pctxt, 
               (Odf_Dde_connection_decls*)pvalue->dde_connection_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dde_connection_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode alphabetical_index_auto_mark_file */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->alphabetical_index_auto_mark_file
                = rtxMemAllocType (pctxt, Odf_Alphabetical_index_auto_mark_file);

            if (pvalue->alphabetical_index_auto_mark_file == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Alphabetical_index_auto_mark_file ((Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file);
            asn1Init_Odf_Alphabetical_index_auto_mark_file ((Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file);

            stat = asn1D_Odf_Alphabetical_index_auto_mark_file (pctxt, 
               (Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.alphabetical_index_auto_mark_filePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns8_Header_sequence_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns8_Header_sequence_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns8_Header_sequence_element (pdata2);

                  stat = asn1D_Ns8_Header_sequence_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Header_sequence (OSCTXT* pctxt, Ns8_Header_sequence* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("variable-decls"), 14}, 0}, 0 },
      {{{OSUTF8("sequence-decls"), 14}, 0}, 1 },
      {{{OSUTF8("user-field-decls"), 16}, 0}, 2 },
      {{{OSUTF8("dde-connection-decls"), 20}, 0}, 3 },
      {{{OSUTF8("alphabetical-index-auto-mark-file"), 33}, 0}, 4 },
      {{{OSUTF8("h"), 1}, 0}, 5 },
      {{{OSUTF8("p"), 1}, 0}, 5 },
      {{{OSUTF8("list"), 4}, 0}, 5 },
      {{{OSUTF8("table"), 5}, 0}, 5 },
      {{{OSUTF8("section"), 7}, 0}, 5 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 5 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 5 },
      {{{OSUTF8("table-index"), 11}, 0}, 5 },
      {{{OSUTF8("object-index"), 12}, 0}, 5 },
      {{{OSUTF8("user-index"), 10}, 0}, 5 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 5 },
      {{{OSUTF8("bibliography"), 12}, 0}, 5 },
      {{{OSUTF8("index-title"), 11}, 0}, 5 },
      {{{OSUTF8("change"), 6}, 0}, 5 },
      {{{OSUTF8("change-start"), 12}, 0}, 5 },
      {{{OSUTF8("change-end"), 10}, 0}, 5 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 21, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 6; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* variable-decls */
         pvalue->variable_decls = rtxMemAllocType (pctxt, Odf_Variable_decls);

         if (pvalue->variable_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->
            variable_decls);

         stat = XmlDec_Odf_Variable_decls (pctxt, pvalue->variable_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.variable_declsPresent = TRUE;
         break;
      }
      case 1: { /* sequence-decls */
         pvalue->sequence_decls = rtxMemAllocType (pctxt, Odf_Sequence_decls);

         if (pvalue->sequence_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->
            sequence_decls);

         stat = XmlDec_Odf_Sequence_decls (pctxt, pvalue->sequence_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.sequence_declsPresent = TRUE;
         break;
      }
      case 2: { /* user-field-decls */
         pvalue->user_field_decls
             = rtxMemAllocType (pctxt, Odf_User_field_decls);

         if (pvalue->user_field_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->
            user_field_decls);

         stat = XmlDec_Odf_User_field_decls (pctxt, pvalue->user_field_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.user_field_declsPresent = TRUE;
         break;
      }
      case 3: { /* dde-connection-decls */
         pvalue->dde_connection_decls
             = rtxMemAllocType (pctxt, Odf_Dde_connection_decls);

         if (pvalue->dde_connection_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->
            dde_connection_decls);

         stat = XmlDec_Odf_Dde_connection_decls (pctxt, pvalue->
            dde_connection_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dde_connection_declsPresent = TRUE;
         break;
      }
      case 4: { /* alphabetical-index-auto-mark-file */
         pvalue->alphabetical_index_auto_mark_file
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index_auto_mark_file);

         if (pvalue->alphabetical_index_auto_mark_file == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index_auto_mark_file (
            (Odf_Alphabetical_index_auto_mark_file*)pvalue->
            alphabetical_index_auto_mark_file);

         stat = XmlDec_Odf_Alphabetical_index_auto_mark_file (pctxt, pvalue->
            alphabetical_index_auto_mark_file);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.alphabetical_index_auto_mark_filePresent = TRUE;
         break;
      }
      case 5: {
         Ns8_Header_sequence_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns8_Header_sequence_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Header_sequence_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns8_Header_sequence_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 5, 16, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 5);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Region_left                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Region_left (OSCTXT* pctxt, Ns8_Region_left *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode p_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_P* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->p_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_P, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_P ((Odf_P*)pdata2);

                  stat = asn1D_Odf_P (pctxt, 
                     (Odf_P*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->p_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Region_left (OSCTXT* pctxt, Ns8_Region_left* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("p"), 1}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_P* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_P);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_P ((Odf_P*)pdata1);

            stat = XmlDec_Odf_P (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->p_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Region_center                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Region_center (OSCTXT* pctxt, Ns8_Region_center *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode p_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_P* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->p_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_P, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_P ((Odf_P*)pdata2);

                  stat = asn1D_Odf_P (pctxt, 
                     (Odf_P*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->p_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Region_center (OSCTXT* pctxt, Ns8_Region_center* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("p"), 1}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_P* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_P);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_P ((Odf_P*)pdata1);

            stat = XmlDec_Odf_P (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->p_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Region_right                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Region_right (OSCTXT* pctxt, Ns8_Region_right *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode p_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_P* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->p_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_P, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_P ((Odf_P*)pdata2);

                  stat = asn1D_Odf_P (pctxt, 
                     (Odf_P*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->p_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Region_right (OSCTXT* pctxt, Ns8_Region_right* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("p"), 1}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Odf_P* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_P);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_P ((Odf_P*)pdata1);

            stat = XmlDec_Odf_P (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->p_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Header_sequence_1                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Header_sequence_1 (OSCTXT* pctxt, 
   Ns8_Header_sequence_1 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode region_left */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Region_left (pctxt, 
               &pvalue->region_left, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.region_leftPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode region_center */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Region_center (pctxt, 
               &pvalue->region_center, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.region_centerPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode region_right */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Region_right (pctxt, 
               &pvalue->region_right, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.region_rightPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Header_sequence_1 (OSCTXT* pctxt, Ns8_Header_sequence_1* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("region-left"), 11}, 0}, 0 },
      {{{OSUTF8("region-center"), 13}, 0}, 1 },
      {{{OSUTF8("region-right"), 12}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* region-left */
         stat = XmlDec_Ns8_Region_left (pctxt, &pvalue->region_left);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.region_leftPresent = TRUE;
         break;
      }
      case 1: { /* region-center */
         stat = XmlDec_Ns8_Region_center (pctxt, &pvalue->region_center);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.region_centerPresent = TRUE;
         break;
      }
      case 2: { /* region-right */
         stat = XmlDec_Ns8_Region_right (pctxt, &pvalue->region_right);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.region_rightPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Header_choice                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Header_choice (OSCTXT* pctxt, Ns8_Header_choice *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.sequence = rtxMemAllocType (pctxt, Ns8_Header_sequence);

         if (pvalue->u.sequence == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns8_Header_sequence (pvalue->u.sequence);
         stat = asn1D_Ns8_Header_sequence (pctxt, 
            pvalue->u.sequence, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.sequence_1
             = rtxMemAllocType (pctxt, Ns8_Header_sequence_1);

         if (pvalue->u.sequence_1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns8_Header_sequence_1 (pvalue->u.sequence_1);
         stat = asn1D_Ns8_Header_sequence_1 (pctxt, 
            pvalue->u.sequence_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns8_Header_choice (OSCTXT* pctxt, Ns8_Header_choice* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("variable-decls"), 14}, 0}, 0 },
      {{{OSUTF8("sequence-decls"), 14}, 0}, 0 },
      {{{OSUTF8("user-field-decls"), 16}, 0}, 0 },
      {{{OSUTF8("dde-connection-decls"), 20}, 0}, 0 },
      {{{OSUTF8("alphabetical-index-auto-mark-file"), 33}, 0}, 0 },
      {{{OSUTF8("h"), 1}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("list"), 4}, 0}, 0 },
      {{{OSUTF8("table"), 5}, 0}, 0 },
      {{{OSUTF8("section"), 7}, 0}, 0 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 0 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 0 },
      {{{OSUTF8("table-index"), 11}, 0}, 0 },
      {{{OSUTF8("object-index"), 12}, 0}, 0 },
      {{{OSUTF8("user-index"), 10}, 0}, 0 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 0 },
      {{{OSUTF8("bibliography"), 12}, 0}, 0 },
      {{{OSUTF8("index-title"), 11}, 0}, 0 },
      {{{OSUTF8("change"), 6}, 0}, 0 },
      {{{OSUTF8("change-start"), 12}, 0}, 0 },
      {{{OSUTF8("change-end"), 10}, 0}, 0 },
      {{{OSUTF8("region-left"), 11}, 0}, 1 },
      {{{OSUTF8("region-center"), 13}, 0}, 1 },
      {{{OSUTF8("region-right"), 12}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 24, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /*  */
      pvalue->u.sequence = rtxMemAllocType (pctxt, Ns8_Header_sequence);

      if (pvalue->u.sequence == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns8_Header_sequence (pvalue->u.sequence);

      stat = XmlDec_Ns8_Header_sequence (pctxt, pvalue->u.sequence);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /*  */
      pvalue->u.sequence_1 = rtxMemAllocType (pctxt, Ns8_Header_sequence_1);

      if (pvalue->u.sequence_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns8_Header_sequence_1 (pvalue->u.sequence_1);

      stat = XmlDec_Ns8_Header_sequence_1 (pctxt, pvalue->u.sequence_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Header                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Header (OSCTXT* pctxt, Ns8_Header *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode display */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Header_display (pctxt, 
               &pvalue->display, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.displayPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Header_choice (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Header (OSCTXT* pctxt, Ns8_Header* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("display"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* display */
            stat = XmlDec_Ns8_Header_display (pctxt, &pvalue->display);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.displayPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns8_Header");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns8_Header");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("variable-decls"), 14}, 0}, 0 },
      {{{OSUTF8("sequence-decls"), 14}, 0}, 0 },
      {{{OSUTF8("user-field-decls"), 16}, 0}, 0 },
      {{{OSUTF8("dde-connection-decls"), 20}, 0}, 0 },
      {{{OSUTF8("alphabetical-index-auto-mark-file"), 33}, 0}, 0 },
      {{{OSUTF8("h"), 1}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("list"), 4}, 0}, 0 },
      {{{OSUTF8("table"), 5}, 0}, 0 },
      {{{OSUTF8("section"), 7}, 0}, 0 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 0 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 0 },
      {{{OSUTF8("table-index"), 11}, 0}, 0 },
      {{{OSUTF8("object-index"), 12}, 0}, 0 },
      {{{OSUTF8("user-index"), 10}, 0}, 0 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 0 },
      {{{OSUTF8("bibliography"), 12}, 0}, 0 },
      {{{OSUTF8("index-title"), 11}, 0}, 0 },
      {{{OSUTF8("change"), 6}, 0}, 0 },
      {{{OSUTF8("change-start"), 12}, 0}, 0 },
      {{{OSUTF8("change-end"), 10}, 0}, 0 },
      {{{OSUTF8("region-left"), 11}, 0}, 0 },
      {{{OSUTF8("region-center"), 13}, 0}, 0 },
      {{{OSUTF8("region-right"), 12}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 24, -1}, {24, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_Ns8_Header_choice (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Header_left_display                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Header_left_display (OSCTXT* pctxt, 
   Ns8_Header_left_display *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Header_left_display (OSCTXT* pctxt, 
   Ns8_Header_left_display* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns8_Header_left_display_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Header_left_sequence_element                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Header_left_sequence_element (OSCTXT* pctxt, 
   Ns8_Header_left_sequence_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

         if (pvalue->u.h == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_H ((Odf_H*)pvalue->u.h);
         stat = asn1D_Odf_H (pctxt, 
            (Odf_H*)pvalue->u.h, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P ((Odf_P*)pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            (Odf_P*)pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List ((Odf_List*)pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            (Odf_List*)pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.table = rtxMemAllocType (pctxt, Table);

         if (pvalue->u.table == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table ((Table*)pvalue->u.table);
         stat = asn1D_Table (pctxt, 
            (Table*)pvalue->u.table, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.section = rtxMemAllocType (pctxt, Odf_Section);

         if (pvalue->u.section == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Section ((Odf_Section*)pvalue->u.section);
         stat = asn1D_Odf_Section (pctxt, 
            (Odf_Section*)pvalue->u.section, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.table_of_content
             = rtxMemAllocType (pctxt, Odf_Table_of_content);

         if (pvalue->u.table_of_content == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_of_content ((Odf_Table_of_content*)pvalue->u.table_of_content);
         stat = asn1D_Odf_Table_of_content (pctxt, 
            (Odf_Table_of_content*)pvalue->u.table_of_content, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.illustration_index
             = rtxMemAllocType (pctxt, Odf_Illustration_index);

         if (pvalue->u.illustration_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Illustration_index ((Odf_Illustration_index*)pvalue->u.illustration_index);
         stat = asn1D_Odf_Illustration_index (pctxt, 
            (Odf_Illustration_index*)pvalue->u.illustration_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.table_index = rtxMemAllocType (pctxt, Odf_Table_index);

         if (pvalue->u.table_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_index ((Odf_Table_index*)pvalue->u.table_index);
         stat = asn1D_Odf_Table_index (pctxt, 
            (Odf_Table_index*)pvalue->u.table_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.object_index = rtxMemAllocType (pctxt, Odf_Object_index);

         if (pvalue->u.object_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Object_index ((Odf_Object_index*)pvalue->u.object_index);
         stat = asn1D_Odf_Object_index (pctxt, 
            (Odf_Object_index*)pvalue->u.object_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.user_index = rtxMemAllocType (pctxt, Odf_User_index);

         if (pvalue->u.user_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index ((Odf_User_index*)pvalue->u.user_index);
         stat = asn1D_Odf_User_index (pctxt, 
            (Odf_User_index*)pvalue->u.user_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.alphabetical_index
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index);

         if (pvalue->u.alphabetical_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index ((Odf_Alphabetical_index*)pvalue->u.alphabetical_index);
         stat = asn1D_Odf_Alphabetical_index (pctxt, 
            (Odf_Alphabetical_index*)pvalue->u.alphabetical_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.bibliography = rtxMemAllocType (pctxt, Odf_Bibliography);

         if (pvalue->u.bibliography == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bibliography ((Odf_Bibliography*)pvalue->u.bibliography);
         stat = asn1D_Odf_Bibliography (pctxt, 
            (Odf_Bibliography*)pvalue->u.bibliography, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.index_title = rtxMemAllocType (pctxt, Odf_Index_title);

         if (pvalue->u.index_title == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_title ((Odf_Index_title*)pvalue->u.index_title);
         stat = asn1D_Odf_Index_title (pctxt, 
            (Odf_Index_title*)pvalue->u.index_title, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

         if (pvalue->u.change == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change ((Odf_Change*)pvalue->u.change);
         stat = asn1D_Odf_Change (pctxt, 
            (Odf_Change*)pvalue->u.change, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

         if (pvalue->u.change_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_start ((Odf_Change_start*)pvalue->u.change_start);
         stat = asn1D_Odf_Change_start (pctxt, 
            (Odf_Change_start*)pvalue->u.change_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

         if (pvalue->u.change_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_end ((Odf_Change_end*)pvalue->u.change_end);
         stat = asn1D_Odf_Change_end (pctxt, 
            (Odf_Change_end*)pvalue->u.change_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns8_Header_left_sequence_element (OSCTXT* pctxt, 
   Ns8_Header_left_sequence_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("h"), 1}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 1 },
      {{{OSUTF8("list"), 4}, 0}, 2 },
      {{{OSUTF8("table"), 5}, 0}, 3 },
      {{{OSUTF8("section"), 7}, 0}, 4 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 5 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 6 },
      {{{OSUTF8("table-index"), 11}, 0}, 7 },
      {{{OSUTF8("object-index"), 12}, 0}, 8 },
      {{{OSUTF8("user-index"), 10}, 0}, 9 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 10 },
      {{{OSUTF8("bibliography"), 12}, 0}, 11 },
      {{{OSUTF8("index-title"), 11}, 0}, 12 },
      {{{OSUTF8("change"), 6}, 0}, 13 },
      {{{OSUTF8("change-start"), 12}, 0}, 14 },
      {{{OSUTF8("change-end"), 10}, 0}, 15 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 16, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* h */
      pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

      if (pvalue->u.h == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_H ((Odf_H*)pvalue->u.h);

      stat = XmlDec_Odf_H (pctxt, pvalue->u.h);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P ((Odf_P*)pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List ((Odf_List*)pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* table */
      pvalue->u.table = rtxMemAllocType (pctxt, Table);

      if (pvalue->u.table == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table ((Table*)pvalue->u.table);

      stat = XmlDec_Table (pctxt, pvalue->u.table);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* section */
      pvalue->u.section = rtxMemAllocType (pctxt, Odf_Section);

      if (pvalue->u.section == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Section ((Odf_Section*)pvalue->u.section);

      stat = XmlDec_Odf_Section (pctxt, pvalue->u.section);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* table-of-content */
      pvalue->u.table_of_content
          = rtxMemAllocType (pctxt, Odf_Table_of_content);

      if (pvalue->u.table_of_content == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_of_content ((Odf_Table_of_content*)pvalue->
         u.table_of_content);

      stat = XmlDec_Odf_Table_of_content (pctxt, pvalue->u.table_of_content);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* illustration-index */
      pvalue->u.illustration_index
          = rtxMemAllocType (pctxt, Odf_Illustration_index);

      if (pvalue->u.illustration_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Illustration_index ((Odf_Illustration_index*)pvalue->
         u.illustration_index);

      stat = XmlDec_Odf_Illustration_index (pctxt, pvalue->u.illustration_index
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* table-index */
      pvalue->u.table_index = rtxMemAllocType (pctxt, Odf_Table_index);

      if (pvalue->u.table_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_index ((Odf_Table_index*)pvalue->u.table_index);

      stat = XmlDec_Odf_Table_index (pctxt, pvalue->u.table_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* object-index */
      pvalue->u.object_index = rtxMemAllocType (pctxt, Odf_Object_index);

      if (pvalue->u.object_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Object_index ((Odf_Object_index*)pvalue->u.object_index);

      stat = XmlDec_Odf_Object_index (pctxt, pvalue->u.object_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* user-index */
      pvalue->u.user_index = rtxMemAllocType (pctxt, Odf_User_index);

      if (pvalue->u.user_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index ((Odf_User_index*)pvalue->u.user_index);

      stat = XmlDec_Odf_User_index (pctxt, pvalue->u.user_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* alphabetical-index */
      pvalue->u.alphabetical_index
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index);

      if (pvalue->u.alphabetical_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index ((Odf_Alphabetical_index*)pvalue->
         u.alphabetical_index);

      stat = XmlDec_Odf_Alphabetical_index (pctxt, pvalue->u.alphabetical_index
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* bibliography */
      pvalue->u.bibliography = rtxMemAllocType (pctxt, Odf_Bibliography);

      if (pvalue->u.bibliography == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bibliography ((Odf_Bibliography*)pvalue->u.bibliography);

      stat = XmlDec_Odf_Bibliography (pctxt, pvalue->u.bibliography);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* index-title */
      pvalue->u.index_title = rtxMemAllocType (pctxt, Odf_Index_title);

      if (pvalue->u.index_title == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_title ((Odf_Index_title*)pvalue->u.index_title);

      stat = XmlDec_Odf_Index_title (pctxt, pvalue->u.index_title);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* change */
      pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

      if (pvalue->u.change == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change ((Odf_Change*)pvalue->u.change);

      stat = XmlDec_Odf_Change (pctxt, pvalue->u.change);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* change-start */
      pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

      if (pvalue->u.change_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_start ((Odf_Change_start*)pvalue->u.change_start);

      stat = XmlDec_Odf_Change_start (pctxt, pvalue->u.change_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* change-end */
      pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

      if (pvalue->u.change_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_end ((Odf_Change_end*)pvalue->u.change_end);

      stat = XmlDec_Odf_Change_end (pctxt, pvalue->u.change_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Header_left_sequence                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Header_left_sequence (OSCTXT* pctxt, 
   Ns8_Header_left_sequence *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode variable_decls */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->variable_decls
                = rtxMemAllocType (pctxt, Odf_Variable_decls);

            if (pvalue->variable_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->variable_decls);
            asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->variable_decls);

            stat = asn1D_Odf_Variable_decls (pctxt, 
               (Odf_Variable_decls*)pvalue->variable_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.variable_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode sequence_decls */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->sequence_decls
                = rtxMemAllocType (pctxt, Odf_Sequence_decls);

            if (pvalue->sequence_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->sequence_decls);
            asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->sequence_decls);

            stat = asn1D_Odf_Sequence_decls (pctxt, 
               (Odf_Sequence_decls*)pvalue->sequence_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sequence_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode user_field_decls */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->user_field_decls
                = rtxMemAllocType (pctxt, Odf_User_field_decls);

            if (pvalue->user_field_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->user_field_decls);
            asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->user_field_decls);

            stat = asn1D_Odf_User_field_decls (pctxt, 
               (Odf_User_field_decls*)pvalue->user_field_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.user_field_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode dde_connection_decls */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->dde_connection_decls
                = rtxMemAllocType (pctxt, Odf_Dde_connection_decls);

            if (pvalue->dde_connection_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->dde_connection_decls);
            asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->dde_connection_decls);

            stat = asn1D_Odf_Dde_connection_decls (pctxt, 
               (Odf_Dde_connection_decls*)pvalue->dde_connection_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dde_connection_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode alphabetical_index_auto_mark_file */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->alphabetical_index_auto_mark_file
                = rtxMemAllocType (pctxt, Odf_Alphabetical_index_auto_mark_file);

            if (pvalue->alphabetical_index_auto_mark_file == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Alphabetical_index_auto_mark_file ((Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file);
            asn1Init_Odf_Alphabetical_index_auto_mark_file ((Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file);

            stat = asn1D_Odf_Alphabetical_index_auto_mark_file (pctxt, 
               (Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.alphabetical_index_auto_mark_filePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns8_Header_left_sequence_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns8_Header_left_sequence_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns8_Header_left_sequence_element (pdata2);

                  stat = asn1D_Ns8_Header_left_sequence_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Header_left_sequence (OSCTXT* pctxt, 
   Ns8_Header_left_sequence* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("variable-decls"), 14}, 0}, 0 },
      {{{OSUTF8("sequence-decls"), 14}, 0}, 1 },
      {{{OSUTF8("user-field-decls"), 16}, 0}, 2 },
      {{{OSUTF8("dde-connection-decls"), 20}, 0}, 3 },
      {{{OSUTF8("alphabetical-index-auto-mark-file"), 33}, 0}, 4 },
      {{{OSUTF8("h"), 1}, 0}, 5 },
      {{{OSUTF8("p"), 1}, 0}, 5 },
      {{{OSUTF8("list"), 4}, 0}, 5 },
      {{{OSUTF8("table"), 5}, 0}, 5 },
      {{{OSUTF8("section"), 7}, 0}, 5 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 5 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 5 },
      {{{OSUTF8("table-index"), 11}, 0}, 5 },
      {{{OSUTF8("object-index"), 12}, 0}, 5 },
      {{{OSUTF8("user-index"), 10}, 0}, 5 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 5 },
      {{{OSUTF8("bibliography"), 12}, 0}, 5 },
      {{{OSUTF8("index-title"), 11}, 0}, 5 },
      {{{OSUTF8("change"), 6}, 0}, 5 },
      {{{OSUTF8("change-start"), 12}, 0}, 5 },
      {{{OSUTF8("change-end"), 10}, 0}, 5 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 21, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 6; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* variable-decls */
         pvalue->variable_decls = rtxMemAllocType (pctxt, Odf_Variable_decls);

         if (pvalue->variable_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->
            variable_decls);

         stat = XmlDec_Odf_Variable_decls (pctxt, pvalue->variable_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.variable_declsPresent = TRUE;
         break;
      }
      case 1: { /* sequence-decls */
         pvalue->sequence_decls = rtxMemAllocType (pctxt, Odf_Sequence_decls);

         if (pvalue->sequence_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->
            sequence_decls);

         stat = XmlDec_Odf_Sequence_decls (pctxt, pvalue->sequence_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.sequence_declsPresent = TRUE;
         break;
      }
      case 2: { /* user-field-decls */
         pvalue->user_field_decls
             = rtxMemAllocType (pctxt, Odf_User_field_decls);

         if (pvalue->user_field_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->
            user_field_decls);

         stat = XmlDec_Odf_User_field_decls (pctxt, pvalue->user_field_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.user_field_declsPresent = TRUE;
         break;
      }
      case 3: { /* dde-connection-decls */
         pvalue->dde_connection_decls
             = rtxMemAllocType (pctxt, Odf_Dde_connection_decls);

         if (pvalue->dde_connection_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->
            dde_connection_decls);

         stat = XmlDec_Odf_Dde_connection_decls (pctxt, pvalue->
            dde_connection_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dde_connection_declsPresent = TRUE;
         break;
      }
      case 4: { /* alphabetical-index-auto-mark-file */
         pvalue->alphabetical_index_auto_mark_file
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index_auto_mark_file);

         if (pvalue->alphabetical_index_auto_mark_file == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index_auto_mark_file (
            (Odf_Alphabetical_index_auto_mark_file*)pvalue->
            alphabetical_index_auto_mark_file);

         stat = XmlDec_Odf_Alphabetical_index_auto_mark_file (pctxt, pvalue->
            alphabetical_index_auto_mark_file);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.alphabetical_index_auto_mark_filePresent = TRUE;
         break;
      }
      case 5: {
         Ns8_Header_left_sequence_element* pdata1;
         do {
            pdata1
                = rtxMemAllocType (pctxt, Ns8_Header_left_sequence_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Header_left_sequence_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns8_Header_left_sequence_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 5, 16, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 5);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Header_left_sequence_1                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Header_left_sequence_1 (OSCTXT* pctxt, 
   Ns8_Header_left_sequence_1 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode region_left */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Region_left (pctxt, 
               &pvalue->region_left, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.region_leftPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode region_center */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Region_center (pctxt, 
               &pvalue->region_center, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.region_centerPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode region_right */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Region_right (pctxt, 
               &pvalue->region_right, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.region_rightPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Header_left_sequence_1 (OSCTXT* pctxt, 
   Ns8_Header_left_sequence_1* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("region-left"), 11}, 0}, 0 },
      {{{OSUTF8("region-center"), 13}, 0}, 1 },
      {{{OSUTF8("region-right"), 12}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* region-left */
         stat = XmlDec_Ns8_Region_left (pctxt, &pvalue->region_left);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.region_leftPresent = TRUE;
         break;
      }
      case 1: { /* region-center */
         stat = XmlDec_Ns8_Region_center (pctxt, &pvalue->region_center);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.region_centerPresent = TRUE;
         break;
      }
      case 2: { /* region-right */
         stat = XmlDec_Ns8_Region_right (pctxt, &pvalue->region_right);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.region_rightPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Header_left_choice                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Header_left_choice (OSCTXT* pctxt, 
   Ns8_Header_left_choice *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.sequence
             = rtxMemAllocType (pctxt, Ns8_Header_left_sequence);

         if (pvalue->u.sequence == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns8_Header_left_sequence (pvalue->u.sequence);
         stat = asn1D_Ns8_Header_left_sequence (pctxt, 
            pvalue->u.sequence, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.sequence_1
             = rtxMemAllocType (pctxt, Ns8_Header_left_sequence_1);

         if (pvalue->u.sequence_1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns8_Header_left_sequence_1 (pvalue->u.sequence_1);
         stat = asn1D_Ns8_Header_left_sequence_1 (pctxt, 
            pvalue->u.sequence_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns8_Header_left_choice (OSCTXT* pctxt, 
   Ns8_Header_left_choice* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("variable-decls"), 14}, 0}, 0 },
      {{{OSUTF8("sequence-decls"), 14}, 0}, 0 },
      {{{OSUTF8("user-field-decls"), 16}, 0}, 0 },
      {{{OSUTF8("dde-connection-decls"), 20}, 0}, 0 },
      {{{OSUTF8("alphabetical-index-auto-mark-file"), 33}, 0}, 0 },
      {{{OSUTF8("h"), 1}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("list"), 4}, 0}, 0 },
      {{{OSUTF8("table"), 5}, 0}, 0 },
      {{{OSUTF8("section"), 7}, 0}, 0 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 0 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 0 },
      {{{OSUTF8("table-index"), 11}, 0}, 0 },
      {{{OSUTF8("object-index"), 12}, 0}, 0 },
      {{{OSUTF8("user-index"), 10}, 0}, 0 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 0 },
      {{{OSUTF8("bibliography"), 12}, 0}, 0 },
      {{{OSUTF8("index-title"), 11}, 0}, 0 },
      {{{OSUTF8("change"), 6}, 0}, 0 },
      {{{OSUTF8("change-start"), 12}, 0}, 0 },
      {{{OSUTF8("change-end"), 10}, 0}, 0 },
      {{{OSUTF8("region-left"), 11}, 0}, 1 },
      {{{OSUTF8("region-center"), 13}, 0}, 1 },
      {{{OSUTF8("region-right"), 12}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 24, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /*  */
      pvalue->u.sequence = rtxMemAllocType (pctxt, Ns8_Header_left_sequence);

      if (pvalue->u.sequence == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns8_Header_left_sequence (pvalue->u.sequence);

      stat = XmlDec_Ns8_Header_left_sequence (pctxt, pvalue->u.sequence);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /*  */
      pvalue->u.sequence_1
          = rtxMemAllocType (pctxt, Ns8_Header_left_sequence_1);

      if (pvalue->u.sequence_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns8_Header_left_sequence_1 (pvalue->u.sequence_1);

      stat = XmlDec_Ns8_Header_left_sequence_1 (pctxt, pvalue->u.sequence_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Header_left                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Header_left (OSCTXT* pctxt, Ns8_Header_left *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode display */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Header_left_display (pctxt, 
               &pvalue->display, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.displayPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Header_left_choice (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Header_left (OSCTXT* pctxt, Ns8_Header_left* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("display"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* display */
            stat = XmlDec_Ns8_Header_left_display (pctxt, &pvalue->display);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.displayPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns8_Header_left");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns8_Header_left");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("variable-decls"), 14}, 0}, 0 },
      {{{OSUTF8("sequence-decls"), 14}, 0}, 0 },
      {{{OSUTF8("user-field-decls"), 16}, 0}, 0 },
      {{{OSUTF8("dde-connection-decls"), 20}, 0}, 0 },
      {{{OSUTF8("alphabetical-index-auto-mark-file"), 33}, 0}, 0 },
      {{{OSUTF8("h"), 1}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("list"), 4}, 0}, 0 },
      {{{OSUTF8("table"), 5}, 0}, 0 },
      {{{OSUTF8("section"), 7}, 0}, 0 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 0 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 0 },
      {{{OSUTF8("table-index"), 11}, 0}, 0 },
      {{{OSUTF8("object-index"), 12}, 0}, 0 },
      {{{OSUTF8("user-index"), 10}, 0}, 0 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 0 },
      {{{OSUTF8("bibliography"), 12}, 0}, 0 },
      {{{OSUTF8("index-title"), 11}, 0}, 0 },
      {{{OSUTF8("change"), 6}, 0}, 0 },
      {{{OSUTF8("change-start"), 12}, 0}, 0 },
      {{{OSUTF8("change-end"), 10}, 0}, 0 },
      {{{OSUTF8("region-left"), 11}, 0}, 0 },
      {{{OSUTF8("region-center"), 13}, 0}, 0 },
      {{{OSUTF8("region-right"), 12}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 24, -1}, {24, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_Ns8_Header_left_choice (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Master_page_sequence                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Master_page_sequence (OSCTXT* pctxt, 
   Ns8_Master_page_sequence *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode header */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Header (pctxt, 
               &pvalue->header, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode header_left */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Header_left (pctxt, 
               &pvalue->header_left, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.header_leftPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Master_page_sequence (OSCTXT* pctxt, 
   Ns8_Master_page_sequence* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("header"), 6}, 0}, 0 },
      {{{OSUTF8("header-left"), 11}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* header */
         stat = XmlDec_Ns8_Header (pctxt, &pvalue->header);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* header-left */
         stat = XmlDec_Ns8_Header_left (pctxt, &pvalue->header_left);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.header_leftPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Footer_display                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Footer_display (OSCTXT* pctxt, 
   Ns8_Footer_display *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Footer_display (OSCTXT* pctxt, Ns8_Footer_display* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns8_Footer_display_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Footer_sequence_element                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Footer_sequence_element (OSCTXT* pctxt, 
   Ns8_Footer_sequence_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

         if (pvalue->u.h == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_H ((Odf_H*)pvalue->u.h);
         stat = asn1D_Odf_H (pctxt, 
            (Odf_H*)pvalue->u.h, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P ((Odf_P*)pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            (Odf_P*)pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List ((Odf_List*)pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            (Odf_List*)pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.table = rtxMemAllocType (pctxt, Table);

         if (pvalue->u.table == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table ((Table*)pvalue->u.table);
         stat = asn1D_Table (pctxt, 
            (Table*)pvalue->u.table, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.section = rtxMemAllocType (pctxt, Odf_Section);

         if (pvalue->u.section == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Section ((Odf_Section*)pvalue->u.section);
         stat = asn1D_Odf_Section (pctxt, 
            (Odf_Section*)pvalue->u.section, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.table_of_content
             = rtxMemAllocType (pctxt, Odf_Table_of_content);

         if (pvalue->u.table_of_content == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_of_content ((Odf_Table_of_content*)pvalue->u.table_of_content);
         stat = asn1D_Odf_Table_of_content (pctxt, 
            (Odf_Table_of_content*)pvalue->u.table_of_content, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.illustration_index
             = rtxMemAllocType (pctxt, Odf_Illustration_index);

         if (pvalue->u.illustration_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Illustration_index ((Odf_Illustration_index*)pvalue->u.illustration_index);
         stat = asn1D_Odf_Illustration_index (pctxt, 
            (Odf_Illustration_index*)pvalue->u.illustration_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.table_index = rtxMemAllocType (pctxt, Odf_Table_index);

         if (pvalue->u.table_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_index ((Odf_Table_index*)pvalue->u.table_index);
         stat = asn1D_Odf_Table_index (pctxt, 
            (Odf_Table_index*)pvalue->u.table_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.object_index = rtxMemAllocType (pctxt, Odf_Object_index);

         if (pvalue->u.object_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Object_index ((Odf_Object_index*)pvalue->u.object_index);
         stat = asn1D_Odf_Object_index (pctxt, 
            (Odf_Object_index*)pvalue->u.object_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.user_index = rtxMemAllocType (pctxt, Odf_User_index);

         if (pvalue->u.user_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index ((Odf_User_index*)pvalue->u.user_index);
         stat = asn1D_Odf_User_index (pctxt, 
            (Odf_User_index*)pvalue->u.user_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.alphabetical_index
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index);

         if (pvalue->u.alphabetical_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index ((Odf_Alphabetical_index*)pvalue->u.alphabetical_index);
         stat = asn1D_Odf_Alphabetical_index (pctxt, 
            (Odf_Alphabetical_index*)pvalue->u.alphabetical_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.bibliography = rtxMemAllocType (pctxt, Odf_Bibliography);

         if (pvalue->u.bibliography == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bibliography ((Odf_Bibliography*)pvalue->u.bibliography);
         stat = asn1D_Odf_Bibliography (pctxt, 
            (Odf_Bibliography*)pvalue->u.bibliography, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.index_title = rtxMemAllocType (pctxt, Odf_Index_title);

         if (pvalue->u.index_title == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_title ((Odf_Index_title*)pvalue->u.index_title);
         stat = asn1D_Odf_Index_title (pctxt, 
            (Odf_Index_title*)pvalue->u.index_title, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

         if (pvalue->u.change == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change ((Odf_Change*)pvalue->u.change);
         stat = asn1D_Odf_Change (pctxt, 
            (Odf_Change*)pvalue->u.change, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

         if (pvalue->u.change_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_start ((Odf_Change_start*)pvalue->u.change_start);
         stat = asn1D_Odf_Change_start (pctxt, 
            (Odf_Change_start*)pvalue->u.change_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

         if (pvalue->u.change_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_end ((Odf_Change_end*)pvalue->u.change_end);
         stat = asn1D_Odf_Change_end (pctxt, 
            (Odf_Change_end*)pvalue->u.change_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns8_Footer_sequence_element (OSCTXT* pctxt, 
   Ns8_Footer_sequence_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("h"), 1}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 1 },
      {{{OSUTF8("list"), 4}, 0}, 2 },
      {{{OSUTF8("table"), 5}, 0}, 3 },
      {{{OSUTF8("section"), 7}, 0}, 4 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 5 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 6 },
      {{{OSUTF8("table-index"), 11}, 0}, 7 },
      {{{OSUTF8("object-index"), 12}, 0}, 8 },
      {{{OSUTF8("user-index"), 10}, 0}, 9 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 10 },
      {{{OSUTF8("bibliography"), 12}, 0}, 11 },
      {{{OSUTF8("index-title"), 11}, 0}, 12 },
      {{{OSUTF8("change"), 6}, 0}, 13 },
      {{{OSUTF8("change-start"), 12}, 0}, 14 },
      {{{OSUTF8("change-end"), 10}, 0}, 15 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 16, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* h */
      pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

      if (pvalue->u.h == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_H ((Odf_H*)pvalue->u.h);

      stat = XmlDec_Odf_H (pctxt, pvalue->u.h);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P ((Odf_P*)pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List ((Odf_List*)pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* table */
      pvalue->u.table = rtxMemAllocType (pctxt, Table);

      if (pvalue->u.table == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table ((Table*)pvalue->u.table);

      stat = XmlDec_Table (pctxt, pvalue->u.table);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* section */
      pvalue->u.section = rtxMemAllocType (pctxt, Odf_Section);

      if (pvalue->u.section == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Section ((Odf_Section*)pvalue->u.section);

      stat = XmlDec_Odf_Section (pctxt, pvalue->u.section);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* table-of-content */
      pvalue->u.table_of_content
          = rtxMemAllocType (pctxt, Odf_Table_of_content);

      if (pvalue->u.table_of_content == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_of_content ((Odf_Table_of_content*)pvalue->
         u.table_of_content);

      stat = XmlDec_Odf_Table_of_content (pctxt, pvalue->u.table_of_content);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* illustration-index */
      pvalue->u.illustration_index
          = rtxMemAllocType (pctxt, Odf_Illustration_index);

      if (pvalue->u.illustration_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Illustration_index ((Odf_Illustration_index*)pvalue->
         u.illustration_index);

      stat = XmlDec_Odf_Illustration_index (pctxt, pvalue->u.illustration_index
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* table-index */
      pvalue->u.table_index = rtxMemAllocType (pctxt, Odf_Table_index);

      if (pvalue->u.table_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_index ((Odf_Table_index*)pvalue->u.table_index);

      stat = XmlDec_Odf_Table_index (pctxt, pvalue->u.table_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* object-index */
      pvalue->u.object_index = rtxMemAllocType (pctxt, Odf_Object_index);

      if (pvalue->u.object_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Object_index ((Odf_Object_index*)pvalue->u.object_index);

      stat = XmlDec_Odf_Object_index (pctxt, pvalue->u.object_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* user-index */
      pvalue->u.user_index = rtxMemAllocType (pctxt, Odf_User_index);

      if (pvalue->u.user_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index ((Odf_User_index*)pvalue->u.user_index);

      stat = XmlDec_Odf_User_index (pctxt, pvalue->u.user_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* alphabetical-index */
      pvalue->u.alphabetical_index
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index);

      if (pvalue->u.alphabetical_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index ((Odf_Alphabetical_index*)pvalue->
         u.alphabetical_index);

      stat = XmlDec_Odf_Alphabetical_index (pctxt, pvalue->u.alphabetical_index
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* bibliography */
      pvalue->u.bibliography = rtxMemAllocType (pctxt, Odf_Bibliography);

      if (pvalue->u.bibliography == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bibliography ((Odf_Bibliography*)pvalue->u.bibliography);

      stat = XmlDec_Odf_Bibliography (pctxt, pvalue->u.bibliography);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* index-title */
      pvalue->u.index_title = rtxMemAllocType (pctxt, Odf_Index_title);

      if (pvalue->u.index_title == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_title ((Odf_Index_title*)pvalue->u.index_title);

      stat = XmlDec_Odf_Index_title (pctxt, pvalue->u.index_title);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* change */
      pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

      if (pvalue->u.change == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change ((Odf_Change*)pvalue->u.change);

      stat = XmlDec_Odf_Change (pctxt, pvalue->u.change);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* change-start */
      pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

      if (pvalue->u.change_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_start ((Odf_Change_start*)pvalue->u.change_start);

      stat = XmlDec_Odf_Change_start (pctxt, pvalue->u.change_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* change-end */
      pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

      if (pvalue->u.change_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_end ((Odf_Change_end*)pvalue->u.change_end);

      stat = XmlDec_Odf_Change_end (pctxt, pvalue->u.change_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Footer_sequence                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Footer_sequence (OSCTXT* pctxt, 
   Ns8_Footer_sequence *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode variable_decls */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->variable_decls
                = rtxMemAllocType (pctxt, Odf_Variable_decls);

            if (pvalue->variable_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->variable_decls);
            asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->variable_decls);

            stat = asn1D_Odf_Variable_decls (pctxt, 
               (Odf_Variable_decls*)pvalue->variable_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.variable_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode sequence_decls */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->sequence_decls
                = rtxMemAllocType (pctxt, Odf_Sequence_decls);

            if (pvalue->sequence_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->sequence_decls);
            asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->sequence_decls);

            stat = asn1D_Odf_Sequence_decls (pctxt, 
               (Odf_Sequence_decls*)pvalue->sequence_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sequence_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode user_field_decls */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->user_field_decls
                = rtxMemAllocType (pctxt, Odf_User_field_decls);

            if (pvalue->user_field_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->user_field_decls);
            asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->user_field_decls);

            stat = asn1D_Odf_User_field_decls (pctxt, 
               (Odf_User_field_decls*)pvalue->user_field_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.user_field_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode dde_connection_decls */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->dde_connection_decls
                = rtxMemAllocType (pctxt, Odf_Dde_connection_decls);

            if (pvalue->dde_connection_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->dde_connection_decls);
            asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->dde_connection_decls);

            stat = asn1D_Odf_Dde_connection_decls (pctxt, 
               (Odf_Dde_connection_decls*)pvalue->dde_connection_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dde_connection_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode alphabetical_index_auto_mark_file */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->alphabetical_index_auto_mark_file
                = rtxMemAllocType (pctxt, Odf_Alphabetical_index_auto_mark_file);

            if (pvalue->alphabetical_index_auto_mark_file == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Alphabetical_index_auto_mark_file ((Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file);
            asn1Init_Odf_Alphabetical_index_auto_mark_file ((Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file);

            stat = asn1D_Odf_Alphabetical_index_auto_mark_file (pctxt, 
               (Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.alphabetical_index_auto_mark_filePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns8_Footer_sequence_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns8_Footer_sequence_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns8_Footer_sequence_element (pdata2);

                  stat = asn1D_Ns8_Footer_sequence_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Footer_sequence (OSCTXT* pctxt, Ns8_Footer_sequence* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("variable-decls"), 14}, 0}, 0 },
      {{{OSUTF8("sequence-decls"), 14}, 0}, 1 },
      {{{OSUTF8("user-field-decls"), 16}, 0}, 2 },
      {{{OSUTF8("dde-connection-decls"), 20}, 0}, 3 },
      {{{OSUTF8("alphabetical-index-auto-mark-file"), 33}, 0}, 4 },
      {{{OSUTF8("h"), 1}, 0}, 5 },
      {{{OSUTF8("p"), 1}, 0}, 5 },
      {{{OSUTF8("list"), 4}, 0}, 5 },
      {{{OSUTF8("table"), 5}, 0}, 5 },
      {{{OSUTF8("section"), 7}, 0}, 5 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 5 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 5 },
      {{{OSUTF8("table-index"), 11}, 0}, 5 },
      {{{OSUTF8("object-index"), 12}, 0}, 5 },
      {{{OSUTF8("user-index"), 10}, 0}, 5 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 5 },
      {{{OSUTF8("bibliography"), 12}, 0}, 5 },
      {{{OSUTF8("index-title"), 11}, 0}, 5 },
      {{{OSUTF8("change"), 6}, 0}, 5 },
      {{{OSUTF8("change-start"), 12}, 0}, 5 },
      {{{OSUTF8("change-end"), 10}, 0}, 5 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 21, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 6; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* variable-decls */
         pvalue->variable_decls = rtxMemAllocType (pctxt, Odf_Variable_decls);

         if (pvalue->variable_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->
            variable_decls);

         stat = XmlDec_Odf_Variable_decls (pctxt, pvalue->variable_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.variable_declsPresent = TRUE;
         break;
      }
      case 1: { /* sequence-decls */
         pvalue->sequence_decls = rtxMemAllocType (pctxt, Odf_Sequence_decls);

         if (pvalue->sequence_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->
            sequence_decls);

         stat = XmlDec_Odf_Sequence_decls (pctxt, pvalue->sequence_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.sequence_declsPresent = TRUE;
         break;
      }
      case 2: { /* user-field-decls */
         pvalue->user_field_decls
             = rtxMemAllocType (pctxt, Odf_User_field_decls);

         if (pvalue->user_field_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->
            user_field_decls);

         stat = XmlDec_Odf_User_field_decls (pctxt, pvalue->user_field_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.user_field_declsPresent = TRUE;
         break;
      }
      case 3: { /* dde-connection-decls */
         pvalue->dde_connection_decls
             = rtxMemAllocType (pctxt, Odf_Dde_connection_decls);

         if (pvalue->dde_connection_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->
            dde_connection_decls);

         stat = XmlDec_Odf_Dde_connection_decls (pctxt, pvalue->
            dde_connection_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dde_connection_declsPresent = TRUE;
         break;
      }
      case 4: { /* alphabetical-index-auto-mark-file */
         pvalue->alphabetical_index_auto_mark_file
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index_auto_mark_file);

         if (pvalue->alphabetical_index_auto_mark_file == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index_auto_mark_file (
            (Odf_Alphabetical_index_auto_mark_file*)pvalue->
            alphabetical_index_auto_mark_file);

         stat = XmlDec_Odf_Alphabetical_index_auto_mark_file (pctxt, pvalue->
            alphabetical_index_auto_mark_file);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.alphabetical_index_auto_mark_filePresent = TRUE;
         break;
      }
      case 5: {
         Ns8_Footer_sequence_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns8_Footer_sequence_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Footer_sequence_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns8_Footer_sequence_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 5, 16, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 5);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Footer_sequence_1                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Footer_sequence_1 (OSCTXT* pctxt, 
   Ns8_Footer_sequence_1 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode region_left */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Region_left (pctxt, 
               &pvalue->region_left, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.region_leftPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode region_center */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Region_center (pctxt, 
               &pvalue->region_center, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.region_centerPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode region_right */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Region_right (pctxt, 
               &pvalue->region_right, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.region_rightPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Footer_sequence_1 (OSCTXT* pctxt, Ns8_Footer_sequence_1* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("region-left"), 11}, 0}, 0 },
      {{{OSUTF8("region-center"), 13}, 0}, 1 },
      {{{OSUTF8("region-right"), 12}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* region-left */
         stat = XmlDec_Ns8_Region_left (pctxt, &pvalue->region_left);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.region_leftPresent = TRUE;
         break;
      }
      case 1: { /* region-center */
         stat = XmlDec_Ns8_Region_center (pctxt, &pvalue->region_center);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.region_centerPresent = TRUE;
         break;
      }
      case 2: { /* region-right */
         stat = XmlDec_Ns8_Region_right (pctxt, &pvalue->region_right);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.region_rightPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Footer_choice                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Footer_choice (OSCTXT* pctxt, Ns8_Footer_choice *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.sequence = rtxMemAllocType (pctxt, Ns8_Footer_sequence);

         if (pvalue->u.sequence == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns8_Footer_sequence (pvalue->u.sequence);
         stat = asn1D_Ns8_Footer_sequence (pctxt, 
            pvalue->u.sequence, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.sequence_1
             = rtxMemAllocType (pctxt, Ns8_Footer_sequence_1);

         if (pvalue->u.sequence_1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns8_Footer_sequence_1 (pvalue->u.sequence_1);
         stat = asn1D_Ns8_Footer_sequence_1 (pctxt, 
            pvalue->u.sequence_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns8_Footer_choice (OSCTXT* pctxt, Ns8_Footer_choice* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("variable-decls"), 14}, 0}, 0 },
      {{{OSUTF8("sequence-decls"), 14}, 0}, 0 },
      {{{OSUTF8("user-field-decls"), 16}, 0}, 0 },
      {{{OSUTF8("dde-connection-decls"), 20}, 0}, 0 },
      {{{OSUTF8("alphabetical-index-auto-mark-file"), 33}, 0}, 0 },
      {{{OSUTF8("h"), 1}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("list"), 4}, 0}, 0 },
      {{{OSUTF8("table"), 5}, 0}, 0 },
      {{{OSUTF8("section"), 7}, 0}, 0 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 0 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 0 },
      {{{OSUTF8("table-index"), 11}, 0}, 0 },
      {{{OSUTF8("object-index"), 12}, 0}, 0 },
      {{{OSUTF8("user-index"), 10}, 0}, 0 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 0 },
      {{{OSUTF8("bibliography"), 12}, 0}, 0 },
      {{{OSUTF8("index-title"), 11}, 0}, 0 },
      {{{OSUTF8("change"), 6}, 0}, 0 },
      {{{OSUTF8("change-start"), 12}, 0}, 0 },
      {{{OSUTF8("change-end"), 10}, 0}, 0 },
      {{{OSUTF8("region-left"), 11}, 0}, 1 },
      {{{OSUTF8("region-center"), 13}, 0}, 1 },
      {{{OSUTF8("region-right"), 12}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 24, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /*  */
      pvalue->u.sequence = rtxMemAllocType (pctxt, Ns8_Footer_sequence);

      if (pvalue->u.sequence == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns8_Footer_sequence (pvalue->u.sequence);

      stat = XmlDec_Ns8_Footer_sequence (pctxt, pvalue->u.sequence);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /*  */
      pvalue->u.sequence_1 = rtxMemAllocType (pctxt, Ns8_Footer_sequence_1);

      if (pvalue->u.sequence_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns8_Footer_sequence_1 (pvalue->u.sequence_1);

      stat = XmlDec_Ns8_Footer_sequence_1 (pctxt, pvalue->u.sequence_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Footer                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Footer (OSCTXT* pctxt, Ns8_Footer *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode display */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Footer_display (pctxt, 
               &pvalue->display, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.displayPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Footer_choice (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Footer (OSCTXT* pctxt, Ns8_Footer* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("display"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* display */
            stat = XmlDec_Ns8_Footer_display (pctxt, &pvalue->display);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.displayPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns8_Footer");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns8_Footer");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("variable-decls"), 14}, 0}, 0 },
      {{{OSUTF8("sequence-decls"), 14}, 0}, 0 },
      {{{OSUTF8("user-field-decls"), 16}, 0}, 0 },
      {{{OSUTF8("dde-connection-decls"), 20}, 0}, 0 },
      {{{OSUTF8("alphabetical-index-auto-mark-file"), 33}, 0}, 0 },
      {{{OSUTF8("h"), 1}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("list"), 4}, 0}, 0 },
      {{{OSUTF8("table"), 5}, 0}, 0 },
      {{{OSUTF8("section"), 7}, 0}, 0 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 0 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 0 },
      {{{OSUTF8("table-index"), 11}, 0}, 0 },
      {{{OSUTF8("object-index"), 12}, 0}, 0 },
      {{{OSUTF8("user-index"), 10}, 0}, 0 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 0 },
      {{{OSUTF8("bibliography"), 12}, 0}, 0 },
      {{{OSUTF8("index-title"), 11}, 0}, 0 },
      {{{OSUTF8("change"), 6}, 0}, 0 },
      {{{OSUTF8("change-start"), 12}, 0}, 0 },
      {{{OSUTF8("change-end"), 10}, 0}, 0 },
      {{{OSUTF8("region-left"), 11}, 0}, 0 },
      {{{OSUTF8("region-center"), 13}, 0}, 0 },
      {{{OSUTF8("region-right"), 12}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 24, -1}, {24, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_Ns8_Footer_choice (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Footer_left_display                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Footer_left_display (OSCTXT* pctxt, 
   Ns8_Footer_left_display *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Footer_left_display (OSCTXT* pctxt, 
   Ns8_Footer_left_display* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns8_Footer_left_display_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Footer_left_sequence_element                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Footer_left_sequence_element (OSCTXT* pctxt, 
   Ns8_Footer_left_sequence_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

         if (pvalue->u.h == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_H ((Odf_H*)pvalue->u.h);
         stat = asn1D_Odf_H (pctxt, 
            (Odf_H*)pvalue->u.h, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P ((Odf_P*)pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            (Odf_P*)pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List ((Odf_List*)pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            (Odf_List*)pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.table = rtxMemAllocType (pctxt, Table);

         if (pvalue->u.table == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table ((Table*)pvalue->u.table);
         stat = asn1D_Table (pctxt, 
            (Table*)pvalue->u.table, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.section = rtxMemAllocType (pctxt, Odf_Section);

         if (pvalue->u.section == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Section ((Odf_Section*)pvalue->u.section);
         stat = asn1D_Odf_Section (pctxt, 
            (Odf_Section*)pvalue->u.section, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.table_of_content
             = rtxMemAllocType (pctxt, Odf_Table_of_content);

         if (pvalue->u.table_of_content == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_of_content ((Odf_Table_of_content*)pvalue->u.table_of_content);
         stat = asn1D_Odf_Table_of_content (pctxt, 
            (Odf_Table_of_content*)pvalue->u.table_of_content, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.illustration_index
             = rtxMemAllocType (pctxt, Odf_Illustration_index);

         if (pvalue->u.illustration_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Illustration_index ((Odf_Illustration_index*)pvalue->u.illustration_index);
         stat = asn1D_Odf_Illustration_index (pctxt, 
            (Odf_Illustration_index*)pvalue->u.illustration_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.table_index = rtxMemAllocType (pctxt, Odf_Table_index);

         if (pvalue->u.table_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_index ((Odf_Table_index*)pvalue->u.table_index);
         stat = asn1D_Odf_Table_index (pctxt, 
            (Odf_Table_index*)pvalue->u.table_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.object_index = rtxMemAllocType (pctxt, Odf_Object_index);

         if (pvalue->u.object_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Object_index ((Odf_Object_index*)pvalue->u.object_index);
         stat = asn1D_Odf_Object_index (pctxt, 
            (Odf_Object_index*)pvalue->u.object_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.user_index = rtxMemAllocType (pctxt, Odf_User_index);

         if (pvalue->u.user_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index ((Odf_User_index*)pvalue->u.user_index);
         stat = asn1D_Odf_User_index (pctxt, 
            (Odf_User_index*)pvalue->u.user_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.alphabetical_index
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index);

         if (pvalue->u.alphabetical_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index ((Odf_Alphabetical_index*)pvalue->u.alphabetical_index);
         stat = asn1D_Odf_Alphabetical_index (pctxt, 
            (Odf_Alphabetical_index*)pvalue->u.alphabetical_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.bibliography = rtxMemAllocType (pctxt, Odf_Bibliography);

         if (pvalue->u.bibliography == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bibliography ((Odf_Bibliography*)pvalue->u.bibliography);
         stat = asn1D_Odf_Bibliography (pctxt, 
            (Odf_Bibliography*)pvalue->u.bibliography, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.index_title = rtxMemAllocType (pctxt, Odf_Index_title);

         if (pvalue->u.index_title == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Index_title ((Odf_Index_title*)pvalue->u.index_title);
         stat = asn1D_Odf_Index_title (pctxt, 
            (Odf_Index_title*)pvalue->u.index_title, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

         if (pvalue->u.change == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change ((Odf_Change*)pvalue->u.change);
         stat = asn1D_Odf_Change (pctxt, 
            (Odf_Change*)pvalue->u.change, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

         if (pvalue->u.change_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_start ((Odf_Change_start*)pvalue->u.change_start);
         stat = asn1D_Odf_Change_start (pctxt, 
            (Odf_Change_start*)pvalue->u.change_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

         if (pvalue->u.change_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_end ((Odf_Change_end*)pvalue->u.change_end);
         stat = asn1D_Odf_Change_end (pctxt, 
            (Odf_Change_end*)pvalue->u.change_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns8_Footer_left_sequence_element (OSCTXT* pctxt, 
   Ns8_Footer_left_sequence_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("h"), 1}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 1 },
      {{{OSUTF8("list"), 4}, 0}, 2 },
      {{{OSUTF8("table"), 5}, 0}, 3 },
      {{{OSUTF8("section"), 7}, 0}, 4 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 5 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 6 },
      {{{OSUTF8("table-index"), 11}, 0}, 7 },
      {{{OSUTF8("object-index"), 12}, 0}, 8 },
      {{{OSUTF8("user-index"), 10}, 0}, 9 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 10 },
      {{{OSUTF8("bibliography"), 12}, 0}, 11 },
      {{{OSUTF8("index-title"), 11}, 0}, 12 },
      {{{OSUTF8("change"), 6}, 0}, 13 },
      {{{OSUTF8("change-start"), 12}, 0}, 14 },
      {{{OSUTF8("change-end"), 10}, 0}, 15 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 16, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* h */
      pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

      if (pvalue->u.h == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_H ((Odf_H*)pvalue->u.h);

      stat = XmlDec_Odf_H (pctxt, pvalue->u.h);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P ((Odf_P*)pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List ((Odf_List*)pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* table */
      pvalue->u.table = rtxMemAllocType (pctxt, Table);

      if (pvalue->u.table == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table ((Table*)pvalue->u.table);

      stat = XmlDec_Table (pctxt, pvalue->u.table);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* section */
      pvalue->u.section = rtxMemAllocType (pctxt, Odf_Section);

      if (pvalue->u.section == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Section ((Odf_Section*)pvalue->u.section);

      stat = XmlDec_Odf_Section (pctxt, pvalue->u.section);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* table-of-content */
      pvalue->u.table_of_content
          = rtxMemAllocType (pctxt, Odf_Table_of_content);

      if (pvalue->u.table_of_content == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_of_content ((Odf_Table_of_content*)pvalue->
         u.table_of_content);

      stat = XmlDec_Odf_Table_of_content (pctxt, pvalue->u.table_of_content);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* illustration-index */
      pvalue->u.illustration_index
          = rtxMemAllocType (pctxt, Odf_Illustration_index);

      if (pvalue->u.illustration_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Illustration_index ((Odf_Illustration_index*)pvalue->
         u.illustration_index);

      stat = XmlDec_Odf_Illustration_index (pctxt, pvalue->u.illustration_index
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* table-index */
      pvalue->u.table_index = rtxMemAllocType (pctxt, Odf_Table_index);

      if (pvalue->u.table_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_index ((Odf_Table_index*)pvalue->u.table_index);

      stat = XmlDec_Odf_Table_index (pctxt, pvalue->u.table_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* object-index */
      pvalue->u.object_index = rtxMemAllocType (pctxt, Odf_Object_index);

      if (pvalue->u.object_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Object_index ((Odf_Object_index*)pvalue->u.object_index);

      stat = XmlDec_Odf_Object_index (pctxt, pvalue->u.object_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* user-index */
      pvalue->u.user_index = rtxMemAllocType (pctxt, Odf_User_index);

      if (pvalue->u.user_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index ((Odf_User_index*)pvalue->u.user_index);

      stat = XmlDec_Odf_User_index (pctxt, pvalue->u.user_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* alphabetical-index */
      pvalue->u.alphabetical_index
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index);

      if (pvalue->u.alphabetical_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index ((Odf_Alphabetical_index*)pvalue->
         u.alphabetical_index);

      stat = XmlDec_Odf_Alphabetical_index (pctxt, pvalue->u.alphabetical_index
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* bibliography */
      pvalue->u.bibliography = rtxMemAllocType (pctxt, Odf_Bibliography);

      if (pvalue->u.bibliography == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bibliography ((Odf_Bibliography*)pvalue->u.bibliography);

      stat = XmlDec_Odf_Bibliography (pctxt, pvalue->u.bibliography);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* index-title */
      pvalue->u.index_title = rtxMemAllocType (pctxt, Odf_Index_title);

      if (pvalue->u.index_title == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Index_title ((Odf_Index_title*)pvalue->u.index_title);

      stat = XmlDec_Odf_Index_title (pctxt, pvalue->u.index_title);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* change */
      pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

      if (pvalue->u.change == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change ((Odf_Change*)pvalue->u.change);

      stat = XmlDec_Odf_Change (pctxt, pvalue->u.change);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* change-start */
      pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

      if (pvalue->u.change_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_start ((Odf_Change_start*)pvalue->u.change_start);

      stat = XmlDec_Odf_Change_start (pctxt, pvalue->u.change_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* change-end */
      pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

      if (pvalue->u.change_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_end ((Odf_Change_end*)pvalue->u.change_end);

      stat = XmlDec_Odf_Change_end (pctxt, pvalue->u.change_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Footer_left_sequence                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Footer_left_sequence (OSCTXT* pctxt, 
   Ns8_Footer_left_sequence *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode variable_decls */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->variable_decls
                = rtxMemAllocType (pctxt, Odf_Variable_decls);

            if (pvalue->variable_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->variable_decls);
            asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->variable_decls);

            stat = asn1D_Odf_Variable_decls (pctxt, 
               (Odf_Variable_decls*)pvalue->variable_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.variable_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode sequence_decls */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->sequence_decls
                = rtxMemAllocType (pctxt, Odf_Sequence_decls);

            if (pvalue->sequence_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->sequence_decls);
            asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->sequence_decls);

            stat = asn1D_Odf_Sequence_decls (pctxt, 
               (Odf_Sequence_decls*)pvalue->sequence_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sequence_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode user_field_decls */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->user_field_decls
                = rtxMemAllocType (pctxt, Odf_User_field_decls);

            if (pvalue->user_field_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->user_field_decls);
            asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->user_field_decls);

            stat = asn1D_Odf_User_field_decls (pctxt, 
               (Odf_User_field_decls*)pvalue->user_field_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.user_field_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode dde_connection_decls */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->dde_connection_decls
                = rtxMemAllocType (pctxt, Odf_Dde_connection_decls);

            if (pvalue->dde_connection_decls == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->dde_connection_decls);
            asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->dde_connection_decls);

            stat = asn1D_Odf_Dde_connection_decls (pctxt, 
               (Odf_Dde_connection_decls*)pvalue->dde_connection_decls, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dde_connection_declsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode alphabetical_index_auto_mark_file */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->alphabetical_index_auto_mark_file
                = rtxMemAllocType (pctxt, Odf_Alphabetical_index_auto_mark_file);

            if (pvalue->alphabetical_index_auto_mark_file == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_Alphabetical_index_auto_mark_file ((Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file);
            asn1Init_Odf_Alphabetical_index_auto_mark_file ((Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file);

            stat = asn1D_Odf_Alphabetical_index_auto_mark_file (pctxt, 
               (Odf_Alphabetical_index_auto_mark_file*)pvalue->alphabetical_index_auto_mark_file, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.alphabetical_index_auto_mark_filePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns8_Footer_left_sequence_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns8_Footer_left_sequence_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns8_Footer_left_sequence_element (pdata2);

                  stat = asn1D_Ns8_Footer_left_sequence_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Footer_left_sequence (OSCTXT* pctxt, 
   Ns8_Footer_left_sequence* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("variable-decls"), 14}, 0}, 0 },
      {{{OSUTF8("sequence-decls"), 14}, 0}, 1 },
      {{{OSUTF8("user-field-decls"), 16}, 0}, 2 },
      {{{OSUTF8("dde-connection-decls"), 20}, 0}, 3 },
      {{{OSUTF8("alphabetical-index-auto-mark-file"), 33}, 0}, 4 },
      {{{OSUTF8("h"), 1}, 0}, 5 },
      {{{OSUTF8("p"), 1}, 0}, 5 },
      {{{OSUTF8("list"), 4}, 0}, 5 },
      {{{OSUTF8("table"), 5}, 0}, 5 },
      {{{OSUTF8("section"), 7}, 0}, 5 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 5 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 5 },
      {{{OSUTF8("table-index"), 11}, 0}, 5 },
      {{{OSUTF8("object-index"), 12}, 0}, 5 },
      {{{OSUTF8("user-index"), 10}, 0}, 5 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 5 },
      {{{OSUTF8("bibliography"), 12}, 0}, 5 },
      {{{OSUTF8("index-title"), 11}, 0}, 5 },
      {{{OSUTF8("change"), 6}, 0}, 5 },
      {{{OSUTF8("change-start"), 12}, 0}, 5 },
      {{{OSUTF8("change-end"), 10}, 0}, 5 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 21, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 6; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* variable-decls */
         pvalue->variable_decls = rtxMemAllocType (pctxt, Odf_Variable_decls);

         if (pvalue->variable_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Variable_decls ((Odf_Variable_decls*)pvalue->
            variable_decls);

         stat = XmlDec_Odf_Variable_decls (pctxt, pvalue->variable_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.variable_declsPresent = TRUE;
         break;
      }
      case 1: { /* sequence-decls */
         pvalue->sequence_decls = rtxMemAllocType (pctxt, Odf_Sequence_decls);

         if (pvalue->sequence_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Sequence_decls ((Odf_Sequence_decls*)pvalue->
            sequence_decls);

         stat = XmlDec_Odf_Sequence_decls (pctxt, pvalue->sequence_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.sequence_declsPresent = TRUE;
         break;
      }
      case 2: { /* user-field-decls */
         pvalue->user_field_decls
             = rtxMemAllocType (pctxt, Odf_User_field_decls);

         if (pvalue->user_field_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_field_decls ((Odf_User_field_decls*)pvalue->
            user_field_decls);

         stat = XmlDec_Odf_User_field_decls (pctxt, pvalue->user_field_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.user_field_declsPresent = TRUE;
         break;
      }
      case 3: { /* dde-connection-decls */
         pvalue->dde_connection_decls
             = rtxMemAllocType (pctxt, Odf_Dde_connection_decls);

         if (pvalue->dde_connection_decls == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Dde_connection_decls ((Odf_Dde_connection_decls*)pvalue->
            dde_connection_decls);

         stat = XmlDec_Odf_Dde_connection_decls (pctxt, pvalue->
            dde_connection_decls);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dde_connection_declsPresent = TRUE;
         break;
      }
      case 4: { /* alphabetical-index-auto-mark-file */
         pvalue->alphabetical_index_auto_mark_file
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index_auto_mark_file);

         if (pvalue->alphabetical_index_auto_mark_file == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index_auto_mark_file (
            (Odf_Alphabetical_index_auto_mark_file*)pvalue->
            alphabetical_index_auto_mark_file);

         stat = XmlDec_Odf_Alphabetical_index_auto_mark_file (pctxt, pvalue->
            alphabetical_index_auto_mark_file);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.alphabetical_index_auto_mark_filePresent = TRUE;
         break;
      }
      case 5: {
         Ns8_Footer_left_sequence_element* pdata1;
         do {
            pdata1
                = rtxMemAllocType (pctxt, Ns8_Footer_left_sequence_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Footer_left_sequence_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns8_Footer_left_sequence_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 5, 16, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 5);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Footer_left_sequence_1                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Footer_left_sequence_1 (OSCTXT* pctxt, 
   Ns8_Footer_left_sequence_1 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode region_left */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Region_left (pctxt, 
               &pvalue->region_left, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.region_leftPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode region_center */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Region_center (pctxt, 
               &pvalue->region_center, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.region_centerPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode region_right */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Region_right (pctxt, 
               &pvalue->region_right, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.region_rightPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Footer_left_sequence_1 (OSCTXT* pctxt, 
   Ns8_Footer_left_sequence_1* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("region-left"), 11}, 0}, 0 },
      {{{OSUTF8("region-center"), 13}, 0}, 1 },
      {{{OSUTF8("region-right"), 12}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* region-left */
         stat = XmlDec_Ns8_Region_left (pctxt, &pvalue->region_left);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.region_leftPresent = TRUE;
         break;
      }
      case 1: { /* region-center */
         stat = XmlDec_Ns8_Region_center (pctxt, &pvalue->region_center);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.region_centerPresent = TRUE;
         break;
      }
      case 2: { /* region-right */
         stat = XmlDec_Ns8_Region_right (pctxt, &pvalue->region_right);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.region_rightPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Footer_left_choice                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Footer_left_choice (OSCTXT* pctxt, 
   Ns8_Footer_left_choice *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.sequence
             = rtxMemAllocType (pctxt, Ns8_Footer_left_sequence);

         if (pvalue->u.sequence == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns8_Footer_left_sequence (pvalue->u.sequence);
         stat = asn1D_Ns8_Footer_left_sequence (pctxt, 
            pvalue->u.sequence, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.sequence_1
             = rtxMemAllocType (pctxt, Ns8_Footer_left_sequence_1);

         if (pvalue->u.sequence_1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns8_Footer_left_sequence_1 (pvalue->u.sequence_1);
         stat = asn1D_Ns8_Footer_left_sequence_1 (pctxt, 
            pvalue->u.sequence_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns8_Footer_left_choice (OSCTXT* pctxt, 
   Ns8_Footer_left_choice* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("variable-decls"), 14}, 0}, 0 },
      {{{OSUTF8("sequence-decls"), 14}, 0}, 0 },
      {{{OSUTF8("user-field-decls"), 16}, 0}, 0 },
      {{{OSUTF8("dde-connection-decls"), 20}, 0}, 0 },
      {{{OSUTF8("alphabetical-index-auto-mark-file"), 33}, 0}, 0 },
      {{{OSUTF8("h"), 1}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("list"), 4}, 0}, 0 },
      {{{OSUTF8("table"), 5}, 0}, 0 },
      {{{OSUTF8("section"), 7}, 0}, 0 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 0 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 0 },
      {{{OSUTF8("table-index"), 11}, 0}, 0 },
      {{{OSUTF8("object-index"), 12}, 0}, 0 },
      {{{OSUTF8("user-index"), 10}, 0}, 0 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 0 },
      {{{OSUTF8("bibliography"), 12}, 0}, 0 },
      {{{OSUTF8("index-title"), 11}, 0}, 0 },
      {{{OSUTF8("change"), 6}, 0}, 0 },
      {{{OSUTF8("change-start"), 12}, 0}, 0 },
      {{{OSUTF8("change-end"), 10}, 0}, 0 },
      {{{OSUTF8("region-left"), 11}, 0}, 1 },
      {{{OSUTF8("region-center"), 13}, 0}, 1 },
      {{{OSUTF8("region-right"), 12}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 24, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /*  */
      pvalue->u.sequence = rtxMemAllocType (pctxt, Ns8_Footer_left_sequence);

      if (pvalue->u.sequence == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns8_Footer_left_sequence (pvalue->u.sequence);

      stat = XmlDec_Ns8_Footer_left_sequence (pctxt, pvalue->u.sequence);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /*  */
      pvalue->u.sequence_1
          = rtxMemAllocType (pctxt, Ns8_Footer_left_sequence_1);

      if (pvalue->u.sequence_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns8_Footer_left_sequence_1 (pvalue->u.sequence_1);

      stat = XmlDec_Ns8_Footer_left_sequence_1 (pctxt, pvalue->u.sequence_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Footer_left                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Footer_left (OSCTXT* pctxt, Ns8_Footer_left *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode display */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Footer_left_display (pctxt, 
               &pvalue->display, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.displayPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Footer_left_choice (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Footer_left (OSCTXT* pctxt, Ns8_Footer_left* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("display"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* display */
            stat = XmlDec_Ns8_Footer_left_display (pctxt, &pvalue->display);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.displayPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns8_Footer_left");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns8_Footer_left");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("variable-decls"), 14}, 0}, 0 },
      {{{OSUTF8("sequence-decls"), 14}, 0}, 0 },
      {{{OSUTF8("user-field-decls"), 16}, 0}, 0 },
      {{{OSUTF8("dde-connection-decls"), 20}, 0}, 0 },
      {{{OSUTF8("alphabetical-index-auto-mark-file"), 33}, 0}, 0 },
      {{{OSUTF8("h"), 1}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("list"), 4}, 0}, 0 },
      {{{OSUTF8("table"), 5}, 0}, 0 },
      {{{OSUTF8("section"), 7}, 0}, 0 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 0 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 0 },
      {{{OSUTF8("table-index"), 11}, 0}, 0 },
      {{{OSUTF8("object-index"), 12}, 0}, 0 },
      {{{OSUTF8("user-index"), 10}, 0}, 0 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 0 },
      {{{OSUTF8("bibliography"), 12}, 0}, 0 },
      {{{OSUTF8("index-title"), 11}, 0}, 0 },
      {{{OSUTF8("change"), 6}, 0}, 0 },
      {{{OSUTF8("change-start"), 12}, 0}, 0 },
      {{{OSUTF8("change-end"), 10}, 0}, 0 },
      {{{OSUTF8("region-left"), 11}, 0}, 0 },
      {{{OSUTF8("region-center"), 13}, 0}, 0 },
      {{{OSUTF8("region-right"), 12}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 24, -1}, {24, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_Ns8_Footer_left_choice (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Master_page_sequence_1                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Master_page_sequence_1 (OSCTXT* pctxt, 
   Ns8_Master_page_sequence_1 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode footer */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Footer (pctxt, 
               &pvalue->footer, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode footer_left */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Footer_left (pctxt, 
               &pvalue->footer_left, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.footer_leftPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Master_page_sequence_1 (OSCTXT* pctxt, 
   Ns8_Master_page_sequence_1* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("footer"), 6}, 0}, 0 },
      {{{OSUTF8("footer-left"), 11}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* footer */
         stat = XmlDec_Ns8_Footer (pctxt, &pvalue->footer);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* footer-left */
         stat = XmlDec_Ns8_Footer_left (pctxt, &pvalue->footer_left);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.footer_leftPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Master_page_element                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Master_page_element (OSCTXT* pctxt, 
   Ns8_Master_page_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

         if (pvalue->u.rect == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);
         stat = asn1D_Ns3_Rect (pctxt, 
            (Ns3_Rect*)pvalue->u.rect, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

         if (pvalue->u.line == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);
         stat = asn1D_Ns3_Line (pctxt, 
            (Ns3_Line*)pvalue->u.line, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

         if (pvalue->u.polyline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);
         stat = asn1D_Ns3_Polyline (pctxt, 
            (Ns3_Polyline*)pvalue->u.polyline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

         if (pvalue->u.polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);
         stat = asn1D_Ns3_Polygon (pctxt, 
            (Ns3_Polygon*)pvalue->u.polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.regular_polygon
             = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

         if (pvalue->u.regular_polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->u.regular_polygon);
         stat = asn1D_Ns3_Regular_polygon (pctxt, 
            (Ns3_Regular_polygon*)pvalue->u.regular_polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

         if (pvalue->u.path == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);
         stat = asn1D_Ns3_Path (pctxt, 
            (Ns3_Path*)pvalue->u.path, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

         if (pvalue->u.circle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);
         stat = asn1D_Ns3_Circle (pctxt, 
            (Ns3_Circle*)pvalue->u.circle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

         if (pvalue->u.ellipse == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);
         stat = asn1D_Ns3_Ellipse (pctxt, 
            (Ns3_Ellipse*)pvalue->u.ellipse, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

         if (pvalue->u.g == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);
         stat = asn1D_Ns3_G (pctxt, 
            (Ns3_G*)pvalue->u.g, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.page_thumbnail
             = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

         if (pvalue->u.page_thumbnail == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->u.page_thumbnail);
         stat = asn1D_Ns3_Page_thumbnail (pctxt, 
            (Ns3_Page_thumbnail*)pvalue->u.page_thumbnail, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

         if (pvalue->u.frame == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);
         stat = asn1D_Ns3_Frame (pctxt, 
            (Ns3_Frame*)pvalue->u.frame, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

         if (pvalue->u.measure == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);
         stat = asn1D_Ns3_Measure (pctxt, 
            (Ns3_Measure*)pvalue->u.measure, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

         if (pvalue->u.caption == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);
         stat = asn1D_Ns3_Caption (pctxt, 
            (Ns3_Caption*)pvalue->u.caption, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

         if (pvalue->u.connector == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);
         stat = asn1D_Ns3_Connector (pctxt, 
            (Ns3_Connector*)pvalue->u.connector, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

         if (pvalue->u.control == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);
         stat = asn1D_Ns3_Control (pctxt, 
            (Ns3_Control*)pvalue->u.control, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

         if (pvalue->u.scene == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);
         stat = asn1D_Ns7_Scene (pctxt, 
            (Ns7_Scene*)pvalue->u.scene, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

         if (pvalue->u.custom_shape == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);
         stat = asn1D_Ns3_Custom_shape (pctxt, 
            (Ns3_Custom_shape*)pvalue->u.custom_shape, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns8_Master_page_element (OSCTXT* pctxt, 
   Ns8_Master_page_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("rect"), 4}, 0}, 0 },
      {{{OSUTF8("line"), 4}, 0}, 1 },
      {{{OSUTF8("polyline"), 8}, 0}, 2 },
      {{{OSUTF8("polygon"), 7}, 0}, 3 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 4 },
      {{{OSUTF8("path"), 4}, 0}, 5 },
      {{{OSUTF8("circle"), 6}, 0}, 6 },
      {{{OSUTF8("ellipse"), 7}, 0}, 7 },
      {{{OSUTF8("g"), 1}, 0}, 8 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 9 },
      {{{OSUTF8("frame"), 5}, 0}, 10 },
      {{{OSUTF8("measure"), 7}, 0}, 11 },
      {{{OSUTF8("caption"), 7}, 0}, 12 },
      {{{OSUTF8("connector"), 9}, 0}, 13 },
      {{{OSUTF8("control"), 7}, 0}, 14 },
      {{{OSUTF8("scene"), 5}, 0}, 15 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 16 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 17, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* rect */
      pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

      if (pvalue->u.rect == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);

      stat = XmlDec_Ns3_Rect (pctxt, pvalue->u.rect);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* line */
      pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

      if (pvalue->u.line == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);

      stat = XmlDec_Ns3_Line (pctxt, pvalue->u.line);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* polyline */
      pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

      if (pvalue->u.polyline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);

      stat = XmlDec_Ns3_Polyline (pctxt, pvalue->u.polyline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* polygon */
      pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

      if (pvalue->u.polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);

      stat = XmlDec_Ns3_Polygon (pctxt, pvalue->u.polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* regular-polygon */
      pvalue->u.regular_polygon
          = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

      if (pvalue->u.regular_polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->
         u.regular_polygon);

      stat = XmlDec_Ns3_Regular_polygon (pctxt, pvalue->u.regular_polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* path */
      pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

      if (pvalue->u.path == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);

      stat = XmlDec_Ns3_Path (pctxt, pvalue->u.path);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* circle */
      pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

      if (pvalue->u.circle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);

      stat = XmlDec_Ns3_Circle (pctxt, pvalue->u.circle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* ellipse */
      pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

      if (pvalue->u.ellipse == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);

      stat = XmlDec_Ns3_Ellipse (pctxt, pvalue->u.ellipse);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* g */
      pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

      if (pvalue->u.g == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);

      stat = XmlDec_Ns3_G (pctxt, pvalue->u.g);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* page-thumbnail */
      pvalue->u.page_thumbnail = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

      if (pvalue->u.page_thumbnail == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->
         u.page_thumbnail);

      stat = XmlDec_Ns3_Page_thumbnail (pctxt, pvalue->u.page_thumbnail);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* frame */
      pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

      if (pvalue->u.frame == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);

      stat = XmlDec_Ns3_Frame (pctxt, pvalue->u.frame);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* measure */
      pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

      if (pvalue->u.measure == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);

      stat = XmlDec_Ns3_Measure (pctxt, pvalue->u.measure);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* caption */
      pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

      if (pvalue->u.caption == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);

      stat = XmlDec_Ns3_Caption (pctxt, pvalue->u.caption);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* connector */
      pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

      if (pvalue->u.connector == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);

      stat = XmlDec_Ns3_Connector (pctxt, pvalue->u.connector);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* control */
      pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

      if (pvalue->u.control == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);

      stat = XmlDec_Ns3_Control (pctxt, pvalue->u.control);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* scene */
      pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

      if (pvalue->u.scene == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);

      stat = XmlDec_Ns7_Scene (pctxt, pvalue->u.scene);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* custom-shape */
      pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

      if (pvalue->u.custom_shape == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);

      stat = XmlDec_Ns3_Custom_shape (pctxt, pvalue->u.custom_shape);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Master_page                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Master_page (OSCTXT* pctxt, Ns8_Master_page *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->style_name = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name);
            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name);

            stat = asn1D_Ns3_Style_name (pctxt, 
               (Ns3_Style_name*)pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode display_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Display_name (pctxt, 
               &pvalue->display_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.display_namePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Name (pctxt, 
               &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode next_style_name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Master_page_next_style_name (pctxt, 
               &pvalue->next_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.next_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode page_layout_name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Page_layout_name (pctxt, 
               &pvalue->page_layout_name, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode sequence */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Master_page_sequence (pctxt, 
               &pvalue->sequence, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sequencePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode sequence_1 */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Master_page_sequence_1 (pctxt, 
               &pvalue->sequence_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sequence_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode forms */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->forms = rtxMemAllocType (pctxt, Ns13_Forms);

            if (pvalue->forms == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Forms ((Ns13_Forms*)pvalue->forms);
            asn1Init_Ns13_Forms ((Ns13_Forms*)pvalue->forms);

            stat = asn1D_Ns13_Forms (pctxt, 
               (Ns13_Forms*)pvalue->forms, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.formsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode style_list */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns8_Style* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->style_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns8_Style, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns8_Style (pdata2);

                  stat = asn1D_Ns8_Style (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->style_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 9:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns8_Master_page_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns8_Master_page_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns8_Master_page_element (pdata2);

                  stat = asn1D_Ns8_Master_page_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 10:
         /* decode notes */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->notes = rtxMemAllocType (pctxt, Ns10_Notes);

            if (pvalue->notes == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns10_Notes ((Ns10_Notes*)pvalue->notes);
            asn1Init_Ns10_Notes ((Ns10_Notes*)pvalue->notes);

            stat = asn1D_Ns10_Notes (pctxt, 
               (Ns10_Notes*)pvalue->notes, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.notesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 4) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Master_page (OSCTXT* pctxt, Ns8_Master_page* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("display-name"), 12}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("next-style-name"), 15}, 0 },
         { {OSUTF8("page-layout-name"), 16}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* style-name */
            pvalue->style_name = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name);

            stat = XmlDec_Ns3_Style_name (pctxt, pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 1: /* display-name */
            stat = XmlDec_Ns8_Display_name (pctxt, &pvalue->display_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.display_namePresent = TRUE;
            break;

         case 2: /* name */
            stat = XmlDec_Ns8_Name (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* next-style-name */
            stat = XmlDec_Ns8_Master_page_next_style_name (pctxt, &pvalue->
               next_style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.next_style_namePresent = TRUE;
            break;

         case 4: /* page-layout-name */
            stat = XmlDec_Ns8_Page_layout_name (pctxt, &pvalue->
               page_layout_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns8_Master_page");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns8_Master_page");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("header"), 6}, 0}, 0 },
      {{{OSUTF8("footer"), 6}, 0}, 1 },
      {{{OSUTF8("forms"), 5}, 0}, 2 },
      {{{OSUTF8("style"), 5}, 0}, 3 },
      {{{OSUTF8("rect"), 4}, 0}, 4 },
      {{{OSUTF8("line"), 4}, 0}, 4 },
      {{{OSUTF8("polyline"), 8}, 0}, 4 },
      {{{OSUTF8("polygon"), 7}, 0}, 4 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 4 },
      {{{OSUTF8("path"), 4}, 0}, 4 },
      {{{OSUTF8("circle"), 6}, 0}, 4 },
      {{{OSUTF8("ellipse"), 7}, 0}, 4 },
      {{{OSUTF8("g"), 1}, 0}, 4 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 4 },
      {{{OSUTF8("frame"), 5}, 0}, 4 },
      {{{OSUTF8("measure"), 7}, 0}, 4 },
      {{{OSUTF8("caption"), 7}, 0}, 4 },
      {{{OSUTF8("connector"), 9}, 0}, 4 },
      {{{OSUTF8("control"), 7}, 0}, 4 },
      {{{OSUTF8("scene"), 5}, 0}, 4 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 4 },
      {{{OSUTF8("notes"), 5}, 0}, 5 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 22, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 6; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /*  */
         stat = XmlDec_Ns8_Master_page_sequence (pctxt, &pvalue->sequence);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.sequencePresent = TRUE;
         break;
      }
      case 1: { /*  */
         stat = XmlDec_Ns8_Master_page_sequence_1 (pctxt, &pvalue->sequence_1
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.sequence_1Present = TRUE;
         break;
      }
      case 2: { /* forms */
         pvalue->forms = rtxMemAllocType (pctxt, Ns13_Forms);

         if (pvalue->forms == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Forms ((Ns13_Forms*)pvalue->forms);

         stat = XmlDec_Ns13_Forms (pctxt, pvalue->forms);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.formsPresent = TRUE;
         break;
      }
      case 3: {
         Ns8_Style* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns8_Style);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Style (pdata1);

            stat = XmlDec_Ns8_Style (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->style_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 3, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 3);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 4: {
         Ns8_Master_page_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns8_Master_page_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Master_page_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns8_Master_page_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 4, 17, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 4);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 5: { /* notes */
         pvalue->notes = rtxMemAllocType (pctxt, Ns10_Notes);

         if (pvalue->notes == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns10_Notes ((Ns10_Notes*)pvalue->notes);

         stat = XmlDec_Ns10_Notes (pctxt, pvalue->notes);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.notesPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Handout_master_element                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Handout_master_element (OSCTXT* pctxt, 
   Ns8_Handout_master_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

         if (pvalue->u.rect == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);
         stat = asn1D_Ns3_Rect (pctxt, 
            (Ns3_Rect*)pvalue->u.rect, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

         if (pvalue->u.line == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);
         stat = asn1D_Ns3_Line (pctxt, 
            (Ns3_Line*)pvalue->u.line, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

         if (pvalue->u.polyline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);
         stat = asn1D_Ns3_Polyline (pctxt, 
            (Ns3_Polyline*)pvalue->u.polyline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

         if (pvalue->u.polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);
         stat = asn1D_Ns3_Polygon (pctxt, 
            (Ns3_Polygon*)pvalue->u.polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.regular_polygon
             = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

         if (pvalue->u.regular_polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->u.regular_polygon);
         stat = asn1D_Ns3_Regular_polygon (pctxt, 
            (Ns3_Regular_polygon*)pvalue->u.regular_polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

         if (pvalue->u.path == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);
         stat = asn1D_Ns3_Path (pctxt, 
            (Ns3_Path*)pvalue->u.path, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

         if (pvalue->u.circle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);
         stat = asn1D_Ns3_Circle (pctxt, 
            (Ns3_Circle*)pvalue->u.circle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

         if (pvalue->u.ellipse == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);
         stat = asn1D_Ns3_Ellipse (pctxt, 
            (Ns3_Ellipse*)pvalue->u.ellipse, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

         if (pvalue->u.g == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);
         stat = asn1D_Ns3_G (pctxt, 
            (Ns3_G*)pvalue->u.g, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.page_thumbnail
             = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

         if (pvalue->u.page_thumbnail == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->u.page_thumbnail);
         stat = asn1D_Ns3_Page_thumbnail (pctxt, 
            (Ns3_Page_thumbnail*)pvalue->u.page_thumbnail, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

         if (pvalue->u.frame == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);
         stat = asn1D_Ns3_Frame (pctxt, 
            (Ns3_Frame*)pvalue->u.frame, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

         if (pvalue->u.measure == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);
         stat = asn1D_Ns3_Measure (pctxt, 
            (Ns3_Measure*)pvalue->u.measure, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

         if (pvalue->u.caption == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);
         stat = asn1D_Ns3_Caption (pctxt, 
            (Ns3_Caption*)pvalue->u.caption, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

         if (pvalue->u.connector == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);
         stat = asn1D_Ns3_Connector (pctxt, 
            (Ns3_Connector*)pvalue->u.connector, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

         if (pvalue->u.control == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);
         stat = asn1D_Ns3_Control (pctxt, 
            (Ns3_Control*)pvalue->u.control, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

         if (pvalue->u.scene == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);
         stat = asn1D_Ns7_Scene (pctxt, 
            (Ns7_Scene*)pvalue->u.scene, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

         if (pvalue->u.custom_shape == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);
         stat = asn1D_Ns3_Custom_shape (pctxt, 
            (Ns3_Custom_shape*)pvalue->u.custom_shape, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns8_Handout_master_element (OSCTXT* pctxt, 
   Ns8_Handout_master_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("rect"), 4}, 0}, 0 },
      {{{OSUTF8("line"), 4}, 0}, 1 },
      {{{OSUTF8("polyline"), 8}, 0}, 2 },
      {{{OSUTF8("polygon"), 7}, 0}, 3 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 4 },
      {{{OSUTF8("path"), 4}, 0}, 5 },
      {{{OSUTF8("circle"), 6}, 0}, 6 },
      {{{OSUTF8("ellipse"), 7}, 0}, 7 },
      {{{OSUTF8("g"), 1}, 0}, 8 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 9 },
      {{{OSUTF8("frame"), 5}, 0}, 10 },
      {{{OSUTF8("measure"), 7}, 0}, 11 },
      {{{OSUTF8("caption"), 7}, 0}, 12 },
      {{{OSUTF8("connector"), 9}, 0}, 13 },
      {{{OSUTF8("control"), 7}, 0}, 14 },
      {{{OSUTF8("scene"), 5}, 0}, 15 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 16 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 17, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* rect */
      pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

      if (pvalue->u.rect == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Rect ((Ns3_Rect*)pvalue->u.rect);

      stat = XmlDec_Ns3_Rect (pctxt, pvalue->u.rect);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* line */
      pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

      if (pvalue->u.line == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Line ((Ns3_Line*)pvalue->u.line);

      stat = XmlDec_Ns3_Line (pctxt, pvalue->u.line);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* polyline */
      pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

      if (pvalue->u.polyline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polyline ((Ns3_Polyline*)pvalue->u.polyline);

      stat = XmlDec_Ns3_Polyline (pctxt, pvalue->u.polyline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* polygon */
      pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

      if (pvalue->u.polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polygon ((Ns3_Polygon*)pvalue->u.polygon);

      stat = XmlDec_Ns3_Polygon (pctxt, pvalue->u.polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* regular-polygon */
      pvalue->u.regular_polygon
          = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

      if (pvalue->u.regular_polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Regular_polygon ((Ns3_Regular_polygon*)pvalue->
         u.regular_polygon);

      stat = XmlDec_Ns3_Regular_polygon (pctxt, pvalue->u.regular_polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* path */
      pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

      if (pvalue->u.path == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Path ((Ns3_Path*)pvalue->u.path);

      stat = XmlDec_Ns3_Path (pctxt, pvalue->u.path);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* circle */
      pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

      if (pvalue->u.circle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Circle ((Ns3_Circle*)pvalue->u.circle);

      stat = XmlDec_Ns3_Circle (pctxt, pvalue->u.circle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* ellipse */
      pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

      if (pvalue->u.ellipse == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Ellipse ((Ns3_Ellipse*)pvalue->u.ellipse);

      stat = XmlDec_Ns3_Ellipse (pctxt, pvalue->u.ellipse);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* g */
      pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

      if (pvalue->u.g == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);

      stat = XmlDec_Ns3_G (pctxt, pvalue->u.g);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* page-thumbnail */
      pvalue->u.page_thumbnail = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

      if (pvalue->u.page_thumbnail == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Page_thumbnail ((Ns3_Page_thumbnail*)pvalue->
         u.page_thumbnail);

      stat = XmlDec_Ns3_Page_thumbnail (pctxt, pvalue->u.page_thumbnail);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* frame */
      pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

      if (pvalue->u.frame == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);

      stat = XmlDec_Ns3_Frame (pctxt, pvalue->u.frame);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* measure */
      pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

      if (pvalue->u.measure == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Measure ((Ns3_Measure*)pvalue->u.measure);

      stat = XmlDec_Ns3_Measure (pctxt, pvalue->u.measure);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* caption */
      pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

      if (pvalue->u.caption == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Caption ((Ns3_Caption*)pvalue->u.caption);

      stat = XmlDec_Ns3_Caption (pctxt, pvalue->u.caption);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* connector */
      pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

      if (pvalue->u.connector == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Connector ((Ns3_Connector*)pvalue->u.connector);

      stat = XmlDec_Ns3_Connector (pctxt, pvalue->u.connector);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* control */
      pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

      if (pvalue->u.control == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Control ((Ns3_Control*)pvalue->u.control);

      stat = XmlDec_Ns3_Control (pctxt, pvalue->u.control);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* scene */
      pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

      if (pvalue->u.scene == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);

      stat = XmlDec_Ns7_Scene (pctxt, pvalue->u.scene);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* custom-shape */
      pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

      if (pvalue->u.custom_shape == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Custom_shape ((Ns3_Custom_shape*)pvalue->u.custom_shape);

      stat = XmlDec_Ns3_Custom_shape (pctxt, pvalue->u.custom_shape);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Handout_master                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Handout_master (OSCTXT* pctxt, 
   Ns8_Handout_master *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->style_name = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name);
            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name);

            stat = asn1D_Ns3_Style_name (pctxt, 
               (Ns3_Style_name*)pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode presentation_page_layout_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->presentation_page_layout_name
                = rtxMemAllocType (pctxt, Ns10_Presentation_page_layout_name);

            if (pvalue->presentation_page_layout_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns10_Presentation_page_layout_name ((Ns10_Presentation_page_layout_name*)pvalue->presentation_page_layout_name);
            asn1Init_Ns10_Presentation_page_layout_name ((Ns10_Presentation_page_layout_name*)pvalue->presentation_page_layout_name);

            stat = asn1D_Ns10_Presentation_page_layout_name (pctxt, 
               (Ns10_Presentation_page_layout_name*)pvalue->presentation_page_layout_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.presentation_page_layout_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode use_date_time_name */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns10_Use_date_time_name (pctxt, 
               (Ns10_Use_date_time_name*)&pvalue->use_date_time_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.use_date_time_namePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode use_footer_name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns10_Use_footer_name (pctxt, 
               (Ns10_Use_footer_name*)&pvalue->use_footer_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.use_footer_namePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode use_header_name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns10_Use_header_name (pctxt, 
               (Ns10_Use_header_name*)&pvalue->use_header_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.use_header_namePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode page_layout_name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns8_Page_layout_name (pctxt, 
               &pvalue->page_layout_name, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns8_Handout_master_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns8_Handout_master_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns8_Handout_master_element (pdata2);

                  stat = asn1D_Ns8_Handout_master_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns8_Handout_master (OSCTXT* pctxt, Ns8_Handout_master* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("presentation-page-layout-name"), 29}, 0 },
         { {OSUTF8("use-date-time-name"), 18}, 0 },
         { {OSUTF8("use-footer-name"), 15}, 0 },
         { {OSUTF8("use-header-name"), 15}, 0 },
         { {OSUTF8("page-layout-name"), 16}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 6, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* style-name */
            pvalue->style_name = rtxMemAllocType (pctxt, Ns3_Style_name);

            if (pvalue->style_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Style_name ((Ns3_Style_name*)pvalue->style_name);

            stat = XmlDec_Ns3_Style_name (pctxt, pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 1: /* presentation-page-layout-name */
            pvalue->presentation_page_layout_name
                = rtxMemAllocType (pctxt, Ns10_Presentation_page_layout_name);

            if (pvalue->presentation_page_layout_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns10_Presentation_page_layout_name (
               (Ns10_Presentation_page_layout_name*)pvalue->
               presentation_page_layout_name);

            stat = XmlDec_Ns10_Presentation_page_layout_name (pctxt, pvalue->
               presentation_page_layout_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.presentation_page_layout_namePresent = TRUE;
            break;

         case 2: /* use-date-time-name */
            stat = XmlDec_Ns10_Use_date_time_name (pctxt, &pvalue->
               use_date_time_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.use_date_time_namePresent = TRUE;
            break;

         case 3: /* use-footer-name */
            stat = XmlDec_Ns10_Use_footer_name (pctxt, &pvalue->use_footer_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.use_footer_namePresent = TRUE;
            break;

         case 4: /* use-header-name */
            stat = XmlDec_Ns10_Use_header_name (pctxt, &pvalue->use_header_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.use_header_namePresent = TRUE;
            break;

         case 5: /* page-layout-name */
            stat = XmlDec_Ns8_Page_layout_name (pctxt, &pvalue->
               page_layout_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns8_Handout_master");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns8_Handout_master");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("rect"), 4}, 0}, 0 },
      {{{OSUTF8("line"), 4}, 0}, 0 },
      {{{OSUTF8("polyline"), 8}, 0}, 0 },
      {{{OSUTF8("polygon"), 7}, 0}, 0 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 0 },
      {{{OSUTF8("path"), 4}, 0}, 0 },
      {{{OSUTF8("circle"), 6}, 0}, 0 },
      {{{OSUTF8("ellipse"), 7}, 0}, 0 },
      {{{OSUTF8("g"), 1}, 0}, 0 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 0 },
      {{{OSUTF8("frame"), 5}, 0}, 0 },
      {{{OSUTF8("measure"), 7}, 0}, 0 },
      {{{OSUTF8("caption"), 7}, 0}, 0 },
      {{{OSUTF8("connector"), 9}, 0}, 0 },
      {{{OSUTF8("control"), 7}, 0}, 0 },
      {{{OSUTF8("scene"), 5}, 0}, 0 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 17, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Ns8_Handout_master_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns8_Handout_master_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Handout_master_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns8_Handout_master_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 17, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Legend_expansion                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Legend_expansion (OSCTXT* pctxt, 
   Ns8_Legend_expansion *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Legend_expansion (OSCTXT* pctxt, Ns8_Legend_expansion* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns8_Legend_expansion_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Legend_expansion_aspect_ratio                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns8_Legend_expansion_aspect_ratio (OSCTXT* pctxt, 
   Ns8_Legend_expansion_aspect_ratio *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_real (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns8_Legend_expansion_aspect_ratio (OSCTXT* pctxt, 
   Ns8_Legend_expansion_aspect_ratio* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDouble (pctxt, pvalue, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

